"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[66215],{652:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>l,frontMatter:()=>a,metadata:()=>c,toc:()=>h});var i=o(85893),n=o(11151);const a={},r="The defmethod macro",c={id:"meta-object-protocol/the-defmethod-macro",title:"The defmethod macro",description:"The defmethod macro",source:"@site/docs/meta-object-protocol/the-defmethod-macro.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/the-defmethod-macro",permalink:"/cl-language-reference/meta-object-protocol/the-defmethod-macro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/the-defmethod-macro.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The defgeneric macro",permalink:"/cl-language-reference/meta-object-protocol/the-defgeneric-macro"},next:{title:"update-dependent",permalink:"/cl-language-reference/meta-object-protocol/update-dependent"}},s={},h=[{value:"The <code>defmethod</code> macro",id:"the-defmethod-macro-1",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"the-defmethod-macro",children:"The defmethod macro"}),"\n",(0,i.jsxs)(t.h3,{id:"the-defmethod-macro-1",children:["The ",(0,i.jsx)(t.code,{children:"defmethod"})," macro"]}),"\n",(0,i.jsxs)(t.p,{children:["The evaluation or execution of a ",(0,i.jsx)(t.code,{children:"defmethod"})," form requires first that the body of the method be converted to a method function. This process is described in the next section. The result of this process is a method function and a set of additional initialization arguments to be used when creating the new method. Given these two values, the evaluation or execution of a ",(0,i.jsx)(t.code,{children:"defmethod"})," form proceeds in three steps. The first step ensures the existence of a generic function with the specified name. This is done by calling the function ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),". The first argument in this call is the generic function name specified in the ",(0,i.jsx)(t.code,{children:"defmethod"})," form. The second step is the creation of the new method metaobject by calling ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The class of the new method metaobject is determined by calling ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/generic-function-method-class",children:"generic-function-method-class"})," on the result of the call to ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," from the first step. The initialization arguments received by the call to ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," are as follows:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"qualifiers"})," initialization argument is a list of the qualifiers which appeared in the ",(0,i.jsx)(t.code,{children:"defmethod"})," form. No special processing is done on these values. The order of the elements of this list is the same as in the ",(0,i.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"lambda-list"})," initialization argument is the unspecialized lambda list from the ",(0,i.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"specializers"})," initialization argument is a list of the specializers for the method. For specializers which are classes, the specializer is the class metaobject itself. In the case of ",(0,i.jsx)(t.code,{children:"eql"})," specializers, it will be an ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/class-eql-specializer",children:"eql-specializer"})," metaobject obtained by calling ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/intern-eql-specializer",children:"intern-eql-specializer"})," on the result of evaluating the ",(0,i.jsx)(t.code,{children:"eql"})," specializer form in the lexical environment of the ",(0,i.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"function"})," initialization argument is the method function."]}),"\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"declarations"})," initialization argument is a list of the declarations from the ",(0,i.jsx)(t.code,{children:"defmethod"})," form. If there are no declarations in the macro form, this initialization argument either doesn't appear, or appears with a value of the empty list."]}),"\n",(0,i.jsxs)(t.li,{children:["The value of the ",(0,i.jsx)(t.code,{children:"documentation"})," initialization argument is the documentation string from the ",(0,i.jsx)(t.code,{children:"defmethod"})," form. If there is no documentation string in the macro form this initialization argument either doesn't appear, or appears with a value of false."]}),"\n",(0,i.jsx)(t.li,{children:"Any other initialization argument produced in conjunction with the method function are also included."}),"\n",(0,i.jsxs)(t.li,{children:["The implementation is free to include additional initialization arguments provided these are not symbols accessible in the ",(0,i.jsx)(t.code,{children:"common-lisp-user"})," package, or exported by any package defined in the ANSI Common Lisp standard."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In the third step, ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/add-method",children:"add-method"})," is called to add the newly created method to the set of methods associated with the generic function metaobject. The result of the call to ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/add-method",children:"add-method"})," is returned as the result of evaluating or executing the ",(0,i.jsx)(t.code,{children:"defmethod"})," form. An example showing a typical ",(0,i.jsx)(t.code,{children:"defmethod"})," form and a sample expansion is shown in ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/fig-defmethod-1",children:"this figure"}),". The processing of the method body for this method is shown in ",(0,i.jsx)(t.a,{href:"/meta-object-protocol/fig-defmethod-2",children:"this figure"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>c,a:()=>r});var i=o(67294);const n={},a=i.createContext(n);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);