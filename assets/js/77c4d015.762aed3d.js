"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[4565],{1438:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>le,contentTitle:()=>re,default:()=>oe,frontMatter:()=>se,metadata:()=>te,toc:()=>ce});var s=i(5893),r=i(1151);function t(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1 Evaluation"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Execution"})," of ",(0,s.jsx)(n.em,{children:"code"})," can be accomplished by a variety of means ranging from direct interpretation of a ",(0,s.jsx)(n.em,{children:"form"})," representing a ",(0,s.jsx)(n.em,{children:"program"})," to invocation of ",(0,s.jsx)(n.em,{children:"compiled code"})," produced by a ",(0,s.jsx)(n.em,{children:"compiler"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Evaluation"})," is the process by which a ",(0,s.jsx)(n.em,{children:"program"})," is ",(0,s.jsx)(n.em,{children:"executed"})," in Common Lisp. The mechanism of ",(0,s.jsx)(n.em,{children:"evaluation"})," is manifested both implicitly through the effect of the ",(0,s.jsx)(n.em,{children:"Lisp read-eval-print loop"}),", and explicitly through the presence of the ",(0,s.jsx)(n.em,{children:"functions"})," ",(0,s.jsx)(n.strong,{children:"eval"}),", ",(0,s.jsx)(n.strong,{children:"compile"}),", ",(0,s.jsx)(n.strong,{children:"compile-file"}),", and ",(0,s.jsx)(n.strong,{children:"load"}),". Any of these facilities might share the same execution strategy, or each might use a different one."]}),"\n",(0,s.jsxs)(n.p,{children:["The behavior of a ",(0,s.jsx)(n.em,{children:"conforming program"})," processed by ",(0,s.jsx)(n.strong,{children:"eval"})," and by ",(0,s.jsx)(n.strong,{children:"compile-file"})," might differ; see Section 3.2.2.3 (Semantic Constraints)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Evaluation"})," can be understood in terms of a model in which an interpreter recursively traverses a ",(0,s.jsx)(n.em,{children:"form"})," performing each step of the computation as it goes. This model, which describes the semantics of Common Lisp ",(0,s.jsx)(n.em,{children:"programs"}),", is described in Section 3.1.2 (The Evaluation Model)."]})]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}function c(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1 Introduction to Environments"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"binding"})," is an association between a ",(0,s.jsx)(n.em,{children:"name"})," and that which the name denotes. ",(0,s.jsx)(n.em,{children:"Bindings"})," are ",(0,s.jsx)(n.em,{children:"established"})," in a ",(0,s.jsx)(n.em,{children:"lexical environment"})," or a ",(0,s.jsx)(n.em,{children:"dynamic environment"})," by particular ",(0,s.jsx)(n.em,{children:"special operators"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"environment"})," is a set of ",(0,s.jsx)(n.em,{children:"bindings"})," and other information used during evaluation (",(0,s.jsx)(n.em,{children:"e.g."}),", to associate meanings with names)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Bindings"})," in an ",(0,s.jsx)(n.em,{children:"environment"})," are partitioned into ",(0,s.jsx)(n.em,{children:"namespaces"}),". A single ",(0,s.jsx)(n.em,{children:"name"})," can simultaneously have more than one associated ",(0,s.jsx)(n.em,{children:"binding"})," per ",(0,s.jsx)(n.em,{children:"environment"}),", but can have only one associated ",(0,s.jsx)(n.em,{children:"binding"})," per ",(0,s.jsx)(n.em,{children:"namespace"}),"."]})]})}function a(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function o(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1.1 The Global Environment"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"global environment"})," is that part of an ",(0,s.jsx)(n.em,{children:"environment"})," that contains ",(0,s.jsx)(n.em,{children:"bindings"})," with both ",(0,s.jsx)(n.em,{children:"indefinite scope"})," and ",(0,s.jsx)(n.em,{children:"indefinite extent"}),". The ",(0,s.jsx)(n.em,{children:"global environment"})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"dynamic variables"})," and ",(0,s.jsx)(n.em,{children:"constant variables"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"functions"}),", ",(0,s.jsx)(n.em,{children:"macros"}),", and ",(0,s.jsx)(n.em,{children:"special operators"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"compiler macros"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"type"})," and ",(0,s.jsx)(n.em,{children:"class names"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"proclamations"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function d(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1.2 Dynamic Environments"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"dynamic environment"})," for ",(0,s.jsx)(n.em,{children:"evaluation"})," is that part of an ",(0,s.jsx)(n.em,{children:"environment"})," that contains ",(0,s.jsx)(n.em,{children:"bindings"})," whose duration is bounded by points of ",(0,s.jsx)(n.em,{children:"establishment"})," and ",(0,s.jsx)(n.em,{children:"disestablishment"})," within the execution of the ",(0,s.jsx)(n.em,{children:"form"})," that established the ",(0,s.jsx)(n.em,{children:"binding"}),". A ",(0,s.jsx)(n.em,{children:"dynamic environment"})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," for ",(0,s.jsx)(n.em,{children:"dynamic variables"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"active catch tags"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"exit points"})," established by ",(0,s.jsx)(n.strong,{children:"unwind-protect"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"active handlers"})," and ",(0,s.jsx)(n.em,{children:"restarts"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"dynamic environment"})," that is active at any given point in the ",(0,s.jsx)(n.em,{children:"execution"})," of a ",(0,s.jsx)(n.em,{children:"program"})," is referred to by definite reference as \u201cthe current ",(0,s.jsx)(n.em,{children:"dynamic environment"}),",\u201d or sometimes as just \u201cthe ",(0,s.jsx)(n.em,{children:"dynamic environment"}),".\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:["Within a given ",(0,s.jsx)(n.em,{children:"namespace"}),", a ",(0,s.jsx)(n.em,{children:"name"})," is said to be ",(0,s.jsx)(n.em,{children:"bound"})," in a ",(0,s.jsx)(n.em,{children:"dynamic environment"})," if there is a ",(0,s.jsx)(n.em,{children:"binding"})," associated with its ",(0,s.jsx)(n.em,{children:"name"})," in the ",(0,s.jsx)(n.em,{children:"dynamic environment"})," or, if not, there is a ",(0,s.jsx)(n.em,{children:"binding"})," associated with its name in the ",(0,s.jsx)(n.em,{children:"global environment"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function x(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1.3 Lexical Environments"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lexical environment"})," for ",(0,s.jsx)(n.em,{children:"evaluation"})," at some position in a ",(0,s.jsx)(n.em,{children:"program"})," is that part of the ",(0,s.jsx)(n.em,{children:"environment"})," that contains information having ",(0,s.jsx)(n.em,{children:"lexical scope"})," within the ",(0,s.jsx)(n.em,{children:"forms"})," containing that position. A ",(0,s.jsx)(n.em,{children:"lexical environment"})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"lexical variables"})," and ",(0,s.jsx)(n.em,{children:"symbol macros"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"functions"})," and ",(0,s.jsx)(n.em,{children:"macros"}),". (Implicit in this is information about those ",(0,s.jsx)(n.em,{children:"compiler macros"})," that are locally disabled.)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"block tags"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(n.em,{children:"go tags"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"declarations"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"lexical environment"})," that is active at any given position in a ",(0,s.jsx)(n.em,{children:"program"})," being semantically processed is referred to by definite reference as \u201cthe current ",(0,s.jsx)(n.em,{children:"lexical environment"}),",\u201d or sometimes as just \u201cthe ",(0,s.jsx)(n.em,{children:"lexical environment"}),".\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:["Within a given ",(0,s.jsx)(n.em,{children:"namespace"}),", a ",(0,s.jsx)(n.em,{children:"name"})," is said to be ",(0,s.jsx)(n.em,{children:"bound"})," in a ",(0,s.jsx)(n.em,{children:"lexical environment"})," if there is a ",(0,s.jsx)(n.em,{children:"binding"})," associated with its ",(0,s.jsx)(n.em,{children:"name"})," in the ",(0,s.jsx)(n.em,{children:"lexical environment"})," or, if not, there is a ",(0,s.jsx)(n.em,{children:"binding"})," associated with its name in the ",(0,s.jsx)(n.em,{children:"global environment"}),"."]})]})}function j(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}function u(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1.3.1 The Null Lexical Environment"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"null lexical environment"})," is equivalent to the ",(0,s.jsx)(n.em,{children:"global environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Although in general the representation of an ",(0,s.jsx)(n.em,{children:"environment object"})," is ",(0,s.jsx)(n.em,{children:"implementation-dependent"}),", ",(0,s.jsx)(n.strong,{children:"nil"})," can be used in any situation where an ",(0,s.jsx)(n.em,{children:"environment object"})," is called for in order to denote the ",(0,s.jsx)(n.em,{children:"null lexical environment"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}function f(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.1.4 Environment Objects"})}),"\n",(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(n.em,{children:"operators"})," make use of an ",(0,s.jsx)(n.em,{children:"object"}),", called an ",(0,s.jsx)(n.em,{children:"environment object"}),", that represents the set of ",(0,s.jsx)(n.em,{children:"lexical bindings"})," needed to perform semantic analysis on a ",(0,s.jsx)(n.em,{children:"form"})," in a given ",(0,s.jsx)(n.em,{children:"lexical environment"}),". The set of ",(0,s.jsx)(n.em,{children:"bindings"})," in an ",(0,s.jsx)(n.em,{children:"environment object"})," may be a subset of the ",(0,s.jsx)(n.em,{children:"bindings"})," that would be needed to actually perform an ",(0,s.jsx)(n.em,{children:"evaluation"}),"; for example, ",(0,s.jsx)(n.em,{children:"values"})," associated with ",(0,s.jsx)(n.em,{children:"variable names"})," and ",(0,s.jsx)(n.em,{children:"function names"})," in the corresponding ",(0,s.jsx)(n.em,{children:"lexical environment"})," might not be available in an ",(0,s.jsx)(n.em,{children:"environment object"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"type"})," and nature of an ",(0,s.jsx)(n.em,{children:"environment object"})," is ",(0,s.jsx)(n.em,{children:"implementation-dependent"}),". The ",(0,s.jsx)(n.em,{children:"values"})," of ",(0,s.jsx)(n.em,{children:"environment parameters"})," to ",(0,s.jsx)(n.em,{children:"macro functions"})," are examples of ",(0,s.jsx)(n.em,{children:"environment objects"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"object"})," ",(0,s.jsx)(n.strong,{children:"nil"})," when used as an ",(0,s.jsx)(n.em,{children:"environment object"})," denotes the ",(0,s.jsx)(n.em,{children:"null lexical environment"}),"; see Section 3.1.1.3.1 (The Null Lexical Environment)."]})]})}function b(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}function g(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2 The Evaluation Model"})}),"\n",(0,s.jsxs)(n.p,{children:["A Common Lisp system evaluates ",(0,s.jsx)(n.em,{children:"forms"})," with respect to lexical, dynamic, and global ",(0,s.jsx)(n.em,{children:"environments"}),". The following sections describe the components of the Common Lisp evaluation model."]})]})}function v(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}function y(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1 Form Evaluation"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Forms"})," fall into three categories: ",(0,s.jsx)(n.em,{children:"symbols"}),", ",(0,s.jsx)(n.em,{children:"conses"}),", and ",(0,s.jsx)(n.em,{children:"self-evaluating objects"}),". The following sections explain these categories."]})]})}function w(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function T(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.1 Symbols as Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"form"})," is a ",(0,s.jsx)(n.em,{children:"symbol"}),", then it is either a ",(0,s.jsx)(n.em,{children:"symbol macro"})," or a ",(0,s.jsx)(n.em,{children:"variable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"symbol"})," names a ",(0,s.jsx)(n.em,{children:"symbol macro"})," if there is a ",(0,s.jsx)(n.em,{children:"binding"})," of the ",(0,s.jsx)(n.em,{children:"symbol"})," as a ",(0,s.jsx)(n.em,{children:"symbol macro"})," in the current ",(0,s.jsx)(n.em,{children:"lexical environment"})," (see ",(0,s.jsx)(n.strong,{children:"define-symbol-macro"})," and ",(0,s.jsx)(n.strong,{children:"symbol-macrolet"}),"). If the ",(0,s.jsx)(n.em,{children:"symbol"})," is a ",(0,s.jsx)(n.em,{children:"symbol macro"}),", its expansion function is obtained. The expansion function is a function of two arguments, and is invoked by calling the ",(0,s.jsx)(n.em,{children:"macroexpand hook"})," with the expansion function as its"]}),"\n",(0,s.jsxs)(n.p,{children:["first argument, the ",(0,s.jsx)(n.em,{children:"symbol"})," as its second argument, and an ",(0,s.jsx)(n.em,{children:"environment object"})," (corresponding to the current ",(0,s.jsx)(n.em,{children:"lexical environment"}),") as its third argument. The ",(0,s.jsx)(n.em,{children:"macroexpand hook"}),", in turn, calls the expansion function with the ",(0,s.jsx)(n.em,{children:"form"})," as its first argument and the ",(0,s.jsx)(n.em,{children:"environment"})," as its second argument. The ",(0,s.jsx)(n.em,{children:"value"})," of the expansion function, which is passed through by the ",(0,s.jsx)(n.em,{children:"macroexpand hook"}),", is a ",(0,s.jsx)(n.em,{children:"form"}),". This resulting ",(0,s.jsx)(n.em,{children:"form"})," is processed in place of the original ",(0,s.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"form"})," is a ",(0,s.jsx)(n.em,{children:"symbol"})," that is not a ",(0,s.jsx)(n.em,{children:"symbol macro"}),", then it is the ",(0,s.jsx)(n.em,{children:"name"})," of a ",(0,s.jsx)(n.em,{children:"variable"}),", and the ",(0,s.jsx)(n.em,{children:"value"})," of that ",(0,s.jsx)(n.em,{children:"variable"})," is returned. There are three kinds of variables: ",(0,s.jsx)(n.em,{children:"lexical variables"}),", ",(0,s.jsx)(n.em,{children:"dynamic variables"}),","]}),"\n",(0,s.jsxs)(n.p,{children:["and ",(0,s.jsx)(n.em,{children:"constant variables"}),". A ",(0,s.jsx)(n.em,{children:"variable"})," can store one ",(0,s.jsx)(n.em,{children:"object"}),". The main operations on a ",(0,s.jsx)(n.em,{children:"variable"})," are to ",(0,s.jsx)(n.em,{children:"read"})," <sub>1</sub> and to ",(0,s.jsx)(n.em,{children:"write"}),"<sub>1</sub> its ",(0,s.jsx)(n.em,{children:"value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"unbound-variable"})," should be signaled if an ",(0,s.jsx)(n.em,{children:"unbound variable"})," is referenced."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Non-constant variables"})," can be ",(0,s.jsx)(n.em,{children:"assigned"})," by using ",(0,s.jsx)(n.strong,{children:"setq"})," or ",(0,s.jsx)(n.em,{children:"bound"})," <sub>3</sub> by using ",(0,s.jsx)(n.strong,{children:"let"}),". Figure 3\u20131 lists some ",(0,s.jsx)(n.em,{children:"defined names"})," that are applicable to assigning, binding, and defining ",(0,s.jsx)(n.em,{children:"variables"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"boundp let progv"})," </p><p>",(0,s.jsx)(n.strong,{children:"defconstant let* psetq"})," </p><p>",(0,s.jsx)(n.strong,{children:"defparameter makunbound set"})," </p><p>",(0,s.jsx)(n.strong,{children:"defvar multiple-value-bind setq"})," </p><p>",(0,s.jsx)(n.strong,{children:"lambda multiple-value-setq symbol-value"}),"</p>"]})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20131. Some Defined Names Applicable to Variables"})}),"\n",(0,s.jsx)(n.p,{children:"The following is a description of each kind of variable."})]})}function F(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(T,{...e})}):T(e)}function E(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.1.1 Lexical Variables"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lexical variable"})," is a ",(0,s.jsx)(n.em,{children:"variable"})," that can be referenced only within the ",(0,s.jsx)(n.em,{children:"lexical scope"})," of the ",(0,s.jsx)(n.em,{children:"form"})," that establishes that ",(0,s.jsx)(n.em,{children:"variable"}),"; ",(0,s.jsx)(n.em,{children:"lexical variables"})," have ",(0,s.jsx)(n.em,{children:"lexical scope"}),". Each time a ",(0,s.jsx)(n.em,{children:"form"})," creates a ",(0,s.jsx)(n.em,{children:"lexical binding"})," of a ",(0,s.jsx)(n.em,{children:"variable"}),", a ",(0,s.jsx)(n.em,{children:"fresh binding"})," is ",(0,s.jsx)(n.em,{children:"established"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Within the ",(0,s.jsx)(n.em,{children:"scope"})," of a ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"lexical variable name"}),", uses of that ",(0,s.jsx)(n.em,{children:"name"})," as a ",(0,s.jsx)(n.em,{children:"variable"})," are considered to be references to that ",(0,s.jsx)(n.em,{children:"binding"})," except where the ",(0,s.jsx)(n.em,{children:"variable"})," is ",(0,s.jsx)(n.em,{children:"shadowed"})," <sub>2</sub> by a ",(0,s.jsx)(n.em,{children:"form"})," that ",(0,s.jsx)(n.em,{children:"establishes"})," a ",(0,s.jsx)(n.em,{children:"fresh binding"})," for that ",(0,s.jsx)(n.em,{children:"variable name"}),", or by a ",(0,s.jsx)(n.em,{children:"form"})," that locally ",(0,s.jsx)(n.em,{children:"declares"})," the ",(0,s.jsx)(n.em,{children:"name"})," ",(0,s.jsx)(n.strong,{children:"special"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lexical variable"})," always has a ",(0,s.jsx)(n.em,{children:"value"}),". There is no ",(0,s.jsx)(n.em,{children:"operator"})," that introduces a ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"lexical variable"})," without giving it an initial ",(0,s.jsx)(n.em,{children:"value"}),", nor is there any ",(0,s.jsx)(n.em,{children:"operator"})," that can make a ",(0,s.jsx)(n.em,{children:"lexical variable"})," be ",(0,s.jsx)(n.em,{children:"unbound"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Bindings"})," of ",(0,s.jsx)(n.em,{children:"lexical variables"})," are found in the ",(0,s.jsx)(n.em,{children:"lexical environment"}),"."]})]})}function k(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(E,{...e})}):E(e)}function A(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.1.2 Dynamic Variables"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"variable"})," is a ",(0,s.jsx)(n.em,{children:"dynamic variable"})," if one of the following conditions hold:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," It is locally declared or globally proclaimed ",(0,s.jsx)(n.strong,{children:"special"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," It occurs textually within a ",(0,s.jsx)(n.em,{children:"form"})," that creates a ",(0,s.jsx)(n.em,{children:"dynamic binding"})," for a ",(0,s.jsx)(n.em,{children:"variable"})," of the ",(0,s.jsx)(n.em,{children:"same name"}),", and the ",(0,s.jsx)(n.em,{children:"binding"})," is not ",(0,s.jsx)(n.em,{children:"shadowed"})," <sub>2</sub> by a ",(0,s.jsx)(n.em,{children:"form"})," that creates a ",(0,s.jsx)(n.em,{children:"lexical binding"})," of the same ",(0,s.jsx)(n.em,{children:"variable name"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"dynamic variable"})," can be referenced at any time in any ",(0,s.jsx)(n.em,{children:"program"}),"; there is no textual limitation on references to ",(0,s.jsx)(n.em,{children:"dynamic variables"}),". At any given time, all ",(0,s.jsx)(n.em,{children:"dynamic variables"})," with a given name refer to exactly one ",(0,s.jsx)(n.em,{children:"binding"}),", either in the ",(0,s.jsx)(n.em,{children:"dynamic environment"})," or in the ",(0,s.jsx)(n.em,{children:"global environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"value"})," part of the ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"dynamic variable"})," might be empty; in this case, the ",(0,s.jsx)(n.em,{children:"dynamic variable"})," is said to have no ",(0,s.jsx)(n.em,{children:"value"}),", or to be ",(0,s.jsx)(n.em,{children:"unbound"}),". A ",(0,s.jsx)(n.em,{children:"dynamic variable"})," can be made ",(0,s.jsx)(n.em,{children:"unbound"})," by using ",(0,s.jsx)(n.strong,{children:"makunbound"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The effect of ",(0,s.jsx)(n.em,{children:"binding"})," a ",(0,s.jsx)(n.em,{children:"dynamic variable"})," is to create a new ",(0,s.jsx)(n.em,{children:"binding"})," to which all references to that ",(0,s.jsx)(n.em,{children:"dynamic variable"})," in any ",(0,s.jsx)(n.em,{children:"program"})," refer for the duration of the ",(0,s.jsx)(n.em,{children:"evaluation"})," of the ",(0,s.jsx)(n.em,{children:"form"})," that creates the ",(0,s.jsx)(n.em,{children:"dynamic binding"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"dynamic variable"})," can be referenced outside the ",(0,s.jsx)(n.em,{children:"dynamic extent"})," of a ",(0,s.jsx)(n.em,{children:"form"})," that ",(0,s.jsx)(n.em,{children:"binds"})," it. Such a ",(0,s.jsx)(n.em,{children:"variable"})," is sometimes called a \u201cglobal variable\u201d but is still in all respects just a ",(0,s.jsx)(n.em,{children:"dynamic variable"})," whose ",(0,s.jsx)(n.em,{children:"binding"})," happens to exist in the ",(0,s.jsx)(n.em,{children:"global environment"})," rather than in some ",(0,s.jsx)(n.em,{children:"dynamic environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"dynamic variable"})," is ",(0,s.jsx)(n.em,{children:"unbound"})," unless and until explicitly assigned a value, except for those variables whose initial value is defined in this specification or by an ",(0,s.jsx)(n.em,{children:"implementation"}),"."]})]})}function L(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(A,{...e})}):A(e)}function S(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.1.3 Constant Variables"})}),"\n",(0,s.jsxs)(n.p,{children:["Certain variables, called ",(0,s.jsx)(n.em,{children:"constant variables"}),", are reserved as \u201cnamed constants.\u201d The consequences are undefined if an attempt is made to assign a value to, or create a ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"constant variable"}),", except that a \u2018compatible\u2019 redefinition of a ",(0,s.jsx)(n.em,{children:"constant variable"})," using ",(0,s.jsx)(n.strong,{children:"defconstant"})," is permitted; see the ",(0,s.jsx)(n.em,{children:"macro"})," ",(0,s.jsx)(n.strong,{children:"defconstant"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Keywords"}),", ",(0,s.jsx)(n.em,{children:"symbols"})," defined by Common Lisp or the ",(0,s.jsx)(n.em,{children:"implementation"})," as constant (such as ",(0,s.jsx)(n.strong,{children:"nil"}),", ",(0,s.jsx)(n.strong,{children:"t"}),", and ",(0,s.jsx)(n.strong,{children:"pi"}),"), and ",(0,s.jsx)(n.em,{children:"symbols"})," declared as constant using ",(0,s.jsx)(n.strong,{children:"defconstant"})," are ",(0,s.jsx)(n.em,{children:"constant variables"}),"."]})]})}function C(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(S,{...e})}):S(e)}function I(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables"})}),"\n",(0,s.jsxs)(n.p,{children:["The same ",(0,s.jsx)(n.em,{children:"symbol"})," can name both a ",(0,s.jsx)(n.em,{children:"lexical variable"})," and a ",(0,s.jsx)(n.em,{children:"dynamic variable"}),", but never in the same ",(0,s.jsx)(n.em,{children:"lexical environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, the ",(0,s.jsx)(n.em,{children:"symbol"})," x is used, at different times, as the ",(0,s.jsx)(n.em,{children:"name"})," of a ",(0,s.jsx)(n.em,{children:"lexical variable"})," and as the ",(0,s.jsx)(n.em,{children:"name"})," of a ",(0,s.jsx)(n.em,{children:"dynamic variable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"(let ((x 1)) ;Binds a special variable X"}),"\n",(0,s.jsx)(n.p,{children:"(declare (special x))"}),"\n",(0,s.jsx)(n.p,{children:"(let ((x 2)) ;Binds a lexical variable X"}),"\n",(0,s.jsx)(n.p,{children:"(+ x ;Reads a lexical variable X"}),"\n",(0,s.jsx)(n.p,{children:"(locally (declare (special x))"}),"\n",(0,s.jsx)(n.p,{children:"x)))) ;Reads a special variable X"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," 3"]})]})}function z(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(I,{...e})}):I(e)}function q(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.2 Conses as Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"cons"})," that is used as a ",(0,s.jsx)(n.em,{children:"form"})," is called a ",(0,s.jsx)(n.em,{children:"compound form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"car"})," of that ",(0,s.jsx)(n.em,{children:"compound form"})," is a ",(0,s.jsx)(n.em,{children:"symbol"}),", that ",(0,s.jsx)(n.em,{children:"symbol"})," is the ",(0,s.jsx)(n.em,{children:"name"})," of an ",(0,s.jsx)(n.em,{children:"operator"})," , and the ",(0,s.jsx)(n.em,{children:"form"})," is either a ",(0,s.jsx)(n.em,{children:"special form"}),", a ",(0,s.jsx)(n.em,{children:"macro form"}),", or a ",(0,s.jsx)(n.em,{children:"function form"}),", depending on the ",(0,s.jsx)(n.em,{children:"function binding"})," of the ",(0,s.jsx)(n.em,{children:"operator"})," in the current ",(0,s.jsx)(n.em,{children:"lexical environment"}),". If the ",(0,s.jsx)(n.em,{children:"operator"})," is neither a ",(0,s.jsx)(n.em,{children:"special operator"})]}),"\n",(0,s.jsxs)(n.p,{children:["nor a ",(0,s.jsx)(n.em,{children:"macro name"}),", it is assumed to be a ",(0,s.jsx)(n.em,{children:"function name"})," (even if there is no definition for such a ",(0,s.jsx)(n.em,{children:"function"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"car"})," of the ",(0,s.jsx)(n.em,{children:"compound form"})," is not a ",(0,s.jsx)(n.em,{children:"symbol"}),", then that ",(0,s.jsx)(n.em,{children:"car"})," must be a ",(0,s.jsx)(n.em,{children:"lambda expression"}),", in which case the ",(0,s.jsx)(n.em,{children:"compound form"})," is a ",(0,s.jsx)(n.em,{children:"lambda form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["How a ",(0,s.jsx)(n.em,{children:"compound form"})," is processed depends on whether it is classified as a ",(0,s.jsx)(n.em,{children:"special form"}),", a ",(0,s.jsx)(n.em,{children:"macro form"}),", a ",(0,s.jsx)(n.em,{children:"function form"}),", or a ",(0,s.jsx)(n.em,{children:"lambda form"}),"."]})]})}function V(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}function N(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.2.1 Special Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"special form"})," is a ",(0,s.jsx)(n.em,{children:"form"})," with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both. A ",(0,s.jsx)(n.em,{children:"special operator"})," has access to the current ",(0,s.jsx)(n.em,{children:"lexical environment"})," and the current ",(0,s.jsx)(n.em,{children:"dynamic environment"}),". Each ",(0,s.jsx)(n.em,{children:"special operator"})," defines the manner in which its ",(0,s.jsx)(n.em,{children:"subexpressions"})," are treated\u2014which are ",(0,s.jsx)(n.em,{children:"forms"}),", which are special syntax, ",(0,s.jsx)(n.em,{children:"etc."})]}),"\n",(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(n.em,{children:"special operators"})," create new lexical or dynamic ",(0,s.jsx)(n.em,{children:"environments"})," for use during the ",(0,s.jsx)(n.em,{children:"evaluation"})," of ",(0,s.jsx)(n.em,{children:"subforms"})," of the ",(0,s.jsx)(n.em,{children:"special form"}),". For example, ",(0,s.jsx)(n.strong,{children:"block"})," creates a new ",(0,s.jsx)(n.em,{children:"lexical environment"})," that is the same as the one in force at the point of evaluation of the ",(0,s.jsx)(n.strong,{children:"block"})," ",(0,s.jsx)(n.em,{children:"form"})," with the addition of a ",(0,s.jsx)(n.em,{children:"binding"})," of the ",(0,s.jsx)(n.strong,{children:"block"})," name to an ",(0,s.jsx)(n.em,{children:"exit point"})," from the ",(0,s.jsx)(n.strong,{children:"block"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The set of ",(0,s.jsx)(n.em,{children:"special operator names"})," is fixed in Common Lisp; no way is provided for the user to define a ",(0,s.jsx)(n.em,{children:"special operator"})," . Figure 3\u20132 lists all of the Common Lisp ",(0,s.jsx)(n.em,{children:"symbols"})," that have definitions as ",(0,s.jsx)(n.em,{children:"special operators"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"block let* return-from"})," </p><p>",(0,s.jsx)(n.strong,{children:"catch load-time-value setq"})," </p><p>",(0,s.jsx)(n.strong,{children:"eval-when locally symbol-macrolet flet macrolet tagbody"})," </p><p>",(0,s.jsx)(n.strong,{children:"function multiple-value-call the"})," </p><p>",(0,s.jsx)(n.strong,{children:"go multiple-value-prog1 throw"})," </p><p>",(0,s.jsx)(n.strong,{children:"if progn unwind-protect labels progv"})," </p><p>",(0,s.jsx)(n.strong,{children:"let quote"}),"</p>"]})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20132. Common Lisp Special Operators"})})]})}function B(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(N,{...e})}):N(e)}function O(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.2.2 Macro Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"operator"})," names a ",(0,s.jsx)(n.em,{children:"macro"}),", its associated ",(0,s.jsx)(n.em,{children:"macro function"})," is applied to the entire ",(0,s.jsx)(n.em,{children:"form"})," and the result of that application is used in place of the original ",(0,s.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Specifically, a ",(0,s.jsx)(n.em,{children:"symbol"})," names a ",(0,s.jsx)(n.em,{children:"macro"})," in a given ",(0,s.jsx)(n.em,{children:"lexical environment"})," if ",(0,s.jsx)(n.strong,{children:"macro-function"})," is ",(0,s.jsx)(n.em,{children:"true"})," of the ",(0,s.jsx)(n.em,{children:"symbol"})," and that ",(0,s.jsx)(n.em,{children:"environment"}),". The ",(0,s.jsx)(n.em,{children:"function"})," returned by ",(0,s.jsx)(n.strong,{children:"macro-function"})," is a ",(0,s.jsx)(n.em,{children:"function"})," of two arguments, called the expansion function. The expansion function is invoked by calling the ",(0,s.jsx)(n.em,{children:"macroexpand hook"})," with the expansion function as its first argument, the entire ",(0,s.jsx)(n.em,{children:"macro form"})," as its"]}),"\n",(0,s.jsxs)(n.p,{children:["second argument, and an ",(0,s.jsx)(n.em,{children:"environment object"})," (corresponding to the current ",(0,s.jsx)(n.em,{children:"lexical environment"}),") as its third argument. The ",(0,s.jsx)(n.em,{children:"macroexpand hook"}),", in turn, calls the expansion function with the ",(0,s.jsx)(n.em,{children:"form"})," as its first argument and the ",(0,s.jsx)(n.em,{children:"environment"})," as its second argument. The ",(0,s.jsx)(n.em,{children:"value"})," of the expansion function, which is passed through by the ",(0,s.jsx)(n.em,{children:"macroexpand hook"}),", is a ",(0,s.jsx)(n.em,{children:"form"}),". The returned ",(0,s.jsx)(n.em,{children:"form"})," is ",(0,s.jsx)(n.em,{children:"evaluated"})," in place of the original ",(0,s.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences are undefined if a ",(0,s.jsx)(n.em,{children:"macro function"})," destructively modifies any part of its ",(0,s.jsx)(n.em,{children:"form"})," argument."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"macro name"})," is not a ",(0,s.jsx)(n.em,{children:"function designator"})," , and cannot be used as the ",(0,s.jsx)(n.em,{children:"function"})," argument to ",(0,s.jsx)(n.em,{children:"functions"})," such as ",(0,s.jsx)(n.strong,{children:"apply"}),", ",(0,s.jsx)(n.strong,{children:"funcall"}),", or ",(0,s.jsx)(n.strong,{children:"map"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"implementation"})," is free to implement a Common Lisp ",(0,s.jsx)(n.em,{children:"special operator"})," as a ",(0,s.jsx)(n.em,{children:"macro"}),". An ",(0,s.jsx)(n.em,{children:"implementation"})," is free to implement any ",(0,s.jsx)(n.em,{children:"macro operator"})," as a ",(0,s.jsx)(n.em,{children:"special operator"})," , but only if an equivalent definition of the ",(0,s.jsx)(n.em,{children:"macro"})," is also provided."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20133 lists some ",(0,s.jsx)(n.em,{children:"defined names"})," that are applicable to ",(0,s.jsx)(n.em,{children:"macros"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"*macroexpand-hook* macro-function macroexpand-1 defmacro macroexpand macrolet"})})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20133. Defined names applicable to macros"})})]})}function D(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}function M(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.2.3 Function Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"operator"})," is a ",(0,s.jsx)(n.em,{children:"symbol"})," naming a ",(0,s.jsx)(n.em,{children:"function"}),", the ",(0,s.jsx)(n.em,{children:"form"})," represents a ",(0,s.jsx)(n.em,{children:"function form"}),", and the ",(0,s.jsx)(n.em,{children:"cdr"})," of the list contains the ",(0,s.jsx)(n.em,{children:"forms"})," which when evaluated will supply the arguments passed to the ",(0,s.jsx)(n.em,{children:"function"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.em,{children:"function name"})," is not defined, an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"undefined-function"})," should be signaled at run time; see Section 3.2.2.3 (Semantic Constraints)."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"function form"})," is evaluated as follows:"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"subforms"})," in the ",(0,s.jsx)(n.em,{children:"cdr"})," of the original ",(0,s.jsx)(n.em,{children:"form"})," are evaluated in left-to-right order in the current lexical and dynamic ",(0,s.jsx)(n.em,{children:"environments"}),". The ",(0,s.jsx)(n.em,{children:"primary value"})," of each such ",(0,s.jsx)(n.em,{children:"evaluation"})," becomes an ",(0,s.jsx)(n.em,{children:"argument"})," to the named ",(0,s.jsx)(n.em,{children:"function"}),"; any additional ",(0,s.jsx)(n.em,{children:"values"})," returned by the ",(0,s.jsx)(n.em,{children:"subforms"})," are discarded."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"functional value"})," of the ",(0,s.jsx)(n.em,{children:"operator"})," is retrieved from the ",(0,s.jsx)(n.em,{children:"lexical environment"}),", and that ",(0,s.jsx)(n.em,{children:"function"})," is invoked with the indicated arguments."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the order of ",(0,s.jsx)(n.em,{children:"evaluation"})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"})," themselves is strictly left-to-right, it is not specified whether the definition of the ",(0,s.jsx)(n.em,{children:"operator"})," in a ",(0,s.jsx)(n.em,{children:"function form"})," is looked up before the ",(0,s.jsx)(n.em,{children:"evaluation"})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"}),", after the ",(0,s.jsx)(n.em,{children:"evaluation"})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"}),", or between the ",(0,s.jsx)(n.em,{children:"evaluation"})," of any two ",(0,s.jsx)(n.em,{children:"argument subforms"})," if there is more than one such ",(0,s.jsx)(n.em,{children:"argument subform"}),". For example, the following might return 23 or 24."]}),"\n",(0,s.jsx)(n.p,{children:"(defun foo (x) (+ x 3))"}),"\n",(0,s.jsx)(n.p,{children:"(defun bar () (setf (symbol-function \u2019foo) #\u2019(lambda (x) (+ x 4))))"}),"\n",(0,s.jsx)(n.p,{children:"(foo (progn (bar) 20))"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"function name"})," can be ",(0,s.jsx)(n.em,{children:"established"})," in one of several ways. A ",(0,s.jsx)(n.em,{children:"bind ing"})," for a ",(0,s.jsx)(n.em,{children:"function name"})," in the ",(0,s.jsx)(n.em,{children:"global environment"})," can be ",(0,s.jsx)(n.em,{children:"established"})," by ",(0,s.jsx)(n.strong,{children:"defun"}),", ",(0,s.jsx)(n.strong,{children:"setf"})," of ",(0,s.jsx)(n.strong,{children:"fdefinition"}),", ",(0,s.jsx)(n.strong,{children:"setf"})," of ",(0,s.jsx)(n.strong,{children:"symbol-function"}),", ",(0,s.jsx)(n.strong,{children:"ensure-generic-function"}),", ",(0,s.jsx)(n.strong,{children:"defmethod"})," (implicitly, due to ",(0,s.jsx)(n.strong,{children:"ensure-generic-function"}),"), or ",(0,s.jsx)(n.strong,{children:"defgeneric"}),". A ",(0,s.jsx)(n.em,{children:"binding"})," for a ",(0,s.jsx)(n.em,{children:"function name"})," in the ",(0,s.jsx)(n.em,{children:"lexical environment"})," can be ",(0,s.jsx)(n.em,{children:"established"})," by ",(0,s.jsx)(n.strong,{children:"flet"})," or ",(0,s.jsx)(n.strong,{children:"labels"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20134 lists some ",(0,s.jsx)(n.em,{children:"defined names"})," that are applicable to ",(0,s.jsx)(n.em,{children:"functions"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"apply fdefinition mapcan"})," </p><p>",(0,s.jsx)(n.strong,{children:"call-arguments-limit flet mapcar"})," </p><p>",(0,s.jsx)(n.strong,{children:"complement fmakunbound mapcon"})," </p><p>",(0,s.jsx)(n.strong,{children:"constantly funcall mapl"})," </p><p>",(0,s.jsx)(n.strong,{children:"defgeneric function maplist"})," </p><p>",(0,s.jsx)(n.strong,{children:"defmethod functionp multiple-value-call defun labels reduce"})," </p><p>",(0,s.jsx)(n.strong,{children:"fboundp map symbol-function"}),"</p>"]})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20134. Some function-related defined names"})})]})}function X(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(M,{...e})}):M(e)}function H(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.2.4 Lambda Forms"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lambda form"})," is similar to a ",(0,s.jsx)(n.em,{children:"function form"}),", except that the ",(0,s.jsx)(n.em,{children:"function name"})," is replaced by a ",(0,s.jsx)(n.em,{children:"lambda expression"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lambda form"})," is equivalent to using ",(0,s.jsx)(n.em,{children:"funcall"})," of a ",(0,s.jsx)(n.em,{children:"lexical closure"})," of the ",(0,s.jsx)(n.em,{children:"lambda expression"})," on the given ",(0,s.jsx)(n.em,{children:"arguments"}),". (In practice, some compilers are more likely to produce inline code for a ",(0,s.jsx)(n.em,{children:"lambda form"})," than for an arbitrary named function that has been declared ",(0,s.jsx)(n.strong,{children:"inline"}),"; however, such a difference is not semantic.)"]}),"\n",(0,s.jsx)(n.p,{children:"For further information, see Section 3.1.3 (Lambda Expressions)."})]})}function R(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(H,{...e})}):H(e)}function W(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.3 Self-Evaluating Objects"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"form"})," that is neither a ",(0,s.jsx)(n.em,{children:"symbol"})," nor a ",(0,s.jsx)(n.em,{children:"cons"})," is defined to be a ",(0,s.jsx)(n.em,{children:"self-evaluating object"}),". ",(0,s.jsx)(n.em,{children:"Evaluating"})," such an ",(0,s.jsx)(n.em,{children:"object yields"})," the ",(0,s.jsx)(n.em,{children:"same object"})," as a result."]}),"\n",(0,s.jsxs)(n.p,{children:["Certain specific ",(0,s.jsx)(n.em,{children:"symbols"})," and ",(0,s.jsx)(n.em,{children:"conses"})," might also happen to be \u201cself-evaluating\u201d but only as a special case of a more general set of rules for the ",(0,s.jsx)(n.em,{children:"evaluation"})," of ",(0,s.jsx)(n.em,{children:"symbols"})," and ",(0,s.jsx)(n.em,{children:"conses"}),"; such ",(0,s.jsx)(n.em,{children:"objects"})," are not considered to be ",(0,s.jsx)(n.em,{children:"self-evaluating objects"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences are undefined if ",(0,s.jsx)(n.em,{children:"literal objects"})," (including ",(0,s.jsx)(n.em,{children:"self-evaluating objects"}),") are destructively modified."]})]})}function _(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(W,{...e})}):W(e)}function G(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.2.1.3.1 Examples of Self-Evaluating Objects"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Numbers"}),", ",(0,s.jsx)(n.em,{children:"pathnames"}),", and ",(0,s.jsx)(n.em,{children:"arrays"})," are examples of ",(0,s.jsx)(n.em,{children:"self-evaluating objects"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["3 ",(0,s.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,s.jsxs)(n.p,{children:["#c(2/3 5/8) ",(0,s.jsx)(n.em,{children:"\u2192"})," #C(2/3 5/8)"]}),"\n",(0,s.jsxs)(n.p,{children:['#p"S:[BILL]OTHELLO.TXT" ',(0,s.jsx)(n.em,{children:"\u2192"}),' #P"S:[BILL]OTHELLO.TXT"']}),"\n",(0,s.jsxs)(n.p,{children:["#(a b c) ",(0,s.jsx)(n.em,{children:"\u2192"})," #(A B C)"]}),"\n",(0,s.jsxs)(n.p,{children:['"fred smith" ',(0,s.jsx)(n.em,{children:"\u2192"}),' "fred smith"']})]})}function P(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(G,{...e})}):G(e)}function K(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.3 Lambda Expressions"})}),"\n",(0,s.jsxs)(n.p,{children:["In a ",(0,s.jsx)(n.em,{children:"lambda expression"}),", the body is evaluated in a lexical ",(0,s.jsx)(n.em,{children:"environment"})," that is formed by adding the ",(0,s.jsx)(n.em,{children:"binding"})," of each ",(0,s.jsx)(n.em,{children:"parameter"})," in the ",(0,s.jsx)(n.em,{children:"lambda list"})," with the corresponding ",(0,s.jsx)(n.em,{children:"value"})," from the ",(0,s.jsx)(n.em,{children:"arguments"})," to the current lexical ",(0,s.jsx)(n.em,{children:"environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For further discussion of how ",(0,s.jsx)(n.em,{children:"bindings"})," are ",(0,s.jsx)(n.em,{children:"established"})," based on the ",(0,s.jsx)(n.em,{children:"lambda list"}),", see Section 3.4 (Lambda Lists)."]}),"\n",(0,s.jsxs)(n.p,{children:["The body of a ",(0,s.jsx)(n.em,{children:"lambda expression"})," is an ",(0,s.jsx)(n.em,{children:"implicit progn"}),"; the ",(0,s.jsx)(n.em,{children:"values"})," it returns are returned by the ",(0,s.jsx)(n.em,{children:"lambda expression"}),"."]})]})}function U(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(K,{...e})}):K(e)}function Z(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.4 Closures and Lexical Binding"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"lexical closure"})," is a ",(0,s.jsx)(n.em,{children:"function"})," that can refer to and alter the values of ",(0,s.jsx)(n.em,{children:"lexical bindings established"})," by ",(0,s.jsx)(n.em,{children:"binding forms"})," that textually include the function definition."]}),"\n",(0,s.jsxs)(n.p,{children:["Consider this code, where x is not declared ",(0,s.jsx)(n.strong,{children:"special"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"(defun two-funs (x)"}),"\n",(0,s.jsx)(n.p,{children:"(list (function (lambda () x))"}),"\n",(0,s.jsx)(n.p,{children:"(function (lambda (y) (setq x y)))))"}),"\n",(0,s.jsx)(n.p,{children:"(setq funs (two-funs 6))"}),"\n",(0,s.jsxs)(n.p,{children:["(funcall (car funs)) ",(0,s.jsx)(n.em,{children:"\u2192"})," 6"]}),"\n",(0,s.jsxs)(n.p,{children:["(funcall (cadr funs) 43) ",(0,s.jsx)(n.em,{children:"\u2192"})," 43"]}),"\n",(0,s.jsxs)(n.p,{children:["(funcall (car funs)) ",(0,s.jsx)(n.em,{children:"\u2192"})," 43"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"function"})," ",(0,s.jsx)(n.em,{children:"special form"})," coerces a ",(0,s.jsx)(n.em,{children:"lambda expression"})," into a ",(0,s.jsx)(n.em,{children:"closure"})," in which the ",(0,s.jsx)(n.em,{children:"lexical environment"})," in effect when the ",(0,s.jsx)(n.em,{children:"special form"})," is evaluated is captured along with the ",(0,s.jsx)(n.em,{children:"lambda expression"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The function two-funs returns a ",(0,s.jsx)(n.em,{children:"list"})," of two ",(0,s.jsx)(n.em,{children:"functions"}),", each of which refers to the ",(0,s.jsx)(n.em,{children:"binding"})," of the variable x created on entry to the function two-funs when it was called. This variable has the value 6 initially, but ",(0,s.jsx)(n.strong,{children:"setq"})," can alter this ",(0,s.jsx)(n.em,{children:"binding"}),". The ",(0,s.jsx)(n.em,{children:"lexical closure"})," created for the first ",(0,s.jsx)(n.em,{children:"lambda expression"})," does not \u201csnapshot\u201d the ",(0,s.jsx)(n.em,{children:"value"})," 6 for x when the ",(0,s.jsx)(n.em,{children:"closure"})," is created; rather it captures the ",(0,s.jsx)(n.em,{children:"binding"})," of x. The second ",(0,s.jsx)(n.em,{children:"function"})," can be used to alter the ",(0,s.jsx)(n.em,{children:"value"})," in the same (captured) ",(0,s.jsx)(n.em,{children:"binding"})," (to 43, in the example), and this altered variable binding then affects the value returned by the first ",(0,s.jsx)(n.em,{children:"function"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In situations where a ",(0,s.jsx)(n.em,{children:"closure"})," of a ",(0,s.jsx)(n.em,{children:"lambda expression"})," over the same set of ",(0,s.jsx)(n.em,{children:"bindings"})," may be produced more than once, the various resulting ",(0,s.jsx)(n.em,{children:"closures"})," may or may not be ",(0,s.jsx)(n.em,{children:"identical"}),", at the discretion of the ",(0,s.jsx)(n.em,{children:"implementation"}),". That is, two ",(0,s.jsx)(n.em,{children:"functions"})," that are behaviorally indistinguishable might or might not be ",(0,s.jsx)(n.em,{children:"identical"}),". Two ",(0,s.jsx)(n.em,{children:"functions"})," that are behaviorally distinguishable are ",(0,s.jsx)(n.em,{children:"distinct"}),". For example:"]}),"\n",(0,s.jsx)(n.p,{children:"(let ((x 5) (funs \u2019()))"}),"\n",(0,s.jsx)(n.p,{children:"(dotimes (j 10)"}),"\n",(0,s.jsx)(n.p,{children:"(push #\u2019(lambda (z)"}),"\n",(0,s.jsx)(n.p,{children:"(if (null z) (setq x 0) (+ x z)))"}),"\n",(0,s.jsx)(n.p,{children:"funs))"}),"\n",(0,s.jsx)(n.p,{children:"funs)"}),"\n",(0,s.jsxs)(n.p,{children:["The result of the above ",(0,s.jsx)(n.em,{children:"form"})," is a ",(0,s.jsx)(n.em,{children:"list"})," of ten ",(0,s.jsx)(n.em,{children:"closures"}),". Each requires only the ",(0,s.jsx)(n.em,{children:"binding"})," of x. It is the same ",(0,s.jsx)(n.em,{children:"binding"})," in each case, but the ten ",(0,s.jsx)(n.em,{children:"closure objects"})," might or might not be ",(0,s.jsx)(n.em,{children:"identical"}),". On the other hand, the result of the ",(0,s.jsx)(n.em,{children:"form"})]}),"\n",(0,s.jsx)(n.p,{children:"(let ((funs \u2019()))"}),"\n",(0,s.jsx)(n.p,{children:"(dotimes (j 10)"}),"\n",(0,s.jsx)(n.p,{children:"(let ((x 5))"}),"\n",(0,s.jsx)(n.p,{children:"(push (function (lambda (z)"}),"\n",(0,s.jsx)(n.p,{children:"(if (null z) (setq x 0) (+ x z))))"}),"\n",(0,s.jsx)(n.p,{children:"funs)))"}),"\n",(0,s.jsx)(n.p,{children:"funs)"}),"\n",(0,s.jsxs)(n.p,{children:["is also a ",(0,s.jsx)(n.em,{children:"list"})," of ten ",(0,s.jsx)(n.em,{children:"closures"}),". However, in this case no two of the ",(0,s.jsx)(n.em,{children:"closure objects"})," can be ",(0,s.jsx)(n.em,{children:"identical"})," because each ",(0,s.jsx)(n.em,{children:"closure"})," is closed over a distinct ",(0,s.jsx)(n.em,{children:"binding"})," of x, and these ",(0,s.jsx)(n.em,{children:"bindings"})," can be behaviorally distinguished because of the use of ",(0,s.jsx)(n.strong,{children:"setq"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The result of the ",(0,s.jsx)(n.em,{children:"form"})]}),"\n",(0,s.jsx)(n.p,{children:"(let ((funs \u2019()))"}),"\n",(0,s.jsx)(n.p,{children:"(dotimes (j 10)"}),"\n",(0,s.jsx)(n.p,{children:"(let ((x 5))"}),"\n",(0,s.jsx)(n.p,{children:"(push (function (lambda (z) (+ x z)))"}),"\n",(0,s.jsx)(n.p,{children:"funs)))"}),"\n",(0,s.jsx)(n.p,{children:"funs)"}),"\n",(0,s.jsxs)(n.p,{children:["is a ",(0,s.jsx)(n.em,{children:"list"})," of ten ",(0,s.jsx)(n.em,{children:"closure objects"})," that might or might not be ",(0,s.jsx)(n.em,{children:"identical"}),". A different ",(0,s.jsx)(n.em,{children:"binding"})," of x is involved for each ",(0,s.jsx)(n.em,{children:"closure"}),", but the ",(0,s.jsx)(n.em,{children:"bindings"})," cannot be distinguished because their values are the ",(0,s.jsx)(n.em,{children:"same"})," and immutable (there being no occurrence of ",(0,s.jsx)(n.strong,{children:"setq"})," on x). A compiler could internally transform the ",(0,s.jsx)(n.em,{children:"form"})," to"]}),"\n",(0,s.jsx)(n.p,{children:"(let ((funs \u2019()))"}),"\n",(0,s.jsx)(n.p,{children:"(dotimes (j 10)"}),"\n",(0,s.jsx)(n.p,{children:"(push (function (lambda (z) (+ 5 z)))"}),"\n",(0,s.jsx)(n.p,{children:"funs))"}),"\n",(0,s.jsx)(n.p,{children:"funs)"}),"\n",(0,s.jsxs)(n.p,{children:["where the ",(0,s.jsx)(n.em,{children:"closures"})," may be ",(0,s.jsx)(n.em,{children:"identical"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It is possible that a ",(0,s.jsx)(n.em,{children:"closure"})," does not close over any variable bindings. In the code fragment (mapcar (function (lambda (x) (+ x 2))) y)"]}),"\n",(0,s.jsxs)(n.p,{children:["the function (lambda (x) (+ x 2)) contains no references to any outside object. In this case, the same ",(0,s.jsx)(n.em,{children:"closure"})," might be returned for all evaluations of the ",(0,s.jsx)(n.strong,{children:"function"})," ",(0,s.jsx)(n.em,{children:"form"}),"."]})]})}function J(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Z,{...e})}):Z(e)}function Q(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.5 Shadowing"})}),"\n",(0,s.jsxs)(n.p,{children:["If two ",(0,s.jsx)(n.em,{children:"forms"})," that ",(0,s.jsx)(n.em,{children:"establish lexical bindings"})," with the same ",(0,s.jsx)(n.em,{children:"name N"})," are textually nested, then references to ",(0,s.jsx)(n.em,{children:"N"})," within the inner ",(0,s.jsx)(n.em,{children:"form"})," refer to the ",(0,s.jsx)(n.em,{children:"binding"})," established by the inner ",(0,s.jsx)(n.em,{children:"form"}),"; the inner ",(0,s.jsx)(n.em,{children:"binding"})," for ",(0,s.jsx)(n.em,{children:"N shadows"})," the outer ",(0,s.jsx)(n.em,{children:"binding"})," for ",(0,s.jsx)(n.em,{children:"N"}),". Outside the inner ",(0,s.jsx)(n.em,{children:"form"})," but inside the outer one, references to ",(0,s.jsx)(n.em,{children:"N"})," refer to the ",(0,s.jsx)(n.em,{children:"binding"})," established by the outer ",(0,s.jsx)(n.em,{children:"form"}),". For example:"]}),"\n",(0,s.jsx)(n.p,{children:"(defun test (x z)"}),"\n",(0,s.jsx)(n.p,{children:"(let ((z (* x 2)))"}),"\n",(0,s.jsx)(n.p,{children:"(print z))"}),"\n",(0,s.jsx)(n.p,{children:"z)"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"binding"})," of the variable z by ",(0,s.jsx)(n.strong,{children:"let"})," shadows the ",(0,s.jsx)(n.em,{children:"parameter"})," binding for the function test. The reference to the variable z in the ",(0,s.jsx)(n.strong,{children:"print"})," ",(0,s.jsx)(n.em,{children:"form"})," refers to the ",(0,s.jsx)(n.strong,{children:"let"})," binding. The reference to z at the end of the function test refers to the ",(0,s.jsx)(n.em,{children:"parameter"})," named z."]}),"\n",(0,s.jsxs)(n.p,{children:["Constructs that are lexically scoped act as if new names were generated for each ",(0,s.jsx)(n.em,{children:"object"})," on each execution. Therefore, dynamic shadowing cannot occur. For example:"]}),"\n",(0,s.jsx)(n.p,{children:"(defun contorted-example (f g x)"}),"\n",(0,s.jsx)(n.p,{children:"(if (= x 0)"}),"\n",(0,s.jsx)(n.p,{children:"(funcall f)"}),"\n",(0,s.jsx)(n.p,{children:"(block here"}),"\n",(0,s.jsx)(n.p,{children:"(+ 5 (contorted-example g"}),"\n",(0,s.jsx)(n.p,{children:"#\u2019(lambda () (return-from here 4))"}),"\n",(0,s.jsx)(n.p,{children:"(- x 1))))))"}),"\n",(0,s.jsx)(n.p,{children:"Consider the call (contorted-example nil nil 2). This produces 4. During the course of execution, there are three calls to contorted-example, interleaved with two blocks:"}),"\n",(0,s.jsx)(n.p,{children:"(contorted-example nil nil 2)"}),"\n",(0,s.jsx)(n.p,{children:"(block here<sub>1</sub> ...)"}),"\n",(0,s.jsx)(n.p,{children:"(contorted-example nil #\u2019(lambda () (return-from here<sub>1</sub> 4)) 1)"}),"\n",(0,s.jsx)(n.p,{children:"(block here<sub>2</sub> ...)"}),"\n",(0,s.jsx)(n.p,{children:"(contorted-example #\u2019(lambda () (return-from here<sub>1</sub> 4))"}),"\n",(0,s.jsx)(n.p,{children:"#\u2019(lambda () (return-from here<sub>2</sub> 4))"}),"\n",(0,s.jsx)(n.p,{children:"\\0)"}),"\n",(0,s.jsx)(n.p,{children:"(funcall f)"}),"\n",(0,s.jsxs)(n.p,{children:["where f ",(0,s.jsx)(n.em,{children:"\u2192"})," #\u2019(lambda () (return-from here<sub>1</sub> 4))"]}),"\n",(0,s.jsx)(n.p,{children:"(return-from here<sub>1</sub> 4)"}),"\n",(0,s.jsxs)(n.p,{children:["At the time the funcall is executed there are two ",(0,s.jsx)(n.strong,{children:"block"})," ",(0,s.jsx)(n.em,{children:"exit points"})," outstanding, each apparently named here. The ",(0,s.jsx)(n.strong,{children:"return-from"})," ",(0,s.jsx)(n.em,{children:"form"})," executed as a result of the funcall operation refers to the outer outstanding ",(0,s.jsx)(n.em,{children:"exit point"})," (here<sub>1</sub>), not the inner one (here<sub>2</sub>). It refers to that ",(0,s.jsx)(n.em,{children:"exit point"})," textually visible at the point of execution of ",(0,s.jsx)(n.strong,{children:"function"})," (here abbreviated by the #\u2019 syntax) that resulted in creation of the ",(0,s.jsx)(n.em,{children:"function object"})," actually invoked by ",(0,s.jsx)(n.strong,{children:"funcall"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If, in this example, one were to change the (funcall f) to (funcall g), then the value of the call (contorted-example nil nil 2) would be 9. The value would change because ",(0,s.jsx)(n.strong,{children:"funcall"})," would cause the execution of (return-from here<sub>2</sub> 4), thereby causing a return from the inner ",(0,s.jsx)(n.em,{children:"exit point"})," (here<sub>2</sub>)."]}),"\n",(0,s.jsxs)(n.p,{children:["When that occurs, the value 4 is returned from the middle invocation of contorted-example, 5 is added to that to get 9, and that value is returned from the outer block and the outermost call to contorted-example. The point is that the choice of ",(0,s.jsx)(n.em,{children:"exit point"})," returned from has nothing to do with its being innermost or outermost; rather, it depends on the lexical environment that is packaged up with a ",(0,s.jsx)(n.em,{children:"lambda expression"})," when ",(0,s.jsx)(n.strong,{children:"function"})," is executed."]})]})}function Y(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Q,{...e})}):Q(e)}function $(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.6 Extent"})}),"\n",(0,s.jsxs)(n.p,{children:["Contorted-example works only because the ",(0,s.jsx)(n.em,{children:"function"})," named by f is invoked during the ",(0,s.jsx)(n.em,{children:"extent"})," of the ",(0,s.jsx)(n.em,{children:"exit point"}),". Once the flow of execution has left the block, the ",(0,s.jsx)(n.em,{children:"exit point"})," is ",(0,s.jsx)(n.em,{children:"disestablished"}),". For example:"]}),"\n",(0,s.jsx)(n.p,{children:"(defun invalid-example ()"}),"\n",(0,s.jsx)(n.p,{children:"(let ((y (block here #\u2019(lambda (z) (return-from here z)))))"}),"\n",(0,s.jsx)(n.p,{children:"(if (numberp y) y (funcall y 5))))"}),"\n",(0,s.jsxs)(n.p,{children:["One might expect the call (invalid-example) to produce 5 by the following incorrect reasoning: ",(0,s.jsx)(n.strong,{children:"let"})," binds y to the value of ",(0,s.jsx)(n.strong,{children:"block"}),"; this value is a ",(0,s.jsx)(n.em,{children:"function"})," resulting from the ",(0,s.jsx)(n.em,{children:"lambda expression"}),". Because y is not a number, it is invoked on the value 5. The ",(0,s.jsx)(n.strong,{children:"return-from"})," should then return this value from the ",(0,s.jsx)(n.em,{children:"exit point"})," named here, thereby exiting from the block again and giving y the value 5 which, being a number, is then returned as the value of the call to invalid-example."]}),"\n",(0,s.jsxs)(n.p,{children:["The argument fails only because ",(0,s.jsx)(n.em,{children:"exit points"})," have ",(0,s.jsx)(n.em,{children:"dynamic extent"}),". The argument is correct up to the execution of ",(0,s.jsx)(n.strong,{children:"return-from"}),". The execution of ",(0,s.jsx)(n.strong,{children:"return-from"})," should signal an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"control-error"}),", however, not because it cannot refer to the ",(0,s.jsx)(n.em,{children:"exit point"}),", but because it does correctly refer to an ",(0,s.jsx)(n.em,{children:"exit point"})," and that ",(0,s.jsx)(n.em,{children:"exit point"})," has been ",(0,s.jsx)(n.em,{children:"disestablished"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A reference by name to a dynamic ",(0,s.jsx)(n.em,{children:"exit point"})," binding such as a ",(0,s.jsx)(n.em,{children:"catch tag"})," refers to the most recently ",(0,s.jsx)(n.em,{children:"established binding"})," of that name that has not been ",(0,s.jsx)(n.em,{children:"disestablished"}),". For example:"]}),"\n",(0,s.jsx)(n.p,{children:"(defun fun1 (x)"}),"\n",(0,s.jsx)(n.p,{children:"(catch \u2019trap (+ 3 (fun2 x))))"}),"\n",(0,s.jsx)(n.p,{children:"(defun fun2 (y)"}),"\n",(0,s.jsx)(n.p,{children:"(catch \u2019trap (* 5 (fun3 y))))"}),"\n",(0,s.jsx)(n.p,{children:"(defun fun3 (z)"}),"\n",(0,s.jsx)(n.p,{children:"(throw \u2019trap z))"}),"\n",(0,s.jsxs)(n.p,{children:["Consider the call (fun1 7). The result is 10. At the time the ",(0,s.jsx)(n.strong,{children:"throw"})," is executed, there are two outstanding catchers with the name trap: one established within procedure fun1, and the other within procedure fun2. The latter is the more recent, and so the value 7 is returned from ",(0,s.jsx)(n.strong,{children:"catch"})," in fun2. Viewed from within fun3, the ",(0,s.jsx)(n.strong,{children:"catch"})," in fun2 shadows the one in fun1. Had fun2 been defined as"]}),"\n",(0,s.jsx)(n.p,{children:"(defun fun2 (y)"}),"\n",(0,s.jsx)(n.p,{children:"(catch \u2019snare (* 5 (fun3 y))))"}),"\n",(0,s.jsxs)(n.p,{children:["then the two ",(0,s.jsx)(n.em,{children:"exit points"})," would have different ",(0,s.jsx)(n.em,{children:"names"}),", and therefore the one in fun1 would not be shadowed. The result would then have been 7."]})]})}function ee(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3.1.7 Return Values"})}),"\n",(0,s.jsxs)(n.p,{children:["Ordinarily the result of calling a ",(0,s.jsx)(n.em,{children:"function"})," is a single ",(0,s.jsx)(n.em,{children:"object"}),". Sometimes, however, it is convenient for a function to compute several ",(0,s.jsx)(n.em,{children:"objects"})," and return them."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to receive other than exactly one value from a ",(0,s.jsx)(n.em,{children:"form"}),", one of several ",(0,s.jsx)(n.em,{children:"special forms"})," or ",(0,s.jsx)(n.em,{children:"macros"})," must be used to request those values. If a ",(0,s.jsx)(n.em,{children:"form"})," produces ",(0,s.jsx)(n.em,{children:"multiple values"})," which were not requested in this way, then the first value is given to the caller and all others are discarded; if the ",(0,s.jsx)(n.em,{children:"form"})," produces zero values, then the caller receives ",(0,s.jsx)(n.strong,{children:"nil"})," as a value."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20135 lists some ",(0,s.jsx)(n.em,{children:"operators"})," for receiving ",(0,s.jsx)(n.em,{children:"multiple values"}),"<sub>2</sub>. These ",(0,s.jsx)(n.em,{children:"operators"})," can be used to specify one or more ",(0,s.jsx)(n.em,{children:"forms"})," to ",(0,s.jsx)(n.em,{children:"evaluate"})," and where to put the ",(0,s.jsx)(n.em,{children:"values"})," returned by those ",(0,s.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"multiple-value-bind multiple-value-prog1 return-from multiple-value-call multiple-value-setq throw"})," </p><p>",(0,s.jsx)(n.strong,{children:"multiple-value-list return"}),"</p>"]})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20135. Some operators applicable to receiving multiple values"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"function"})," ",(0,s.jsx)(n.strong,{children:"values"})," can produce ",(0,s.jsx)(n.em,{children:"multiple values"}),"<sub>2</sub>. (values) returns zero values; (values ",(0,s.jsx)(n.em,{children:"form"}),") returns the ",(0,s.jsx)(n.em,{children:"primary value"})," returned by ",(0,s.jsx)(n.em,{children:"form"}),"; (values ",(0,s.jsx)(n.em,{children:"form1 form2"}),") returns two values, the ",(0,s.jsx)(n.em,{children:"primary value"})," of ",(0,s.jsx)(n.em,{children:"form1"})," and the ",(0,s.jsx)(n.em,{children:"primary value"})," of ",(0,s.jsx)(n.em,{children:"form2"}),"; and so on."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.strong,{children:"multiple-values-limit"})," and ",(0,s.jsx)(n.strong,{children:"values-list"}),"."]})]})}function ie(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ne,{...e})}):ne(e)}const se={title:"3.1 Evaluation"},re="3.1 Evaluation",te={id:"chap-3/d-b-evaluation",title:"3.1 Evaluation",description:"3.1.1 Introduction to Environments",source:"@site/docs/chap-3/d-b-evaluation.md",sourceDirName:"chap-3",slug:"/chap-3/d-b-evaluation",permalink:"/cl-language-reference/docs/chap-3/d-b-evaluation",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chap-3/d-b-evaluation.md",tags:[],version:"current",frontMatter:{title:"3.1 Evaluation"},sidebar:"tutorialSidebar",previous:{title:"3. Evaluation and Compilation",permalink:"/cl-language-reference/docs/category/3-evaluation-and-compilation"},next:{title:"3.2 Compilation",permalink:"/cl-language-reference/docs/chap-3/d-c-compilation"}},le={},ce=[{value:"3.1.1 Introduction to Environments",id:"311-introduction-to-environments",level:2},{value:"3.1.1.1 The Global Environment",id:"3111-the-global-environment",level:3},{value:"3.1.1.2 Dynamic Environments",id:"3112-dynamic-environments",level:3},{value:"3.1.1.3 Lexical Environments",id:"3113-lexical-environments",level:3},{value:"3.1.1.3.1 The Null Lexical Environment",id:"31131-the-null-lexical-environment",level:4},{value:"3.1.1.4 Environment Objects",id:"3114-environment-objects",level:3},{value:"3.1.2 The Evaluation Model",id:"312-the-evaluation-model",level:2},{value:"3.1.2.1 Form Evaluation",id:"3121-form-evaluation",level:3},{value:"3.1.2.1.1 Symbols as Forms",id:"31211-symbols-as-forms",level:4},{value:"3.1.2.1.1.1 Lexical Variables",id:"312111-lexical-variables",level:5},{value:"3.1.2.1.1.2 Dynamic Variables",id:"312112-dynamic-variables",level:5},{value:"3.1.2.1.1.3 Constant Variables",id:"312113-constant-variables",level:5},{value:"3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables",id:"312114-symbols-naming-both-lexical-and-dynamic-variables",level:5},{value:"3.1.2.1.2 Conses as Forms",id:"31212-conses-as-forms",level:4},{value:"3.1.2.1.2.1 Special Forms",id:"312121-special-forms",level:5},{value:"3.1.2.1.2.2 Macro Forms",id:"312122-macro-forms",level:5},{value:"3.1.2.1.2.3 Function Forms",id:"312123-function-forms",level:5},{value:"3.1.2.1.2.4 Lambda Forms",id:"312124-lambda-forms",level:5},{value:"3.1.2.1.3 Self",id:"31213-self",level:4},{value:"3.1.2.1.3.1 Examples of Self",id:"312131-examples-of-self",level:5},{value:"3.1.3 Lambda Expressions",id:"313-lambda-expressions",level:2},{value:"3.1.4 Closures and Lexical Binding",id:"314-closures-and-lexical-binding",level:2},{value:"3.1.5 Shadowing",id:"315-shadowing",level:2},{value:"3.1.6 Extent",id:"316-extent",level:2},{value:"3.1.7 Return Values",id:"317-return-values",level:2}];function ae(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"31-evaluation",children:"3.1 Evaluation"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h2,{id:"311-introduction-to-environments",children:"3.1.1 Introduction to Environments"}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(n.h3,{id:"3111-the-global-environment",children:"3.1.1.1 The Global Environment"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(n.h3,{id:"3112-dynamic-environments",children:"3.1.1.2 Dynamic Environments"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(n.h3,{id:"3113-lexical-environments",children:"3.1.1.3 Lexical Environments"}),"\n","\n",(0,s.jsx)(j,{}),"\n",(0,s.jsx)(n.h4,{id:"31131-the-null-lexical-environment",children:"3.1.1.3.1 The Null Lexical Environment"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(n.h3,{id:"3114-environment-objects",children:"3.1.1.4 Environment Objects"}),"\n","\n",(0,s.jsx)(b,{}),"\n",(0,s.jsx)(n.h2,{id:"312-the-evaluation-model",children:"3.1.2 The Evaluation Model"}),"\n","\n",(0,s.jsx)(v,{}),"\n",(0,s.jsx)(n.h3,{id:"3121-form-evaluation",children:"3.1.2.1 Form Evaluation"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(n.h4,{id:"31211-symbols-as-forms",children:"3.1.2.1.1 Symbols as Forms"}),"\n","\n",(0,s.jsx)(F,{}),"\n",(0,s.jsx)(n.h5,{id:"312111-lexical-variables",children:"3.1.2.1.1.1 Lexical Variables"}),"\n","\n",(0,s.jsx)(k,{}),"\n",(0,s.jsx)(n.h5,{id:"312112-dynamic-variables",children:"3.1.2.1.1.2 Dynamic Variables"}),"\n","\n",(0,s.jsx)(L,{}),"\n",(0,s.jsx)(n.h5,{id:"312113-constant-variables",children:"3.1.2.1.1.3 Constant Variables"}),"\n","\n",(0,s.jsx)(C,{}),"\n",(0,s.jsx)(n.h5,{id:"312114-symbols-naming-both-lexical-and-dynamic-variables",children:"3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables"}),"\n","\n",(0,s.jsx)(z,{}),"\n",(0,s.jsx)(n.h4,{id:"31212-conses-as-forms",children:"3.1.2.1.2 Conses as Forms"}),"\n","\n",(0,s.jsx)(V,{}),"\n",(0,s.jsx)(n.h5,{id:"312121-special-forms",children:"3.1.2.1.2.1 Special Forms"}),"\n","\n",(0,s.jsx)(B,{}),"\n",(0,s.jsx)(n.h5,{id:"312122-macro-forms",children:"3.1.2.1.2.2 Macro Forms"}),"\n","\n",(0,s.jsx)(D,{}),"\n",(0,s.jsx)(n.h5,{id:"312123-function-forms",children:"3.1.2.1.2.3 Function Forms"}),"\n","\n",(0,s.jsx)(X,{}),"\n",(0,s.jsx)(n.h5,{id:"312124-lambda-forms",children:"3.1.2.1.2.4 Lambda Forms"}),"\n","\n",(0,s.jsx)(R,{}),"\n",(0,s.jsx)(n.h4,{id:"31213-self",children:"3.1.2.1.3 Self"}),"\n","\n",(0,s.jsx)(_,{}),"\n",(0,s.jsx)(n.h5,{id:"312131-examples-of-self",children:"3.1.2.1.3.1 Examples of Self"}),"\n","\n",(0,s.jsx)(P,{}),"\n",(0,s.jsx)(n.h2,{id:"313-lambda-expressions",children:"3.1.3 Lambda Expressions"}),"\n","\n",(0,s.jsx)(U,{}),"\n",(0,s.jsx)(n.h2,{id:"314-closures-and-lexical-binding",children:"3.1.4 Closures and Lexical Binding"}),"\n","\n",(0,s.jsx)(J,{}),"\n",(0,s.jsx)(n.h2,{id:"315-shadowing",children:"3.1.5 Shadowing"}),"\n","\n",(0,s.jsx)(Y,{}),"\n",(0,s.jsx)(n.h2,{id:"316-extent",children:"3.1.6 Extent"}),"\n","\n",(0,s.jsx)(ee,{}),"\n",(0,s.jsx)(n.h2,{id:"317-return-values",children:"3.1.7 Return Values"}),"\n","\n","\n",(0,s.jsx)(ie,{})]})}function oe(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ae,{...e})}):ae(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>l});var s=i(7294);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);