"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[59516],{28453:(e,t,r)=>{r.d(t,{R:()=>c,x:()=>l});var n=r(96540);const s={},i=n.createContext(s);function c(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(i.Provider,{value:t},e.children)}},69998:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>n,toc:()=>x});const n=JSON.parse('{"id":"chap-17/bh-d-dictionary/sort_stable-sort_function","title":"sort, stable-sort","description":"Expanded Reference: sort, stable-sort","source":"@site/docs/chap-17/bh-d-dictionary/sort_stable-sort_function.md","sourceDirName":"chap-17/bh-d-dictionary","slug":"/chap-17/bh-d-dictionary/sort_stable-sort_function","permalink":"/cl-language-reference/chap-17/bh-d-dictionary/sort_stable-sort_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-17/bh-d-dictionary/sort_stable-sort_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"sort, stable-sort"},"sidebar":"tutorialSidebar","previous":{"title":"sequence","permalink":"/cl-language-reference/chap-17/bh-d-dictionary/sequence_system-class"},"next":{"title":"subseq","permalink":"/cl-language-reference/chap-17/bh-d-dictionary/subseq_accessor"}}');var s=r(74848),i=r(28453);function c(e){const t={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{DictionaryLink:r,GlossaryTerm:n}=t;return r||d("DictionaryLink",!0),n||d("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"sort, stable-sort"})," ",(0,s.jsx)(n,{term:"function",children:(0,s.jsx)("i",{children:"Function"})})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(r,{term:"sort",children:(0,s.jsx)("b",{children:"sort"})})," ",(0,s.jsx)(t.em,{children:"sequence predicate"})," &key ",(0,s.jsx)(t.em,{children:"key \u2192 sorted-sequence"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(r,{term:"stable-sort",children:(0,s.jsx)("b",{children:"stable-sort"})})," ",(0,s.jsx)(t.em,{children:"sequence predicate"})," &key ",(0,s.jsx)(t.em,{children:"key \u2192 sorted-sequence"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"sequence"}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"proper sequence",children:(0,s.jsx)("i",{children:"proper sequence"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})}),"\u2014a ",(0,s.jsx)(n,{term:"designator",children:(0,s.jsx)("i",{children:"designator"})})," for a ",(0,s.jsx)(n,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," of two arguments that returns a ",(0,s.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),". ",(0,s.jsx)(n,{styled:!0,term:"key",children:(0,s.jsx)("i",{children:"key"})}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"designator",children:(0,s.jsx)("i",{children:"designator"})})," for a ",(0,s.jsx)(n,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," of one argument, or ",(0,s.jsx)(r,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"sorted-sequence"}),"\u2014a ",(0,s.jsx)(t.em,{children:"sequence"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(r,{term:"sort",children:(0,s.jsx)("b",{children:"sort"})})," and ",(0,s.jsx)(r,{term:"stable-sort",children:(0,s.jsx)("b",{children:"stable-sort"})})," destructively sort ",(0,s.jsx)(t.em,{children:"sequences"})," according to the order determined by the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," function."]}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.em,{children:"sequence"})," is a ",(0,s.jsx)(n,{term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," , the result is a ",(0,s.jsx)(n,{term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," that has the same ",(0,s.jsx)(n,{styled:!0,term:"actual array element type",children:(0,s.jsx)("i",{children:"actual array element type"})})," as ",(0,s.jsx)(t.em,{children:"sequence"}),". If ",(0,s.jsx)(t.em,{children:"sequence"})," is a ",(0,s.jsx)(n,{term:"list",children:(0,s.jsx)("i",{children:"list"})}),", the result is a ",(0,s.jsx)(n,{term:"list",children:(0,s.jsx)("i",{children:"list"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(r,{term:"sort",children:(0,s.jsx)("b",{children:"sort"})})," determines the relationship between two elements by giving keys extracted from the elements to the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})}),". The first argument to the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," function is the part of one element of ",(0,s.jsx)(t.em,{children:"sequence"})," extracted by the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," function (if supplied); the second argument is the part of another element of ",(0,s.jsx)(t.em,{children:"sequence"})," extracted by the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," function (if supplied). ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"Predicate"})})," should return ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," if and only if the first argument is strictly less than the second (in some appropriate sense). If the first argument is"]}),"\n",(0,s.jsxs)(t.p,{children:["greater than or equal to the second (in the appropriate sense), then the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," should return ",(0,s.jsx)(n,{term:"false",children:(0,s.jsx)("i",{children:"false"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The argument to the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," function is the ",(0,s.jsx)(t.em,{children:"sequence"})," element. The return value of the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," function becomes an argument to ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})}),". If ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," is not supplied or ",(0,s.jsx)(r,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})}),", the ",(0,s.jsx)(t.em,{children:"sequence"})," element itself is used. There is no guarantee on the number of times the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," will be called."]}),"\n",(0,s.jsxs)(t.p,{children:["If the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," and ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," always return, then the sorting operation will always terminate, producing a ",(0,s.jsx)(t.em,{children:"sequence"})," containing the same ",(0,s.jsx)(n,{term:"element",children:(0,s.jsx)("i",{children:"elements"})})," as ",(0,s.jsx)(t.em,{children:"sequence"})," (that is, the result is a permutation of ",(0,s.jsx)(t.em,{children:"sequence"}),"). This is guaranteed even if the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," does not really consistently represent a total order (in which case the ",(0,s.jsx)(n,{term:"element",children:(0,s.jsx)("i",{children:"elements"})})," will be scrambled in some unpredictable way, but no ",(0,s.jsx)(n,{term:"element",children:(0,s.jsx)("i",{children:"element"})})," will be lost). If the ",(0,s.jsx)(n,{term:"key",children:(0,s.jsx)("i",{children:"key"})})," consistently returns meaningful keys, and the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," does reflect some total ordering criterion on those keys, then the ",(0,s.jsx)(n,{term:"element",children:(0,s.jsx)("i",{children:"elements"})})," of the ",(0,s.jsx)(t.em,{children:"sorted-sequence"})," will be properly sorted according to that ordering."]}),"\n",(0,s.jsx)(r,{styled:!0,term:"sort, stable-sort",children:(0,s.jsx)("b",{children:"sort, stable-sort"})}),"\n",(0,s.jsxs)(t.p,{children:["The sorting operation performed by ",(0,s.jsx)(r,{term:"sort",children:(0,s.jsx)("b",{children:"sort"})})," is not guaranteed stable. Elements considered equal by the ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," might or might not stay in their original order. The ",(0,s.jsx)(n,{term:"predicate",children:(0,s.jsx)("i",{children:"predicate"})})," is assumed to consider two elements x and y to be equal if (funcall ",(0,s.jsx)(t.em,{children:"predicate x y"}),") and (funcall ",(0,s.jsx)(t.em,{children:"predicate y x"}),") are both ",(0,s.jsx)(n,{term:"false",children:(0,s.jsx)("i",{children:"false"})}),". ",(0,s.jsx)(r,{term:"stable-sort",children:(0,s.jsx)("b",{children:"stable-sort"})})," guarantees stability."]}),"\n",(0,s.jsxs)(t.p,{children:["The sorting operation can be destructive in all cases. In the case of a ",(0,s.jsx)(n,{term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," argument, this is accomplished by permuting the elements in place. In the case of a ",(0,s.jsx)(n,{term:"list",children:(0,s.jsx)("i",{children:"list"})}),", the ",(0,s.jsx)(n,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," is destructively reordered in the same manner as for ",(0,s.jsx)(r,{term:"nreverse",children:(0,s.jsx)("b",{children:"nreverse"})}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lisp",children:'(setq tester (copy-seq "lkjashd")) \u2192 "lkjashd" \n(sort tester #\u2019char-lessp) \u2192 "adhjkls" \n(setq tester (list \u2019(1 2 3) \u2019(4 5 6) \u2019(7 8 9))) \u2192 ((1 2 3) (4 5 6) (7 8 9)) \n(sort tester #\u2019> :key #\u2019car) \u2192 ((7 8 9) (4 5 6) (1 2 3)) \n(setq tester (list 1 2 3 4 5 6 7 8 9 0)) \u2192 (1 2 3 4 5 6 7 8 9 0) \n(stable-sort tester #\u2019(lambda (x y) (and (oddp x) (evenp y)))) \n\u2192 (1 3 5 7 9 2 4 6 8 0) \n(sort (setq committee-data \n\t    (vector (list (list "JonL" "White") "Iteration") \n\t\t    (list (list "Dick" "Waters") "Iteration") \n\t\t    (list (list "Dick" "Gabriel") "Objects") \n\t\t    (list (list "Kent" "Pitman") "Conditions") \n\t\t    (list (list "Gregor" "Kiczales") "Objects") \n\t\t    (list (list "David" "Moon") "Objects") \n\t\t    (list (list "Kathy" "Chapman") "Editorial") \n\t\t    (list (list "Larry" "Masinter") "Cleanup") \n\t\t    (list (list "Sandra" "Loosemore") "Compiler"))) \n      #\u2019string-lessp :key #\u2019cadar) \n\u2192 #((("Kathy" "Chapman") "Editorial") \n    (("Dick" "Gabriel") "Objects") \n    (("Gregor" "Kiczales") "Objects") \n    (("Sandra" "Loosemore") "Compiler") \n    (("Larry" "Masinter") "Cleanup") \n    (("David" "Moon") "Objects") \n    (("Kent" "Pitman") "Conditions") \n    (("Dick" "Waters") "Iteration") \n    (("JonL" "White") "Iteration")) \n;; Note that individual alphabetical order within \u2018committees\u2019 \n;; is preserved. \n(setq committee-data \n      (stable-sort committee-data #\u2019string-lessp :key #\u2019cadr)) \n\u2192 #((("Larry" "Masinter") "Cleanup") \n    (("Sandra" "Loosemore") "Compiler") \n    (("Kent" "Pitman") "Conditions") \n    (("Kathy" "Chapman") "Editorial") \n    \n    \n    (("Dick" "Waters") "Iteration") \n    (("JonL" "White") "Iteration") \n    (("Dick" "Gabriel") "Objects") \n    (("Gregor" "Kiczales") "Objects") \n    (("David" "Moon") "Objects")) \n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(t.p,{children:["Should be prepared to signal an error of ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(r,{term:"type-error",children:(0,s.jsx)("b",{children:"type-error"})})," if ",(0,s.jsx)(t.em,{children:"sequence"})," is not a ",(0,s.jsx)(n,{styled:!0,term:"proper sequence",children:(0,s.jsx)("i",{children:"proper sequence"})}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(r,{term:"merge",children:(0,s.jsx)("b",{children:"merge"})}),", Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects), Section 3.7 (Destructive Operations)"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.em,{children:"sequence"})," is a ",(0,s.jsx)(n,{term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," , the result might or might not be simple, and might or might not be ",(0,s.jsx)(n,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})})," to ",(0,s.jsx)(t.em,{children:"sequence"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function d(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const o={title:"sort, stable-sort"},a="sort, stable-sort",h={},x=[{value:"Expanded Reference: sort, stable-sort",id:"expanded-reference-sort-stable-sort",level:2}];function j(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"sort-stable-sort",children:"sort, stable-sort"})}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(t.h2,{id:"expanded-reference-sort-stable-sort",children:"Expanded Reference: sort, stable-sort"}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lisp",children:"(sort, stable-sort )\n"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}}}]);