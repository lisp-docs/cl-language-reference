"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[1477],{9845:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>oe,contentTitle:()=>le,default:()=>xe,frontMatter:()=>ce,metadata:()=>he,toc:()=>de});var s=r(5893),i=r(1151);function t(e){return(0,s.jsx)(s.Fragment,{})}function a(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t()}function c(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Common Lisp provides a representation of most ",(0,s.jsx)(n.em,{children:"objects"})," in the form of printed text called the printed representation. Functions such as ",(0,s.jsx)(n.strong,{children:"print"})," take an ",(0,s.jsx)(n.em,{children:"object"})," and send the characters of its printed representation to a ",(0,s.jsx)(n.em,{children:"stream"}),". The collection of routines that does this is known as the (Common Lisp) printer."]}),"\n",(0,s.jsxs)(n.p,{children:["Reading a printed representation typically produces an ",(0,s.jsx)(n.em,{children:"object"})," that is ",(0,s.jsx)(n.strong,{children:"equal"})," to the originally printed ",(0,s.jsx)(n.em,{children:"object"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function h(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Most ",(0,s.jsx)(n.em,{children:"objects"})," have more than one possible textual representation. For example, the positive ",(0,s.jsx)(n.em,{children:"integer"})," with a magnitude of twenty-seven can be textually expressed in any of these ways:"]}),"\n",(0,s.jsx)(n.p,{children:"27 27. #o33 #x1B #b11011 #.(* 3 3 3) 81/3"}),"\n",(0,s.jsx)(n.p,{children:"A list containing the two symbols A and B can also be textually expressed in a variety of ways:"}),"\n",(0,s.jsx)(n.p,{children:"(A B) (a b) ( a b ) (\\A |B|)"}),"\n",(0,s.jsx)(n.p,{children:"(|\\A|"}),"\n",(0,s.jsx)(n.p,{children:"B"}),"\n",(0,s.jsx)(n.p,{children:")"}),"\n",(0,s.jsxs)(n.p,{children:["In general, from the point of view of the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," , wherever ",(0,s.jsx)(n.em,{children:"whitespace"})," is permissible in a textual representation, any number of ",(0,s.jsx)(n.em,{children:"spaces"})," and ",(0,s.jsx)(n.em,{children:"newlines"})," can appear in ",(0,s.jsx)(n.em,{children:"standard syntax"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:["When a function such as ",(0,s.jsx)(n.strong,{children:"print"})," produces a printed representation, it must choose from among many possible textual representations. In most cases, it chooses a program readable representation, but in certain cases it might use a more compact notation that is not program-readable."]}),"\n",(0,s.jsxs)(n.p,{children:["A number of option variables, called ",(0,s.jsx)(n.em,{children:"printer control variables"}),", are provided to permit control of individual aspects of the printed representation of ",(0,s.jsx)(n.em,{children:"objects"}),". Figure 22\u20131 shows the ",(0,s.jsx)(n.em,{children:"standardized printer control variables"}),"; there might also be ",(0,s.jsx)(n.em,{children:"implementation-defined printer control variables"}),"."]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"*print-array* *print-gensym* *print-pprint-dispatch* *print-base* *print-length* *print-pretty*"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-case* *print-level* *print-radix*"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-circle* *print-lines* *print-readably* *print-escape* *print-miser-width* *print-right-margin*"}),"</p>"]})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 22\u20131. Standardized Printer Control Variables"})}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u20131"})]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.em,{children:"printer control variables"}),", the following additional ",(0,s.jsx)(n.em,{children:"defined names"})," relate to or affect the behavior of the ",(0,s.jsx)(n.em,{children:"Lisp printer"})," :"]}),"\n",(0,s.jsx)(n.table,{children:(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"*package* *read-eval* readtable-case *read-default-float-format* *readtable*"})})})})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 22\u20132. Additional Influences on the Lisp printer."})})]})}function o(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}function d(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," controls whether the ",(0,s.jsx)(n.em,{children:"Lisp printer"})," tries to produce notations such as escape characters and package prefixes."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," can be used to override many of the individual aspects controlled by the other ",(0,s.jsx)(n.em,{children:"printer control variables"})," when program-readable output is especially important."]}),"\n",(0,s.jsxs)(n.p,{children:["One of the many effects of making the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," be ",(0,s.jsx)(n.em,{children:"true"})," is that the ",(0,s.jsx)(n.em,{children:"Lisp printer"})," behaves as if ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," were also ",(0,s.jsx)(n.em,{children:"true"}),". For notational convenience, we say that if the value of either ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," or ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", then ",(0,s.jsx)(n.em,{children:"printer escaping"})," is \u201cenabled\u201d; and we say that if the values of both ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," and ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," are ",(0,s.jsx)(n.em,{children:"false"}),", then ",(0,s.jsx)(n.em,{children:"printer escaping"})," is \u201cdisabled\u201d."]})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function x(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"Lisp printer"})," makes its determination of how to print an ",(0,s.jsx)(n.em,{children:"object"})," as follows:"]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", printing is controlled by the ",(0,s.jsx)(n.em,{children:"current pprint dispatch table"}),"; see Section 22.2.1.4 (Pretty Print Dispatch Tables)."]}),"\n",(0,s.jsxs)(n.p,{children:["Otherwise (if the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"false"}),"), the object\u2019s ",(0,s.jsx)(n.strong,{children:"print-object"})," method is used; see Section 22.1.3 (Default Print-Object Methods)."]})]})}function j(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}function m(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["This section describes the default behavior of ",(0,s.jsx)(n.strong,{children:"print-object"})," methods for the ",(0,s.jsx)(n.em,{children:"standardized types"}),"."]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}function f(e){return(0,s.jsx)(s.Fragment,{})}function g(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(f,{...e})}):f()}function b(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Integers"})," are printed in the radix specified by the ",(0,s.jsx)(n.em,{children:"current output base"})," in positional notation, most significant digit first. If appropriate, a radix specifier can be printed; see ",(0,s.jsx)(n.strong,{children:"*print-radix*"}),". If an ",(0,s.jsx)(n.em,{children:"integer"})," is negative, a minus sign is printed and then the absolute value of the ",(0,s.jsx)(n.em,{children:"integer"})," is printed. The ",(0,s.jsx)(n.em,{children:"integer"})," zero is represented by the single digit 0 and never has a sign. A decimal point might be printed, depending on the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-radix*"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For related information about the syntax of an ",(0,s.jsx)(n.em,{children:"integer"})," , see Section 2.3.2.1.1 (Syntax of an Integer)."]})]})}function y(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}function v(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Ratios"})," are printed as follows: the absolute value of the numerator is printed, as for an ",(0,s.jsx)(n.em,{children:"integer"})," ; then a /; then the denominator. The numerator and denominator are both printed in the radix specified by the ",(0,s.jsx)(n.em,{children:"current output base"}),"; they are obtained as if by ",(0,s.jsx)(n.strong,{children:"numerator"})," and ",(0,s.jsx)(n.strong,{children:"denominator"}),", and so ",(0,s.jsx)(n.em,{children:"ratios"})," are printed in reduced form (lowest terms). If appropriate, a radix specifier can be printed; see"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*print-radix*"}),". If the ratio is negative, a minus sign is printed before the numerator. For related information about the syntax of a ",(0,s.jsx)(n.em,{children:"ratio"}),", see Section 2.3.2.1.2 (Syntax of a Ratio)."]})]})}function w(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(v,{...e})}):v(e)}function A(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If the magnitude of the <i>float</i> is either zero or between 10<sup><i>\u2212</i>3</sup>(inclusive) and 10<sup>7</sup>(exclusive), it is printed as the integer part of the number, then a decimal point, followed by the fractional part of the number; there is always at least one digit on each side of the decimal point. If the sign of the number (as determined by <b>float-sign</b>) is negative, then a minus sign is printed before the number. If the format of the number does not match that specified by <b>",(0,s.jsx)(n.em,{children:"read-default-float-format"}),"</b>, then the <i>exponent marker</i> for that format and the digit 0 are also printed. For example, the base of the natural logarithms as a <i>short float</i> might be printed as 2.71828S0."]}),"\n",(0,s.jsxs)(n.p,{children:["For non-zero magnitudes outside of the range 10<sup><i>\u2212</i>3</sup>to 10<sup>7</sup>, a <i>float</i> is printed in computerized scientific notation. The representation of the number is scaled to be between 1 (inclusive) and 10 (exclusive) and then printed, with one digit before the decimal point and at least one digit after the decimal point. Next the <i>exponent marker</i> for the format is printed, except that if the format of the number matches that specified by <b>",(0,s.jsx)(n.em,{children:"read-default-float-format"}),"</b>, then the <i>exponent marker</i> E is used. Finally, the power of ten by which the fraction must be multiplied to equal the original number is printed as a decimal integer. For example, Avogadro\u2019s number as a <i>short float</i> is printed as 6.02S23."]}),"\n",(0,s.jsxs)(n.p,{children:["For related information about the syntax of a ",(0,s.jsx)(n.em,{children:"float"}),", see Section 2.3.2.2 (Syntax of a Float)."]})]})}function E(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(A,{...e})}):A(e)}function P(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"complex"})," is printed as #C, an open parenthesis, the printed representation of its real part, a space, the printed representation of its imaginary part, and finally a close parenthesis."]}),"\n",(0,s.jsxs)(n.p,{children:["For related information about the syntax of a ",(0,s.jsx)(n.em,{children:"complex"})," , see Section 2.3.2.3 (Syntax of a Complex) and Section 2.4.8.11 (Sharpsign C)."]}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u20133"})]})]})}function S(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}function C(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["The printed representation of a number must not contain ",(0,s.jsx)(n.em,{children:"escape characters"}),"; see Section 2.3.1.1.1 (Escape Characters and Potential Numbers)."]})}function T(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}function I(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.em,{children:"printer escaping"})," is disabled, a ",(0,s.jsx)(n.em,{children:"character"})," prints as itself; it is sent directly to the output ",(0,s.jsx)(n.em,{children:"stream"}),". When ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled, then #\\ syntax is used."]}),"\n",(0,s.jsxs)(n.p,{children:["When the printer types out the name of a ",(0,s.jsx)(n.em,{children:"character"})," , it uses the same table as the #\\ ",(0,s.jsx)(n.em,{children:"reader macro"})," would use; therefore any ",(0,s.jsx)(n.em,{children:"character"})," name that is typed out is acceptable as input (in that ",(0,s.jsx)(n.em,{children:"implementation"}),"). If a ",(0,s.jsx)(n.em,{children:"non-graphic character"})," has a ",(0,s.jsx)(n.em,{children:"standardized name"}),"<sub>5</sub>, that ",(0,s.jsx)(n.em,{children:"name"})," is preferred over non-standard ",(0,s.jsx)(n.em,{children:"names"})," for printing in #\\ notation. For the ",(0,s.jsx)(n.em,{children:"graphic standard characters"}),", the ",(0,s.jsx)(n.em,{children:"character"})," itself is always used for printing in #\\ notation\u2014even if the ",(0,s.jsx)(n.em,{children:"character"})," also has a ",(0,s.jsx)(n.em,{children:"name"}),"<sub>5</sub>."]}),"\n",(0,s.jsxs)(n.p,{children:["For details about the #\\ ",(0,s.jsx)(n.em,{children:"reader macro"}),", see Section 2.4.8.1 (Sharpsign Backslash)."]})]})}function R(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(I,{...e})}):I(e)}function F(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.em,{children:"printer escaping"})," is disabled, only the characters of the ",(0,s.jsx)(n.em,{children:"symbol"}),"\u2019s ",(0,s.jsx)(n.em,{children:"name"})," are output (but the case in which to print characters in the ",(0,s.jsx)(n.em,{children:"name"})," is controlled by ",(0,s.jsx)(n.strong,{children:"*print-case*"}),"; see Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp Printer))."]}),"\n",(0,s.jsxs)(n.p,{children:["The remainder of this section applies only when ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled."]}),"\n",(0,s.jsxs)(n.p,{children:["When printing a ",(0,s.jsx)(n.em,{children:"symbol"}),", the printer inserts enough ",(0,s.jsx)(n.em,{children:"single escape"})," and/or ",(0,s.jsx)(n.em,{children:"multiple escape"})," characters (",(0,s.jsx)(n.em,{children:"backslashes"})," and/or ",(0,s.jsx)(n.em,{children:"vertical-bars"}),") so that if ",(0,s.jsx)(n.strong,{children:"read"})," were called with the same ",(0,s.jsx)(n.strong,{children:"*readtable*"})," and with ",(0,s.jsx)(n.strong,{children:"*read-base*"})," bound to the ",(0,s.jsx)(n.em,{children:"current output base"}),", it would return the same ",(0,s.jsx)(n.em,{children:"symbol"})," (if it is not ",(0,s.jsx)(n.em,{children:"apparently uninterned"}),") or an ",(0,s.jsx)(n.em,{children:"uninterned symbol"})," with the same ",(0,s.jsx)(n.em,{children:"print name"})," (otherwise)."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-base*"})," were 16 when printing the symbol face, it would have to be printed as \\FACE or \\Face or |FACE|, because the token face would be read as a hexadecimal number (decimal value 64206) if the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*read-base*"})," were 16."]}),"\n",(0,s.jsxs)(n.p,{children:["For additional restrictions concerning characters with nonstandard ",(0,s.jsx)(n.em,{children:"syntax types"})," in the ",(0,s.jsx)(n.em,{children:"current readtable"}),", see the ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*print-readably*"})]}),"\n",(0,s.jsxs)(n.p,{children:["For information about how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses ",(0,s.jsx)(n.em,{children:"symbols"}),", see Section 2.3.4 (Symbols as Tokens) and Section 2.4.8.5 (Sharpsign Colon)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"nil"})," might be printed as () when ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"true"})," and ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled."]})]})}function Z(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(F,{...e})}):F(e)}function L(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Package prefixes"})," are printed if necessary. The rules for ",(0,s.jsx)(n.em,{children:"package prefixes"})," are as follows. When the ",(0,s.jsx)(n.em,{children:"symbol"})," is printed, if it is in the KEYWORD ",(0,s.jsx)(n.em,{children:"package"}),", then it is printed with a preceding ",(0,s.jsx)(n.em,{children:"colon"}),"; otherwise, if it is ",(0,s.jsx)(n.em,{children:"accessible"})," in the ",(0,s.jsx)(n.em,{children:"current package"}),", it is printed without any ",(0,s.jsx)(n.em,{children:"package prefix"})," ; otherwise, it is printed with a ",(0,s.jsx)(n.em,{children:"package prefix"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"symbol"})," that is ",(0,s.jsx)(n.em,{children:"apparently uninterned"})," is printed preceded by \u201c#:\u201d if ",(0,s.jsx)(n.strong,{children:"*print-gensym*"})," is ",(0,s.jsx)(n.em,{children:"true"})," and ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled; if ",(0,s.jsx)(n.strong,{children:"*print-gensym*"})," is ",(0,s.jsx)(n.em,{children:"false"})," or ",(0,s.jsx)(n.em,{children:"printer escaping"})," is disabled, then the ",(0,s.jsx)(n.em,{children:"symbol"})," is printed without a prefix, as if it were in the ",(0,s.jsx)(n.em,{children:"current package"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Because the #: syntax does not intern the following symbol, it is necessary to use circular-list syntax if ",(0,s.jsx)(n.strong,{children:"*print-circle*"})," is ",(0,s.jsx)(n.em,{children:"true"})," and the same uninterned symbol appears several times in an expression to be printed. For example, the result of"]}),"\n",(0,s.jsx)(n.p,{children:'(let ((x (make-symbol "FOO"))) (list x x))'}),"\n",(0,s.jsxs)(n.p,{children:["would be printed as (#",":foo"," #",":foo",") if ",(0,s.jsx)(n.strong,{children:"*print-circle*"})," were ",(0,s.jsx)(n.em,{children:"false"}),", but as (#1=#",":foo"," #1#) if ",(0,s.jsx)(n.strong,{children:"*print-circle*"})," were ",(0,s.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"A summary of the preceding package prefix rules follows:"}),"\n",(0,s.jsxs)(n.p,{children:["foo",":bar"]}),"\n",(0,s.jsxs)(n.p,{children:["foo",":bar"," is printed when ",(0,s.jsx)(n.em,{children:"symbol"})," bar is external in its ",(0,s.jsx)(n.em,{children:"home package"})," foo and is not ",(0,s.jsx)(n.em,{children:"accessible"})," in the ",(0,s.jsx)(n.em,{children:"current package"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"foo::bar"}),"\n",(0,s.jsxs)(n.p,{children:["foo::bar is printed when bar is internal in its ",(0,s.jsx)(n.em,{children:"home package"})," foo and is not ",(0,s.jsx)(n.em,{children:"accessible"})," in the ",(0,s.jsx)(n.em,{children:"current package"}),"."]}),"\n",(0,s.jsx)(n.p,{children:":bar"}),"\n",(0,s.jsxs)(n.p,{children:[":bar"," is printed when the home package of bar is the KEYWORD ",(0,s.jsx)(n.em,{children:"package"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["#",":bar"]}),"\n",(0,s.jsxs)(n.p,{children:["#",":bar"," is printed when bar is ",(0,s.jsx)(n.em,{children:"apparently uninterned"}),", even in the pathological case that bar has no ",(0,s.jsx)(n.em,{children:"home package"})," but is nevertheless somehow ",(0,s.jsx)(n.em,{children:"accessible"})," in the ",(0,s.jsx)(n.em,{children:"current package"}),"."]})]})}function k(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(L,{...e})}):L(e)}function B(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.em,{children:"printer escaping"})," is disabled, or the characters under consideration are not already quoted specifically by ",(0,s.jsx)(n.em,{children:"single escape"})," or ",(0,s.jsx)(n.em,{children:"multiple escape"})," syntax, the ",(0,s.jsx)(n.em,{children:"readtable case"})," of the ",(0,s.jsx)(n.em,{children:"current readtable"})," affects the way the ",(0,s.jsx)(n.em,{children:"Lisp printer"})," writes ",(0,s.jsx)(n.em,{children:"symbols"})," in the following ways:"]}),"\n",(0,s.jsx)(n.p,{children:":upcase"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":upcase",", ",(0,s.jsx)(n.em,{children:"uppercase characters"})," are printed in the case specified by ",(0,s.jsx)(n.strong,{children:"*print-case*"}),", and ",(0,s.jsx)(n.em,{children:"lowercase characters"})," are printed in their own case."]}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u20135"})]}),"\n",(0,s.jsx)(n.p,{children:":downcase"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":downcase",", ",(0,s.jsx)(n.em,{children:"uppercase characters"})," are printed in their own case, and ",(0,s.jsx)(n.em,{children:"lowercase characters"})," are printed in the case specified by ",(0,s.jsx)(n.strong,{children:"*print-case*"}),"."]}),"\n",(0,s.jsx)(n.p,{children:":preserve"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":preserve",", all ",(0,s.jsx)(n.em,{children:"alphabetic characters"})," are printed in their own case."]}),"\n",(0,s.jsx)(n.p,{children:":invert"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":invert",", the case of all ",(0,s.jsx)(n.em,{children:"alphabetic characters"})," in single case symbol names is inverted. Mixed-case symbol names are printed as is."]}),"\n",(0,s.jsxs)(n.p,{children:["The rules for escaping ",(0,s.jsx)(n.em,{children:"alphabetic characters"})," in symbol names are affected by the ",(0,s.jsx)(n.strong,{children:"readtable-case"})," if ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled. ",(0,s.jsx)(n.em,{children:"Alphabetic characters"})," are escaped as follows:"]}),"\n",(0,s.jsx)(n.p,{children:":upcase"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":upcase",", all ",(0,s.jsx)(n.em,{children:"lowercase characters"})," must be escaped."]}),"\n",(0,s.jsx)(n.p,{children:":downcase"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":downcase",", all ",(0,s.jsx)(n.em,{children:"uppercase characters"})," must be escaped."]}),"\n",(0,s.jsx)(n.p,{children:":preserve"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":preserve",", no ",(0,s.jsx)(n.em,{children:"alphabetic characters"})," need be escaped."]}),"\n",(0,s.jsx)(n.p,{children:":invert"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":invert",", no ",(0,s.jsx)(n.em,{children:"alphabetic characters"})," need be escaped."]})]})}function N(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(B,{...e})}):B(e)}function O(e){const n={del:"del",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"(defun test-readtable-case-printing ()"}),"\n",(0,s.jsx)(n.p,{children:"(let ((*readtable* (copy-readtable nil))"}),"\n",(0,s.jsx)(n.p,{children:"(*print-case* *print-case*))"}),"\n",(0,s.jsx)(n.p,{children:'(format t "READTABLE-CASE *PRINT-CASE* Symbol-name Output~'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.del,{children:"%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013"})}),"\n",(0,s.jsx)(n.p,{children:'~%")'}),"\n",(0,s.jsxs)(n.p,{children:["(dolist (readtable-case \u2019(",":upcase"," ",":downcase"," ",":preserve"," ",":invert","))"]}),"\n",(0,s.jsx)(n.p,{children:"(setf (readtable-case *readtable*) readtable-case)"}),"\n",(0,s.jsxs)(n.p,{children:["(dolist (print-case \u2019(",":upcase"," ",":downcase"," ",":capitalize","))"]}),"\n",(0,s.jsx)(n.p,{children:"(dolist (symbol \u2019(|ZEBRA| |Zebra| |zebra|))"}),"\n",(0,s.jsx)(n.p,{children:"(setq *print-case* print-case)"}),"\n",(0,s.jsxs)(n.p,{children:['(format t "',(0,s.jsxs)(n.del,{children:["&:",(0,s.jsx)(n.del,{children:"A"}),"15T:",(0,s.jsx)(n.del,{children:"A"}),"29T"]}),"A",(0,s.jsx)(n.del,{children:"42T"}),'A"']}),"\n",(0,s.jsx)(n.p,{children:"(string-upcase readtable-case)"}),"\n",(0,s.jsx)(n.p,{children:"(string-upcase print-case)"}),"\n",(0,s.jsx)(n.p,{children:"(symbol-name symbol)"}),"\n",(0,s.jsx)(n.p,{children:"(prin1-to-string symbol)))))))"}),"\n",(0,s.jsx)(n.p,{children:"The output from (test-readtable-case-printing) should be as follows:"}),"\n",(0,s.jsx)(n.p,{children:"READTABLE-CASE *PRINT-CASE* Symbol-name Output"}),"\n",(0,s.jsx)(n.p,{children:"\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013"}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":UPCASE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":UPCASE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":UPCASE"," zebra |zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":DOWNCASE"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":DOWNCASE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":DOWNCASE"," zebra |zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":CAPITALIZE"," ZEBRA Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":CAPITALIZE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ",":CAPITALIZE"," zebra |zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":UPCASE"," ZEBRA |ZEBRA|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":UPCASE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":UPCASE"," zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":DOWNCASE"," ZEBRA |ZEBRA|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":DOWNCASE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":DOWNCASE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":CAPITALIZE"," ZEBRA |ZEBRA|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":CAPITALIZE"," Zebra |Zebra|"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ",":CAPITALIZE"," zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":UPCASE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":UPCASE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":UPCASE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":DOWNCASE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":DOWNCASE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":DOWNCASE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":CAPITALIZE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":CAPITALIZE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ",":CAPITALIZE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":UPCASE"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":UPCASE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":UPCASE"," zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":DOWNCASE"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":DOWNCASE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":DOWNCASE"," zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":CAPITALIZE"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":CAPITALIZE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ",":CAPITALIZE"," zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u20137"})]})]})}function W(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}function z(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The characters of the ",(0,s.jsx)(n.em,{children:"string"})," are output in order. If ",(0,s.jsx)(n.em,{children:"printer escaping"})," is enabled, a ",(0,s.jsx)(n.em,{children:"double-quote"})," is output before and after, and all ",(0,s.jsx)(n.em,{children:"double-quotes"})," and ",(0,s.jsx)(n.em,{children:"single escapes"})," are preceded by ",(0,s.jsx)(n.em,{children:"backslash"}),". The printing of ",(0,s.jsx)(n.em,{children:"strings"})," is not affected by ",(0,s.jsx)(n.strong,{children:"*print-array*"}),". Only the ",(0,s.jsx)(n.em,{children:"active elements"})," of the ",(0,s.jsx)(n.em,{children:"string"})," are printed."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses ",(0,s.jsx)(n.em,{children:"strings"}),", see Section 2.4.5 (Double-Quote)."]})]})}function D(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(z,{...e})}):z(e)}function V(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Wherever possible, list notation is preferred over dot notation. Therefore the following algorithm is used to print a ",(0,s.jsx)(n.em,{children:"cons x"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["1. A ",(0,s.jsx)(n.em,{children:"left-parenthesis"})," is printed."]}),"\n",(0,s.jsxs)(n.p,{children:["2. The ",(0,s.jsx)(n.em,{children:"car"})," of ",(0,s.jsx)(n.em,{children:"x"})," is printed."]}),"\n",(0,s.jsxs)(n.p,{children:["3. If the ",(0,s.jsx)(n.em,{children:"cdr"})," of ",(0,s.jsx)(n.em,{children:"x"})," is itself a ",(0,s.jsx)(n.em,{children:"cons"}),", it is made to be the current ",(0,s.jsx)(n.em,{children:"cons"})," (",(0,s.jsx)(n.em,{children:"i.e."}),", ",(0,s.jsx)(n.em,{children:"x"})," becomes that ",(0,s.jsx)(n.em,{children:"cons"}),"), a ",(0,s.jsx)(n.em,{children:"space"})," is printed, and step 2 is re-entered."]}),"\n",(0,s.jsxs)(n.p,{children:["4. If the ",(0,s.jsx)(n.em,{children:"cdr"})," of ",(0,s.jsx)(n.em,{children:"x"})," is not ",(0,s.jsx)(n.em,{children:"null"}),", a ",(0,s.jsx)(n.em,{children:"space"}),", a ",(0,s.jsx)(n.em,{children:"dot"}),", a ",(0,s.jsx)(n.em,{children:"space"}),", and the ",(0,s.jsx)(n.em,{children:"cdr"})," of ",(0,s.jsx)(n.em,{children:"x"})," are printed."]}),"\n",(0,s.jsxs)(n.p,{children:["5. A ",(0,s.jsx)(n.em,{children:"right-parenthesis"})," is printed."]}),"\n",(0,s.jsxs)(n.p,{children:["Actually, the above algorithm is only used when ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"false"}),". When ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"true"})," (or when ",(0,s.jsx)(n.strong,{children:"pprint"})," is used), additional ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>1</sub> may replace the use of a single ",(0,s.jsx)(n.em,{children:"space"}),", and a more elaborate algorithm with similar goals but more presentational flexibility is used; see Section 22.1.2 (Printer Dispatching)."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the two expressions below are equivalent, and the reader accepts either one and produces the same ",(0,s.jsx)(n.em,{children:"cons"}),", the printer always prints such a ",(0,s.jsx)(n.em,{children:"cons"})," in the second form."]}),"\n",(0,s.jsx)(n.p,{children:"(a . (b . ((c . (d . nil)) . (e . nil))))"}),"\n",(0,s.jsx)(n.p,{children:"(a b (c d) e)"}),"\n",(0,s.jsxs)(n.p,{children:["The printing of ",(0,s.jsx)(n.em,{children:"conses"})," is affected by ",(0,s.jsx)(n.strong,{children:"*print-level*"}),", ",(0,s.jsx)(n.strong,{children:"*print-length*"}),", and ",(0,s.jsx)(n.strong,{children:"*print-circle*"}),". Following are examples of printed representations of ",(0,s.jsx)(n.em,{children:"lists"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"(a . b) ;A dotted pair of a and b"}),"\n",(0,s.jsx)(n.p,{children:"(a.b) ;A list of one element, the symbol named a.b"}),"\n",(0,s.jsx)(n.p,{children:"(a. b) ;A list of two elements a. and b"}),"\n",(0,s.jsx)(n.p,{children:"(a .b) ;A list of two elements a and .b"}),"\n",(0,s.jsx)(n.p,{children:"(a b . c) ;A dotted list of a and b with c at the end; two conses"}),"\n",(0,s.jsx)(n.p,{children:".iot ;The symbol whose name is .iot"}),"\n",(0,s.jsx)(n.p,{children:"(. b) ;Invalid \u2013 an error is signaled if an attempt is made to read"}),"\n",(0,s.jsx)(n.p,{children:";this syntax."}),"\n",(0,s.jsx)(n.p,{children:"(a .) ;Invalid \u2013 an error is signaled."}),"\n",(0,s.jsx)(n.p,{children:"(a .. b) ;Invalid \u2013 an error is signaled."}),"\n",(0,s.jsx)(n.p,{children:"(a . . b) ;Invalid \u2013 an error is signaled."}),"\n",(0,s.jsx)(n.p,{children:"(a b c ...) ;Invalid \u2013 an error is signaled."}),"\n",(0,s.jsx)(n.p,{children:"(a . b) ;A list of three elements a, ., and b"}),"\n",(0,s.jsx)(n.p,{children:"(a |.| b) ;A list of three elements a, ., and b"}),"\n",(0,s.jsx)(n.p,{children:"(a ... b) ;A list of three elements a, ..., and b"}),"\n",(0,s.jsx)(n.p,{children:"(a |...| b) ;A list of three elements a, ..., and b"}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses ",(0,s.jsx)(n.em,{children:"lists"})," and ",(0,s.jsx)(n.em,{children:"conses"}),", see Section 2.4.1 (Left-Parenthesis)."]})]})}function U(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(V,{...e})}):V(e)}function q(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"bit vector"})," is printed as #* followed by the bits of the ",(0,s.jsx)(n.em,{children:"bit vector"})," in order. If ",(0,s.jsx)(n.strong,{children:"*print-array*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", then the ",(0,s.jsx)(n.em,{children:"bit vector"})," is printed in a format (using #<) that is concise but not readable. Only the ",(0,s.jsx)(n.em,{children:"active elements"})," of the ",(0,s.jsx)(n.em,{children:"bit vector"})," are printed."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parsing of ",(0,s.jsx)(n.em,{children:"bit vectors"}),", see Section 2.4.8.4 (Sharpsign Asterisk)."]})]})}function M(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}function _(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.strong,{children:"*print-array*"})," is ",(0,s.jsx)(n.em,{children:"true"})," and ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", any ",(0,s.jsx)(n.em,{children:"vector"})," other than a ",(0,s.jsx)(n.em,{children:"string"})," or ",(0,s.jsx)(n.em,{children:"bit vector"})," is printed using general-vector syntax; this means that information about specialized vector representations does not appear. The printed representation of a zero-length ",(0,s.jsx)(n.em,{children:"vector"})," is #(). The printed representation of a non-zero-length ",(0,s.jsx)(n.em,{children:"vector"})," begins with #(. Following that, the first element of the ",(0,s.jsx)(n.em,{children:"vector"})," is printed. If there are any other elements, they are printed in turn, with each such additional element preceded by a ",(0,s.jsx)(n.em,{children:"space"})," if ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", or ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>1</sub> if ",(0,s.jsx)(n.strong,{children:"*print-pretty*"})," is ",(0,s.jsx)(n.em,{children:"true"}),". A ",(0,s.jsx)(n.em,{children:"right-parenthesis"})," after the last element terminates the printed representation of the ",(0,s.jsx)(n.em,{children:"vector"})," . The printing of ",(0,s.jsx)(n.em,{children:"vectors"})," is affected by ",(0,s.jsx)(n.strong,{children:"*print-level*"})," and ",(0,s.jsx)(n.strong,{children:"*print-length*"}),". If the ",(0,s.jsx)(n.em,{children:"vector"})," has a ",(0,s.jsx)(n.em,{children:"fill pointer"})," , then only those elements below the ",(0,s.jsx)(n.em,{children:"fill pointer"})," are printed."]}),"\n",(0,s.jsxs)(n.p,{children:["If both ",(0,s.jsx)(n.strong,{children:"*print-array*"})," and ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," are ",(0,s.jsx)(n.em,{children:"false"}),", the ",(0,s.jsx)(n.em,{children:"vector"})," is not printed as described above, but in a format (using #<) that is concise but not readable."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the ",(0,s.jsx)(n.em,{children:"vector"})," prints in an ",(0,s.jsx)(n.em,{children:"implementation-defined"})," manner; see the ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*print-readably*"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses these \u201cother ",(0,s.jsx)(n.em,{children:"vectors"}),",\u201d see Section 2.4.8.3 (Sharpsign Left-Parenthesis)."]}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u20139"})]})]})}function Y(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}function K(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.strong,{children:"*print-array*"})," is ",(0,s.jsx)(n.em,{children:"true"})," and ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", any ",(0,s.jsx)(n.em,{children:"array"})," other than a ",(0,s.jsx)(n.em,{children:"vector"})," is printed using #nA format. Let n be the ",(0,s.jsx)(n.em,{children:"rank"})," of the ",(0,s.jsx)(n.em,{children:"array"}),". Then # is printed, then n as a decimal integer, then A, then n open parentheses. Next the ",(0,s.jsx)(n.em,{children:"elements"})," are scanned in row-major order, using ",(0,s.jsx)(n.strong,{children:"write"})," on each ",(0,s.jsx)(n.em,{children:"element"}),", and separating ",(0,s.jsx)(n.em,{children:"elements"})," from each other with ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>1</sub>. The array\u2019s dimensions are numbered 0 to n-1 from left to right, and are enumerated with the rightmost index changing fastest. Every time the index for dimension j is incremented, the following actions are taken:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If j < n-1, then a close parenthesis is printed."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If incrementing the index for dimension j caused it to equal dimension j, that index is reset to zero and the index for dimension j-1 is incremented (thereby performing these three steps recursively), unless j=0, in which case the entire algorithm is terminated. If incrementing the index for dimension j did not cause it to equal dimension j, then a space is printed."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If j < n-1, then an open parenthesis is printed."]}),"\n",(0,s.jsxs)(n.p,{children:["This causes the contents to be printed in a format suitable for ",":initial-contents"," to ",(0,s.jsx)(n.strong,{children:"make-array"}),". The lists effectively printed by this procedure are subject to truncation by ",(0,s.jsx)(n.strong,{children:"*print-level*"})," and ",(0,s.jsx)(n.strong,{children:"*print-length*"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"array"})," is of a specialized ",(0,s.jsx)(n.em,{children:"type"}),", containing bits or characters, then the innermost lists generated by the algorithm given above can instead be printed using bit-vector or string syntax, provided that these innermost lists would not be subject to truncation by ",(0,s.jsx)(n.strong,{children:"*print-length*"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If both ",(0,s.jsx)(n.strong,{children:"*print-array*"})," and ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," are ",(0,s.jsx)(n.em,{children:"false"}),", then the ",(0,s.jsx)(n.em,{children:"array"})," is printed in a format (using #<) that is concise but not readable."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the ",(0,s.jsx)(n.em,{children:"array"})," prints in an ",(0,s.jsx)(n.em,{children:"implementation-defined"})," manner; see the ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*print-readably*"}),". In particular, this may be important for arrays having some dimension 0."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses these \u201cother ",(0,s.jsx)(n.em,{children:"arrays"}),",\u201d see Section 2.4.8.12 (Sharpsign A)."]})]})}function H(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(K,{...e})}):K(e)}function Q(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"(let ((a (make-array \u2019(3 3)))"}),"\n",(0,s.jsx)(n.p,{children:"(*print-pretty* t)"}),"\n",(0,s.jsx)(n.p,{children:"(*print-array* t))"}),"\n",(0,s.jsx)(n.p,{children:'(dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j)))) (print a)'}),"\n",(0,s.jsxs)(n.p,{children:["(print (make-array 9 ",":displaced-to"," a)))"]}),"\n",(0,s.jsx)(n.p,{children:'\u25b7 #2A(("<0,0>" "<0,1>" "<0,2>")'}),"\n",(0,s.jsx)(n.p,{children:'\u25b7 ("<1,0>" "<1,1>" "<1,2>")'}),"\n",(0,s.jsx)(n.p,{children:'\u25b7 ("<2,0>" "<2,1>" "<2,2>"))'}),"\n",(0,s.jsx)(n.p,{children:'\u25b7 #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #<ARRAY 9 indirect 36363476>"]})]})}function G(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Q,{...e})}):Q(e)}function J(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A specific syntax for printing ",(0,s.jsx)(n.em,{children:"objects"})," of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"random-state"})," is not specified. However, every ",(0,s.jsx)(n.em,{children:"implementation"})," must arrange to print a ",(0,s.jsx)(n.em,{children:"random state object"})," in such a way that, within the same implementation, ",(0,s.jsx)(n.strong,{children:"read"})," can construct from the printed representation a copy of the ",(0,s.jsx)(n.em,{children:"random state"})," object as if the copy had been made by ",(0,s.jsx)(n.strong,{children:"make-random-state"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the type ",(0,s.jsx)(n.em,{children:"random state"})," is effectively implemented by using the machinery for ",(0,s.jsx)(n.strong,{children:"defstruct"}),", the usual structure syntax can then be used for printing ",(0,s.jsx)(n.em,{children:"random state"})," objects; one might look something like"]}),"\n",(0,s.jsxs)(n.p,{children:["#S(RANDOM-STATE ",":DATA"," #(14 49 98436589 786345 8734658324 ... ))"]}),"\n",(0,s.jsxs)(n.p,{children:["where the components are ",(0,s.jsx)(n.em,{children:"implementation-dependent"}),"."]})]})}function X(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(J,{...e})}):J(e)}function $(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.em,{children:"printer escaping"}),' is enabled, the syntax #P"..." is how a ',(0,s.jsx)(n.em,{children:"pathname"})," is printed by ",(0,s.jsx)(n.strong,{children:"write"}),' and the other functions herein described. The "..." is the namestring representation of the pathname.']}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.em,{children:"printer escaping"})," is disabled, ",(0,s.jsx)(n.strong,{children:"write"})," writes a ",(0,s.jsx)(n.em,{children:"pathname P"})," by writing (namestring ",(0,s.jsx)(n.em,{children:"P"}),") instead. For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses ",(0,s.jsx)(n.em,{children:"pathnames"}),", see Section 2.4.8.14 (Sharpsign P)."]})]})}function ee(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["By default, a ",(0,s.jsx)(n.em,{children:"structure"})," of type ",(0,s.jsx)(n.em,{children:"S"})," is printed using #S syntax. This behavior can be customized by specifying a ",":print-function"," or ",":print-object"," option to the ",(0,s.jsx)(n.strong,{children:"defstruct"})," ",(0,s.jsx)(n.em,{children:"form"})," that defines ",(0,s.jsx)(n.em,{children:"S"}),", or by writing a ",(0,s.jsx)(n.strong,{children:"print-object"})," ",(0,s.jsx)(n.em,{children:"method"})," that is ",(0,s.jsx)(n.em,{children:"specialized"})," for ",(0,s.jsx)(n.em,{children:"objects"})," of type ",(0,s.jsx)(n.em,{children:"S"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Different structures might print out in different ways; the default notation for structures is: #S(",(0,s.jsx)(n.em,{children:"structure-name {slot-key slot-value}"}),"*)"]}),"\n",(0,s.jsxs)(n.p,{children:["where #S indicates structure syntax, ",(0,s.jsx)(n.em,{children:"structure-name"})," is a ",(0,s.jsx)(n.em,{children:"structure name"}),", each ",(0,s.jsx)(n.em,{children:"slot-key"})," is an initialization argument ",(0,s.jsx)(n.em,{children:"name"})," for a ",(0,s.jsx)(n.em,{children:"slot"})," in the ",(0,s.jsx)(n.em,{children:"structure"}),", and each corresponding ",(0,s.jsx)(n.em,{children:"slot-value"})," is a representation of the ",(0,s.jsx)(n.em,{children:"object"})," in that ",(0,s.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," parses ",(0,s.jsx)(n.em,{children:"structures"}),", see Section 2.4.8.13 (Sharpsign S). Printer ",(0,s.jsx)(n.strong,{children:"22\u201311"})]})]})}function re(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ne,{...e})}):ne(e)}function se(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Other ",(0,s.jsx)(n.em,{children:"objects"})," are printed in an ",(0,s.jsx)(n.em,{children:"implementation-dependent"})," manner. It is not required that an ",(0,s.jsx)(n.em,{children:"implementation"})," print those ",(0,s.jsx)(n.em,{children:"objects readably"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.em,{children:"hash tables"}),", ",(0,s.jsx)(n.em,{children:"readtables"}),", ",(0,s.jsx)(n.em,{children:"packages"}),", ",(0,s.jsx)(n.em,{children:"streams"}),", and ",(0,s.jsx)(n.em,{children:"functions"})," might not print ",(0,s.jsx)(n.em,{children:"readably"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A common notation to use in this circumstance is #<...>. Since #< is not readable by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," , the precise format of the text which follows is not important, but a common format to use is that provided by the ",(0,s.jsx)(n.strong,{children:"print-unreadable-object"})," ",(0,s.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For information on how the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," treats this notation, see Section 2.4.8.20 (Sharpsign Less-Than-Sign). For information on how to notate ",(0,s.jsx)(n.em,{children:"objects"})," that cannot be printed ",(0,s.jsx)(n.em,{children:"readably"}),", see Section 2.4.8.6 (Sharpsign Dot)."]})]})}function ie(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(se,{...e})}):se(e)}function te(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"(let ((*print-escape* t)) (fresh-line) (write #\\a))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 #\\a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #\\a"]}),"\n",(0,s.jsx)(n.p,{children:"(let ((*print-escape* nil) (*print-readably* nil))"}),"\n",(0,s.jsx)(n.p,{children:"(fresh-line)"}),"\n",(0,s.jsx)(n.p,{children:"(write #\\a))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #\\a"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line) (prin1 #\\a))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 #\\a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #\\a"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line) (print #\\a))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 #\\a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #\\a"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line) (princ #\\a))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," #\\a"]}),"\n",(0,s.jsx)(n.p,{children:"(dolist (val \u2019(t nil))"}),"\n",(0,s.jsx)(n.p,{children:"(let ((*print-escape* val) (*print-readably* val))"}),"\n",(0,s.jsx)(n.p,{children:"(print \u2019#\\a)"}),"\n",(0,s.jsx)(n.p,{children:"(prin1 #\\a) (write-char #\\Space)"}),"\n",(0,s.jsx)(n.p,{children:"(princ #\\a) (write-char #\\Space)"}),"\n",(0,s.jsx)(n.p,{children:"(write #\\a)))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 #\\a #\\a a #\\a"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 #\\a #\\a a a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line) (write \u2019(let ((a 1) (b 2)) (+ a b))))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (LET ((A 1) (B 2)) (+ A B))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (LET ((A 1) (B 2)) (+ A B))"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line) (pprint \u2019(let ((a 1) (b 2)) (+ a b))))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (LET ((A 1)"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (B 2))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (+ A B))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (LET ((A 1) (B 2)) (+ A B))"]}),"\n",(0,s.jsx)(n.p,{children:"(progn (fresh-line)"}),"\n",(0,s.jsxs)(n.p,{children:["(write \u2019(let ((a 1) (b 2)) (+ a b)) ",":pretty"," t))"]}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (LET ((A 1)"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (B 2))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (+ A B))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (LET ((A 1) (B 2)) (+ A B))"]}),"\n",(0,s.jsx)(n.p,{children:"(with-output-to-string (s)"}),"\n",(0,s.jsxs)(n.p,{children:["(write \u2019write ",":stream"," s)"]}),"\n",(0,s.jsx)(n.p,{children:"(prin1 \u2019prin1 s))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"}),' "WRITEPRIN1"']}),"\n",(0,s.jsxs)(n.p,{children:["Printer ",(0,s.jsx)(n.strong,{children:"22\u201313"})]})]})}function ae(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(te,{...e})}):te(e)}const ce={title:"22.1 The Lisp Printer"},le="22.1 The Lisp Printer",he={id:"chap-22/cc-b-the-lisp-printer",title:"22.1 The Lisp Printer",description:"22.1.1 Overview of The Lisp Printer",source:"@site/docs/chap-22/cc-b-the-lisp-printer.md",sourceDirName:"chap-22",slug:"/chap-22/cc-b-the-lisp-printer",permalink:"/cl-language-reference/docs/chap-22/cc-b-the-lisp-printer",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-22/cc-b-the-lisp-printer.md",tags:[],version:"current",frontMatter:{title:"22.1 The Lisp Printer"},sidebar:"tutorialSidebar",previous:{title:"22. Printer",permalink:"/cl-language-reference/docs/category/22-printer"},next:{title:"22.2 The Lisp Pretty Printer",permalink:"/cl-language-reference/docs/chap-22/cc-c-the-lisp-pretty-printer"}},oe={},de=[{value:"22.1.1 Overview of The Lisp Printer",id:"2211-overview-of-the-lisp-printer",level:2},{value:"22.1.1.1 Multiple Possible Textual Representations",id:"22111-multiple-possible-textual-representations",level:3},{value:"22.1.1.1.1 Printer Escaping",id:"221111-printer-escaping",level:4},{value:"22.1.2 Printer Dispatching",id:"2212-printer-dispatching",level:2},{value:"22.1.3 Default Print",id:"2213-default-print",level:2},{value:"22.1.3.1 Printing Numbers",id:"22131-printing-numbers",level:3},{value:"22.1.3.1.1 Printing Integers",id:"221311-printing-integers",level:4},{value:"22.1.3.1.2 Printing Ratios",id:"221312-printing-ratios",level:4},{value:"22.1.3.1.3 Printing Floats",id:"221313-printing-floats",level:4},{value:"22.1.3.1.4 Printing Complexes",id:"221314-printing-complexes",level:4},{value:"22.1.3.1.5 Note about Printing Numbers",id:"221315-note-about-printing-numbers",level:4},{value:"22.1.3.2 Printing Characters",id:"22132-printing-characters",level:3},{value:"22.1.3.3 Printing Symbols",id:"22133-printing-symbols",level:3},{value:"22.1.3.3.1 Package Prefixes for Symbols",id:"221331-package-prefixes-for-symbols",level:4},{value:"22.1.3.3.2 Effect of Readtable Case on the Lisp Printer",id:"221332-effect-of-readtable-case-on-the-lisp-printer",level:4},{value:"22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer",id:"2213321-examples-of-effect-of-readtable-case-on-the-lisp-printer",level:5},{value:"22.1.3.4 Printing Strings",id:"22134-printing-strings",level:3},{value:"22.1.3.5 Printing Lists and Conses",id:"22135-printing-lists-and-conses",level:3},{value:"22.1.3.6 Printing Bit Vectors",id:"22136-printing-bit-vectors",level:3},{value:"22.1.3.7 Printing Other Vectors",id:"22137-printing-other-vectors",level:3},{value:"22.1.3.8 Printing Other Arrays",id:"22138-printing-other-arrays",level:3},{value:"22.1.3.9 Examples of Printing Arrays",id:"22139-examples-of-printing-arrays",level:3},{value:"22.1.3.10 Printing Random States",id:"221310-printing-random-states",level:3},{value:"22.1.3.11 Printing Pathnames",id:"221311-printing-pathnames",level:3},{value:"22.1.3.12 Printing Structures",id:"221312-printing-structures",level:3},{value:"22.1.3.13 Printing Other Objects",id:"221313-printing-other-objects",level:3},{value:"22.1.4 Examples of Printer Behavior",id:"2214-examples-of-printer-behavior",level:2}];function pe(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"221-the-lisp-printer",children:"22.1 The Lisp Printer"}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(n.h2,{id:"2211-overview-of-the-lisp-printer",children:"22.1.1 Overview of The Lisp Printer"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h3,{id:"22111-multiple-possible-textual-representations",children:"22.1.1.1 Multiple Possible Textual Representations"}),"\n","\n",(0,s.jsx)(o,{}),"\n",(0,s.jsx)(n.h4,{id:"221111-printer-escaping",children:"22.1.1.1.1 Printer Escaping"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(n.h2,{id:"2212-printer-dispatching",children:"22.1.2 Printer Dispatching"}),"\n","\n",(0,s.jsx)(j,{}),"\n",(0,s.jsx)(n.h2,{id:"2213-default-print",children:"22.1.3 Default Print"}),"\n","\n",(0,s.jsx)(u,{}),"\n",(0,s.jsx)(n.h3,{id:"22131-printing-numbers",children:"22.1.3.1 Printing Numbers"}),"\n","\n",(0,s.jsx)(g,{}),"\n",(0,s.jsx)(n.h4,{id:"221311-printing-integers",children:"22.1.3.1.1 Printing Integers"}),"\n","\n",(0,s.jsx)(y,{}),"\n",(0,s.jsx)(n.h4,{id:"221312-printing-ratios",children:"22.1.3.1.2 Printing Ratios"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(n.h4,{id:"221313-printing-floats",children:"22.1.3.1.3 Printing Floats"}),"\n","\n",(0,s.jsx)(E,{}),"\n",(0,s.jsx)(n.h4,{id:"221314-printing-complexes",children:"22.1.3.1.4 Printing Complexes"}),"\n","\n",(0,s.jsx)(S,{}),"\n",(0,s.jsx)(n.h4,{id:"221315-note-about-printing-numbers",children:"22.1.3.1.5 Note about Printing Numbers"}),"\n","\n",(0,s.jsx)(T,{}),"\n",(0,s.jsx)(n.h3,{id:"22132-printing-characters",children:"22.1.3.2 Printing Characters"}),"\n","\n",(0,s.jsx)(R,{}),"\n",(0,s.jsx)(n.h3,{id:"22133-printing-symbols",children:"22.1.3.3 Printing Symbols"}),"\n","\n",(0,s.jsx)(Z,{}),"\n",(0,s.jsx)(n.h4,{id:"221331-package-prefixes-for-symbols",children:"22.1.3.3.1 Package Prefixes for Symbols"}),"\n","\n",(0,s.jsx)(k,{}),"\n",(0,s.jsx)(n.h4,{id:"221332-effect-of-readtable-case-on-the-lisp-printer",children:"22.1.3.3.2 Effect of Readtable Case on the Lisp Printer"}),"\n","\n",(0,s.jsx)(N,{}),"\n",(0,s.jsx)(n.h5,{id:"2213321-examples-of-effect-of-readtable-case-on-the-lisp-printer",children:"22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer"}),"\n","\n",(0,s.jsx)(W,{}),"\n",(0,s.jsx)(n.h3,{id:"22134-printing-strings",children:"22.1.3.4 Printing Strings"}),"\n","\n",(0,s.jsx)(D,{}),"\n",(0,s.jsx)(n.h3,{id:"22135-printing-lists-and-conses",children:"22.1.3.5 Printing Lists and Conses"}),"\n","\n",(0,s.jsx)(U,{}),"\n",(0,s.jsx)(n.h3,{id:"22136-printing-bit-vectors",children:"22.1.3.6 Printing Bit Vectors"}),"\n","\n",(0,s.jsx)(M,{}),"\n",(0,s.jsx)(n.h3,{id:"22137-printing-other-vectors",children:"22.1.3.7 Printing Other Vectors"}),"\n","\n",(0,s.jsx)(Y,{}),"\n",(0,s.jsx)(n.h3,{id:"22138-printing-other-arrays",children:"22.1.3.8 Printing Other Arrays"}),"\n","\n",(0,s.jsx)(H,{}),"\n",(0,s.jsx)(n.h3,{id:"22139-examples-of-printing-arrays",children:"22.1.3.9 Examples of Printing Arrays"}),"\n","\n",(0,s.jsx)(G,{}),"\n",(0,s.jsx)(n.h3,{id:"221310-printing-random-states",children:"22.1.3.10 Printing Random States"}),"\n","\n",(0,s.jsx)(X,{}),"\n",(0,s.jsx)(n.h3,{id:"221311-printing-pathnames",children:"22.1.3.11 Printing Pathnames"}),"\n","\n",(0,s.jsx)(ee,{}),"\n",(0,s.jsx)(n.h3,{id:"221312-printing-structures",children:"22.1.3.12 Printing Structures"}),"\n","\n",(0,s.jsx)(re,{}),"\n",(0,s.jsx)(n.h3,{id:"221313-printing-other-objects",children:"22.1.3.13 Printing Other Objects"}),"\n","\n",(0,s.jsx)(ie,{}),"\n",(0,s.jsx)(n.h2,{id:"2214-examples-of-printer-behavior",children:"22.1.4 Examples of Printer Behavior"}),"\n","\n","\n",(0,s.jsx)(ae,{})]})}function xe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(pe,{...e})}):pe(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>c,a:()=>a});var s=r(7294);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);