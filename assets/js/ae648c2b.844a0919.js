"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[13243],{37269:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>c,metadata:()=>r,toc:()=>s});var n=o(85893),i=o(11151);const c={},a="Generic function invocation protocol",r={id:"meta-object-protocol/generic-function-invocation-protocol",title:"Generic function invocation protocol",description:"Generic function invocation protocol",source:"@site/docs/meta-object-protocol/generic-function-invocation-protocol.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/generic-function-invocation-protocol",permalink:"/cl-language-reference/meta-object-protocol/generic-function-invocation-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/generic-function-invocation-protocol.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"generic-function-declarations",permalink:"/cl-language-reference/meta-object-protocol/generic-function-declarations"},next:{title:"generic-function-lambda-list-standard-generic-function",permalink:"/cl-language-reference/meta-object-protocol/generic-function-lambda-list-standard-generic-function"}},l={},s=[{value:"Generic function invocation protocol",id:"generic-function-invocation-protocol-1",level:3}];function d(e){const t={a:"a",em:"em",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"generic-function-invocation-protocol",children:"Generic function invocation protocol"}),"\n",(0,n.jsx)(t.h3,{id:"generic-function-invocation-protocol-1",children:"Generic function invocation protocol"}),"\n",(0,n.jsx)(t.p,{children:"Associated with each generic function is its discriminating function. Each time the generic function is called, the discriminating function is called to provide the behavior of the generic function. The discriminating function receives the full set of arguments received by the generic function. It must lookup and execute the appropriate methods, and return the appropriate values."}),"\n",(0,n.jsxs)(t.p,{children:["The discriminating function is computed by the highest layer of the generic function invocation protocol, ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"}),". Whenever a generic function metaobject is initialized, reinitialized, or a method is added or removed, the discriminating function is recomputed. The new discriminating function is then stored with ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/set-funcallable-instance-function",children:"set-funcallable-instance-function"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Discriminating functions call ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"})," and ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods-using-classes",children:"compute-applicable-methods-using-classes"})," to compute the methods applicable to the generic functions arguments. Applicable methods are combined by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," to produce an ",(0,n.jsx)(t.em,{children:"effective method"}),". Provisions are made to allow memoization of the method applicability and effective methods computations. (See the description of ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"})," for details.)"]}),"\n",(0,n.jsxs)(t.p,{children:["The body of method definitions are processed by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"}),". The result of this generic function is a lambda expression which is processed by either ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm#compile",children:"compile"})," or the file compiler to produce a ",(0,n.jsx)(t.em,{children:"method function"}),". The arguments received by the method function are controlled by the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"})," forms appearing in the effective methods. By default, method functions accept two arguments: a list of arguments to the generic function, and a list of next methods. The list of next methods corresponds to the next methods argument to ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"}),". If ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"})," appears with additional arguments, these will be passed to the method functions as well; in these cases, ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"})," must have created the method lambdas to expect additional arguments."]})]})}function m(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>r,a:()=>a});var n=o(67294);const i={},c=n.createContext(i);function a(e){const t=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(c.Provider,{value:t},e.children)}}}]);