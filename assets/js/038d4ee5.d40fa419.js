"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[623],{6355:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>v,contentTitle:()=>y,default:()=>T,frontMatter:()=>b,metadata:()=>w,toc:()=>E});var s=r(5893),i=r(1151);function t(e){return(0,s.jsx)(s.Fragment,{})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t()}function d(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["Various aspects of the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," can be controlled dynamically. See Section 2.1.1 (Readtables) and Section 2.1.2 (Variables that affect the Lisp Reader)."]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function a(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"readtable case"})," of the ",(0,s.jsx)(n.em,{children:"current readtable"})," affects the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," in the following ways: ",":upcase"]}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":upcase",", unescaped constituent ",(0,s.jsx)(n.em,{children:"characters"})," are converted to ",(0,s.jsx)(n.em,{children:"uppercase"}),", as specified in Section 2.2 (Reader Algorithm)."]}),"\n",(0,s.jsx)(n.p,{children:":downcase"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":downcase",", unescaped constituent ",(0,s.jsx)(n.em,{children:"characters"})," are converted to ",(0,s.jsx)(n.em,{children:"lowercase"}),"."]}),"\n",(0,s.jsx)(n.p,{children:":preserve"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":preserve",", the case of all ",(0,s.jsx)(n.em,{children:"characters"})," remains unchanged."]}),"\n",(0,s.jsx)(n.p,{children:":invert"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.em,{children:"readtable case"})," is ",":invert",", then if all of the unescaped letters in the extended token are of the same ",(0,s.jsx)(n.em,{children:"case"}),", those (unescaped) letters are converted to the opposite ",(0,s.jsx)(n.em,{children:"case"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}function o(e){const n={del:"del",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"(defun test-readtable-case-reading ()"}),"\n",(0,s.jsx)(n.p,{children:"(let ((*readtable* (copy-readtable nil)))"}),"\n",(0,s.jsx)(n.p,{children:'(format t "READTABLE-CASE Input Symbol-name~'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.del,{children:"%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-"})}),"\n",(0,s.jsx)(n.p,{children:'~%")'}),"\n",(0,s.jsxs)(n.p,{children:["(dolist (readtable-case \u2019(",":upcase"," ",":downcase"," ",":preserve"," ",":invert","))"]}),"\n",(0,s.jsx)(n.p,{children:"(setf (readtable-case *readtable*) readtable-case)"}),"\n",(0,s.jsx)(n.p,{children:'(dolist (input \u2019("ZEBRA" "Zebra" "zebra"))'}),"\n",(0,s.jsxs)(n.p,{children:['(format t "',(0,s.jsxs)(n.del,{children:["&:",(0,s.jsx)(n.del,{children:"A"}),"16T"]}),"A",(0,s.jsx)(n.del,{children:"24T"}),'A"']}),"\n",(0,s.jsx)(n.p,{children:"(string-upcase readtable-case)"}),"\n",(0,s.jsx)(n.p,{children:"input"}),"\n",(0,s.jsx)(n.p,{children:"(symbol-name (read-from-string input)))))))"}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u20131"})]}),"\n",(0,s.jsx)(n.p,{children:"The output from (test-readtable-case-reading) should be as follows:"}),"\n",(0,s.jsx)(n.p,{children:"READTABLE-CASE Input Symbol-name"}),"\n",(0,s.jsx)(n.p,{children:"\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-"}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," Zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":UPCASE"," zebra ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," Zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":DOWNCASE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," ZEBRA ZEBRA"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":PRESERVE"," zebra zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," ZEBRA zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," Zebra Zebra"]}),"\n",(0,s.jsxs)(n.p,{children:[":INVERT"," zebra ZEBRA"]})]})}function x(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function j(e){return(0,s.jsx)(s.Fragment,{})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j()}function m(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Eof-error-p"})," in input function calls controls what happens if input is from a file (or any other input source that has a definite end) and the end of the file is reached. If ",(0,s.jsx)(n.em,{children:"eof-error-p"})," is ",(0,s.jsx)(n.em,{children:"true"})," (the default), an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"end-of-file"})," is signaled at end of file. If it is ",(0,s.jsx)(n.em,{children:"false"}),", then no error is signaled, and instead the function returns ",(0,s.jsx)(n.em,{children:"eof-value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Functions such as ",(0,s.jsx)(n.strong,{children:"read"})," that read the representation of an ",(0,s.jsx)(n.em,{children:"object"})," rather than a single character always signals an error, regardless of ",(0,s.jsx)(n.em,{children:"eof-error-p"}),", if the file ends in the middle of an object representation. For example, if a file does not contain enough right parentheses to balance the left parentheses in it, ",(0,s.jsx)(n.strong,{children:"read"})," signals an error. If a file ends in a ",(0,s.jsx)(n.em,{children:"symbol"})," or a ",(0,s.jsx)(n.em,{children:"number"})," immediately followed by end-of-file, ",(0,s.jsx)(n.strong,{children:"read"})," reads the ",(0,s.jsx)(n.em,{children:"symbol"})," or ",(0,s.jsx)(n.em,{children:"number"})," successfully and when called again will act according to ",(0,s.jsx)(n.em,{children:"eof-error-p"}),". Similarly, the ",(0,s.jsx)(n.em,{children:"function"})," ",(0,s.jsx)(n.strong,{children:"read-line"})," successfully reads the last line of a file even if that line is terminated by end-of-file rather than the newline character. Ignorable text, such as lines containing only ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> or comments, are not considered to begin an ",(0,s.jsx)(n.em,{children:"object"}),"; if ",(0,s.jsx)(n.strong,{children:"read"})," begins to read an ",(0,s.jsx)(n.em,{children:"expression"})," but sees only such ignorable text, it does not consider the file to end in the middle of an ",(0,s.jsx)(n.em,{children:"object"}),". Thus an ",(0,s.jsx)(n.em,{children:"eof-error-p"})," argument controls what happens when the file ends between ",(0,s.jsx)(n.em,{children:"objects"}),"."]})]})}function f(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}function g(e){const n={em:"em",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"recursive-p"})," is supplied and not ",(0,s.jsx)(n.strong,{children:"nil"}),", it specifies that this function call is not an outermost call to ",(0,s.jsx)(n.strong,{children:"read"})," but an embedded call, typically from a ",(0,s.jsx)(n.em,{children:"reader macro function"}),". It is important to distinguish such recursive calls for three reasons."]}),"\n",(0,s.jsxs)(n.p,{children:["1. An outermost call establishes the context within which the #",(0,s.jsx)(n.em,{children:"n"}),"= and #",(0,s.jsx)(n.em,{children:"n"}),"# syntax is scoped. Consider, for example, the expression"]}),"\n",(0,s.jsx)(n.p,{children:"(cons \u2019#3=(p q r) \u2019(x y . #3#))"}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"single-quote reader macro"})," were defined in this way:"]}),"\n",(0,s.jsx)(n.p,{children:"(set-macro-character #\\\u2019 ;incorrect"}),"\n",(0,s.jsx)(n.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(n.p,{children:"(list \u2019quote (read stream))))"}),"\n",(0,s.jsxs)(n.p,{children:["then each call to the ",(0,s.jsx)(n.em,{children:"single-quote reader macro function"})," would establish independent contexts for the scope of ",(0,s.jsx)(n.strong,{children:"read"})," information, including the scope of identifications between markers like \u201c#3=\u201d and \u201c#3#\u201d. However, for this expression, the scope was clearly intended to be determined by the outer set of parentheses, so such a definition would be incorrect. The correct way to define the ",(0,s.jsx)(n.em,{children:"single-quote reader macro"})," uses ",(0,s.jsx)(n.em,{children:"recursive-p"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"(set-macro-character #\\\u2019 ;correct"}),"\n",(0,s.jsx)(n.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(n.p,{children:"(list \u2019quote (read stream t nil t))))"}),"\n",(0,s.jsxs)(n.p,{children:["2. A recursive call does not alter whether the reading process is to preserve ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> or not (as determined by whether the outermost call was to ",(0,s.jsx)(n.strong,{children:"read"})," or ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"}),"). Suppose again that ",(0,s.jsx)(n.em,{children:"single-quote"})," were to be defined as shown above in the incorrect definition. Then a call to ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," that read the expression \u2019foo",(0,s.jsx)(n.em,{children:"hSpacei"})," would fail to preserve the space character following the symbol foo because the ",(0,s.jsx)(n.em,{children:"single-quote reader macro function"})," calls ",(0,s.jsx)(n.strong,{children:"read"}),", not ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"}),", to read the following expression (in this case foo). The correct definition, which passes the value ",(0,s.jsx)(n.em,{children:"true"})," for ",(0,s.jsx)(n.em,{children:"recursive-p"})," to ",(0,s.jsx)(n.strong,{children:"read"}),", allows the outermost call to determine whether ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> is preserved."]}),"\n",(0,s.jsxs)(n.p,{children:["3. When end-of-file is encountered and the ",(0,s.jsx)(n.em,{children:"eof-error-p"})," argument is not ",(0,s.jsx)(n.strong,{children:"nil"}),", the kind of error that is signaled may depend on the value of ",(0,s.jsx)(n.em,{children:"recursive-p"}),". If ",(0,s.jsx)(n.em,{children:"recursive-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", then the end-of-file is deemed to have occurred within the middle of a printed representation; if ",(0,s.jsx)(n.em,{children:"recursive-p"})," is ",(0,s.jsx)(n.em,{children:"false"}),", then the end-of-file may be deemed to have occurred between ",(0,s.jsx)(n.em,{children:"objects"})," rather than within the middle of one."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u20133"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtable"})," ",(0,s.jsx)(n.em,{children:"System Class"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Class Precedence List:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtable"}),", ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"readtable"})," maps ",(0,s.jsx)(n.em,{children:"characters"})," into ",(0,s.jsx)(n.em,{children:"syntax types"})," for the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," ; see Chapter 2 (Syntax). A ",(0,s.jsx)(n.em,{children:"readtable"})," also contains associations between ",(0,s.jsx)(n.em,{children:"macro characters"})," and their ",(0,s.jsx)(n.em,{children:"reader macro functions"}),", and records information about the case conversion rules to be used by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," when parsing ",(0,s.jsx)(n.em,{children:"symbols"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.em,{children:"simple character"})," must be representable in the ",(0,s.jsx)(n.em,{children:"readtable"}),". It is ",(0,s.jsx)(n.em,{children:"implementation-defined"})," whether ",(0,s.jsx)(n.em,{children:"non-simple characters"})," can have syntax descriptions in the ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:"Section 2.1.1 (Readtables), Section 22.1.3.13 (Printing Other Objects)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"copy-readtable"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"copy-readtable"})," &optional ",(0,s.jsx)(n.em,{children:"from-readtable to-readtable \u2192 readtable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"from-readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable designator"})," . The default is the ",(0,s.jsx)(n.em,{children:"current readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"to-readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable"})," or ",(0,s.jsx)(n.strong,{children:"nil"}),". The default is ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"readtable"}),"\u2014the ",(0,s.jsx)(n.em,{children:"to-readtable"})," if it is ",(0,s.jsx)(n.em,{children:"non-nil"}),", or else a ",(0,s.jsx)(n.em,{children:"fresh readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"copy-readtable"})," copies ",(0,s.jsx)(n.em,{children:"from-readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"to-readtable"})," is ",(0,s.jsx)(n.strong,{children:"nil"}),", a new ",(0,s.jsx)(n.em,{children:"readtable"})," is created and returned. Otherwise the ",(0,s.jsx)(n.em,{children:"readtable"})," specified by ",(0,s.jsx)(n.em,{children:"to-readtable"})," is modified and returned."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"copy-readtable"})," copies the setting of ",(0,s.jsx)(n.strong,{children:"readtable-case"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(setq zvar 123) ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-syntax-from-char #\\z #\\\u2019 (setq table2 (copy-readtable))) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsxs)(n.p,{children:["(copy-readtable table2 *readtable*) ",(0,s.jsx)(n.em,{children:"\u2192"})," #<READTABLE 614000277>"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," VAR"]}),"\n",(0,s.jsxs)(n.p,{children:["(setq *readtable* (copy-readtable)) ",(0,s.jsx)(n.em,{children:"\u2192"})," #<READTABLE 46210223>"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," VAR"]}),"\n",(0,s.jsxs)(n.p,{children:["(setq *readtable* (copy-readtable nil)) ",(0,s.jsx)(n.em,{children:"\u2192"})," #<READTABLE 46302670>"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtable"}),", ",(0,s.jsx)(n.strong,{children:"*readtable*"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsx)(n.p,{children:"(setq *readtable* (copy-readtable nil))"}),"\n",(0,s.jsxs)(n.p,{children:["restores the input syntax to standard Common Lisp syntax, even if the ",(0,s.jsx)(n.em,{children:"initial readtable"})," has been clobbered (assuming it is not so badly clobbered that you cannot type in the above expression)."]}),"\n",(0,s.jsx)(n.p,{children:"On the other hand,"}),"\n",(0,s.jsx)(n.p,{children:"(setq *readtable* (copy-readtable))"}),"\n",(0,s.jsxs)(n.p,{children:["replaces the current ",(0,s.jsx)(n.em,{children:"readtable"})," with a copy of itself. This is useful if you want to save a copy of a readtable for later use, protected from alteration in the meantime. It is also useful if you want to locally bind the readtable to a copy of itself, as in:"]}),"\n",(0,s.jsx)(n.p,{children:"(let ((*readtable* (copy-readtable))) ...)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"make-dispatch-macro-character"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"make-dispatch-macro-character"})," ",(0,s.jsx)(n.em,{children:"char"})," &optional ",(0,s.jsx)(n.em,{children:"non-terminating-p readtable \u2192"})," ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"non-terminating-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable"}),". The default is the ",(0,s.jsx)(n.em,{children:"current readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"make-dispatch-macro-character"})," makes ",(0,s.jsx)(n.em,{children:"char"})," be a ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," in ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Initially, every ",(0,s.jsx)(n.em,{children:"character"})," in the dispatch table associated with the ",(0,s.jsx)(n.em,{children:"char"})," has an associated function that signals an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"reader-error"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u20135"})]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"non-terminating-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," is made a ",(0,s.jsx)(n.em,{children:"non-terminating macro character"})," ; if ",(0,s.jsx)(n.em,{children:"non-terminating-p"})," is ",(0,s.jsx)(n.em,{children:"false"}),", the ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," is made a ",(0,s.jsx)(n.em,{children:"terminating macro character"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(get-macro-character #\\{) ",(0,s.jsx)(n.em,{children:"\u2192"})," NIL, ",(0,s.jsx)(n.em,{children:"false"})]}),"\n",(0,s.jsxs)(n.p,{children:["(make-dispatch-macro-character #\\{) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["(not (get-macro-character #\\{)) ",(0,s.jsx)(n.em,{children:"\u2192 false"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"readtable"})," is altered."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*readtable*"}),", ",(0,s.jsx)(n.strong,{children:"set-dispatch-macro-character"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read, read-preserving-whitespace"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"})," &optional ",(0,s.jsx)(n.em,{children:"input-stream eof-error-p eof-value recursive-p \u2192 object"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," &optional ",(0,s.jsx)(n.em,{children:"input-stream eof-error-p"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"eof-value recursive-p"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"\u2192 object"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"input-stream"}),"\u2014an ",(0,s.jsx)(n.em,{children:"input stream designator"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"eof-error-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"eof-value"}),"\u2014an ",(0,s.jsx)(n.em,{children:"object"}),". The default is ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"recursive-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"object"}),"\u2014an ",(0,s.jsx)(n.em,{children:"object"})," (parsed by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," ) or the ",(0,s.jsx)(n.em,{children:"eof-value"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"})," parses the printed representation of an ",(0,s.jsx)(n.em,{children:"object"})," from ",(0,s.jsx)(n.em,{children:"input-stream"})," and builds such an ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," is like ",(0,s.jsx)(n.strong,{children:"read"})," but preserves any ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> ",(0,s.jsx)(n.em,{children:"character"})," that delimits the printed representation of the ",(0,s.jsx)(n.em,{children:"object"}),". ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," is exactly like ",(0,s.jsx)(n.strong,{children:"read"})," when the ",(0,s.jsx)(n.em,{children:"recursive-p argument"})," to ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," is ",(0,s.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"read, read-preserving-whitespace"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.strong,{children:"*read-suppress*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", ",(0,s.jsx)(n.strong,{children:"read"})," throws away the delimiting ",(0,s.jsx)(n.em,{children:"character"})," required by certain printed representations if it is a ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> ",(0,s.jsx)(n.em,{children:"character"})," ; but ",(0,s.jsx)(n.strong,{children:"read"})," preserves the character (using ",(0,s.jsx)(n.strong,{children:"unread-char"}),") if it is syntactically meaningful, because it could be the start of the next expression."]}),"\n",(0,s.jsxs)(n.p,{children:["If a file ends in a ",(0,s.jsx)(n.em,{children:"symbol"})," or a ",(0,s.jsx)(n.em,{children:"number"})," immediately followed by an ",(0,s.jsx)(n.em,{children:"end of file"}),"<sub>1</sub>, ",(0,s.jsx)(n.strong,{children:"read"})," reads the ",(0,s.jsx)(n.em,{children:"symbol"})," or ",(0,s.jsx)(n.em,{children:"number"})," successfully; when called again, it sees the ",(0,s.jsx)(n.em,{children:"end of file"}),"<sub>1</sub> and only then acts according to ",(0,s.jsx)(n.em,{children:"eof-error-p"}),". If a file contains ignorable text at the end, such as blank lines and comments, ",(0,s.jsx)(n.strong,{children:"read"})," does not consider it to end in the middle of an ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"recursive-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the call to ",(0,s.jsx)(n.strong,{children:"read"})," is expected to be made from within some function that itself has been called from ",(0,s.jsx)(n.strong,{children:"read"})," or from a similar input function, rather than from the top level."]}),"\n",(0,s.jsxs)(n.p,{children:["Both functions return the ",(0,s.jsx)(n.em,{children:"object"})," read from ",(0,s.jsx)(n.em,{children:"input-stream"}),". ",(0,s.jsx)(n.em,{children:"Eof-value"})," is returned if ",(0,s.jsx)(n.em,{children:"eof-error-p"})," is ",(0,s.jsx)(n.em,{children:"false"})," and end of file is reached before the beginning of an ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"(read)"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 \u2019a"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (QUOTE A)"]}),"\n",(0,s.jsxs)(n.p,{children:['(with-input-from-string (is " ") (read is nil \u2019the-end)) ',(0,s.jsx)(n.em,{children:"\u2192"})," THE-END"]}),"\n",(0,s.jsx)(n.p,{children:"(defun skip-then-read-char (s c n)"}),"\n",(0,s.jsx)(n.p,{children:"(if (char= c #\\{) (read s t nil t) (read-preserving-whitespace s))"}),"\n",(0,s.jsxs)(n.p,{children:["(read-char-no-hang s)) ",(0,s.jsx)(n.em,{children:"\u2192"})," SKIP-THEN-READ-CHAR"]}),"\n",(0,s.jsx)(n.p,{children:"(let ((*readtable* (copy-readtable nil)))"}),"\n",(0,s.jsx)(n.p,{children:"(set-dispatch-macro-character ## #\\{ #\u2019skip-then-read-char)"}),"\n",(0,s.jsx)(n.p,{children:"(set-dispatch-macro-character ## #\\} #\u2019skip-then-read-char)"}),"\n",(0,s.jsx)(n.p,{children:'(with-input-from-string (is "#{123 x #}123 y")'}),"\n",(0,s.jsxs)(n.p,{children:['(format t "~S ~S" (read is) (read is)))) ',(0,s.jsx)(n.em,{children:"\u2192"})," #\\x, #\\Space, NIL"]}),"\n",(0,s.jsxs)(n.p,{children:["As an example, consider this ",(0,s.jsx)(n.em,{children:"reader macro"})," definition:"]}),"\n",(0,s.jsx)(n.p,{children:"(defun slash-reader (stream char)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(n.p,{children:"\u2018(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)"}),"\n",(0,s.jsx)(n.p,{children:"then (progn (read-char stream t nil t)"}),"\n",(0,s.jsx)(n.p,{children:"(read-preserving-whitespace stream t nil t))"}),"\n",(0,s.jsx)(n.p,{children:"collect dir"}),"\n",(0,s.jsx)(n.p,{children:"while (eql (peek-char nil stream nil nil t) #/))))"}),"\n",(0,s.jsx)(n.p,{children:"(set-macro-character #/ #\u2019slash-reader)"}),"\n",(0,s.jsxs)(n.p,{children:["Consider now calling ",(0,s.jsx)(n.strong,{children:"read"})," on this expression:"]}),"\n",(0,s.jsx)(n.p,{children:"(zyedh /usr/games/zork /usr/games/boggle)"}),"\n",(0,s.jsx)(n.p,{children:"The / macro reads objects separated by more / characters; thus /usr/games/zork is intended to read as (path usr games zork). The entire example expression should therefore be read as"}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u20137"})]}),"\n",(0,s.jsx)(n.p,{children:"(zyedh (path usr games zork) (path usr games boggle))"}),"\n",(0,s.jsxs)(n.p,{children:["However, if ",(0,s.jsx)(n.strong,{children:"read"})," had been used instead of ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"}),", then after the reading of the symbol zork, the following space would be discarded; the next call to ",(0,s.jsx)(n.strong,{children:"peek-char"})," would see the following /, and the loop would continue, producing this interpretation:"]}),"\n",(0,s.jsx)(n.p,{children:"(zyedh (path usr games zork usr games boggle))"}),"\n",(0,s.jsxs)(n.p,{children:["There are times when ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> <sup>should be discarded. If a command interpreter takes single</sup> character commands, but occasionally reads an ",(0,s.jsx)(n.em,{children:"object"})," then if the ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> after a ",(0,s.jsx)(n.em,{children:"symbol"})," is not discarded it might be interpreted as a command some time later after the ",(0,s.jsx)(n.em,{children:"symbol"})," had been read."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*standard-input*"}),", ",(0,s.jsx)(n.strong,{children:"*terminal-io*"}),", ",(0,s.jsx)(n.strong,{children:"*readtable*"}),", ",(0,s.jsx)(n.strong,{children:"*read-default-float-format*"}),", ",(0,s.jsx)(n.strong,{children:"*read-base*"}),", ",(0,s.jsx)(n.strong,{children:"*read-suppress*"}),", ",(0,s.jsx)(n.strong,{children:"*package*"}),", ",(0,s.jsx)(n.strong,{children:"*read-eval*"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"})," signals an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"end-of-file"}),", regardless of ",(0,s.jsx)(n.em,{children:"eof-error-p"}),", if the file ends in the middle of an ",(0,s.jsx)(n.em,{children:"object"})," representation. For example, if a file does not contain enough right parentheses to balance the left parentheses in it, ",(0,s.jsx)(n.strong,{children:"read"})," signals an error. This is detected when ",(0,s.jsx)(n.strong,{children:"read"})," or ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," is called with ",(0,s.jsx)(n.em,{children:"recursive-p"})," and ",(0,s.jsx)(n.em,{children:"eof-error-p non-nil"}),", and end-of-file is reached before the beginning of an ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"eof-error-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"end-of-file"})," is signaled at the end of file."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"peek-char"}),", ",(0,s.jsx)(n.strong,{children:"read-char"}),", ",(0,s.jsx)(n.strong,{children:"unread-char"}),", ",(0,s.jsx)(n.strong,{children:"read-from-string"}),", ",(0,s.jsx)(n.strong,{children:"read-delimited-list"}),", ",(0,s.jsx)(n.strong,{children:"parse-integer"}),", Chapter 2 (Syntax), Section 23.1 (Reader Concepts)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-delimited-list"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-delimited-list"})," ",(0,s.jsx)(n.em,{children:"char"})," &optional ",(0,s.jsx)(n.em,{children:"input-stream recursive-p \u2192 list"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"input-stream"}),"\u2014an ",(0,s.jsx)(n.em,{children:"input stream designator"})," . The default is ",(0,s.jsx)(n.em,{children:"standard input"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"recursive-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"list"}),"\u2014a ",(0,s.jsx)(n.em,{children:"list"})," of the ",(0,s.jsx)(n.em,{children:"objects"})," read."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"read-delimited-list"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-delimited-list"})," reads ",(0,s.jsx)(n.em,{children:"objects"})," from ",(0,s.jsx)(n.em,{children:"input-stream"})," until the next character after an ",(0,s.jsx)(n.em,{children:"object"}),"\u2019s representation (ignoring ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> characters and comments) is ",(0,s.jsx)(n.em,{children:"char"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-delimited-list"})," looks ahead at each step for the next non-",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> ",(0,s.jsx)(n.em,{children:"character"})," and peeks at it as if with ",(0,s.jsx)(n.strong,{children:"peek-char"}),". If it is ",(0,s.jsx)(n.em,{children:"char"}),", then the ",(0,s.jsx)(n.em,{children:"character"})," is consumed and the ",(0,s.jsx)(n.em,{children:"list"})," of ",(0,s.jsx)(n.em,{children:"objects"})," is returned. If it is a ",(0,s.jsx)(n.em,{children:"constituent"})," or ",(0,s.jsx)(n.em,{children:"escape character"})," , then ",(0,s.jsx)(n.strong,{children:"read"})," is used to read an ",(0,s.jsx)(n.em,{children:"object"}),", which is added to the end of the ",(0,s.jsx)(n.em,{children:"list"}),". If it is a ",(0,s.jsx)(n.em,{children:"macro character"})," , its ",(0,s.jsx)(n.em,{children:"reader macro function"})," is called; if the function returns a ",(0,s.jsx)(n.em,{children:"value"}),", that ",(0,s.jsx)(n.em,{children:"value"})," is added to the ",(0,s.jsx)(n.em,{children:"list"}),". The peek-ahead process is then repeated."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"recursive-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", this call is expected to be embedded in a higher-level call to ",(0,s.jsx)(n.strong,{children:"read"})," or a similar function."]}),"\n",(0,s.jsxs)(n.p,{children:["It is an error to reach end-of-file during the operation of ",(0,s.jsx)(n.strong,{children:"read-delimited-list"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences are undefined if ",(0,s.jsx)(n.em,{children:"char"})," has a ",(0,s.jsx)(n.em,{children:"syntax type"})," of ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> in the ",(0,s.jsx)(n.em,{children:"current readtable"}),". ",(0,s.jsx)(n.strong,{children:"Examples:"})]}),"\n",(0,s.jsx)(n.p,{children:"(read-delimited-list #]) 1 2 3 4 5 6 ]"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (1 2 3 4 5 6)"]}),"\n",(0,s.jsxs)(n.p,{children:["Suppose you wanted #{",(0,s.jsx)(n.em,{children:"a b c . . . z"}),"} to read as a list of all pairs of the elements ",(0,s.jsx)(n.em,{children:"a"}),", ",(0,s.jsx)(n.em,{children:"b"}),", ",(0,s.jsx)(n.em,{children:"c"}),", ",(0,s.jsx)(n.em,{children:". . ."}),", ",(0,s.jsx)(n.em,{children:"z"}),", for example."]}),"\n",(0,s.jsx)(n.p,{children:"#{p q z a} reads as ((p q) (p z) (p a) (q z) (q a) (z a))"}),"\n",(0,s.jsxs)(n.p,{children:["This can be done by specifying a macro-character definition for #{ that does two things: reads in all the items up to the }, and constructs the pairs. ",(0,s.jsx)(n.strong,{children:"read-delimited-list"})," performs the first task."]}),"\n",(0,s.jsx)(n.p,{children:"(defun |#{-reader| (stream char arg)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char arg))"}),"\n",(0,s.jsx)(n.p,{children:"(mapcon #\u2019(lambda (x)"}),"\n",(0,s.jsx)(n.p,{children:"(mapcar #\u2019(lambda (y) (list (car x) y)) (cdr x)))"}),"\n",(0,s.jsxs)(n.p,{children:["(read-delimited-list #\\} stream t))) ",(0,s.jsx)(n.em,{children:"\u2192"})," |#{-reader|"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-dispatch-macro-character ## #\\{ #\u2019|#{-reader|) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-macro-character #\\} (get-macro-character #) ",(0,s.jsx)(n.strong,{children:"nil"}),"))"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.em,{children:"true"})," is supplied for the ",(0,s.jsx)(n.em,{children:"recursive-p"})," argument."]}),"\n",(0,s.jsx)(n.p,{children:"It is necessary here to give a definition to the character } as well to prevent it from being a constituent. If the line"}),"\n",(0,s.jsxs)(n.p,{children:["(set-macro-character #\\} (get-macro-character #) ",(0,s.jsx)(n.strong,{children:"nil"}),"))"]}),"\n",(0,s.jsx)(n.p,{children:"shown above were not included, then the } in"}),"\n",(0,s.jsx)(n.p,{children:"#{ p q z a}"}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u20139"})]}),"\n",(0,s.jsxs)(n.p,{children:["would be considered a constituent character, part of the symbol named a}. This could be corrected by putting a space before the }, but it is better to call ",(0,s.jsx)(n.strong,{children:"set-macro-character"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Giving } the same definition as the standard definition of the character ) has the twin benefit of making it terminate tokens for use with ",(0,s.jsx)(n.strong,{children:"read-delimited-list"})," and also making it invalid for use in any other context. Attempting to read a stray } will signal an error."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*standard-input*"}),", ",(0,s.jsx)(n.strong,{children:"*readtable*"}),", ",(0,s.jsx)(n.strong,{children:"*terminal-io*"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"}),", ",(0,s.jsx)(n.strong,{children:"peek-char"}),", ",(0,s.jsx)(n.strong,{children:"read-char"}),", ",(0,s.jsx)(n.strong,{children:"unread-char"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-delimited-list"})," is intended for use in implementing ",(0,s.jsx)(n.em,{children:"reader macros"}),". Usually it is desirable for ",(0,s.jsx)(n.em,{children:"char"})," to be a ",(0,s.jsx)(n.em,{children:"terminating macro character"})," so that it can be used to delimit tokens; however, ",(0,s.jsx)(n.strong,{children:"read-delimited-list"})," makes no attempt to alter the syntax specified for ",(0,s.jsx)(n.em,{children:"char"})," by the current readtable. The caller must make any necessary changes to the readtable syntax explicitly."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-from-string"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read-from-string"})," ",(0,s.jsx)(n.em,{children:"string"})," &optional ",(0,s.jsx)(n.em,{children:"eof-error-p eof-value"})]}),"\n",(0,s.jsxs)(n.p,{children:["&key ",(0,s.jsx)(n.em,{children:"start end preserve-whitespace"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"\u2192 object, position"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"string"}),"\u2014a ",(0,s.jsx)(n.em,{children:"string"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"eof-error-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"eof-value"}),"\u2014an ",(0,s.jsx)(n.em,{children:"object"}),". The default is ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"start"}),", ",(0,s.jsx)(n.em,{children:"end"}),"\u2014",(0,s.jsx)(n.em,{children:"bounding index designators"})," of ",(0,s.jsx)(n.em,{children:"string"}),". The defaults for ",(0,s.jsx)(n.em,{children:"start"})," and ",(0,s.jsx)(n.em,{children:"end"})," are 0 and ",(0,s.jsx)(n.strong,{children:"nil"}),", respectively."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"preserve-whitespace"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"object"}),"\u2014an ",(0,s.jsx)(n.em,{children:"object"})," (parsed by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," ) or the ",(0,s.jsx)(n.em,{children:"eof-value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"position"}),"\u2014an ",(0,s.jsx)(n.em,{children:"integer"})," greater than or equal to zero, and less than or equal to one more than the ",(0,s.jsx)(n.em,{children:"length"})," of the ",(0,s.jsx)(n.em,{children:"string"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Parses the printed representation of an ",(0,s.jsx)(n.em,{children:"object"})," from the subsequence of ",(0,s.jsx)(n.em,{children:"string bounded"})," by ",(0,s.jsx)(n.em,{children:"start"})," and ",(0,s.jsx)(n.em,{children:"end"}),", as if ",(0,s.jsx)(n.strong,{children:"read"})," had been called on an ",(0,s.jsx)(n.em,{children:"input stream"})," containing those same ",(0,s.jsx)(n.em,{children:"characters"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"preserve-whitespace"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the operation will preserve ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub> as ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})," would do."]}),"\n",(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(n.em,{children:"object"})," is successfully parsed, the ",(0,s.jsx)(n.em,{children:"primary value"}),", ",(0,s.jsx)(n.em,{children:"object"}),", is the ",(0,s.jsx)(n.em,{children:"object"})," that was parsed. If ",(0,s.jsx)(n.em,{children:"eof-error-p"})," is ",(0,s.jsx)(n.em,{children:"false"})," and if the end of the ",(0,s.jsx)(n.em,{children:"substring"})," is reached, ",(0,s.jsx)(n.em,{children:"eof-value"})," is returned."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"secondary value"}),", ",(0,s.jsx)(n.em,{children:"position"}),", is the index of the first ",(0,s.jsx)(n.em,{children:"character"})," in the ",(0,s.jsx)(n.em,{children:"bounded string"})," that was not read. The ",(0,s.jsx)(n.em,{children:"position"})," may depend upon the value of ",(0,s.jsx)(n.em,{children:"preserve-whitespace"}),". If the entire ",(0,s.jsx)(n.em,{children:"string"})," was read, the ",(0,s.jsx)(n.em,{children:"position"})," returned is either the ",(0,s.jsx)(n.em,{children:"length"})," of the ",(0,s.jsx)(n.em,{children:"string"})," or one greater than the ",(0,s.jsx)(n.em,{children:"length"})," of the ",(0,s.jsx)(n.em,{children:"string"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:['(read-from-string " 1 3 5" t nil ',":start"," 2) ",(0,s.jsx)(n.em,{children:"\u2192"})," 3, 5"]}),"\n",(0,s.jsxs)(n.p,{children:['(read-from-string "(a b c)") ',(0,s.jsx)(n.em,{children:"\u2192"})," (A B C), 7"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(n.p,{children:["If the end of the supplied substring occurs before an ",(0,s.jsx)(n.em,{children:"object"})," can be read, an error is signaled if ",(0,s.jsx)(n.em,{children:"eof-error-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),". An error is signaled if the end of the ",(0,s.jsx)(n.em,{children:"substring"})," occurs in the middle of an incomplete ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"}),", ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["The reason that ",(0,s.jsx)(n.em,{children:"position"})," is allowed to be beyond the ",(0,s.jsx)(n.em,{children:"length"})," of the ",(0,s.jsx)(n.em,{children:"string"})," is to permit (but not require) the ",(0,s.jsx)(n.em,{children:"implementation"})," to work by simulating the effect of a trailing delimiter at the end of the ",(0,s.jsx)(n.em,{children:"bounded string"}),". When ",(0,s.jsx)(n.em,{children:"preserve-whitespace"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the ",(0,s.jsx)(n.em,{children:"position"})," might count the simulated delimiter."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtable-case"})," ",(0,s.jsx)(n.em,{children:"Accessor"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtable-case"})," ",(0,s.jsx)(n.em,{children:"readtable \u2192 mode"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"(setf (readtable-case"})," ",(0,s.jsx)(n.em,{children:"readtable"}),"**)** ",(0,s.jsx)(n.em,{children:"mode"}),"**)**"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"mode"}),"\u2014a ",(0,s.jsx)(n.em,{children:"case sensitivity mode"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201311"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Accesses"})," the ",(0,s.jsx)(n.em,{children:"readtable case"})," of ",(0,s.jsx)(n.em,{children:"readtable"}),", which affects the way in which the ",(0,s.jsx)(n.em,{children:"Lisp Reader"})," reads ",(0,s.jsx)(n.em,{children:"symbols"})," and the way in which the ",(0,s.jsx)(n.em,{children:"Lisp Printer"})," writes ",(0,s.jsx)(n.em,{children:"symbols"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"See Section 23.1.2.1 (Examples of Effect of Readtable Case on the Lisp Reader) and Section 22.1.3.3.2.1 (Examples of Effect of Readtable Case on the Lisp Printer)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(n.p,{children:["Should signal an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"type-error"})," if ",(0,s.jsx)(n.em,{children:"readtable"})," is not a ",(0,s.jsx)(n.em,{children:"readtable"}),". Should signal an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"type-error"})," if ",(0,s.jsx)(n.em,{children:"mode"})," is not a ",(0,s.jsx)(n.em,{children:"case sensitivity mode"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*readtable*"}),", ",(0,s.jsx)(n.strong,{children:"*print-escape*"}),", Section 2.2 (Reader Algorithm), Section 23.1.2 (Effect of Readtable Case on the Lisp Reader), Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp Printer)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"copy-readtable"})," copies the ",(0,s.jsx)(n.em,{children:"readtable case"})," of the ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtablep"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readtablep"})," ",(0,s.jsx)(n.em,{children:"object \u2192 generalized-boolean"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"object"}),"\u2014an ",(0,s.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"generalized-boolean"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.em,{children:"true"})," if ",(0,s.jsx)(n.em,{children:"object"})," is of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"readtable"}),"; otherwise, returns ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(readtablep *readtable*) ",(0,s.jsx)(n.em,{children:"\u2192 true"})]}),"\n",(0,s.jsxs)(n.p,{children:["(readtablep (copy-readtable)) ",(0,s.jsx)(n.em,{children:"\u2192 true"})]}),"\n",(0,s.jsxs)(n.p,{children:["(readtablep \u2019*readtable*) ",(0,s.jsx)(n.em,{children:"\u2192 false"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["(readtablep ",(0,s.jsx)(n.em,{children:"object"}),") ",(0,s.jsx)(n.em,{children:"\u2261"})," (typep ",(0,s.jsx)(n.em,{children:"object"})," \u2019readtable)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-dispatch-macro-character,"})," ",(0,s.jsx)(n.em,{children:". . ."})]}),"\n",(0,s.jsx)(n.p,{children:"<b><sup>set-dispatch-macro-character, get-dispatch-macro</sup> character</b> <i>Function</i>"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"get-dispatch-macro-character"})," ",(0,s.jsx)(n.em,{children:"disp-char sub-char"})," &optional ",(0,s.jsx)(n.em,{children:"readtable \u2192 function"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-dispatch-macro-character"})," ",(0,s.jsx)(n.em,{children:"disp-char sub-char new-function"})," &optional ",(0,s.jsx)(n.em,{children:"readtable \u2192"})," ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"disp-char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"sub-char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable designator"})," . The default is the ",(0,s.jsx)(n.em,{children:"current readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"function"}),"\u2014a ",(0,s.jsx)(n.em,{children:"function designator"})," or ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"new-function"}),"\u2014a ",(0,s.jsx)(n.em,{children:"function designator"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-dispatch-macro-character"})," causes ",(0,s.jsx)(n.em,{children:"new-function"})," to be called when ",(0,s.jsx)(n.em,{children:"disp-char"})," followed by ",(0,s.jsx)(n.em,{children:"sub-char"})," is read. If ",(0,s.jsx)(n.em,{children:"sub-char"})," is a lowercase letter, it is converted to its uppercase equivalent. It is an error if ",(0,s.jsx)(n.em,{children:"sub-char"})," is one of the ten decimal digits."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-dispatch-macro-character"})," installs a ",(0,s.jsx)(n.em,{children:"new-function"})," to be called when a particular ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," pair is read. ",(0,s.jsx)(n.em,{children:"New-function"})," is installed as the dispatch function to be called when ",(0,s.jsx)(n.em,{children:"readtable"})," is in use and when ",(0,s.jsx)(n.em,{children:"disp-char"})," is followed by ",(0,s.jsx)(n.em,{children:"sub-char"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For more information about how the ",(0,s.jsx)(n.em,{children:"new-function"})," is invoked, see Section 2.1.4.4 (Macro Characters)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"get-dispatch-macro-character"})," retrieves the dispatch function associated with ",(0,s.jsx)(n.em,{children:"disp-char"})," and ",(0,s.jsx)(n.em,{children:"sub-char"})," in ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"get-dispatch-macro-character"})," returns the macro-character function for ",(0,s.jsx)(n.em,{children:"sub-char"})," under ",(0,s.jsx)(n.em,{children:"disp char"}),", or ",(0,s.jsx)(n.strong,{children:"nil"})," if there is no function associated with ",(0,s.jsx)(n.em,{children:"sub-char"}),". If ",(0,s.jsx)(n.em,{children:"sub-char"})," is a decimal digit, ",(0,s.jsx)(n.strong,{children:"get-dispatch-macro-character"})," returns ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(get-dispatch-macro-character ## #\\{) ",(0,s.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,s.jsx)(n.p,{children:"(set-dispatch-macro-character ## #\\{ ;dispatch on #{"}),"\n",(0,s.jsx)(n.p,{children:"#\u2019(lambda(s c n)"}),"\n",(0,s.jsx)(n.p,{children:"(let ((list (read s nil (values) t))) ;list is object after #n{"}),"\n",(0,s.jsx)(n.p,{children:"(when (consp list) ;return nth element of list"}),"\n",(0,s.jsx)(n.p,{children:"(unless (and n (< 0 n (length list))) (setq n 0))"}),"\n",(0,s.jsx)(n.p,{children:"(setq list (nth n list)))"}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201313"})]}),"\n",(0,s.jsxs)(n.p,{children:["list))) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["#{(1 2 3 4) ",(0,s.jsx)(n.em,{children:"\u2192"})," 1"]}),"\n",(0,s.jsxs)(n.p,{children:["#3{(0 1 2 3) ",(0,s.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,s.jsxs)(n.p,{children:["#{123 ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsxs)(n.p,{children:["If it is desired that #$",(0,s.jsx)(n.em,{children:"foo"})," : as if it were (dollars ",(0,s.jsx)(n.em,{children:"foo"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"(defun |#$-reader| (stream subchar arg)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore subchar arg))"}),"\n",(0,s.jsxs)(n.p,{children:["(list \u2019dollars (read stream t nil t))) ",(0,s.jsx)(n.em,{children:"\u2192"})," |#$-reader|"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-dispatch-macro-character ## #$ #\u2019|#$-reader|) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:"Section 2.1.4.4 (Macro Characters)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"readtable"})," is modified."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*readtable*"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(n.p,{children:["For either function, an error is signaled if ",(0,s.jsx)(n.em,{children:"disp-char"})," is not a ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," in ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"*readtable*"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["It is necessary to use ",(0,s.jsx)(n.strong,{children:"make-dispatch-macro-character"})," to set up the dispatch character before specifying its sub-characters."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-macro-character, get-macro-character"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"get-macro-character"})," ",(0,s.jsx)(n.em,{children:"char"})," &optional ",(0,s.jsx)(n.em,{children:"readtable \u2192 function, non-terminating-p"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-macro-character"})," ",(0,s.jsx)(n.em,{children:"char new-function"})," &optional ",(0,s.jsx)(n.em,{children:"non-terminating-p readtable \u2192"})," ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"non-terminating-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"set-macro-character, get-macro-character"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable designator"})," . The default is the ",(0,s.jsx)(n.em,{children:"current readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"function"}),"\u2014",(0,s.jsx)(n.strong,{children:"nil"}),", or a ",(0,s.jsx)(n.em,{children:"designator"})," for a ",(0,s.jsx)(n.em,{children:"function"})," of two ",(0,s.jsx)(n.em,{children:"arguments"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"new-function"}),"\u2014a ",(0,s.jsx)(n.em,{children:"function designator"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"get-macro-character"})," returns as its ",(0,s.jsx)(n.em,{children:"primary value"}),", ",(0,s.jsx)(n.em,{children:"function"}),", the ",(0,s.jsx)(n.em,{children:"reader macro function"})," associated with ",(0,s.jsx)(n.em,{children:"char"})," in ",(0,s.jsx)(n.em,{children:"readtable"})," (if any), or else ",(0,s.jsx)(n.strong,{children:"nil"})," if ",(0,s.jsx)(n.em,{children:"char"})," is not a ",(0,s.jsx)(n.em,{children:"macro character"})," in ",(0,s.jsx)(n.em,{children:"readtable"}),". The ",(0,s.jsx)(n.em,{children:"secondary value"}),", ",(0,s.jsx)(n.em,{children:"non-terminating-p"}),", is ",(0,s.jsx)(n.em,{children:"true"})," if ",(0,s.jsx)(n.em,{children:"char"})," is a ",(0,s.jsx)(n.em,{children:"non-terminating macro character"})," ; otherwise, it is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-macro-character"})," causes ",(0,s.jsx)(n.em,{children:"char"})," to be a ",(0,s.jsx)(n.em,{children:"macro character"})," associated with the ",(0,s.jsx)(n.em,{children:"reader macro function new-function"})," (or the ",(0,s.jsx)(n.em,{children:"designator"})," for ",(0,s.jsx)(n.em,{children:"new-function"}),") in ",(0,s.jsx)(n.em,{children:"readtable"}),". If ",(0,s.jsx)(n.em,{children:"non-terminating-p"})," is ",(0,s.jsx)(n.em,{children:"true"}),", ",(0,s.jsx)(n.em,{children:"char"})," becomes a ",(0,s.jsx)(n.em,{children:"non-terminating macro character"})," ; otherwise it becomes a ",(0,s.jsx)(n.em,{children:"terminating macro character"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(get-macro-character #\\{) ",(0,s.jsx)(n.em,{children:"\u2192"})," NIL, ",(0,s.jsx)(n.em,{children:"false"})]}),"\n",(0,s.jsxs)(n.p,{children:["(not (get-macro-character #;)) ",(0,s.jsx)(n.em,{children:"\u2192 false"})]}),"\n",(0,s.jsxs)(n.p,{children:["The following is a possible definition for the ",(0,s.jsx)(n.em,{children:"single-quote reader macro"})," in ",(0,s.jsx)(n.em,{children:"standard syntax"})," :"]}),"\n",(0,s.jsx)(n.p,{children:"(defun single-quote-reader (stream char)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsxs)(n.p,{children:["(list \u2019quote (read stream t nil t))) ",(0,s.jsx)(n.em,{children:"\u2192"})," SINGLE-QUOTE-READER"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-macro-character #\\\u2019 #\u2019single-quote-reader) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["Here single-quote-reader reads an ",(0,s.jsx)(n.em,{children:"object"})," following the ",(0,s.jsx)(n.em,{children:"single-quote"})," and returns a ",(0,s.jsx)(n.em,{children:"list"})," of ",(0,s.jsx)(n.strong,{children:"quote"})," and that ",(0,s.jsx)(n.em,{children:"object"}),". The ",(0,s.jsx)(n.em,{children:"char"})," argument is ignored."]}),"\n",(0,s.jsxs)(n.p,{children:["The following is a possible definition for the ",(0,s.jsx)(n.em,{children:"semicolon reader macro"})," in ",(0,s.jsx)(n.em,{children:"standard syntax"})," :"]}),"\n",(0,s.jsx)(n.p,{children:"(defun semicolon-reader (stream char)"}),"\n",(0,s.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(n.p,{children:";; First swallow the rest of the current input line."}),"\n",(0,s.jsx)(n.p,{children:";; End-of-file is acceptable for terminating the comment."}),"\n",(0,s.jsx)(n.p,{children:"(do () ((char= (read-char stream nil #\\Newline t) #\\Newline)))"}),"\n",(0,s.jsx)(n.p,{children:";; Return zero values."}),"\n",(0,s.jsxs)(n.p,{children:["(values)) ",(0,s.jsx)(n.em,{children:"\u2192"})," SEMICOLON-READER"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-macro-character #; #\u2019semicolon-reader) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"readtable"})," is modified."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"*readtable*"})}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201315"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-syntax-from-char"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-syntax-from-char"})," ",(0,s.jsx)(n.em,{children:"to-char from-char"})," &optional ",(0,s.jsx)(n.em,{children:"to-readtable from-readtable \u2192"})," ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"to-char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"from-char"}),"\u2014a ",(0,s.jsx)(n.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"to-readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable"}),". The default is the ",(0,s.jsx)(n.em,{children:"current readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"from-readtable"}),"\u2014a ",(0,s.jsx)(n.em,{children:"readtable designator"})," . The default is the ",(0,s.jsx)(n.em,{children:"standard readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-syntax-from-char"})," makes the syntax of ",(0,s.jsx)(n.em,{children:"to-char"})," in ",(0,s.jsx)(n.em,{children:"to-readtable"})," be the same as the syntax of ",(0,s.jsx)(n.em,{children:"from-char"})," in ",(0,s.jsx)(n.em,{children:"from-readtable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-syntax-from-char"})," copies the ",(0,s.jsx)(n.em,{children:"syntax types"})," of ",(0,s.jsx)(n.em,{children:"from-char"}),". If ",(0,s.jsx)(n.em,{children:"from-char"})," is a ",(0,s.jsx)(n.em,{children:"macro character"})," , its ",(0,s.jsx)(n.em,{children:"reader macro function"})," is copied also. If the character is a ",(0,s.jsx)(n.em,{children:"dispatching macro character"})," , its entire dispatch table of ",(0,s.jsx)(n.em,{children:"reader macro functions"})," is copied. The ",(0,s.jsx)(n.em,{children:"constituent traits"})," of ",(0,s.jsx)(n.em,{children:"from-char"})," are not copied."]}),"\n",(0,s.jsxs)(n.p,{children:['A macro definition from a character such as " can be copied to another character; the standard definition for " looks for another character that is the same as the character that invoked it. The definition of ( can not be meaningfully copied to {, on the other hand. The result is that ',(0,s.jsx)(n.em,{children:"lists"})," are of the form {a b c), not {a b c}, because the definition always looks for a closing parenthesis, not a closing brace."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(set-syntax-from-char #\\7 #;) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["123579 ",(0,s.jsx)(n.em,{children:"\u2192"})," 1235"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"to-readtable"})," is modified."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,s.jsxs)(n.p,{children:["The existing values in the ",(0,s.jsx)(n.em,{children:"from-readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"set-macro-character"}),", ",(0,s.jsx)(n.strong,{children:"make-dispatch-macro-character"}),", Section 2.1.4 (Character Syntax Types)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"constituent traits"})," of a ",(0,s.jsx)(n.em,{children:"character"})," are \u201chard wired\u201d into the parser for extended ",(0,s.jsx)(n.em,{children:"tokens"}),". For example, if the definition of S is copied to *, then * will become a ",(0,s.jsx)(n.em,{children:"constituent"})," that is ",(0,s.jsx)(n.em,{children:"alphabetic"}),"<sub>2</sub> but that cannot be used as a ",(0,s.jsx)(n.em,{children:"short float exponent marker"})," . For further information, see Section 2.1.4.2 (Constituent Traits)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"with-standard-io-syntax"})," ",(0,s.jsx)(n.em,{children:"Macro"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"with-standard-io-syntax"})," ",(0,s.jsx)(n.em,{children:"{form}"}),"* ",(0,s.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"forms"}),"\u2014an ",(0,s.jsx)(n.em,{children:"implicit progn"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"results"}),"\u2014the ",(0,s.jsx)(n.em,{children:"values"})," returned by the ",(0,s.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Within the dynamic extent of the body of ",(0,s.jsx)(n.em,{children:"forms"}),", all reader/printer control variables, including any ",(0,s.jsx)(n.em,{children:"implementation-defined"})," ones not specified by this standard, are bound to values that produce standard read/print behavior. The values for the variables specified by this standard are listed in Figure 23\u20131."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201317"})]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsx)(n.tr,{children:(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Variable Value"})})})}),(0,s.jsx)(n.tbody,{children:(0,s.jsx)(n.tr,{children:(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["<p>",(0,s.jsx)(n.strong,{children:"*package*"})," The CL-USER ",(0,s.jsx)(n.em,{children:"package"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-array* t"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-base*"})," 10 </p><p>",(0,s.jsx)(n.strong,{children:"*print-case*"})," ",":upcase"," </p><p>",(0,s.jsx)(n.strong,{children:"*print-circle* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-escape* t"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-gensym* t"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-length* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-level* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-lines* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-miser-width* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-pprint-dispatch*"})," The ",(0,s.jsx)(n.em,{children:"standard pprint dispatch table"})," ",(0,s.jsx)(n.strong,{children:"*print-pretty* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-radix* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-readably* t"})," </p><p>",(0,s.jsx)(n.strong,{children:"*print-right-margin* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*read-base*"})," 10 </p><p>",(0,s.jsx)(n.strong,{children:"*read-default-float-format* single-float"})," </p><p>",(0,s.jsx)(n.strong,{children:"*read-eval* t"})," </p><p>",(0,s.jsx)(n.strong,{children:"*read-suppress* nil"})," </p><p>",(0,s.jsx)(n.strong,{children:"*readtable*"})," The ",(0,s.jsx)(n.em,{children:"standard readtable"}),"</p>"]})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 23\u20131. Values of standard control variables"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(with-open-file (file pathname ",":direction"," ",":output",")"]}),"\n",(0,s.jsx)(n.p,{children:"(with-standard-io-syntax"}),"\n",(0,s.jsx)(n.p,{children:"(print data file)))"}),"\n",(0,s.jsx)(n.p,{children:";;; ... Later, in another Lisp:"}),"\n",(0,s.jsxs)(n.p,{children:["(with-open-file (file pathname ",":direction"," ",":input",")"]}),"\n",(0,s.jsx)(n.p,{children:"(with-standard-io-syntax"}),"\n",(0,s.jsx)(n.p,{children:"(setq data (read file))))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2217"}),(0,s.jsx)(n.strong,{children:"read-base"}),(0,s.jsx)(n.em,{children:"\u2217 Variable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Value Type:"})}),"\n",(0,s.jsxs)(n.p,{children:["a ",(0,s.jsx)(n.em,{children:"radix"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initial Value:"})}),"\n",(0,s.jsx)(n.p,{children:"10."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Controls the interpretation of tokens by ",(0,s.jsx)(n.strong,{children:"read"})," as being ",(0,s.jsx)(n.em,{children:"integers"})," or ",(0,s.jsx)(n.em,{children:"ratios"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*read-base*"}),", called the ",(0,s.jsx)(n.em,{children:"current input base"}),", is the radix in which ",(0,s.jsx)(n.em,{children:"integers"})," and ",(0,s.jsx)(n.em,{children:"ratios"})," are to be read by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," . The parsing of other numeric ",(0,s.jsx)(n.em,{children:"types"})," (",(0,s.jsx)(n.em,{children:"e.g."}),", ",(0,s.jsx)(n.em,{children:"floats"}),") is not affected by this option."]}),"\n",(0,s.jsxs)(n.p,{children:["The effect of ",(0,s.jsx)(n.strong,{children:"*read-base*"})," on the reading of any particular ",(0,s.jsx)(n.em,{children:"rational"})," number can be locally overridden by explicit use of the #O, #X, #B, or #",(0,s.jsx)(n.em,{children:"n"}),"R syntax or by a trailing decimal point."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"(dotimes (i 6)"}),"\n",(0,s.jsx)(n.p,{children:"(let ((*read-base* (+ 10. i)))"}),"\n",(0,s.jsx)(n.p,{children:'(let ((object (read-from-string "(\\DAD DAD |BEE| BEE 123. 123)")))'}),"\n",(0,s.jsx)(n.p,{children:"(print (list *read-base* object)))))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (10 (DAD DAD BEE BEE 123 123))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (11 (DAD DAD BEE BEE 123 146))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (12 (DAD DAD BEE BEE 123 171))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (13 (DAD DAD BEE BEE 123 198))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (14 (DAD 2701 BEE BEE 123 227))"}),"\n",(0,s.jsx)(n.p,{children:"\u25b7 (15 (DAD 3088 BEE 2699 123 258))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsx)(n.p,{children:"Altering the input radix can be useful when reading data files in special formats."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2217"}),(0,s.jsx)(n.strong,{children:"read-default-float-format"}),(0,s.jsx)(n.em,{children:"\u2217 Variable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Value Type:"})}),"\n",(0,s.jsxs)(n.p,{children:["one of the ",(0,s.jsx)(n.em,{children:"atomic type specifiers"})," ",(0,s.jsx)(n.strong,{children:"short-float"}),", ",(0,s.jsx)(n.strong,{children:"single-float"}),", ",(0,s.jsx)(n.strong,{children:"double-float"}),", or ",(0,s.jsx)(n.strong,{children:"long-float"}),", or else some other ",(0,s.jsx)(n.em,{children:"type specifier"})," defined by the ",(0,s.jsx)(n.em,{children:"implementation"})," to be acceptable."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201319"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initial Value:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"symbol"})," ",(0,s.jsx)(n.strong,{children:"single-float"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Controls the floating-point format that is to be used when reading a floating-point number that has no ",(0,s.jsx)(n.em,{children:"exponent marker"})," or that has e or E for an ",(0,s.jsx)(n.em,{children:"exponent marker"})," . Other ",(0,s.jsx)(n.em,{children:"exponent markers"})," explicitly prescribe the floating-point format to be used."]}),"\n",(0,s.jsxs)(n.p,{children:["The printer uses ",(0,s.jsx)(n.strong,{children:"*read-default-float-format*"})," to guide the choice of ",(0,s.jsx)(n.em,{children:"exponent markers"})," when printing floating-point numbers."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"(let ((*read-default-float-format* \u2019double-float))"}),"\n",(0,s.jsx)(n.p,{children:'(read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (1.0 1.0 1.0 1.0 1.0 1.0) ;Implementation has float format F."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (1.0 1.0 1.0s0 1.0 1.0 1.0) ;Implementation has float formats S and F. ",(0,s.jsx)(n.em,{children:"\u2192"})," (1.0d0 1.0d0 1.0 1.0 1.0d0 1.0d0) ;Implementation has float formats F and D. ",(0,s.jsx)(n.em,{children:"\u2192"})," (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D. ",(0,s.jsx)(n.em,{children:"\u2192"})," (1.0d0 1.0d0 1.0 1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L. ",(0,s.jsx)(n.em,{children:"\u2192"})," (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2217"}),(0,s.jsx)(n.strong,{children:"read-eval"}),(0,s.jsx)(n.em,{children:"\u2217 Variable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Value Type:"})}),"\n",(0,s.jsxs)(n.p,{children:["a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initial Value:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["If it is ",(0,s.jsx)(n.em,{children:"true"}),", the #. ",(0,s.jsx)(n.em,{children:"reader macro"})," has its normal effect. Otherwise, that ",(0,s.jsx)(n.em,{children:"reader macro"})," signals an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"reader-error"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"*print-readably*"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.strong,{children:"*read-eval*"})," is ",(0,s.jsx)(n.em,{children:"false"})," and ",(0,s.jsx)(n.strong,{children:"*print-readably*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", any ",(0,s.jsx)(n.em,{children:"method"})," for ",(0,s.jsx)(n.strong,{children:"print-object"})," that would output a reference to the #. ",(0,s.jsx)(n.em,{children:"reader macro"})," either outputs something different or signals an error of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"print-not-readable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2217"}),(0,s.jsx)(n.strong,{children:"read-suppress"}),(0,s.jsx)(n.em,{children:"\u2217 Variable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Value Type:"})}),"\n",(0,s.jsxs)(n.p,{children:["a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initial Value:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["This variable is intended primarily to support the operation of the read-time conditional notations #+ and #-. It is important for the ",(0,s.jsx)(n.em,{children:"reader macros"})," which implement these notations to be able to skip over the printed representation of an ",(0,s.jsx)(n.em,{children:"expression"})," despite the possibility that the syntax of the skipped ",(0,s.jsx)(n.em,{children:"expression"})," may not be entirely valid for the current implementation, since #+ and #- exist in order to allow the same program to be shared among several Lisp implementations (including dialects other than Common Lisp) despite small incompatibilities of syntax."]}),"\n",(0,s.jsxs)(n.p,{children:["If it is ",(0,s.jsx)(n.em,{children:"false"}),", the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," operates normally."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*read-suppress*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", ",(0,s.jsx)(n.strong,{children:"read"}),", ",(0,s.jsx)(n.strong,{children:"read-preserving-whitespace"}),", ",(0,s.jsx)(n.strong,{children:"read-delimited-list"}),", and ",(0,s.jsx)(n.strong,{children:"read-from-string"})," all return a ",(0,s.jsx)(n.em,{children:"primary value"})," of ",(0,s.jsx)(n.strong,{children:"nil"})," when they complete successfully; however, they continue to parse the representation of an ",(0,s.jsx)(n.em,{children:"object"})," in the normal way, in order to skip over the ",(0,s.jsx)(n.em,{children:"object"}),", and continue to indicate ",(0,s.jsx)(n.em,{children:"end of file"})," in the normal way. Except as noted below, any ",(0,s.jsx)(n.em,{children:"standardized reader macro"}),"<sub>2</sub> that is defined to ",(0,s.jsx)(n.em,{children:"read"})," <sub>2</sub> a following ",(0,s.jsx)(n.em,{children:"object"})," or ",(0,s.jsx)(n.em,{children:"token"})," will do so, but not signal an error if the ",(0,s.jsx)(n.em,{children:"object"})," read is not of an appropriate type or syntax. The ",(0,s.jsx)(n.em,{children:"standard syntax"})," and its associated ",(0,s.jsx)(n.em,{children:"reader macros"})," will not construct any new ",(0,s.jsx)(n.em,{children:"objects"})," (",(0,s.jsx)(n.em,{children:"e.g."}),", when reading the representation of a ",(0,s.jsx)(n.em,{children:"symbol"}),", no ",(0,s.jsx)(n.em,{children:"symbol"})," will be constructed or interned)."]}),"\n",(0,s.jsx)(n.p,{children:"Extended tokens"}),"\n",(0,s.jsxs)(n.p,{children:["All extended tokens are completely uninterpreted. Errors such as those that might otherwise be signaled due to detection of invalid ",(0,s.jsx)(n.em,{children:"potential numbers"}),", invalid patterns of ",(0,s.jsx)(n.em,{children:"package markers"}),", and invalid uses of the ",(0,s.jsx)(n.em,{children:"dot"})," character are suppressed."]}),"\n",(0,s.jsxs)(n.p,{children:["Dispatching macro characters (including ",(0,s.jsx)(n.em,{children:"sharpsign"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Dispatching macro characters"})," continue to parse an infix numerical argument, and invoke the dispatch function. The ",(0,s.jsx)(n.em,{children:"standardized sharpsign reader macros"})," do not enforce any constraints on either the presence of or the value of the numerical argument."]}),"\n",(0,s.jsx)(n.p,{children:"#="}),"\n",(0,s.jsxs)(n.p,{children:["The #= notation is totally ignored. It does not read a following ",(0,s.jsx)(n.em,{children:"object"}),". It produces no ",(0,s.jsx)(n.em,{children:"object"}),", but is treated as ",(0,s.jsx)(n.em,{children:"whitespace"}),"<sub>2</sub>."]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201321"})]}),"\n",(0,s.jsx)(n.p,{children:"##"}),"\n",(0,s.jsxs)(n.p,{children:["The ## notation always produces ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["No matter what the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*read-suppress*"}),", parentheses still continue to delimit and construct ",(0,s.jsx)(n.em,{children:"lists"}),"; the #( notation continues to delimit ",(0,s.jsx)(n.em,{children:"vectors"}),"; and comments, ",(0,s.jsx)(n.em,{children:"strings"}),", and the ",(0,s.jsx)(n.em,{children:"single-quote"})," and ",(0,s.jsx)(n.em,{children:"backquote"})," notations continue to be interpreted properly. Such situations as \u2019), #<, #), and #",(0,s.jsx)(n.em,{children:"hSpacei"})," continue to signal errors."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"(let ((*read-suppress* t))"}),"\n",(0,s.jsx)(n.p,{children:"(mapcar #\u2019read-from-string"}),"\n",(0,s.jsxs)(n.p,{children:['\u2019("#(foo bar baz)" "#P(',":type"," ",":lisp",')" "#c1.2"']}),"\n",(0,s.jsx)(n.p,{children:'"#.(PRINT \u2019FOO)" "#3AHELLO" "#S(INTEGER)"'}),"\n",(0,s.jsx)(n.p,{children:'"#*ABC" "#\\GARBAGE" "#RALPHA" "#3R444")))'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2192"})," (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"}),", Chapter 2 (Syntax)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Programmers"})," and ",(0,s.jsx)(n.em,{children:"implementations"})," that define additional ",(0,s.jsx)(n.em,{children:"macro characters"})," are strongly encouraged to make them respect ",(0,s.jsx)(n.strong,{children:"*read-suppress*"})," just as ",(0,s.jsx)(n.em,{children:"standardized macro characters"})," do. That is, when the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*read-suppress*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", they should ignore type errors when reading a following ",(0,s.jsx)(n.em,{children:"object"})," and the ",(0,s.jsx)(n.em,{children:"functions"})," that implement ",(0,s.jsx)(n.em,{children:"dispatching macro characters"})," should tolerate ",(0,s.jsx)(n.strong,{children:"nil"})," as their infix ",(0,s.jsx)(n.em,{children:"parameter"})," value even if a numeric value would ordinarily be required."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2217"}),(0,s.jsx)(n.strong,{children:"readtable"}),(0,s.jsx)(n.em,{children:"\u2217 Variable"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Value Type:"})}),"\n",(0,s.jsxs)(n.p,{children:["a ",(0,s.jsx)(n.em,{children:"readtable"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Initial Value:"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"readtable"})," that conforms to the description of Common Lisp syntax in Chapter 2 (Syntax)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*readtable*"})," is called the ",(0,s.jsx)(n.em,{children:"current readtable"}),". It controls the parsing behavior of the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," , and can also influence the ",(0,s.jsx)(n.em,{children:"Lisp printer"})," (",(0,s.jsx)(n.em,{children:"e.g."}),", see the ",(0,s.jsx)(n.em,{children:"function"})," ",(0,s.jsx)(n.strong,{children:"readtable-case"}),")."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.p,{children:["(readtablep *readtable*) ",(0,s.jsx)(n.em,{children:"\u2192 true"})]}),"\n",(0,s.jsxs)(n.p,{children:["(setq zvar 123) ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsxs)(n.p,{children:["(set-syntax-from-char #\\z #\\\u2019 (setq table2 (copy-readtable))) ",(0,s.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsxs)(n.p,{children:["(setq *readtable* table2) ",(0,s.jsx)(n.em,{children:"\u2192"})," #<READTABLE>"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," VAR"]}),"\n",(0,s.jsxs)(n.p,{children:["(setq *readtable* (copy-readtable nil)) ",(0,s.jsx)(n.em,{children:"\u2192"})," #<READTABLE>"]}),"\n",(0,s.jsxs)(n.p,{children:["zvar ",(0,s.jsx)(n.em,{children:"\u2192"})," 123"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"compile-file"}),", ",(0,s.jsx)(n.strong,{children:"load"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"compile-file"}),", ",(0,s.jsx)(n.strong,{children:"load"}),", ",(0,s.jsx)(n.strong,{children:"readtable"}),", Section 2.1.1.1 (The Current Readtable)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"reader-error"})," ",(0,s.jsx)(n.em,{children:"Condition Type"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Class Precedence List:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"reader-error"}),", ",(0,s.jsx)(n.strong,{children:"parse-error"}),", ",(0,s.jsx)(n.strong,{children:"stream-error"}),", ",(0,s.jsx)(n.strong,{children:"error"}),", ",(0,s.jsx)(n.strong,{children:"serious-condition"}),", ",(0,s.jsx)(n.strong,{children:"condition"}),", ",(0,s.jsx)(n.strong,{children:"t"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"reader-error"})," consists of error conditions that are related to tokenization and parsing done by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," ."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"read"}),", ",(0,s.jsx)(n.strong,{children:"stream-error-stream"}),", Section 23.1 (Reader Concepts)"]}),"\n",(0,s.jsxs)(n.p,{children:["Reader ",(0,s.jsx)(n.strong,{children:"23\u201323"})]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}const b={title:"23.1 Reader Concepts"},y="23.1 Reader Concepts",w={id:"chap-23/cd-b-reader-concepts",title:"23.1 Reader Concepts",description:"23.1.1 Dynamic Control of the Lisp Reader",source:"@site/docs/chap-23/cd-b-reader-concepts.md",sourceDirName:"chap-23",slug:"/chap-23/cd-b-reader-concepts",permalink:"/cl-language-reference/docs/chap-23/cd-b-reader-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-23/cd-b-reader-concepts.md",tags:[],version:"current",frontMatter:{title:"23.1 Reader Concepts"},sidebar:"tutorialSidebar",previous:{title:"23. Reader",permalink:"/cl-language-reference/docs/category/23-reader"},next:{title:"intro",permalink:"/cl-language-reference/docs/chap-23/intro"}},v={},E=[{value:"23.1.1 Dynamic Control of the Lisp Reader",id:"2311-dynamic-control-of-the-lisp-reader",level:2},{value:"23.1.2 Effect of Readtable Case on the Lisp Reader",id:"2312-effect-of-readtable-case-on-the-lisp-reader",level:2},{value:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader",id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",level:3},{value:"23.1.3 Argument Conventions of Some Reader Functions",id:"2313-argument-conventions-of-some-reader-functions",level:2},{value:"23.1.3.1 The EOF",id:"23131-the-eof",level:3},{value:"23.1.3.2 The RECURSIVE",id:"23132-the-recursive",level:3}];function A(e){const n={h1:"h1",h2:"h2",h3:"h3",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"231-reader-concepts",children:"23.1 Reader Concepts"}),"\n","\n",(0,s.jsx)(c,{}),"\n",(0,s.jsx)(n.h2,{id:"2311-dynamic-control-of-the-lisp-reader",children:"23.1.1 Dynamic Control of the Lisp Reader"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h2,{id:"2312-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2 Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(n.h3,{id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,s.jsx)(x,{}),"\n",(0,s.jsx)(n.h2,{id:"2313-argument-conventions-of-some-reader-functions",children:"23.1.3 Argument Conventions of Some Reader Functions"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(n.h3,{id:"23131-the-eof",children:"23.1.3.1 The EOF"}),"\n","\n",(0,s.jsx)(f,{}),"\n",(0,s.jsx)(n.h3,{id:"23132-the-recursive",children:"23.1.3.2 The RECURSIVE"}),"\n","\n","\n",(0,s.jsx)(u,{})]})}function T(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(A,{...e})}):A(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>d,a:()=>c});var s=r(7294);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);