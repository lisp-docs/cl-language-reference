"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[18894],{28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var t=r(96540);const i={},s=t.createContext(i);function d(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(s.Provider,{value:n},e.children)}},42702:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"chap-5/f-d-dictionary/and_macro","title":"and","description":"Expanded Reference: and","source":"@site/docs/chap-5/f-d-dictionary/and_macro.md","sourceDirName":"chap-5/f-d-dictionary","slug":"/chap-5/f-d-dictionary/and_macro","permalink":"/cl-language-reference/chap-5/f-d-dictionary/and_macro","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-5/f-d-dictionary/and_macro.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"and"},"sidebar":"tutorialSidebar","previous":{"title":"5.3 Data and Control Flow Dictionary","permalink":"/cl-language-reference/category/53-data-and-control-flow-dictionary"},"next":{"title":"apply","permalink":"/cl-language-reference/chap-5/f-d-dictionary/apply_function"}}');var i=r(74848),s=r(28453);function d(e){const n={admonition:"admonition",code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:r,GlossaryTerm:t}=n;return r||l("DictionaryLink",!0),t||l("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"and"})," ",(0,i.jsx)(t,{term:"macro",children:(0,i.jsx)("i",{children:"Macro"})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"{form}"})}),"* \u2192 {result}*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),"\u2014a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"results"}),"\u2014the ",(0,i.jsx)(t,{term:"value",children:(0,i.jsx)("i",{children:"values"})})," resulting from the evaluation of the last ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),", or the symbols ",(0,i.jsx)(r,{term:"nil",children:(0,i.jsx)("b",{children:"nil"})})," or ",(0,i.jsx)(r,{term:"t",children:(0,i.jsx)("b",{children:"t"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," evaluates each ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," one at a time from left to right. As soon as any ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," evaluates to ",(0,i.jsx)(r,{term:"nil",children:(0,i.jsx)("b",{children:"nil"})}),", ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," returns ",(0,i.jsx)(r,{term:"nil",children:(0,i.jsx)("b",{children:"nil"})})," without evaluating the remaining ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"forms"})}),". If all ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"forms"})})," but the last evaluate to ",(0,i.jsx)(t,{term:"true",children:(0,i.jsx)("i",{children:"true"})})," values, ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," returns the results produced by evaluating the last ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If no ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"forms"})})," are supplied, (and) returns ",(0,i.jsx)(r,{term:"t",children:(0,i.jsx)("b",{children:"t"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," passes back multiple values from the last ",(0,i.jsx)(t,{term:"subform",children:(0,i.jsx)("i",{children:"subform"})})," but not from subforms other than the last."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(if (and (>= n 0) \n  (< n (length a-simple-vector)) \n  (eq (elt a-simple-vector n) \u2019foo)) \n    (princ "Foo!")) \n'})}),"\n",(0,i.jsxs)(n.p,{children:["The above expression prints Foo! if element n of a-simple-vector is the symbol foo, provided also that n is indeed a valid index for a-simple-vector. Because ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," guarantees left-to-right testing of its parts, ",(0,i.jsx)(r,{term:"elt",children:(0,i.jsx)("b",{children:"elt"})})," is not called if n is out of range."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(defparameter temp1 1) \u2192 temp1\n(defparameter temp2 1) \u2192 temp2\n(defparameter temp3 1) \u2192 temp3\n(and (incf temp1) (incf temp2) (incf temp3)) \u2192 2 \n(and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) \u2192 true \n(decf temp3) \u2192 1 \n(and (decf temp1) (decf temp2) (eq temp3 \u2019nil) (decf temp3)) \u2192 NIL \n(and (eql temp1 temp2) (eql temp2 temp3)) \u2192 true \n(and) \u2192 T \n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{term:"cond",children:(0,i.jsx)("b",{children:"cond"})}),", ",(0,i.jsx)(r,{term:"every",children:(0,i.jsx)("b",{children:"every"})}),", ",(0,i.jsx)(r,{term:"if",children:(0,i.jsx)("b",{children:"if"})}),", ",(0,i.jsx)(r,{term:"or",children:(0,i.jsx)("b",{children:"or"})}),", ",(0,i.jsx)(r,{term:"when",children:(0,i.jsx)("b",{children:"when"})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(and *form*) *\u2261* (let () *form*)\n(and *form1 form2* ...) *\u2261* (when *form1* (and *form2* ...))\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["We fixed the examples so that it uses ",(0,i.jsx)(r,{term:"defparameter",children:(0,i.jsx)("b",{children:"defparameter"})})," to initialize the variables.  and we added a paragraph explaining why ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," must be defined as a macro, and the consequences of it being defined as a macro."]})})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function l(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const c={title:"and"},o="and",h={},m=[{value:"Expanded Reference: and",id:"expanded-reference-and",level:2}];function x(e){const n={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:r,GlossaryTerm:t}=n;return r||j("DictionaryLink",!0),t||j("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"and",children:"and"})}),"\n","\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-and",children:"Expanded Reference: and"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," is defined as a macro because it stops evaluating as soon as any ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," evaluates to ",(0,i.jsx)(r,{term:"nil",children:(0,i.jsx)("b",{children:"nil"})}),".  If it were defined as a function, every ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," would be evaluated before the function was applied.  As a result of ",(0,i.jsx)(r,{term:"and",children:(0,i.jsx)("b",{children:"and"})})," not being a function, it can not be used with ",(0,i.jsx)(r,{term:"apply",children:(0,i.jsx)("b",{children:"apply"})}),".  In order to check that every value of a list is ",(0,i.jsx)(t,{term:"true",children:(0,i.jsx)("i",{children:"true"})}),", the function ",(0,i.jsx)(r,{term:"every",children:(0,i.jsx)("b",{children:"every"})})," could be used."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}function j(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);