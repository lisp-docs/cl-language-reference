"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[57919],{60908:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var i=t(85893),a=t(11151);function r(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"load-time-value"})," ",(0,i.jsx)(n.em,{children:"Special Operator"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"load-time-value"})," ",(0,i.jsx)(n.em,{children:"form"})," &optional ",(0,i.jsx)(n.em,{children:"read-only-p \u2192 object"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"; evaluated as described below."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"read-only-p"}),"\u2014a ",(0,i.jsx)(n.em,{children:"boolean"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014the ",(0,i.jsx)(n.em,{children:"primary value"})," resulting from evaluating ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"load-time-value"})," provides a mechanism for delaying evaluation of ",(0,i.jsx)(n.em,{children:"form"})," until the expression is in the run-time environment; see Section 3.2 (Compilation)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Read-only-p"})," designates whether the result can be considered a ",(0,i.jsx)(n.em,{children:"constant object"}),". If ",(0,i.jsx)(n.strong,{children:"t"}),", the result is a read-only quantity that can, if appropriate to the ",(0,i.jsx)(n.em,{children:"implementation"}),", be copied into read-only space and/or ",(0,i.jsx)(n.em,{children:"coalesced"})," with ",(0,i.jsx)(n.em,{children:"similar constant objects"})," from other ",(0,i.jsx)(n.em,{children:"programs"}),". If ",(0,i.jsx)(n.strong,{children:"nil"})," (the default), the result must be neither copied nor coalesced; it must be considered to be potentially modifiable data."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.strong,{children:"load-time-value"})," expression is processed by ",(0,i.jsx)(n.strong,{children:"compile-file"}),", the compiler performs its normal semantic processing (such as macro expansion and translation into machine code) on ",(0,i.jsx)(n.em,{children:"form"}),", but arranges for the execution of ",(0,i.jsx)(n.em,{children:"form"})," to occur at load time in a ",(0,i.jsx)(n.em,{children:"null lexical environment"}),", with the result of this ",(0,i.jsx)(n.em,{children:"evaluation"})," then being treated as a ",(0,i.jsx)(n.em,{children:"literal object"})," at run time. It is guaranteed that"]}),"\n",(0,i.jsxs)(n.p,{children:["the evaluation of ",(0,i.jsx)(n.em,{children:"form"})," will take place only once when the ",(0,i.jsx)(n.em,{children:"file"})," is ",(0,i.jsx)(n.em,{children:"loaded"}),", but the order of evaluation with respect to the evaluation of ",(0,i.jsx)(n.em,{children:"top level forms"})," in the file is ",(0,i.jsx)(n.em,{children:"implementation-dependent"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.strong,{children:"load-time-value"})," expression appears within a function compiled with ",(0,i.jsx)(n.strong,{children:"compile"}),", the ",(0,i.jsx)(n.em,{children:"form"})," is evaluated at compile time in a ",(0,i.jsx)(n.em,{children:"null lexical environment"}),". The result of this compile-time evaluation is treated as a ",(0,i.jsx)(n.em,{children:"literal object"})," in the compiled code."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"load-time-value"})}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.strong,{children:"load-time-value"})," expression is processed by ",(0,i.jsx)(n.strong,{children:"eval"}),", ",(0,i.jsx)(n.em,{children:"form"})," is evaluated in a ",(0,i.jsx)(n.em,{children:"null lexical environment"}),", and one value is returned. Implementations that implicitly compile (or partially compile) expressions processed by ",(0,i.jsx)(n.strong,{children:"eval"})," might evaluate ",(0,i.jsx)(n.em,{children:"form"})," only once, at the time this compilation is performed."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.em,{children:"same list"})," (load-time-value ",(0,i.jsx)(n.em,{children:"form"}),") is evaluated or compiled more than once, it is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(n.em,{children:"form"})," is evaluated only once or is evaluated more than once. This can happen both when an expression being evaluated or compiled shares substructure, and when the ",(0,i.jsx)(n.em,{children:"same form"})," is processed by ",(0,i.jsx)(n.strong,{children:"eval"})," or ",(0,i.jsx)(n.strong,{children:"compile"})," multiple times. Since a ",(0,i.jsx)(n.strong,{children:"load-time-value"})," expression can be referenced in more than one place and can be evaluated multiple times by ",(0,i.jsx)(n.strong,{children:"eval"}),", it is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether each execution returns a fresh ",(0,i.jsx)(n.em,{children:"object"})," or returns the same ",(0,i.jsx)(n.em,{children:"object"})," as some other execution. Users must use caution when destructively modifying the resulting ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If two lists (load-time-value ",(0,i.jsx)(n.em,{children:"form"}),") that are the ",(0,i.jsx)(n.em,{children:"same"})," under ",(0,i.jsx)(n.strong,{children:"equal"})," but are not ",(0,i.jsx)(n.em,{children:"identical"})," are evaluated or compiled, their values always come from distinct evaluations of ",(0,i.jsx)(n.em,{children:"form"}),". Their ",(0,i.jsx)(n.em,{children:"values"})," may not be coalesced unless ",(0,i.jsx)(n.em,{children:"read-only-p"})," is ",(0,i.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"\n;;; The function INCR1 always returns the same value, even in different images. ;;; The function INCR2 always returns the same value in a given image, \n;;; but the value it returns might vary from image to image. \n(defun incr1 (x) (+ x #.(random 17))) \n(defun incr2 (x) (+ x (load-time-value (random 17)))) \n;;; The function FOO1-REF references the nth element of the first of \n;;; the \\*FOO-ARRAYS\\* that is available at load time. It is permissible for \n;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the \n;;; updated values. \n(defvar \\*foo-arrays\\* (list (make-array 7) (make-array 8))) \n(defun foo1-ref (n) (aref (load-time-value (first \\*my-arrays\\*) nil) n)) \n(defun set-foo1-ref (n val) \n  (setf (aref (load-time-value (first \\*my-arrays\\*) nil) n) val)) \n;;; The function BAR1-REF references the nth element of the first of \n;;; the \\*BAR-ARRAYS\\* that is available at load time. The programmer has \n;;; promised that the array will be treated as read-only, so the system \n;;; can copy or coalesce the array. \n(defvar \\*bar-arrays\\* (list (make-array 7) (make-array 8))) \n(defun bar1-ref (n) (aref (load-time-value (first \\*my-arrays\\*) t) n)) \n;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced \n;;; even though NIL was specified, because the object was already read-only \n;;; when it was written as a literal vector rather than created by a constructor. ;;; User programs must treat the vector v as read-only. \n(defun baz-ref (n)  \n\n  (let ((v (load-time-value #(A B C) nil))) \n    (values (svref v n) v))) \n;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced \n;;; even though NIL was specified in the outer situation because T was specified ;;; in the inner situation. User programs must treat the vector v as read-only. (defun baz-ref (n) \n(let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil))) \n  (values (svref v n) v))) \n\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compile-file"}),", ",(0,i.jsx)(n.strong,{children:"compile"}),", ",(0,i.jsx)(n.strong,{children:"eval"}),", Section 3.2.2.2 (Minimal Compilation), Section 3.2 (Compilation)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"load-time-value"})," must appear outside of quoted structure in a \u201cfor ",(0,i.jsx)(n.em,{children:"evaluation"}),"\u201d position. In situations which would appear to call for use of ",(0,i.jsx)(n.strong,{children:"load-time-value"})," within a quoted structure, the ",(0,i.jsx)(n.em,{children:"backquote reader macro"})," is probably called for; see Section 2.4.6 (Backquote)."]}),"\n",(0,i.jsxs)(n.p,{children:["Specifying ",(0,i.jsx)(n.strong,{children:"nil"})," for ",(0,i.jsx)(n.em,{children:"read-only-p"})," is not a way to force an object to become modifiable if it has already been made read-only. It is only a way to say that, for an object that is modifiable, this operation is not intended to make that object read-only."]})]})}function s(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}const l={},o="load-time-value",c={id:"chap-3/d-i-dictionary/loadtimevalue",title:"load-time-value",description:"Expanded Reference: load-time-value",source:"@site/docs/chap-3/d-i-dictionary/loadtimevalue.md",sourceDirName:"chap-3/d-i-dictionary",slug:"/chap-3/d-i-dictionary/loadtimevalue",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/loadtimevalue",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-i-dictionary/loadtimevalue.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"lambda",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/lambda"},next:{title:"locally",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/locally"}},d={},h=[{value:"Expanded Reference: load-time-value",id:"expanded-reference-load-time-value",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"load-time-value",children:"load-time-value"}),"\n","\n","\n",(0,i.jsx)(s,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-load-time-value",children:"Expanded Reference: load-time-value"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(load-time-value )\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var i=t(67294);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);