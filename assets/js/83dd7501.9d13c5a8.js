"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[29461],{28453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>c});var r=n(96540);const t={},s=r.createContext(t);function d(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(s.Provider,{value:i},e.children)}},62286:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>V,contentTitle:()=>J,default:()=>Z,frontMatter:()=>H,metadata:()=>r,toc:()=>X});const r=JSON.parse('{"id":"chap-7/h-g-generic-functions-and-methods","title":"7.6 Generic Functions and Methods","description":"7.6.1 Introduction to Generic Functions","source":"@site/docs/chap-7/h-g-generic-functions-and-methods.md","sourceDirName":"chap-7","slug":"/chap-7/h-g-generic-functions-and-methods","permalink":"/cl-language-reference/chap-7/h-g-generic-functions-and-methods","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-7/h-g-generic-functions-and-methods.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"7.6 Generic Functions and Methods"},"sidebar":"tutorialSidebar","previous":{"title":"7.5 Slots","permalink":"/cl-language-reference/chap-7/h-f-slots"},"next":{"title":"7.7 Objects Dictionary","permalink":"/cl-language-reference/category/77-objects-dictionary"}}');var t=n(74848),s=n(28453);function d(e){return(0,t.jsx)(t.Fragment,{})}function c(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d()}function o(e){const i={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||h("DictionaryLink",!0),r||h("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is a function whose behavior depends on the ",(0,t.jsx)(i.em,{children:"classes"})," or identities of the ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})})," supplied to it. A ",(0,t.jsx)(i.em,{children:"generic function object"})," is associated with a set of ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})}),", a ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})}),", a ",(0,t.jsx)(r,{styled:!0,term:"method combination",children:(0,t.jsx)("i",{children:"method combination"})}),(0,t.jsx)("sub",{children:"2"}),", and other information."]}),"\n",(0,t.jsxs)(i.p,{children:["Like an ",(0,t.jsx)(r,{styled:!0,term:"ordinary function",children:(0,t.jsx)("i",{children:"ordinary function"})}),", a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," takes ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})}),", performs a series of operations, and perhaps returns useful ",(0,t.jsx)(r,{term:"value",children:(0,t.jsx)("i",{children:"values"})}),". An ",(0,t.jsx)(r,{styled:!0,term:"ordinary function",children:(0,t.jsx)("i",{children:"ordinary function"})})," has a single body of ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that is always ",(0,t.jsx)(i.em,{children:"executed"})," when the ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," is called. A ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," has a set of bodies of ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," of which a subset is selected for ",(0,t.jsx)(i.em,{children:"execution"}),". The selected bodies of ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," and the manner of their combination are determined by the ",(0,t.jsx)(i.em,{children:"classes"})," or identities of one or more of the ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})})," to the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," and by its ",(0,t.jsx)(r,{styled:!0,term:"method combination",children:(0,t.jsx)("i",{children:"method combination"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(r,{styled:!0,term:"ordinary function",children:(0,t.jsx)("i",{children:"Ordinary functions"})})," and ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic functions"})})," are called with identical syntax."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"Generic functions"})})," are true ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"functions"})})," that can be passed as ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})})," and used as the first ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"argument"})})," to ",(0,t.jsx)(n,{term:"funcall",children:(0,t.jsx)("b",{children:"funcall"})})," and ",(0,t.jsx)(n,{term:"apply",children:(0,t.jsx)("b",{children:"apply"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(r,{term:"binding",children:(0,t.jsx)("i",{children:"binding"})})," of a ",(0,t.jsx)(r,{styled:!0,term:"function name",children:(0,t.jsx)("i",{children:"function name"})})," to a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," can be ",(0,t.jsx)(i.em,{children:"established"})," in one of several ways. It can be ",(0,t.jsx)(i.em,{children:"established"})," in the ",(0,t.jsx)(r,{styled:!0,term:"global environment",children:(0,t.jsx)("i",{children:"global environment"})})," by ",(0,t.jsx)(n,{term:"ensure-generic-function",children:(0,t.jsx)("b",{children:"ensure-generic-function"})}),", ",(0,t.jsx)(n,{term:"defmethod",children:(0,t.jsx)("b",{children:"defmethod"})})," (implicitly, due to ",(0,t.jsx)(n,{term:"ensure-generic-function",children:(0,t.jsx)("b",{children:"ensure-generic-function"})}),") or ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," (also implicitly, due to ",(0,t.jsx)(n,{term:"ensure-generic-function",children:(0,t.jsx)("b",{children:"ensure-generic-function"})}),"). No ",(0,t.jsx)(r,{term:"standardized",children:(0,t.jsx)("i",{children:"standardized"})})," mechanism is provided for ",(0,t.jsx)(i.em,{children:"establishing"})," a ",(0,t.jsx)(r,{term:"binding",children:(0,t.jsx)("i",{children:"binding"})})," of a ",(0,t.jsx)(r,{styled:!0,term:"function name",children:(0,t.jsx)("i",{children:"function name"})})," to a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," in the ",(0,t.jsx)(r,{styled:!0,term:"lexical environment",children:(0,t.jsx)("i",{children:"lexical environment"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["When a ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," form is evaluated, one of three actions is taken (due to ",(0,t.jsx)(n,{term:"ensure-generic-function",children:(0,t.jsx)("b",{children:"ensure-generic-function"})}),"):"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If a generic function of the given name already exists, the existing generic function object is modified. Methods specified by the current ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," form are added, and any methods in the existing generic function that were defined by a previous ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," form are removed. Methods added by the current ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," form might replace methods defined by ",(0,t.jsx)(n,{term:"defmethod",children:(0,t.jsx)("b",{children:"defmethod"})}),", ",(0,t.jsx)(n,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})}),", ",(0,t.jsx)(n,{term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})}),", or ",(0,t.jsx)(n,{term:"defstruct",children:(0,t.jsx)("b",{children:"defstruct"})}),". No other methods in the generic function are affected or replaced."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If the given name names an ",(0,t.jsx)(r,{styled:!0,term:"ordinary function",children:(0,t.jsx)("i",{children:"ordinary function"})}),", a ",(0,t.jsx)(r,{term:"macro",children:(0,t.jsx)("i",{children:"macro"})}),", or a ",(0,t.jsx)(r,{styled:!0,term:"special operator",children:(0,t.jsx)("i",{children:"special operator"})})," , an error is signaled."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Otherwise a generic function is created with the methods specified by the method definitions in the ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," form."]}),"\n",(0,t.jsxs)(i.p,{children:["Some ",(0,t.jsx)(r,{term:"operator",children:(0,t.jsx)("i",{children:"operators"})})," permit specification of the options of a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),", such as the ",(0,t.jsx)(r,{term:"type",children:(0,t.jsx)("i",{children:"type"})})," of ",(0,t.jsx)(r,{styled:!0,term:"method combination",children:(0,t.jsx)("i",{children:"method combination"})})," it uses or its ",(0,t.jsx)(r,{styled:!0,term:"argument precedence order",children:(0,t.jsx)("i",{children:"argument precedence order"})})," . These ",(0,t.jsx)(r,{term:"operator",children:(0,t.jsx)("i",{children:"operators"})})," will be referred to as \u201coperators that specify generic function options.\u201d The only ",(0,t.jsx)(i.em,{children:"standardized operator"})," in this category is ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Some ",(0,t.jsx)(r,{term:"operator",children:(0,t.jsx)("i",{children:"operators"})})," define ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," for a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),". These ",(0,t.jsx)(r,{term:"operator",children:(0,t.jsx)("i",{children:"operators"})})," will be referred to as ",(0,t.jsx)(r,{styled:!0,term:"method-defining operator",children:(0,t.jsx)("i",{children:"method-defining operators"})}),"; their associated ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"forms"})})," are called ",(0,t.jsx)(r,{styled:!0,term:"method-defining form",children:(0,t.jsx)("i",{children:"method-defining forms"})}),". The ",(0,t.jsx)(i.em,{children:"standardized method-defining operators"})," are listed in Figure 7\u20131."]}),"\n",(0,t.jsxs)(i.p,{children:["|",(0,t.jsxs)("p",{children:[(0,t.jsx)(i.strong,{children:"defgeneric defmethod defclass"})," "]}),(0,t.jsx)("p",{children:(0,t.jsx)(i.strong,{children:"define-condition defstruct"})}),"|"]}),"\n",(0,t.jsx)(i.p,{children:"| :- |"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Figure 7\u20131. Standardized Method-Defining Operators"})}),"\n",(0,t.jsxs)(i.p,{children:["Note that of the ",(0,t.jsx)(i.em,{children:"standardized method-defining operators"})," only ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," can specify ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," options. ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," and any ",(0,t.jsx)(i.em,{children:"implementation-defined operators"})," that can specify ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," options are also referred to as \u201coperators that specify generic function options.\u201d"]})]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}function h(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function a(e){const i={code:"code",em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||x("DictionaryLink",!0),r||x("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:[(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"Methods"})})," define the class-specific or identity-specific behavior and operations of a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["A ",(0,t.jsx)(i.em,{children:"method object"})," is associated with ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that implements the method\u2019s behavior, a sequence of ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," that specify when the given ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is applicable, a ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})}),", and a sequence of ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," that are used by the method combination facility to distinguish among ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})}),"."]}),"\n",(0,t.jsx)(i.p,{children:"A method object is not a function and cannot be invoked as a function. Various mechanisms in the object system take a method object and invoke its method function, as is the case when a generic function is invoked. When this occurs it is said that the method is invoked or called."}),"\n",(0,t.jsxs)(i.p,{children:["A method-defining form contains the ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that is to be run when the arguments to the generic function cause the method that it defines to be invoked. When a method-defining form is evaluated, a method object is created and one of four actions is taken:"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," of the given name already exists and if a ",(0,t.jsx)(i.em,{children:"method object"})," already exists that agrees with the new one on ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," and ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),", the new ",(0,t.jsx)(i.em,{children:"method object"})," replaces the old one. For a definition of one method agreeing with another on ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," and ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),", see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," of the given name already exists and if there is no ",(0,t.jsx)(i.em,{children:"method object"})," that agrees with the new one on ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," and ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),", the existing ",(0,t.jsx)(i.em,{children:"generic function object"})," is modified to contain the new ",(0,t.jsx)(i.em,{children:"method object"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If the given ",(0,t.jsx)(r,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," names an ",(0,t.jsx)(r,{styled:!0,term:"ordinary function",children:(0,t.jsx)("i",{children:"ordinary function"})}),", a ",(0,t.jsx)(r,{term:"macro",children:(0,t.jsx)("i",{children:"macro"})}),", or a ",(0,t.jsx)(r,{styled:!0,term:"special operator",children:(0,t.jsx)("i",{children:"special operator"})})," , an error is signaled."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Otherwise a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is created with the ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," specified by the ",(0,t.jsx)(r,{styled:!0,term:"method-defining form",children:(0,t.jsx)("i",{children:"method-defining form"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If the ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of a new ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is not ",(0,t.jsx)(r,{term:"congruent",children:(0,t.jsx)("i",{children:"congruent"})})," with the ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),", an error is signaled. If a ",(0,t.jsx)(r,{styled:!0,term:"method-defining operator",children:(0,t.jsx)("i",{children:"method-defining operator"})})," that cannot specify ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," options creates a new ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),", a ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," for that ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is derived from the ",(0,t.jsx)(r,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of the ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," in the ",(0,t.jsx)(r,{styled:!0,term:"method-defining form",children:(0,t.jsx)("i",{children:"method-defining form"})})," in such a way as to be ",(0,t.jsx)(r,{term:"congruent",children:(0,t.jsx)("i",{children:"congruent"})})," with it. For a discussion of ",(0,t.jsx)(i.em,{children:"congruence"}),", see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,t.jsxs)(i.p,{children:["Each method has a ",(0,t.jsx)(r,{styled:!0,term:"specialized lambda list",children:(0,t.jsx)("i",{children:"specialized lambda list"})}),", which determines when that method can be applied. A ",(0,t.jsx)(r,{styled:!0,term:"specialized lambda list",children:(0,t.jsx)("i",{children:"specialized lambda list"})})," is like an ",(0,t.jsx)(r,{styled:!0,term:"ordinary lambda list",children:(0,t.jsx)("i",{children:"ordinary lambda list"})})," except that a specialized parameter may occur instead of the name of a required parameter. A specialized parameter is a list (",(0,t.jsx)(i.em,{children:"variable-name parameter-specializer-name"}),"), where ",(0,t.jsx)(i.em,{children:"parameter-specializer-name"})," is one of the following:"]}),"\n",(0,t.jsxs)(i.p,{children:["a ",(0,t.jsx)(r,{term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})]}),"\n",(0,t.jsxs)(i.p,{children:["denotes a ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," which is the ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," named by that ",(0,t.jsx)(r,{term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["a ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})]}),"\n",(0,t.jsxs)(i.p,{children:["denotes a ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," which is the ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," itself."]}),"\n",(0,t.jsxs)(i.p,{children:["(eql ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"form"})}),")"]}),"\n",(0,t.jsxs)(i.p,{children:["denotes a ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," which satisfies the ",(0,t.jsx)(r,{styled:!0,term:"type specifier",children:(0,t.jsx)("i",{children:"type specifier"})})," (eql ",(0,t.jsx)(r,{term:"object",children:(0,t.jsx)("i",{children:"object"})}),"), where ",(0,t.jsx)(r,{term:"object",children:(0,t.jsx)("i",{children:"object"})})," is the result of evaluating ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"form"})}),". The form ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"form"})})," is evaluated in the lexical environment in which the method-defining form is evaluated. Note that ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"form"})})," is evaluated only once, at the time the method is defined, not each time the generic function is called."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(r,{styled:!0,term:"parameter specializer name",children:(0,t.jsx)("i",{children:"Parameter specializer names"})})," are used in macros intended as the user-level interface (",(0,t.jsx)(n,{term:"defmethod",children:(0,t.jsx)("b",{children:"defmethod"})}),"), while ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are used in the functional interface."]}),"\n",(0,t.jsxs)(i.p,{children:["Only required parameters may be specialized, and there must be a ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," for each required parameter. For notational simplicity, if some required parameter in a ",(0,t.jsx)(r,{styled:!0,term:"specialized lambda list",children:(0,t.jsx)("i",{children:"specialized lambda list"})})," in a method-defining form is simply a variable name, its ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," defaults to the ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," ",(0,t.jsx)(n,{term:"t",children:(0,t.jsx)("b",{children:"t"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Given a generic function and a set of arguments, an applicable method is a method for that generic function whose parameter specializers are satisfied by their corresponding arguments. The following definition specifies what it means for a method to be applicable and for an argument to satisfy a ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," ."]}),"\n",(0,t.jsxs)(i.p,{children:["Let ",(0,t.jsx)("i",{children:"\u27e8A"}),(0,t.jsx)("sub",{children:"1"}),(0,t.jsxs)("i",{children:[", . . . , A",(0,t.jsx)("sub",{children:"n"}),"\u27e9"]})," be the required arguments to a generic function in order. Let ",(0,t.jsx)("i",{children:"\u27e8P"}),(0,t.jsx)("sub",{children:"1"}),(0,t.jsxs)("i",{children:[", . . . , P",(0,t.jsx)("sub",{children:"n"}),"\u27e9"]})," be the ",(0,t.jsx)("i",{children:"parameter specializers"})," corresponding to the required parameters of the method ",(0,t.jsx)("i",{children:"M"})," in order. The method ",(0,t.jsx)("i",{children:"M"})," is applicable when each ",(0,t.jsxs)("i",{children:["A",(0,t.jsx)("sub",{children:"i"})]}),"is of the ",(0,t.jsx)("i",{children:"type"})," specified by the ",(0,t.jsxs)("i",{children:["type specifier P",(0,t.jsx)("sub",{children:"i"})]}),". Because every valid ",(0,t.jsx)("i",{children:"parameter specializer"})," is also a valid ",(0,t.jsx)("i",{children:"type specifier"})," , the ",(0,t.jsx)("i",{children:"function"})," ",(0,t.jsx)("b",{children:"typep"})," can be used during method selection to determine whether an argument satisfies a ",(0,t.jsx)("i",{children:"parameter specializer"})," ."]}),"\n",(0,t.jsxs)(i.p,{children:["A method all of whose ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are the ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," ",(0,t.jsx)(n,{term:"t",children:(0,t.jsx)("b",{children:"t"})})," is called a ",(0,t.jsx)(r,{styled:!0,term:"default method",children:(0,t.jsx)("i",{children:"default method"})}),"; it is always applicable but may be shadowed by a more specific method."]}),"\n",(0,t.jsxs)(i.p,{children:["Methods can have ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),", which give the method combination procedure a way to distinguish among methods. A method that has one or more ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," is called a ",(0,t.jsx)(r,{styled:!0,term:"qualified method",children:(0,t.jsx)("i",{children:"qualified method"})}),". A method with no ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," is called an ",(0,t.jsx)(r,{styled:!0,term:"unqualified method",children:(0,t.jsx)("i",{children:"unqualified method"})}),". A ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," is any ",(0,t.jsx)(r,{term:"non-list",children:(0,t.jsx)("i",{children:"non-list"})}),". The ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," defined by the ",(0,t.jsx)(r,{term:"standardized",children:(0,t.jsx)("i",{children:"standardized"})})," method combination types are ",(0,t.jsx)(r,{term:"symbol",children:(0,t.jsx)("i",{children:"symbols"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["In this specification, the terms \u201c",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary method"})}),"\u201d and \u201c",(0,t.jsx)(r,{styled:!0,term:"auxiliary method",children:(0,t.jsx)("i",{children:"auxiliary method"})}),"\u201d are used to partition ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," within a method combination type according to their intended use. In standard method combination, ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary methods"})})," are ",(0,t.jsx)(r,{styled:!0,term:"unqualified method",children:(0,t.jsx)("i",{children:"unqualified methods"})})," and ",(0,t.jsx)(r,{styled:!0,term:"auxiliary method",children:(0,t.jsx)("i",{children:"auxiliary methods"})})," are methods with a single ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," that is one of ",(0,t.jsx)(i.code,{children:":around"}),", ",(0,t.jsx)(i.code,{children:":before"}),", or ",(0,t.jsx)(i.code,{children:":after"}),". ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"Methods"})})," with these ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," are called ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})}),", ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before methods"})}),", and ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after methods"})}),", respectively. When a method combination type is defined using the short form of ",(0,t.jsx)(n,{term:"define-method-combination",children:(0,t.jsx)("b",{children:"define-method-combination"})}),", ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary methods"})})," are methods qualified with the name of the type of method combination, and auxiliary methods have the ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," ",(0,t.jsx)(i.code,{children:":around"}),". Thus the terms \u201c",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary method"})}),"\u201d and \u201c",(0,t.jsx)(r,{styled:!0,term:"auxiliary method",children:(0,t.jsx)("i",{children:"auxiliary method"})}),"\u201d have only a relative definition within a given method combination type."]})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function x(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function j(e){const i={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||f("DictionaryLink",!0),r||f("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Two ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," are said to agree with each other on ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," and ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," if the following conditions hold:"]}),"\n",(0,t.jsxs)(i.p,{children:["1. Both methods have the same number of required parameters. Suppose the ",(0,t.jsx)("i",{children:"parameter specializers"})," of the two methods are ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:","}),"1"]})," ",(0,t.jsx)("i",{children:". . . P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",n"})]})," and ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:","}),"1"]})," ",(0,t.jsx)("i",{children:". . . P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",n"})]}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["2. For each 1 ",(0,t.jsx)("i",{children:"\u2264 i \u2264 n"}),", ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",i"})]})," agrees with ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",i"})]}),". The ",(0,t.jsx)("i",{children:"parameter specializer P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",i"})]})," agrees with ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",i"})]})," if ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",i"})]})," and ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",i"})]})," are the same class or if ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",i"})]})," = (",(0,t.jsx)("b",{children:"eql"})," ",(0,t.jsx)("i",{children:"object"}),(0,t.jsx)("sub",{children:"1"}),"), ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",i"})]})," = (",(0,t.jsx)("b",{children:"eql"})," ",(0,t.jsx)("i",{children:"object"}),(0,t.jsx)("sub",{children:"2"}),"), and (",(0,t.jsx)("b",{children:"eql"})," ",(0,t.jsx)("i",{children:"object"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsx)("i",{children:"object"}),(0,t.jsx)("sub",{children:"2"}),"). Otherwise ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["1",(0,t.jsx)("i",{children:",i"})]})," and ",(0,t.jsx)("i",{children:"P"}),(0,t.jsxs)("sub",{children:["2",(0,t.jsx)("i",{children:",i"})]})," do not agree."]}),"\n",(0,t.jsxs)(i.p,{children:["3. The two ",(0,t.jsx)(r,{term:"list",children:(0,t.jsx)("i",{children:"lists"})})," of ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," are the ",(0,t.jsx)(r,{term:"same",children:(0,t.jsx)("i",{children:"same"})})," under ",(0,t.jsx)(n,{term:"equal",children:(0,t.jsx)("b",{children:"equal"})}),"."]})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}function f(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function u(e){const i={p:"p",strong:"strong",...(0,s.R)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["These rules define the congruence of a set of ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda lists"})}),", including the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of each method for a given generic function and the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," specified for the generic function itself, if given."]}),"\n",(0,t.jsxs)(i.p,{children:["1. Each ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," must have the same number of required parameters."]}),"\n",(0,t.jsxs)(i.p,{children:["2. Each ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," must have the same number of optional parameters. Each method can supply its own default for an optional parameter."]}),"\n",(0,t.jsxs)(i.p,{children:["3. If any ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," mentions ",(0,t.jsx)(i.strong,{children:"&rest"})," or ",(0,t.jsx)(i.strong,{children:"&key"}),", each ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," must mention one or both of them."]}),"\n",(0,t.jsxs)(i.p,{children:["4. If the ",(0,t.jsx)(n,{styled:!0,term:"generic function lambda list",children:(0,t.jsx)("i",{children:"generic function lambda list"})})," mentions ",(0,t.jsx)(i.strong,{children:"&key"}),", each method must accept all of the keyword names mentioned after ",(0,t.jsx)(i.strong,{children:"&key"}),", either by accepting them explicitly, by specifying ",(0,t.jsx)(i.strong,{children:"&allow-other-keys"}),", or by specifying ",(0,t.jsx)(i.strong,{children:"&rest"})," but not ",(0,t.jsx)(i.strong,{children:"&key"}),". Each method can accept additional keyword arguments of its own. The checking of the validity of keyword names is done in the generic function, not in each method. A method is invoked as if the keyword argument pair whose name is ",":allow-other-keys"," and whose value is ",(0,t.jsx)(n,{term:"true",children:(0,t.jsx)("i",{children:"true"})})," were supplied, though no such argument pair will be passed."]}),"\n",(0,t.jsxs)(i.p,{children:["5. The use of ",(0,t.jsx)(i.strong,{children:"&allow-other-keys"})," need not be consistent across ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda lists"})}),". If ",(0,t.jsx)(i.strong,{children:"&allow-other-keys"})," is mentioned in the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of any applicable ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," or of the ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),", any keyword arguments may be mentioned in the call to the ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["6. The use of ",(0,t.jsx)(i.strong,{children:"&aux"})," need not be consistent across methods."]}),"\n",(0,t.jsxs)(i.p,{children:["If a ",(0,t.jsx)(n,{styled:!0,term:"method-defining operator",children:(0,t.jsx)("i",{children:"method-defining operator"})})," that cannot specify ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," options creates a ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),", and if the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," for the method mentions keyword arguments, the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of the generic function will mention ",(0,t.jsx)(i.strong,{children:"&key"})," (but no keyword arguments)."]})]})}function b(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function y(e){const i={p:"p",strong:"strong",...(0,s.R)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["When a generic function or any of its methods mentions ",(0,t.jsx)(i.strong,{children:"&key"})," in a ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})}),", the specific set of keyword arguments accepted by the generic function varies according to the applicable methods. The set of keyword arguments accepted by the generic function for a particular call is the union of the keyword arguments accepted by all applicable methods and the keyword arguments mentioned after ",(0,t.jsx)(i.strong,{children:"&key"})," in the generic function definition, if any. A method that has ",(0,t.jsx)(i.strong,{children:"&rest"})," but not ",(0,t.jsx)(i.strong,{children:"&key"})," does not affect the set of acceptable keyword arguments. If the ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," of any applicable method or of the generic function definition contains ",(0,t.jsx)(i.strong,{children:"&allow-other-keys"}),", all keyword arguments are accepted by the generic function."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(n,{styled:!0,term:"lambda list",children:(0,t.jsx)("i",{children:"lambda list"})})," congruence rules require that each method accept all of the keyword arguments mentioned after ",(0,t.jsx)(i.strong,{children:"&key"})," in the generic function definition, by accepting them explicitly, by specifying ",(0,t.jsx)(i.strong,{children:"&allow-other-keys"}),", or by specifying ",(0,t.jsx)(i.strong,{children:"&rest"})," but not ",(0,t.jsx)(i.strong,{children:"&key"}),". Each method can accept additional keyword arguments of its own, in addition to the keyword arguments mentioned in the generic function definition."]}),"\n",(0,t.jsxs)(i.p,{children:["If a ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is passed a keyword argument that no applicable method accepts, an error should be signaled; see Section 3.5 (Error Checking in Function Calls)."]})]})}function g(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(y,{...e})}):y(e)}function w(e){const i={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"For example, suppose there are two methods defined for width as follows:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-lisp",children:"(defmethod width ((c character-class) &key font) ...) \n(defmethod width ((p picture-class) &key pixel-size) ...) \n"})}),"\n",(0,t.jsxs)(i.p,{children:["Assume that there are no other methods and no generic function definition for width. The evaluation of the following form should signal an error because the keyword argument ",":pixel-size"," is not accepted by the applicable method."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-lisp",children:"(width (make-instance \u2018character-class :char #\\Q) \n       :font \u2019baskerville :pixel-size 10) \n"})}),"\n",(0,t.jsx)(i.p,{children:"The evaluation of the following form should signal an error."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-lisp",children:"(width (make-instance \u2018picture-class :glyph (glyph #\\Q)) \n       :font \u2019baskerville :pixel-size 10) \n"})}),"\n",(0,t.jsx)(i.p,{children:"The evaluation of the following form will not signal an error if the class named character-picture class is a subclass of both picture-class and character-class."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-lisp",children:"(width (make-instance \u2018character-picture-class :char #\\Q) \n       :font \u2019baskerville :pixel-size 10) \n"})})]})}function v(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(w,{...e})}):w(e)}function k(e){const i={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||T("DictionaryLink",!0),r||T("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["When a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is called with particular arguments, it must determine the code to execute. This code is called the ",(0,t.jsx)(r,{styled:!0,term:"effective method",children:(0,t.jsx)("i",{children:"effective method"})})," for those ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})}),". The ",(0,t.jsx)(r,{styled:!0,term:"effective method",children:(0,t.jsx)("i",{children:"effective method"})})," is a combination of the ",(0,t.jsx)(r,{styled:!0,term:"applicable method",children:(0,t.jsx)("i",{children:"applicable methods"})})," in the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," that ",(0,t.jsx)(r,{term:"call",children:(0,t.jsx)("i",{children:"calls"})})," some or all of the ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If a ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," is called and no ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," are ",(0,t.jsx)(r,{term:"applicable",children:(0,t.jsx)("i",{children:"applicable"})}),", the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," ",(0,t.jsx)(n,{term:"no-applicable-method",children:(0,t.jsx)("b",{children:"no-applicable-method"})})," is invoked, with the ",(0,t.jsx)(i.em,{children:"results"})," from that call being used as the ",(0,t.jsx)(i.em,{children:"results"})," of the call to the original ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),". Calling ",(0,t.jsx)(n,{term:"no-applicable-method",children:(0,t.jsx)("b",{children:"no-applicable-method"})})," takes precedence over checking for acceptable keyword arguments; see Section 7.6.5 (Keyword Arguments in Generic Functions and Methods)."]}),"\n",(0,t.jsxs)(i.p,{children:["When the ",(0,t.jsx)(r,{styled:!0,term:"effective method",children:(0,t.jsx)("i",{children:"effective method"})})," has been determined, it is invoked with the same ",(0,t.jsx)(r,{term:"argument",children:(0,t.jsx)("i",{children:"arguments"})})," as were passed to the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),". Whatever ",(0,t.jsx)(r,{term:"value",children:(0,t.jsx)("i",{children:"values"})})," it returns are returned as the ",(0,t.jsx)(r,{term:"value",children:(0,t.jsx)("i",{children:"values"})})," of the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),"."]})]})}function q(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(k,{...e})}):k(e)}function T(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function z(e){const i={p:"p",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"The effective method is determined by the following three-step procedure:"}),"\n",(0,t.jsx)(i.p,{children:"1. Select the applicable methods."}),"\n",(0,t.jsx)(i.p,{children:"2. Sort the applicable methods by precedence order, putting the most specific method first."}),"\n",(0,t.jsx)(i.p,{children:"3. Apply method combination to the sorted list of applicable methods, producing the effective method."})]})}function A(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(z,{...e})}):z(e)}function I(e){const i={p:"p",...(0,s.R)(),...e.components};return(0,t.jsx)(i.p,{children:"This step is described in Section 7.6.2 (Introduction to Methods)."})}function M(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(I,{...e})}):I(e)}function F(e){const i={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||S("DictionaryLink",!0),r||S("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["To compare the precedence of two methods, their ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are examined in order. The default examination order is from left to right, but an alternative order may be specified by the ",":argument-precedence-order"," option to ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," or to any of the other operators that specify generic function options."]}),"\n",(0,t.jsxs)(i.p,{children:["The corresponding ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," from each method are compared. When a pair of ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," agree, the next pair are compared for agreement. If all corresponding parameter specializers agree, the two methods must have different ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),"; in this case, either method can be selected to precede the other. For information about agreement, see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,t.jsxs)(i.p,{children:["If some corresponding ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," do not agree, the first pair of ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," that do not agree determines the precedence. If both ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are classes, the more specific of the two methods is the method whose ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," appears earlier in the ",(0,t.jsx)(r,{styled:!0,term:"class precedence list",children:(0,t.jsx)("i",{children:"class precedence list"})})," of the corresponding argument. Because of the way in which the set of applicable methods is chosen, the ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are guaranteed to be present in the class precedence list of the class of the argument."]}),"\n",(0,t.jsxs)(i.p,{children:["If just one of a pair of corresponding ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," is (eql ",(0,t.jsx)(r,{term:"object",children:(0,t.jsx)("i",{children:"object"})}),"), the ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," with that ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializer"})})," precedes the other ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})}),". If both ",(0,t.jsx)(r,{styled:!0,term:"parameter specializer",children:(0,t.jsx)("i",{children:"parameter specializers"})})," are ",(0,t.jsx)(n,{term:"eql",children:(0,t.jsx)("b",{children:"eql"})})," ",(0,t.jsx)(r,{term:"expression",children:(0,t.jsx)("i",{children:"expressions"})}),", the specializers must agree (otherwise the two ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," would not both have been applicable to this argument)."]}),"\n",(0,t.jsxs)(i.p,{children:["The resulting list of ",(0,t.jsx)(r,{styled:!0,term:"applicable method",children:(0,t.jsx)("i",{children:"applicable methods"})})," has the most specific ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," first and the least specific ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," last."]})]})}function G(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(F,{...e})}):F(e)}function S(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function E(e){const i={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||C("DictionaryLink",!0),r||C("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["In the simple case\u2014if standard method combination is used and all applicable methods are primary methods\u2014the effective method is the most specific method. That method can call the next most specific method by using the ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})}),". The method that ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," will call is referred to as the ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})}),". The predicate ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," tests whether a next method exists. If ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is called and there is no next most specific method, the generic function ",(0,t.jsx)(n,{term:"no-next-method",children:(0,t.jsx)("b",{children:"no-next-method"})})," is invoked."]}),"\n",(0,t.jsxs)(i.p,{children:["In general, the effective method is some combination of the applicable methods. It is described by a ",(0,t.jsx)(r,{term:"form",children:(0,t.jsx)("i",{children:"form"})})," that contains calls to some or all of the applicable methods, returns the value or values that will be returned as the value or values of the generic function, and optionally makes some of the methods accessible by means of ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The role of each method in the effective method is determined by its ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," and the specificity of the method. A ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," serves to mark a method, and the meaning of a ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," is determined"]}),"\n",(0,t.jsxs)(i.p,{children:["by the way that these marks are used by this step of the procedure. If an applicable method has an unrecognized ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," , this step signals an error and does not include that method in the effective method."]}),"\n",(0,t.jsx)(i.p,{children:"When standard method combination is used together with qualified methods, the effective method is produced as described in Section 7.6.6.2 (Standard Method Combination)."}),"\n",(0,t.jsxs)(i.p,{children:["Another type of method combination can be specified by using the ",":method-combination"," option of ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," or of any of the other operators that specify generic function options. In this way this step of the procedure can be customized."]}),"\n",(0,t.jsxs)(i.p,{children:["New types of method combination can be defined by using the ",(0,t.jsx)(n,{term:"define-method-combination",children:(0,t.jsx)("b",{children:"define-method-combination"})})," ",(0,t.jsx)(r,{term:"macro",children:(0,t.jsx)("i",{children:"macro"})}),"."]})]})}function R(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(E,{...e})}):E(e)}function C(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function L(e){const i={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||P("DictionaryLink",!0),r||P("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Standard method combination is supported by the ",(0,t.jsx)(r,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," ",(0,t.jsx)(n,{term:"standard-generic-function",children:(0,t.jsx)("b",{children:"standard-generic-function"})}),". It is used if no other type of method combination is specified or if the built-in method combination type ",(0,t.jsx)(i.strong,{children:"standard"})," is specified."]}),"\n",(0,t.jsxs)(i.p,{children:["Primary methods define the main action of the effective method, while auxiliary methods modify that action in one of three ways. A primary method has no method ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["An auxiliary method is a method whose ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," is ",":before",", ",":after",", or ",":around",". Standard method combination allows no more than one ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," per method; if a method definition specifies more than one ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," per method, an error is signaled."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before method"})})," has the keyword ",":before"," as its only ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," . A ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before method"})})," specifies ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that is to be run before any ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary methods"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," An ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after method"})})," has the keyword ",":after"," as its only ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," . An ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after method"})})," specifies ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that is to be run after ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary methods"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," An ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," has the keyword ",":around"," as its only ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," . An ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," specifies ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," that is to be run instead of other ",(0,t.jsx)(r,{styled:!0,term:"applicable method",children:(0,t.jsx)("i",{children:"applicable methods"})}),", but which might contain explicit ",(0,t.jsx)(r,{term:"code",children:(0,t.jsx)("i",{children:"code"})})," which calls some of those ",(0,t.jsx)(i.em,{children:"shadowed methods"})," (via ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})}),")."]}),"\n",(0,t.jsx)(i.p,{children:"The semantics of standard method combination is as follows:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If there are any ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})}),", the most specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," is called. It supplies the value or values of the generic function."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Inside the body of an ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})}),", ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," can be used to call the ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})}),". When the next method returns, the ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," can execute more code, perhaps based on the returned value or values. The ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," ",(0,t.jsx)(n,{term:"no-next-method",children:(0,t.jsx)("b",{children:"no-next-method"})})," is invoked if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is used and there is no ",(0,t.jsx)(r,{styled:!0,term:"applicable method",children:(0,t.jsx)("i",{children:"applicable method"})})," to call. The ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," may be used to determine whether a ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})})," exists."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If an ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," invokes ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})}),", the next most specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," is called, if one is applicable. If there are no ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})})," or if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is called by the least specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})}),", the other methods are called as follows:"]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 All the ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before methods"})})," are called, in most-specific-first order. Their values are ignored. An error is signaled if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is used in a ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before method"})}),"."]}),"\n",(0,t.jsx)(i.p,{children:"\u2013 The most specific primary method is called. Inside the body of a primary"}),"\n",(0,t.jsxs)(i.p,{children:["method, ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," may be used to call the next most specific primary"]}),"\n",(0,t.jsx)(i.p,{children:"method. When that method returns, the previous primary method can execute"}),"\n",(0,t.jsx)(i.p,{children:"more code, perhaps based on the returned value or values. The generic function"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(n,{term:"no-next-method",children:(0,t.jsx)("b",{children:"no-next-method"})})," is invoked if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is used and there are no more"]}),"\n",(0,t.jsxs)(i.p,{children:["applicable primary methods. The ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," may be used to"]}),"\n",(0,t.jsxs)(i.p,{children:["determine whether a ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})})," exists. If ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is not used, only"]}),"\n",(0,t.jsxs)(i.p,{children:["the most specific ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary method"})})," is called."]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 All the ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after methods"})})," are called in most-specific-last order. Their values are"]}),"\n",(0,t.jsxs)(i.p,{children:["ignored. An error is signaled if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is used in an ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after method"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If no ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})})," were invoked, the most specific primary method supplies the value or values returned by the generic function. The value or values returned by the invocation of ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," in the least specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," are those returned by the most specific primary method."]}),"\n",(0,t.jsx)(i.p,{children:"In standard method combination, if there is an applicable method but no applicable primary method, an error is signaled."}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before methods"})})," are run in most-specific-first order while the ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after methods"})})," are run in least-specific-first order. The design rationale for this difference can be illustrated with an example. Suppose class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," modifies the behavior of its superclass, ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"}),", by adding ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before methods"})})," and ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after methods"})}),". Whether the behavior of the class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," is defined directly by methods on ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," or is inherited from its superclasses does not affect the relative order of invocation of methods on instances of the class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"}),". Class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"}),"\u2019s ",(0,t.jsx)(r,{styled:!0,term:"before method",children:(0,t.jsx)("i",{children:"before method"})})," runs before all of class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"}),"\u2019s methods. Class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"}),"\u2019s ",(0,t.jsx)(r,{styled:!0,term:"after method",children:(0,t.jsx)("i",{children:"after method"})})," runs after all of class ",(0,t.jsx)(i.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"}),"\u2019s methods."]}),"\n",(0,t.jsxs)(i.p,{children:["By contrast, all ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})})," run before any other methods run. Thus a less specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," runs before a more specific primary method."]}),"\n",(0,t.jsxs)(i.p,{children:["If only primary methods are used and if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is not used, only the most specific method is invoked; that is, more specific methods shadow more general ones."]})]})}function D(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(L,{...e})}):L(e)}function P(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function W(e){const i={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||O("DictionaryLink",!0),r||O("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The macro ",(0,t.jsx)(n,{term:"define-method-combination",children:(0,t.jsx)("b",{children:"define-method-combination"})})," defines new forms of method combination. It provides a mechanism for customizing the production of the effective method. The default procedure for producing an effective method is described in Section 7.6.6.1 (Determining the Effective Method)."]}),"\n",(0,t.jsxs)(i.p,{children:["There are two forms of ",(0,t.jsx)(n,{term:"define-method-combination",children:(0,t.jsx)("b",{children:"define-method-combination"})}),". The short form is a simple facility while the long form is more powerful and more verbose. The long form resembles ",(0,t.jsx)(n,{term:"defmacro",children:(0,t.jsx)("b",{children:"defmacro"})})," in that the body is an expression that computes a Lisp form; it provides mechanisms for implementing arbitrary control structures within method combination and for arbitrary processing of method ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})}),"."]})]})}function N(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(W,{...e})}):W(e)}function O(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function B(e){const i={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:r}=i;return n||K("DictionaryLink",!0),r||K("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The object system provides a set of built-in method combination types. To specify that a generic function is to use one of these method combination types, the name of the method combination type is given as the argument to the ",":method-combination"," option to ",(0,t.jsx)(n,{term:"defgeneric",children:(0,t.jsx)("b",{children:"defgeneric"})})," or to the ",":method-combination"," option to any of the other operators that specify generic function options."]}),"\n",(0,t.jsx)(i.p,{children:"The names of the built-in method combination types are listed in Figure 7\u20132."}),"\n",(0,t.jsxs)(i.p,{children:["|",(0,t.jsx)(i.strong,{children:"+ append max nconc progn and list min or standard"}),"|"]}),"\n",(0,t.jsx)(i.p,{children:"| :- |"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Figure 7\u20132. Built-in Method Combination Types"})}),"\n",(0,t.jsxs)(i.p,{children:["The semantics of the ",(0,t.jsx)(i.strong,{children:"standard"})," built-in method combination type is described in Section 7.6.6.2 (Standard Method Combination). The other built-in method combination types are called simple built-in method combination types."]}),"\n",(0,t.jsxs)(i.p,{children:["The simple built-in method combination types act as though they were defined by the short form of ",(0,t.jsx)(n,{term:"define-method-combination",children:(0,t.jsx)("b",{children:"define-method-combination"})}),". They recognize two roles for ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})}),":"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," An ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," has the keyword symbol ",":around"," as its sole ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," . The meaning of ",":around"," ",(0,t.jsx)(r,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," is the same as in standard method combination. Use of the functions ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," and ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," is supported in ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A primary method has the name of the method combination type as its sole ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," . For example, the built-in method combination type and recognizes methods whose sole ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," is and; these are primary methods. Use of the functions ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," and ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," is not supported in ",(0,t.jsx)(r,{styled:!0,term:"primary method",children:(0,t.jsx)("i",{children:"primary methods"})}),"."]}),"\n",(0,t.jsx)(i.p,{children:"The semantics of the simple built-in method combination types is as follows:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If there are any ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})}),", the most specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," is called. It supplies the value or values of the ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Inside the body of an ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})}),", the function ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," can be used to call the ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})}),". The ",(0,t.jsx)(r,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," ",(0,t.jsx)(n,{term:"no-next-method",children:(0,t.jsx)("b",{children:"no-next-method"})})," is invoked if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is used and there is no applicable method to call. The ",(0,t.jsx)(r,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(n,{term:"next-method-p",children:(0,t.jsx)("b",{children:"next-method-p"})})," may be used to determine whether a ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})})," exists. When the ",(0,t.jsx)(r,{styled:!0,term:"next method",children:(0,t.jsx)("i",{children:"next method"})})," returns, the ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," can execute more code, perhaps based on the returned value or values."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If an ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," invokes ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})}),", the next most specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})})," is called, if one is applicable. If there are no ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})})," or if ",(0,t.jsx)(n,{term:"call-next-method",children:(0,t.jsx)("b",{children:"call-next-method"})})," is called by the least specific ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around method"})}),", a Lisp form derived from the name of the built-in method combination type and from the list of applicable primary methods is evaluated to produce the value of the generic function. Suppose the name of the method combination type is ",(0,t.jsx)(r,{term:"operator",children:(0,t.jsx)("i",{children:"operator"})})," and the call to the generic function is of the form"]}),"\n",(0,t.jsxs)(i.p,{children:["(",(0,t.jsx)("i",{children:"generic-function a"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"})]}),")"]}),"\n",(0,t.jsxs)(i.p,{children:["Let ",(0,t.jsx)("i",{children:"M"}),(0,t.jsx)("sub",{children:"1"}),(0,t.jsxs)("i",{children:[", . . . , M",(0,t.jsx)("sub",{children:"k"})]})," be the applicable primary methods in order; then the derived Lisp form is (",(0,t.jsx)("i",{children:"operator hM"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsx)("i",{children:"a"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"}),"i. . .hM",(0,t.jsx)("sub",{children:"k"})," a"]}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"}),"i"]}),")"]}),"\n",(0,t.jsxs)(i.p,{children:["If the expression ",(0,t.jsxs)("i",{children:["hM",(0,t.jsx)("sub",{children:"i"})," a"]}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"}),"i"]})," is evaluated, the method ",(0,t.jsxs)("i",{children:["M",(0,t.jsx)("sub",{children:"i"})]})," will be applied to the arguments ",(0,t.jsx)("i",{children:"a"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"})]}),". For example, if ",(0,t.jsx)("i",{children:"operator"})," is or, the expression ",(0,t.jsxs)("i",{children:["hM",(0,t.jsx)("sub",{children:"i"})," a"]}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"}),"i"]})," is evaluated only if ",(0,t.jsxs)("i",{children:["hM",(0,t.jsx)("sub",{children:"j"})," a"]}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . a",(0,t.jsx)("sub",{children:"n"}),"i"]}),", 1 ",(0,t.jsx)("i",{children:"\u2264 j"})," < ",(0,t.jsx)("i",{children:"i"}),", returned nil."]}),"\n",(0,t.jsxs)(i.p,{children:["The default order for the primary methods is ",":most-specific-first",". However, the order can be reversed by supplying ",":most-specific-last"," as the second argument to the ",":method-combination"," option."]}),"\n",(0,t.jsxs)(i.p,{children:["The simple built-in method combination types require exactly one ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifier"})})," per method. An error is signaled if there are applicable methods with no ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," or with ",(0,t.jsx)(r,{term:"qualifier",children:(0,t.jsx)("i",{children:"qualifiers"})})," that are not supported by the method combination type. An error is signaled if there are applicable ",(0,t.jsx)(r,{styled:!0,term:"around method",children:(0,t.jsx)("i",{children:"around methods"})})," and no applicable primary methods."]})]})}function Q(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(B,{...e})}):B(e)}function K(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function U(e){const i={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"A subclass inherits methods in the sense that any method applicable to all instances of a class is also applicable to all instances of any subclass of that class."}),"\n",(0,t.jsxs)(i.p,{children:["The inheritance of methods acts the same way regardless of which of the ",(0,t.jsx)(n,{styled:!0,term:"method-defining operator",children:(0,t.jsx)("i",{children:"method-defining operators"})})," created the methods."]}),"\n",(0,t.jsx)(i.p,{children:"The inheritance of methods is described in detail in Section 7.6.6 (Method Selection and Combination)."})]})}function _(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(U,{...e})}):U(e)}const H={title:"7.6 Generic Functions and Methods"},J="7.6 Generic Functions and Methods",V={},X=[{value:"7.6.1 Introduction to Generic Functions",id:"761-introduction-to-generic-functions",level:2},{value:"7.6.2 Introduction to Methods",id:"762-introduction-to-methods",level:2},{value:"7.6.3 Agreement on Parameter Specializers and Qualifiers",id:"763-agreement-on-parameter-specializers-and-qualifiers",level:2},{value:"7.6.4 Congruent Lambda",id:"764-congruent-lambda",level:2},{value:"7.6.5 Keyword Arguments in Generic Functions and Methods",id:"765-keyword-arguments-in-generic-functions-and-methods",level:2},{value:"7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods",id:"7651-examples-of-keyword-arguments-in-generic-functions-and-methods",level:3},{value:"7.6.6 Method Selection and Combination",id:"766-method-selection-and-combination",level:2},{value:"7.6.6.1 Determining the Effective Method",id:"7661-determining-the-effective-method",level:3},{value:"7.6.6.1.1 Selecting the Applicable Methods",id:"76611-selecting-the-applicable-methods",level:4},{value:"7.6.6.1.2 Sorting the Applicable Methods by Precedence Order",id:"76612-sorting-the-applicable-methods-by-precedence-order",level:4},{value:"7.6.6.1.3 Applying method combination to the sorted list of applicable methods",id:"76613-applying-method-combination-to-the-sorted-list-of-applicable-methods",level:4},{value:"7.6.6.2 Standard Method Combination",id:"7662-standard-method-combination",level:3},{value:"7.6.6.3 Declarative Method Combination",id:"7663-declarative-method-combination",level:3},{value:"7.6.6.4 Built",id:"7664-built",level:3},{value:"7.6.7 Inheritance of Methods",id:"767-inheritance-of-methods",level:2}];function Y(e){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"76-generic-functions-and-methods",children:"7.6 Generic Functions and Methods"})}),"\n","\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(i.h2,{id:"761-introduction-to-generic-functions",children:"7.6.1 Introduction to Generic Functions"}),"\n","\n",(0,t.jsx)(l,{}),"\n",(0,t.jsx)(i.h2,{id:"762-introduction-to-methods",children:"7.6.2 Introduction to Methods"}),"\n","\n",(0,t.jsx)(m,{}),"\n",(0,t.jsx)(i.h2,{id:"763-agreement-on-parameter-specializers-and-qualifiers",children:"7.6.3 Agreement on Parameter Specializers and Qualifiers"}),"\n","\n",(0,t.jsx)(p,{}),"\n",(0,t.jsx)(i.h2,{id:"764-congruent-lambda",children:"7.6.4 Congruent Lambda"}),"\n","\n",(0,t.jsx)(b,{}),"\n",(0,t.jsx)(i.h2,{id:"765-keyword-arguments-in-generic-functions-and-methods",children:"7.6.5 Keyword Arguments in Generic Functions and Methods"}),"\n","\n",(0,t.jsx)(g,{}),"\n",(0,t.jsx)(i.h3,{id:"7651-examples-of-keyword-arguments-in-generic-functions-and-methods",children:"7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods"}),"\n","\n",(0,t.jsx)(v,{}),"\n",(0,t.jsx)(i.h2,{id:"766-method-selection-and-combination",children:"7.6.6 Method Selection and Combination"}),"\n","\n",(0,t.jsx)(q,{}),"\n",(0,t.jsx)(i.h3,{id:"7661-determining-the-effective-method",children:"7.6.6.1 Determining the Effective Method"}),"\n","\n",(0,t.jsx)(A,{}),"\n",(0,t.jsx)(i.h4,{id:"76611-selecting-the-applicable-methods",children:"7.6.6.1.1 Selecting the Applicable Methods"}),"\n","\n",(0,t.jsx)(M,{}),"\n",(0,t.jsx)(i.h4,{id:"76612-sorting-the-applicable-methods-by-precedence-order",children:"7.6.6.1.2 Sorting the Applicable Methods by Precedence Order"}),"\n","\n",(0,t.jsx)(G,{}),"\n",(0,t.jsx)(i.h4,{id:"76613-applying-method-combination-to-the-sorted-list-of-applicable-methods",children:"7.6.6.1.3 Applying method combination to the sorted list of applicable methods"}),"\n","\n",(0,t.jsx)(R,{}),"\n",(0,t.jsx)(i.h3,{id:"7662-standard-method-combination",children:"7.6.6.2 Standard Method Combination"}),"\n","\n",(0,t.jsx)(D,{}),"\n",(0,t.jsx)(i.h3,{id:"7663-declarative-method-combination",children:"7.6.6.3 Declarative Method Combination"}),"\n","\n",(0,t.jsx)(N,{}),"\n",(0,t.jsx)(i.h3,{id:"7664-built",children:"7.6.6.4 Built"}),"\n","\n",(0,t.jsx)(Q,{}),"\n",(0,t.jsx)(i.h2,{id:"767-inheritance-of-methods",children:"7.6.7 Inheritance of Methods"}),"\n","\n",(0,t.jsx)(_,{})]})}function Z(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(Y,{...e})}):Y(e)}}}]);