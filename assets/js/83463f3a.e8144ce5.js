"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[35002],{973:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=n(85893),o=n(11151);const a={},s="Initialization of Generic Function Metaobjects",r={id:"meta-object-protocol/initialization-of-generic-function-metaobjects",title:"Initialization of Generic Function Metaobjects",description:"Initialization of Generic Function Metaobjects",source:"@site/docs/meta-object-protocol/initialization-of-generic-function-metaobjects.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/initialization-of-generic-function-metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-generic-function-metaobjects",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/initialization-of-generic-function-metaobjects.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Initialization of generic function and method metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-generic-function-and-method-metaobjects"},next:{title:"Initialization of Method Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-method-metaobjects"}},c={},l=[{value:"Initialization of Generic Function Metaobjects",id:"initialization-of-generic-function-metaobjects-1",level:3},{value:"Methods",id:"methods",level:2}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"initialization-of-generic-function-metaobjects",children:"Initialization of Generic Function Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"initialization-of-generic-function-metaobjects-1",children:"Initialization of Generic Function Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["A generic function metaobject can be created by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the generic function. A generic function metaobject can be redefined by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Some classes of generic function metaobject do not support redefinition; in these cases, ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization of a generic function metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Reinitialization of a generic-function metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a generic function metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize or reinitialize a generic function metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any generic function metaobject or to turn a non-generic-function object into a generic function metaobject."]}),"\n",(0,t.jsxs)(i.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on generic function metaobjects. Since the class of a generic function metaobject may not be changed, no behavior is specified for the results of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on generic function metaobjects."]}),"\n",(0,t.jsxs)(i.p,{children:["During initialization or reinitialization, each initialization argument is checked for errors and then associated with the generic function metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below. (FIXME",":insert"," anchor)."]}),"\n",(0,t.jsx)(i.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. The section ends with a set of restrictions on portable methods affecting generic function metaobject initialization and reinitialization."}),"\n",(0,t.jsxs)(i.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,t.jsx)(i.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,t.jsx)(i.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified generic function metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-generic-function",children:"generic-function"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Unless there is a specific note to the contrary, then during reinitialization, if an initialization argument is not supplied, the previously stored value is left unchanged."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":argument-precedence-order"})," argument is a list of symbols."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this argument appears but the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument does not appear. An error is signaled if this value is not a proper list or if this value is not a permutation of the symbols from the required arguments part of the ",(0,t.jsx)(i.code,{children:":lambda-list"})," initialization argument."]}),"\n",(0,t.jsxs)(i.p,{children:["When the generic function is being initialized or reinitialized, and this argument is not supplied, but the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument is supplied, this value defaults to the symbols from the required arguments part of the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument, in the order they appear in that argument. If neither argument is supplied, neither are initialized (see the description of ",(0,t.jsx)(i.code,{children:":lambda-list"}),".)"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":declarations"})," argument is a list of declarations."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper list or if each of its elements is not a legal declaration."}),"\n",(0,t.jsx)(i.p,{children:"When the generic function is being initialized, and this argument is not supplied, it defaults to the empty list."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":documentation"})," argument is a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If the generic function is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument is a lambda list."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper generic function lambda list."}),"\n",(0,t.jsx)(i.p,{children:"When the generic function is being initialized, and this argument is not supplied, the generic function's lambda list is not initialized. The lambda list will be initialized later, either when the first method is added to the generic function, or a later reinitialization of the generic function."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":method-combination"})," argument is a method combination metaobject. (But see the note at the end of this page. [RS])"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":method-class"})," argument is a class metaobject. (But see the note at the end of this page. [RS])"]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a subclass of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-generic-function",children:"method"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["When the generic function is being initialized, and this argument is not supplied, it defaults to the class ",(0,t.jsx)(i.a,{href:"/cl-language-reference/meta-object-protocol/class-standard-method",children:"standard-method"}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":name"})," argument is an object."]}),"\n",(0,t.jsxs)(i.p,{children:["If the generic function is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the generic function metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,t.jsx)(i.p,{children:"Initialization Argument        Generic Function"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:":argument-precedence-order"}),"   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-argument-precedence-order",children:"generic-function-argument-precedence-order"}),"\n",(0,t.jsx)(i.code,{children:":declarations"}),"                ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-declarations",children:"generic-function-declarations"}),"\n",(0,t.jsx)(i.code,{children:":documentation"}),"               ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"}),"\n",(0,t.jsx)(i.code,{children:":lambda-list"}),"                 ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-lambda-list",children:"generic-function-lambda-list"}),"\n",(0,t.jsx)(i.code,{children:":method-combination"}),"          ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-combination",children:"generic-function-method-combination"}),"\n",(0,t.jsx)(i.code,{children:":method-class"}),"                ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-class",children:"generic-function-method-class"}),"\n",(0,t.jsx)(i.code,{children:":name"}),"                        ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-name",children:"generic-function-name"})]}),"\n",(0,t.jsx)(i.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"It is not specified which methods provide the initialization and reinitialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the generic function metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,t.jsxs)(i.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),", ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,t.jsx)(i.a,{href:"/cl-language-reference/meta-object-protocol/class-generic-function",children:"generic-function"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Portable programs must not define methods on ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["For ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Portable programs must not define primary methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n",(0,t.jsx)(i.li,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The results are undefined if any of these restrictions are violated."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Note:"})}),"\n",(0,t.jsxs)(i.p,{children:["Nowhere in the chain of functions that initialize generic-function metaobjects is any defaulting behavior for method-combination metaobjects defined. One possible solution to this dilemma is to implement that defaulting behavior here, so that if the ",(0,t.jsx)(i.code,{children:":method-combination"})," keyword argument is not supplied, then it defaults to the ",(0,t.jsx)(i.code,{children:"standard"})," method combination. [RS]"]})]})}function h(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>r,a:()=>s});var t=n(67294);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);