"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[7383],{331:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>W,contentTitle:()=>P,default:()=>K,frontMatter:()=>M,metadata:()=>O,toc:()=>U});var i=n(5893),r=n(1151);function t(e){const s={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3 Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["While the object system is general enough to describe all ",(0,i.jsx)(s.em,{children:"standardized classes"})," (including, for example, ",(0,i.jsx)(s.strong,{children:"number"}),", ",(0,i.jsx)(s.strong,{children:"hash-table"}),", and ",(0,i.jsx)(s.strong,{children:"symbol"}),"), Figure 4\u20137 contains a list of ",(0,i.jsx)(s.em,{children:"classes"})," that are especially relevant to understanding the object system."]}),"\n",(0,i.jsx)(s.table,{children:(0,i.jsx)(s.thead,{children:(0,i.jsx)(s.tr,{children:(0,i.jsx)(s.th,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"built-in-class method-combination standard-object class standard-class structure-class generic-function standard-generic-function structure-object method standard-method"})})})})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Figure 4\u20137. Object System Classes"})})]})}function c(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}function l(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.1 Introduction to Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," is an ",(0,i.jsx)(s.em,{children:"object"})," that determines the structure and behavior of a set of other ",(0,i.jsx)(s.em,{children:"objects"}),", which are called its ",(0,i.jsx)(s.em,{children:"instances"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," can inherit structure and behavior from other ",(0,i.jsx)(s.em,{children:"classes"}),". A ",(0,i.jsx)(s.em,{children:"class"})," whose definition refers to other ",(0,i.jsx)(s.em,{children:"classes"})," for the purpose of inheriting from them is said to be a ",(0,i.jsx)(s.em,{children:"subclass"})," of each of those ",(0,i.jsx)(s.em,{children:"classes"}),". The ",(0,i.jsx)(s.em,{children:"classes"})," that are designated for purposes of inheritance are said to be ",(0,i.jsx)(s.em,{children:"superclasses"})," of the inheriting ",(0,i.jsx)(s.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," can have a ",(0,i.jsx)(s.em,{children:"name"}),". The ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"class-name"})," takes a ",(0,i.jsx)(s.em,{children:"class object"})," and returns its ",(0,i.jsx)(s.em,{children:"name"}),". The ",(0,i.jsx)(s.em,{children:"name"})," of an anonymous ",(0,i.jsx)(s.em,{children:"class"})," is ",(0,i.jsx)(s.strong,{children:"nil"}),". A ",(0,i.jsx)(s.em,{children:"symbol"})," can ",(0,i.jsx)(s.em,{children:"name"})," a ",(0,i.jsx)(s.em,{children:"class"}),". The ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"find-class"})," takes a ",(0,i.jsx)(s.em,{children:"symbol"})," and returns the ",(0,i.jsx)(s.em,{children:"class"})," that the ",(0,i.jsx)(s.em,{children:"symbol"})," names. A ",(0,i.jsx)(s.em,{children:"class"})," has a ",(0,i.jsx)(s.em,{children:"proper name"})," if the ",(0,i.jsx)(s.em,{children:"name"})," is a ",(0,i.jsx)(s.em,{children:"symbol"})," and if the ",(0,i.jsx)(s.em,{children:"name"})," of the ",(0,i.jsx)(s.em,{children:"class"})," names that ",(0,i.jsx)(s.em,{children:"class"}),". That is, a ",(0,i.jsx)(s.em,{children:"class C"})," has the ",(0,i.jsx)(s.em,{children:"proper name S"})," if ",(0,i.jsx)(s.em,{children:"S"})," = (class-name ",(0,i.jsx)(s.em,{children:"C"}),") and ",(0,i.jsx)(s.em,{children:"C"})," = (find-class ",(0,i.jsx)(s.em,{children:"S"}),"). Notice that it is possible for (find-class ",(0,i.jsx)(s.em,{children:"S"}),"<sub>1</sub>) = (find-class ",(0,i.jsx)(s.em,{children:"S"}),"<sub>2</sub>) and ",(0,i.jsx)(s.em,{children:"S"}),"<sub>1</sub> ",(0,i.jsx)(s.em,{children:"6"}),"= ",(0,i.jsx)(s.em,{children:"S"}),"<sub>2</sub>. If ",(0,i.jsx)(s.em,{children:"C"})," = (find-class ",(0,i.jsx)(s.em,{children:"S"}),"), we say that ",(0,i.jsx)(s.em,{children:"C"})," is the ",(0,i.jsx)(s.em,{children:"class named S"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"A <i>class C</i><sub>1</sub> is a <i>direct superclass</i> of a <i>class C</i><sub>2</sub> if <i>C</i><sub>2</sub> explicitly designates <i>C</i><sub>1</sub> as a <i>superclass</i> in its definition. In this case <i>C</i><sub>2</sub> is a <i>direct subclass</i> of <i>C</i><sub>1</sub>. A <i>class C<sub>n</sub></i> is a <i>superclass</i> of a <i>class C</i><sub>1</sub> if there exists a series of <i>classes C</i><sub>2</sub><i>, . . . , C<sub>n\u2212</sub></i>1</sub> such that <i>C<sub>i</sub></i>+1</sub> is a <i>direct superclass</i> of <i>C<sub>i</sub></i> for 1 <i>\u2264 i</i> < <i>n</i>. In this case, <i>C</i><sub>1</sub> is a <i>subclass</i> of <i>C<sub>n</sub></i>. A <i>class</i> is considered neither a <i>superclass</i> nor a <i>subclass</i> of"}),"\n",(0,i.jsxs)(s.p,{children:["itself. That is, if ",(0,i.jsx)(s.em,{children:"C"}),"<sub>1</sub> is a ",(0,i.jsx)(s.em,{children:"superclass"})," of ",(0,i.jsx)(s.em,{children:"C"}),"<sub>2</sub>, then ",(0,i.jsx)(s.em,{children:"C"}),"<sub>1</sub> ",(0,i.jsx)(s.em,{children:"6"}),"= ",(0,i.jsx)(s.em,{children:"C"}),"<sub>2</sub>. The set of ",(0,i.jsx)(s.em,{children:"classes"})," consisting of some given ",(0,i.jsx)(s.em,{children:"class C"})," along with all of its ",(0,i.jsx)(s.em,{children:"superclasses"})," is called \u201c",(0,i.jsx)(s.em,{children:"C"})," and its superclasses.\u201d"]}),"\n",(0,i.jsxs)(s.p,{children:["Each ",(0,i.jsx)(s.em,{children:"class"})," has a ",(0,i.jsx)(s.em,{children:"class precedence list"}),", which is a total ordering on the set of the given ",(0,i.jsx)(s.em,{children:"class"})," and its ",(0,i.jsx)(s.em,{children:"superclasses"}),". The total ordering is expressed as a list ordered from most specific to least specific. The ",(0,i.jsx)(s.em,{children:"class precedence list"})," is used in several ways. In general, more specific ",(0,i.jsx)(s.em,{children:"classes"})," can ",(0,i.jsx)(s.em,{children:"shadow"}),"<sub>1</sub> features that would otherwise be inherited from less specific ",(0,i.jsx)(s.em,{children:"classes"}),". The ",(0,i.jsx)(s.em,{children:"method"})," selection and combination process uses the ",(0,i.jsx)(s.em,{children:"class precedence list"})," to order ",(0,i.jsx)(s.em,{children:"methods"})," from most specific to least specific."]}),"\n",(0,i.jsxs)(s.p,{children:["When a ",(0,i.jsx)(s.em,{children:"class"})," is defined, the order in which its direct ",(0,i.jsx)(s.em,{children:"superclasses"})," are mentioned in the defining"]}),"\n",(0,i.jsxs)(s.p,{children:["form is important. Each ",(0,i.jsx)(s.em,{children:"class"})," has a ",(0,i.jsx)(s.em,{children:"local precedence order"}),", which is a ",(0,i.jsx)(s.em,{children:"list"})," consisting of the ",(0,i.jsx)(s.em,{children:"class"})," followed by its ",(0,i.jsx)(s.em,{children:"direct superclasses"})," in the order mentioned in the defining ",(0,i.jsx)(s.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class precedence list"})," is always consistent with the ",(0,i.jsx)(s.em,{children:"local precedence order"})," of each ",(0,i.jsx)(s.em,{children:"class"})," in the list. The ",(0,i.jsx)(s.em,{children:"classes"})," in each ",(0,i.jsx)(s.em,{children:"local precedence order"})," appear within the ",(0,i.jsx)(s.em,{children:"class precedence list"})," in the same order. If the ",(0,i.jsx)(s.em,{children:"local precedence orders"})," are inconsistent with each other, no ",(0,i.jsx)(s.em,{children:"class precedence list"})," can be constructed, and an error is signaled. The ",(0,i.jsx)(s.em,{children:"class precedence list"})," and its computation is discussed in Section 4.3.5 (Determining the Class Precedence List)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"classes"})," are organized into a directed acyclic graph. There are two distinguished ",(0,i.jsx)(s.em,{children:"classes"}),", named ",(0,i.jsx)(s.strong,{children:"t"})," and ",(0,i.jsx)(s.strong,{children:"standard-object"}),". The ",(0,i.jsx)(s.em,{children:"class"})," named ",(0,i.jsx)(s.strong,{children:"t"})," has no ",(0,i.jsx)(s.em,{children:"superclasses"}),". It is a ",(0,i.jsx)(s.em,{children:"superclass"})," of every ",(0,i.jsx)(s.em,{children:"class"})," except itself. The ",(0,i.jsx)(s.em,{children:"class"})," named ",(0,i.jsx)(s.strong,{children:"standard-object"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"})," and is a ",(0,i.jsx)(s.em,{children:"superclass"})," of every ",(0,i.jsx)(s.em,{children:"class"})," that is an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"})," except itself."]}),"\n",(0,i.jsxs)(s.p,{children:["There is a mapping from the object system ",(0,i.jsx)(s.em,{children:"class"})," space into the ",(0,i.jsx)(s.em,{children:"type"})," space. Many of the standard ",(0,i.jsx)(s.em,{children:"types"})," specified in this document have a corresponding ",(0,i.jsx)(s.em,{children:"class"})," that has the same ",(0,i.jsx)(s.em,{children:"name"})," as the ",(0,i.jsx)(s.em,{children:"type"}),". Some ",(0,i.jsx)(s.em,{children:"types"})," do not have a corresponding ",(0,i.jsx)(s.em,{children:"class"}),". The integration of the ",(0,i.jsx)(s.em,{children:"type"})," and ",(0,i.jsx)(s.em,{children:"class"})," systems is discussed in Section 4.3.7 (Integrating Types and Classes)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Classes"})," are represented by ",(0,i.jsx)(s.em,{children:"objects"})," that are themselves ",(0,i.jsx)(s.em,{children:"instances"})," of ",(0,i.jsx)(s.em,{children:"classes"}),". The ",(0,i.jsx)(s.em,{children:"class"})," of the ",(0,i.jsx)(s.em,{children:"class"})," of an ",(0,i.jsx)(s.em,{children:"object"})," is termed the ",(0,i.jsx)(s.em,{children:"metaclass"})," of that ",(0,i.jsx)(s.em,{children:"object"}),". When no misinterpretation is possible, the term ",(0,i.jsx)(s.em,{children:"metaclass"})," is used to refer to a ",(0,i.jsx)(s.em,{children:"class"})," that has ",(0,i.jsx)(s.em,{children:"instances"})," that are themselves ",(0,i.jsx)(s.em,{children:"classes"}),". The ",(0,i.jsx)(s.em,{children:"metaclass"})," determines the form of inheritance used by the ",(0,i.jsx)(s.em,{children:"classes"})," that are its ",(0,i.jsx)(s.em,{children:"instances"})," and the representation of the ",(0,i.jsx)(s.em,{children:"instances"})," of those ",(0,i.jsx)(s.em,{children:"classes"}),". The object system provides a default ",(0,i.jsx)(s.em,{children:"metaclass"}),", ",(0,i.jsx)(s.strong,{children:"standard-class"}),", that is appropriate for most programs."]}),"\n",(0,i.jsxs)(s.p,{children:["Except where otherwise specified, all ",(0,i.jsx)(s.em,{children:"classes"})," mentioned in this standard are ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"}),", all ",(0,i.jsx)(s.em,{children:"generic functions"})," are ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-generic-function"}),", and all ",(0,i.jsx)(s.em,{children:"methods"})," are ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-method"}),"."]})]})}function d(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}function h(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.1.1 Standard Metaclasses"})}),"\n",(0,i.jsxs)(s.p,{children:["The object system provides a number of predefined ",(0,i.jsx)(s.em,{children:"metaclasses"}),". These include the ",(0,i.jsx)(s.em,{children:"classes"})," ",(0,i.jsx)(s.strong,{children:"standard-class"}),", ",(0,i.jsx)(s.strong,{children:"built-in-class"}),", and ",(0,i.jsx)(s.strong,{children:"structure-class"}),":"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"})," is the default ",(0,i.jsx)(s.em,{children:"class"})," of ",(0,i.jsx)(s.em,{children:"classes"})," defined by ",(0,i.jsx)(s.strong,{children:"defclass"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"built-in-class"})," is the ",(0,i.jsx)(s.em,{children:"class"})," whose ",(0,i.jsx)(s.em,{children:"instances"})," are ",(0,i.jsx)(s.em,{children:"classes"})," that have special implementations with restricted capabilities. Any ",(0,i.jsx)(s.em,{children:"class"})," that corresponds to a standard ",(0,i.jsx)(s.em,{children:"type"})," might be an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"built-in-class"}),". The predefined ",(0,i.jsx)(s.em,{children:"type"})," specifiers that are required to have corresponding ",(0,i.jsx)(s.em,{children:"classes"})," are listed in Figure 4\u20138. It is ",(0,i.jsx)(s.em,{children:"implementation-dependent"})," whether each of these ",(0,i.jsx)(s.em,{children:"classes"})," is implemented as a ",(0,i.jsx)(s.em,{children:"built-in class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," All ",(0,i.jsx)(s.em,{children:"classes"})," defined by means of ",(0,i.jsx)(s.strong,{children:"defstruct"})," are ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"structure-class"}),"."]})]})}function a(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function o(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.2 Defining Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["The macro ",(0,i.jsx)(s.strong,{children:"defclass"})," is used to define a new named ",(0,i.jsx)(s.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The definition of a ",(0,i.jsx)(s.em,{children:"class"})," includes:"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," The ",(0,i.jsx)(s.em,{children:"name"})," of the new ",(0,i.jsx)(s.em,{children:"class"}),". For newly-defined ",(0,i.jsx)(s.em,{children:"classes"})," this ",(0,i.jsx)(s.em,{children:"name"})," is a ",(0,i.jsx)(s.em,{children:"proper name"}),". ",(0,i.jsx)(s.em,{children:"\u2022"})," The list of the direct ",(0,i.jsx)(s.em,{children:"superclasses"})," of the new ",(0,i.jsx)(s.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," A set of ",(0,i.jsx)(s.em,{children:"slot specifiers"}),". Each ",(0,i.jsx)(s.em,{children:"slot specifier"})," includes the ",(0,i.jsx)(s.em,{children:"name"})," of the ",(0,i.jsx)(s.em,{children:"slot"})," and zero or more ",(0,i.jsx)(s.em,{children:"slot"})," options. A ",(0,i.jsx)(s.em,{children:"slot"})," option pertains only to a single ",(0,i.jsx)(s.em,{children:"slot"}),". If a ",(0,i.jsx)(s.em,{children:"class"})," definition contains two ",(0,i.jsx)(s.em,{children:"slot specifiers"})," with the same ",(0,i.jsx)(s.em,{children:"name"}),", an error is signaled."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," A set of ",(0,i.jsx)(s.em,{children:"class"})," options. Each ",(0,i.jsx)(s.em,{children:"class"})," option pertains to the ",(0,i.jsx)(s.em,{children:"class"})," as a whole."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"slot"})," options and ",(0,i.jsx)(s.em,{children:"class"})," options of the ",(0,i.jsx)(s.strong,{children:"defclass"})," form provide mechanisms for the following: ",(0,i.jsx)(s.em,{children:"\u2022"})," Supplying a default initial value ",(0,i.jsx)(s.em,{children:"form"})," for a given ",(0,i.jsx)(s.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Requesting that ",(0,i.jsx)(s.em,{children:"methods"})," for ",(0,i.jsx)(s.em,{children:"generic functions"})," be automatically generated for reading or writing ",(0,i.jsx)(s.em,{children:"slots"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Controlling whether a given ",(0,i.jsx)(s.em,{children:"slot"})," is shared by all ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," or whether each ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," has its own ",(0,i.jsx)(s.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Supplying a set of initialization arguments and initialization argument defaults to be used in ",(0,i.jsx)(s.em,{children:"instance"})," creation."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Indicating that the ",(0,i.jsx)(s.em,{children:"metaclass"})," is to be other than the default. The ",":metaclass"," option is reserved for future use; an implementation can be extended to make use of the ",":metaclass"," option."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Indicating the expected ",(0,i.jsx)(s.em,{children:"type"})," for the value stored in the ",(0,i.jsx)(s.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Indicating the ",(0,i.jsx)(s.em,{children:"documentation string"})," for the ",(0,i.jsx)(s.em,{children:"slot"}),"."]})]})}function x(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}function j(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.3 Creating Instances of Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["The generic function ",(0,i.jsx)(s.strong,{children:"make-instance"})," creates and returns a new ",(0,i.jsx)(s.em,{children:"instance"})," of a ",(0,i.jsx)(s.em,{children:"class"}),". The object system provides several mechanisms for specifying how a new ",(0,i.jsx)(s.em,{children:"instance"})," is to be initialized. For example, it is possible to specify the initial values for ",(0,i.jsx)(s.em,{children:"slots"})," in newly created ",(0,i.jsx)(s.em,{children:"instances"})," either by giving arguments to ",(0,i.jsx)(s.strong,{children:"make-instance"})," or by providing default initial values. Further initialization"]}),"\n",(0,i.jsxs)(s.p,{children:["activities can be performed by ",(0,i.jsx)(s.em,{children:"methods"})," written for ",(0,i.jsx)(s.em,{children:"generic functions"})," that are part of the initialization protocol. The complete initialization protocol is described in Section 7.1 (Object Creation and Initialization)."]})]})}function p(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(j,{...e})}):j(e)}function m(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.4 Inheritance"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," can inherit ",(0,i.jsx)(s.em,{children:"methods"}),", ",(0,i.jsx)(s.em,{children:"slots"}),", and some ",(0,i.jsx)(s.strong,{children:"defclass"})," options from its ",(0,i.jsx)(s.em,{children:"superclasses"}),". Other sections describe the inheritance of ",(0,i.jsx)(s.em,{children:"methods"}),", the inheritance of ",(0,i.jsx)(s.em,{children:"slots"})," and ",(0,i.jsx)(s.em,{children:"slot"})," options, and the inheritance of ",(0,i.jsx)(s.em,{children:"class"})," options."]})]})}function f(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}function u(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.4.1 Examples of Inheritance"})}),"\n",(0,i.jsx)(s.p,{children:"(defclass C1 ()"}),"\n",(0,i.jsxs)(s.p,{children:["((S1 ",":initform"," 5.4 ",":type"," number)"]}),"\n",(0,i.jsxs)(s.p,{children:["(S2 ",":allocation"," ",":class",")))"]}),"\n",(0,i.jsx)(s.p,{children:"(defclass C2 (C1)"}),"\n",(0,i.jsxs)(s.p,{children:["((S1 ",":initform"," 5 ",":type"," integer)"]}),"\n",(0,i.jsxs)(s.p,{children:["(S2 ",":allocation"," ",":instance",")"]}),"\n",(0,i.jsxs)(s.p,{children:["(S3 ",":accessor"," C2-S3)))"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Instances"})," of the class C1 have a ",(0,i.jsx)(s.em,{children:"local slot"})," named S1, whose default initial value is 5.4 and whose ",(0,i.jsx)(s.em,{children:"value"})," should always be a ",(0,i.jsx)(s.em,{children:"number"})," . The class C1 also has a ",(0,i.jsx)(s.em,{children:"shared slot"})," named S2."]}),"\n",(0,i.jsxs)(s.p,{children:["There is a ",(0,i.jsx)(s.em,{children:"local slot"})," named S1 in ",(0,i.jsx)(s.em,{children:"instances"})," of C2. The default initial value of S1 is 5. The value of S1 should always be of type (and integer number). There are also ",(0,i.jsx)(s.em,{children:"local slots"})," named S2 and S3 in ",(0,i.jsx)(s.em,{children:"instances"})," of C2. The class C2 has a ",(0,i.jsx)(s.em,{children:"method"})," for C2-S3 for reading the value of slot S3; there is also a ",(0,i.jsx)(s.em,{children:"method"})," for (setf C2-S3) that writes the value of S3."]})]})}function g(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}function y(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.4.2 Inheritance of Class Options"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",":default-initargs"," class option is inherited. The set of defaulted initialization arguments for a ",(0,i.jsx)(s.em,{children:"class"})," is the union of the sets of initialization arguments supplied in the ",":default-initargs"," class options of the ",(0,i.jsx)(s.em,{children:"class"})," and its ",(0,i.jsx)(s.em,{children:"superclasses"}),". When more than one default initial value ",(0,i.jsx)(s.em,{children:"form"})," is supplied"]}),"\n",(0,i.jsxs)(s.p,{children:["for a given initialization argument, the default initial value ",(0,i.jsx)(s.em,{children:"form"})," that is used is the one supplied by the ",(0,i.jsx)(s.em,{children:"class"})," that is most specific according to the ",(0,i.jsx)(s.em,{children:"class precedence list"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If a given ",":default-initargs"," class option specifies an initialization argument of the same ",(0,i.jsx)(s.em,{children:"name"})," more than once, an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"program-error"})," is signaled."]})]})}function b(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(y,{...e})}):y(e)}function v(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.5 Determining the Class Precedence List"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.strong,{children:"defclass"})," form for a ",(0,i.jsx)(s.em,{children:"class"})," provides a total ordering on that ",(0,i.jsx)(s.em,{children:"class"})," and its direct ",(0,i.jsx)(s.em,{children:"superclasses"}),". This ordering is called the ",(0,i.jsx)(s.em,{children:"local precedence order"}),". It is an ordered list of the ",(0,i.jsx)(s.em,{children:"class"})," and its direct ",(0,i.jsx)(s.em,{children:"superclasses"}),". The ",(0,i.jsx)(s.em,{children:"class precedence list"})," for a class ",(0,i.jsx)(s.em,{children:"C"})," is a total ordering on ",(0,i.jsx)(s.em,{children:"C"})," and its ",(0,i.jsx)(s.em,{children:"superclasses"})," that is consistent with the ",(0,i.jsx)(s.em,{children:"local precedence orders"})," for each of ",(0,i.jsx)(s.em,{children:"C"})," and its ",(0,i.jsx)(s.em,{children:"superclasses"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," precedes its direct ",(0,i.jsx)(s.em,{children:"superclasses"}),", and a direct ",(0,i.jsx)(s.em,{children:"superclass"})," precedes all other direct ",(0,i.jsx)(s.em,{children:"superclasses"})," specified to its right in the ",(0,i.jsx)(s.em,{children:"superclasses"})," list of the ",(0,i.jsx)(s.strong,{children:"defclass"})," form. For every class ",(0,i.jsx)(s.em,{children:"C"}),", define"]}),"\n",(0,i.jsx)(s.p,{children:"<i>R<sub>C</sub></i> = <i>{</i>(<i>C, C</i><sub>1</sub>)<i>,</i>(<i>C</i><sub>1</sub><i>, C</i><sub>2</sub>)<i>, . . . ,</i>(<i>C<sub>n\u2212</sub></i>1</sub><i>, C<sub>n</sub></i>)<i>}</i>"}),"\n",(0,i.jsx)(s.p,{children:"where <i>C</i><sub>1</sub><i>, . . . , C<sub>n</sub></i> are the direct <i>superclasses</i> of <i>C</i> in the order in which they are mentioned in the <b>defclass</b> form. These ordered pairs generate the total ordering on the class <i>C</i> and its direct <i>superclasses</i>."}),"\n",(0,i.jsx)(s.p,{children:"Let <i>S<sub>C</sub></i> be the set of <i>C</i> and its <i>superclasses</i>. Let <i>R</i> be"}),"\n",(0,i.jsx)(s.p,{children:"<i>R<sub>c</sub></i>"}),"\n",(0,i.jsx)(s.p,{children:"."}),"\n",(0,i.jsx)(s.p,{children:"<sub><i>R</i> =</sub>[ <i>c\u2208S<sub>C</sub></i>"}),"\n",(0,i.jsx)(s.p,{children:"The set <i>R</i> might or might not generate a partial ordering, depending on whether the <i>R<sub>c</sub></i>, <i>c \u2208 S<sub>C</sub></i> , are consistent; it is assumed that they are consistent and that <i>R</i> generates a partial ordering. When the <i>R<sub>c</sub></i> are not consistent, it is said that <i>R</i> is inconsistent."}),"\n",(0,i.jsx)(s.p,{children:"To compute the <i>class precedence list</i> for <i>C</i>, topologically sort the elements of <i>S<sub>C</sub></i> with respect to the partial ordering generated by <i>R</i>. When the topological sort must select a <i>class</i> from a set of two or more <i>classes</i>, none of which are preceded by other <i>classes</i> with respect to <i>R</i>, the <i>class</i> selected is chosen deterministically, as described below."}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.em,{children:"R"})," is inconsistent, an error is signaled."]})]})}function w(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}function T(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.5.1 Topological Sorting"})}),"\n",(0,i.jsx)(s.p,{children:"Topological sorting proceeds by finding a class <i>C</i> in <i>S<sub>C</sub></i> such that no other <i>class</i> precedes that element according to the elements in <i>R</i>. The class <i>C</i> is placed first in the result. Remove <i>C</i> from <i>S<sub>C</sub></i> , and remove all pairs of the form (<i>C, D</i>), <i>D \u2208 S<sub>C</sub></i> , from <i>R</i>. Repeat the process, adding <i>classes</i> with no predecessors to the end of the result. Stop when no element can be found that has no predecessor."}),"\n",(0,i.jsx)(s.p,{children:"If <i>S<sub>C</sub></i> is not empty and the process has stopped, the set <i>R</i> is inconsistent. If every <i>class</i> in the finite set of <i>classes</i> is preceded by another, then <i>R</i> contains a loop. That is, there is a chain of classes <i>C</i><sub>1</sub><i>, . . . , C<sub>n</sub></i> such that <i>C<sub>i</sub></i> precedes <i>C<sub>i</sub></i>+1</sub>, 1 <i>\u2264 i</i> < <i>n</i>, and <i>C<sub>n</sub></i> precedes <i>C</i><sub>1</sub>."}),"\n",(0,i.jsx)(s.p,{children:"Sometimes there are several <i>classes</i> from <i>S<sub>C</sub></i> with no predecessors. In this case select the one that has a direct <i>subclass</i> rightmost in the <i>class precedence list</i> computed so far. (If there is no such candidate <i>class</i>, <i>R</i> does not generate a partial ordering\u2014the <i>R<sub>c</sub></i>, <i>c \u2208 S<sub>C</sub></i> , are inconsistent.)"}),"\n",(0,i.jsx)(s.p,{children:"In more precise terms, let <i>{N</i><sub>1</sub><i>, . . . , N<sub>m</sub>}</i>, <i>m \u2265</i> 2, be the <i>classes</i> from <i>S<sub>C</sub></i> with no predecessors. Let (<i>C</i><sub>1</sub> <i>. . . C<sub>n</sub></i>), <i>n \u2265</i> 1, be the <i>class precedence list</i> constructed so far. <i>C</i><sub>1</sub> is the most specific <i>class</i>, and <i>C<sub>n</sub></i> is the least specific. Let 1 <i>\u2264 j \u2264 n</i> be the largest number such that there exists an <i>i</i> where 1 <i>\u2264 i \u2264 m</i> and <i>N<sub>i</sub></i>is a direct <i>superclass</i> of <i>C<sub>j</sub></i> ; <i>N<sub>i</sub></i>is placed next."}),"\n",(0,i.jsxs)(s.p,{children:["The effect of this rule for selecting from a set of ",(0,i.jsx)(s.em,{children:"classes"})," with no predecessors is that the ",(0,i.jsx)(s.em,{children:"classes"})," in a simple ",(0,i.jsx)(s.em,{children:"superclass"})," chain are adjacent in the ",(0,i.jsx)(s.em,{children:"class precedence list"})," and that ",(0,i.jsx)(s.em,{children:"classes"})," in each relatively separated subgraph are adjacent in the ",(0,i.jsx)(s.em,{children:"class precedence list"}),". For example, let ",(0,i.jsx)(s.em,{children:"T"}),"<sub>1</sub> and ",(0,i.jsx)(s.em,{children:"T"}),"<sub>2</sub> be subgraphs whose only element in common is the class ",(0,i.jsx)(s.em,{children:"J"}),". Suppose that no superclass of ",(0,i.jsx)(s.em,{children:"J"})," appears in either ",(0,i.jsx)(s.em,{children:"T"}),"<sub>1</sub> or ",(0,i.jsx)(s.em,{children:"T"}),"<sub>2</sub>, and that ",(0,i.jsx)(s.em,{children:"J"})," is in the superclass chain of every class in both ",(0,i.jsx)(s.em,{children:"T"}),"<sub>1</sub> and ",(0,i.jsx)(s.em,{children:"T"}),"<sub>2</sub>. Let ",(0,i.jsx)(s.em,{children:"C"}),"<sub>1</sub> be the bottom of ",(0,i.jsx)(s.em,{children:"T"}),"<sub>1</sub>; and let ",(0,i.jsx)(s.em,{children:"C"}),"<sub>2</sub> be the bottom of ",(0,i.jsx)(s.em,{children:"T"}),"<sub>2</sub>. Suppose ",(0,i.jsx)(s.em,{children:"C"})," is a ",(0,i.jsx)(s.em,{children:"class"})," whose direct ",(0,i.jsx)(s.em,{children:"superclasses"})," are ",(0,i.jsx)(s.em,{children:"C"}),"<sub>1</sub> and ",(0,i.jsx)(s.em,{children:"C"}),"<sub>2</sub> in that order, then the ",(0,i.jsx)(s.em,{children:"class precedence list"})," for ",(0,i.jsx)(s.em,{children:"C"})," starts with ",(0,i.jsx)(s.em,{children:"C"})," and is followed by all ",(0,i.jsx)(s.em,{children:"classes"})," in ",(0,i.jsx)(s.em,{children:"T"}),"<sub>1</sub> except ",(0,i.jsx)(s.em,{children:"J"}),". All the ",(0,i.jsx)(s.em,{children:"classes"})," of ",(0,i.jsx)(s.em,{children:"T"}),"<sub>2</sub> are next. The ",(0,i.jsx)(s.em,{children:"class J"})," and its ",(0,i.jsx)(s.em,{children:"superclasses"})," appear last."]})]})}function C(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(T,{...e})}):T(e)}function S(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.5.2 Examples of Class Precedence List Determination"})}),"\n",(0,i.jsxs)(s.p,{children:["This example determines a ",(0,i.jsx)(s.em,{children:"class precedence list"})," for the class pie. The following ",(0,i.jsx)(s.em,{children:"classes"})," are defined: (defclass pie (apple cinnamon) ())"]}),"\n",(0,i.jsx)(s.p,{children:"(defclass apple (fruit) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass cinnamon (spice) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass fruit (food) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass spice (food) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass food () ())"}),"\n",(0,i.jsx)(s.p,{children:"The set <i>S<sub>pie</sub></i> = <i>{</i>pie, apple, cinnamon, fruit, spice, food, standard-object, t<i>}</i>. The set <i>R</i> = <i>{</i>(pie, apple), (apple, cinnamon), (apple, fruit), (cinnamon, spice),"}),"\n",(0,i.jsxs)(s.p,{children:["(fruit, food), (spice, food), (food, standard-object), (standard-object, t)",(0,i.jsx)(s.em,{children:"}"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The class pie is not preceded by anything, so it comes first; the result so far is (pie). Remove pie from ",(0,i.jsx)(s.em,{children:"S"})," and pairs mentioning pie from ",(0,i.jsx)(s.em,{children:"R"})," to get ",(0,i.jsx)(s.em,{children:"S"})," = ",(0,i.jsxs)(s.em,{children:["{",(0,i.jsx)(s.em,{children:"apple, cinnamon, fruit, spice, food, standard-object, t"}),"}"]})," and ",(0,i.jsx)(s.em,{children:"R"})," = ",(0,i.jsx)(s.em,{children:"{"}),"(apple, cinnamon), (apple, fruit), (cinnamon, spice), (fruit, food), (spice, food), (food, standard-object), (standard-object, t)",(0,i.jsx)(s.em,{children:"}"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The class apple is not preceded by anything, so it is next; the result is (pie apple). Removing apple and the relevant pairs results in ",(0,i.jsx)(s.em,{children:"S"})," = ",(0,i.jsxs)(s.em,{children:["{",(0,i.jsx)(s.em,{children:"cinnamon, fruit, spice, food, standard-object, t"}),"}"]})," and ",(0,i.jsx)(s.em,{children:"R"})," = ",(0,i.jsx)(s.em,{children:"{"}),"(cinnamon, spice), (fruit, food), (spice, food), (food, standard-object), (standard-object, t)",(0,i.jsx)(s.em,{children:"}"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The classes cinnamon and fruit are not preceded by anything, so the one with a direct ",(0,i.jsx)(s.em,{children:"subclass"})," rightmost in the ",(0,i.jsx)(s.em,{children:"class precedence list"})," computed so far goes next. The class apple is a direct ",(0,i.jsx)(s.em,{children:"subclass"})]}),"\n",(0,i.jsxs)(s.p,{children:["of fruit, and the class pie is a direct ",(0,i.jsx)(s.em,{children:"subclass"})," of cinnamon. Because apple appears to the right of pie in the ",(0,i.jsx)(s.em,{children:"class precedence list"}),", fruit goes next, and the result so far is (pie apple fruit). ",(0,i.jsx)(s.em,{children:"S"})," = ",(0,i.jsxs)(s.em,{children:["{",(0,i.jsx)(s.em,{children:"cinnamon, spice, food, standard-object, t"}),"}"]}),"; ",(0,i.jsx)(s.em,{children:"R"})," = ",(0,i.jsx)(s.em,{children:"{"}),"(cinnamon, spice), (spice, food), (food, standard-object), (standard-object, t)",(0,i.jsx)(s.em,{children:"}"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The class cinnamon is next, giving the result so far as (pie apple fruit cinnamon). At this point ",(0,i.jsx)(s.em,{children:"S"})," = ",(0,i.jsxs)(s.em,{children:["{",(0,i.jsx)(s.em,{children:"spice, food, standard-object, t"}),"}"]}),"; ",(0,i.jsx)(s.em,{children:"R"})," = ",(0,i.jsx)(s.em,{children:"{"}),"(spice, food), (food, standard-object), (standard-object, t)",(0,i.jsx)(s.em,{children:"}"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The classes spice, food, ",(0,i.jsx)(s.strong,{children:"standard-object"}),", and ",(0,i.jsx)(s.strong,{children:"t"})," are added in that order, and the ",(0,i.jsx)(s.em,{children:"class precedence list"})," is (pie apple fruit cinnamon spice food standard-object t)."]}),"\n",(0,i.jsxs)(s.p,{children:["It is possible to write a set of ",(0,i.jsx)(s.em,{children:"class"})," definitions that cannot be ordered. For example: (defclass new-class (fruit apple) ())"]}),"\n",(0,i.jsx)(s.p,{children:"(defclass apple (fruit) ())"}),"\n",(0,i.jsxs)(s.p,{children:["The class fruit must precede apple because the local ordering of ",(0,i.jsx)(s.em,{children:"superclasses"})," must be preserved. The class apple must precede fruit because a ",(0,i.jsx)(s.em,{children:"class"})," always precedes its own ",(0,i.jsx)(s.em,{children:"superclasses"}),". When this situation occurs, an error is signaled, as happens here when the system tries to compute the ",(0,i.jsx)(s.em,{children:"class precedence list"})," of new-class."]}),"\n",(0,i.jsx)(s.p,{children:"The following might appear to be a conflicting set of definitions:"}),"\n",(0,i.jsx)(s.p,{children:"(defclass pie (apple cinnamon) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass pastry (cinnamon apple) ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass apple () ())"}),"\n",(0,i.jsx)(s.p,{children:"(defclass cinnamon () ())"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class precedence list"})," for pie is (pie apple cinnamon standard-object t)."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class precedence list"})," for pastry is (pastry cinnamon apple standard-object t)."]}),"\n",(0,i.jsxs)(s.p,{children:["It is not a problem for apple to precede cinnamon in the ordering of the ",(0,i.jsx)(s.em,{children:"superclasses"})," of pie but not in the ordering for pastry. However, it is not possible to build a new ",(0,i.jsx)(s.em,{children:"class"})," that has both pie and pastry as ",(0,i.jsx)(s.em,{children:"superclasses"}),"."]})]})}function I(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(S,{...e})}):S(e)}function A(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.6 Redefining Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"class"})," that is a ",(0,i.jsx)(s.em,{children:"direct instance"})," of ",(0,i.jsx)(s.strong,{children:"standard-class"})," can be redefined if the new ",(0,i.jsx)(s.em,{children:"class"})," is also a ",(0,i.jsx)(s.em,{children:"direct instance"})," of ",(0,i.jsx)(s.strong,{children:"standard-class"}),". Redefining a ",(0,i.jsx)(s.em,{children:"class"})," modifies the existing ",(0,i.jsx)(s.em,{children:"class object"})," to reflect the new ",(0,i.jsx)(s.em,{children:"class"})," definition; it does not create a new ",(0,i.jsx)(s.em,{children:"class object"})," for the ",(0,i.jsx)(s.em,{children:"class"}),". Any ",(0,i.jsx)(s.em,{children:"method object"})," created by a ",":reader",", ",":writer",", or ",":accessor"," option specified by the old ",(0,i.jsx)(s.strong,{children:"defclass"})," form is removed from the corresponding ",(0,i.jsx)(s.em,{children:"generic function"}),". ",(0,i.jsx)(s.em,{children:"Methods"})," specified by the new ",(0,i.jsx)(s.strong,{children:"defclass"})," form are added."]}),"\n",(0,i.jsxs)(s.p,{children:["When the class ",(0,i.jsx)(s.em,{children:"C"})," is redefined, changes are propagated to its ",(0,i.jsx)(s.em,{children:"instances"})," and to ",(0,i.jsx)(s.em,{children:"instances"})," of any of its ",(0,i.jsx)(s.em,{children:"subclasses"}),". Updating such an ",(0,i.jsx)(s.em,{children:"instance"})," occurs at an ",(0,i.jsx)(s.em,{children:"implementation-dependent"})," time, but no later than the next time a ",(0,i.jsx)(s.em,{children:"slot"})," of that ",(0,i.jsx)(s.em,{children:"instance"})," is read or written. Updating an ",(0,i.jsx)(s.em,{children:"instance"})," does not change its identity as defined by the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"eq"}),". The updating process may change the ",(0,i.jsx)(s.em,{children:"slots"})," of that particular ",(0,i.jsx)(s.em,{children:"instance"}),", but it does not create a new ",(0,i.jsx)(s.em,{children:"instance"}),". Whether updating an ",(0,i.jsx)(s.em,{children:"instance"})," consumes storage is ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that redefining a ",(0,i.jsx)(s.em,{children:"class"})," may cause ",(0,i.jsx)(s.em,{children:"slots"})," to be added or deleted. If a ",(0,i.jsx)(s.em,{children:"class"})," is redefined in a way that changes the set of ",(0,i.jsx)(s.em,{children:"local slots accessible"})," in ",(0,i.jsx)(s.em,{children:"instances"}),", the ",(0,i.jsx)(s.em,{children:"instances"})," are updated. It is ",(0,i.jsx)(s.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(s.em,{children:"instances"})," are updated if a ",(0,i.jsx)(s.em,{children:"class"})," is redefined in a way that does not change the set of ",(0,i.jsx)(s.em,{children:"local slots accessible"})," in ",(0,i.jsx)(s.em,{children:"instances"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The value of a ",(0,i.jsx)(s.em,{children:"slot"})," that is specified as shared both in the old ",(0,i.jsx)(s.em,{children:"class"})," and in the new ",(0,i.jsx)(s.em,{children:"class"})," is retained. If such a ",(0,i.jsx)(s.em,{children:"shared slot"})," was unbound in the old ",(0,i.jsx)(s.em,{children:"class"}),", it is unbound in the new ",(0,i.jsx)(s.em,{children:"class"}),". ",(0,i.jsx)(s.em,{children:"Slots"})," that were local in the old ",(0,i.jsx)(s.em,{children:"class"})," and that are shared in the new ",(0,i.jsx)(s.em,{children:"class"})," are initialized. Newly added ",(0,i.jsx)(s.em,{children:"shared slots"})," are initialized."]}),"\n",(0,i.jsxs)(s.p,{children:["Each newly added ",(0,i.jsx)(s.em,{children:"shared slot"})," is set to the result of evaluating the ",(0,i.jsx)(s.em,{children:"captured initialization form"})," for the ",(0,i.jsx)(s.em,{children:"slot"})," that was specified in the ",(0,i.jsx)(s.strong,{children:"defclass"})," ",(0,i.jsx)(s.em,{children:"form"})," for the new ",(0,i.jsx)(s.em,{children:"class"}),". If there was no ",(0,i.jsx)(s.em,{children:"initialization form"}),", the ",(0,i.jsx)(s.em,{children:"slot"})," is unbound."]}),"\n",(0,i.jsxs)(s.p,{children:["If a ",(0,i.jsx)(s.em,{children:"class"})," is redefined in such a way that the set of ",(0,i.jsx)(s.em,{children:"local slots accessible"})," in an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," is changed, a two-step process of updating the ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," takes place. The process may be explicitly started by invoking the generic function ",(0,i.jsx)(s.strong,{children:"make-instances-obsolete"}),". This two-step process can happen in other circumstances in some implementations. For example, in some implementations this two-step process is triggered if the order of ",(0,i.jsx)(s.em,{children:"slots"})," in storage is changed."]}),"\n",(0,i.jsxs)(s.p,{children:["The first step modifies the structure of the ",(0,i.jsx)(s.em,{children:"instance"})," by adding new ",(0,i.jsx)(s.em,{children:"local slots"})," and discarding ",(0,i.jsx)(s.em,{children:"local slots"})," that are not defined in the new version of the ",(0,i.jsx)(s.em,{children:"class"}),". The second step initializes the newly-added ",(0,i.jsx)(s.em,{children:"local slots"})," and performs any other user-defined actions. These two steps are further specified in the next two sections."]})]})}function z(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(A,{...e})}):A(e)}function k(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.6.1 Modifying the Structure of Instances"})}),"\n",(0,i.jsxs)(s.p,{children:["The first step modifies the structure of ",(0,i.jsx)(s.em,{children:"instances"})," of the redefined ",(0,i.jsx)(s.em,{children:"class"})," to conform to its new ",(0,i.jsx)(s.em,{children:"class"})," definition. ",(0,i.jsx)(s.em,{children:"Local slots"})," specified by the new ",(0,i.jsx)(s.em,{children:"class"})," definition that are not specified as either local or shared by the old ",(0,i.jsx)(s.em,{children:"class"})," are added, and ",(0,i.jsx)(s.em,{children:"slots"})," not specified as either local or shared by the new ",(0,i.jsx)(s.em,{children:"class"})," definition that are specified as local by the old ",(0,i.jsx)(s.em,{children:"class"})," are discarded. The ",(0,i.jsx)(s.em,{children:"names"})," of these added and discarded ",(0,i.jsx)(s.em,{children:"slots"})," are passed as arguments to ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," as described in"]}),"\n",(0,i.jsx)(s.p,{children:"the next section."}),"\n",(0,i.jsxs)(s.p,{children:["The values of ",(0,i.jsx)(s.em,{children:"local slots"})," specified by both the new and old ",(0,i.jsx)(s.em,{children:"classes"})," are retained. If such a ",(0,i.jsx)(s.em,{children:"local slot"})," was unbound, it remains unbound."]}),"\n",(0,i.jsxs)(s.p,{children:["The value of a ",(0,i.jsx)(s.em,{children:"slot"})," that is specified as shared in the old ",(0,i.jsx)(s.em,{children:"class"})," and as local in the new ",(0,i.jsx)(s.em,{children:"class"})," is retained. If such a ",(0,i.jsx)(s.em,{children:"shared slot"})," was unbound, the ",(0,i.jsx)(s.em,{children:"local slot"})," is unbound."]})]})}function R(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(k,{...e})}):k(e)}function F(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.6.2 Initializing Newly Added Local Slots"})}),"\n",(0,i.jsxs)(s.p,{children:["The second step initializes the newly added ",(0,i.jsx)(s.em,{children:"local slots"})," and performs any other user-defined actions. This step is implemented by the generic function ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"}),", which is called after completion of the first step of modifying the structure of the ",(0,i.jsx)(s.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The generic function ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," takes four required arguments: the ",(0,i.jsx)(s.em,{children:"instance"})," being updated after it has undergone the first step, a list of the names of ",(0,i.jsx)(s.em,{children:"local slots"})," that were added, a list of the names of ",(0,i.jsx)(s.em,{children:"local slots"})," that were discarded, and a property list containing the ",(0,i.jsx)(s.em,{children:"slot"})," names and values of ",(0,i.jsx)(s.em,{children:"slots"})," that were discarded and had values. Included among the discarded ",(0,i.jsx)(s.em,{children:"slots"})," are ",(0,i.jsx)(s.em,{children:"slots"})," that were local in the old ",(0,i.jsx)(s.em,{children:"class"})," and that are shared in the new ",(0,i.jsx)(s.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The generic function ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," also takes any number of initialization arguments. When it is called by the system to update an ",(0,i.jsx)(s.em,{children:"instance"})," whose ",(0,i.jsx)(s.em,{children:"class"})," has been redefined, no initialization arguments are provided."]}),"\n",(0,i.jsxs)(s.p,{children:["There is a system-supplied primary ",(0,i.jsx)(s.em,{children:"method"})," for ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," whose ",(0,i.jsx)(s.em,{children:"parameter specializer"})," for its ",(0,i.jsx)(s.em,{children:"instance"})," argument is the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-object"}),". First this ",(0,i.jsx)(s.em,{children:"method"})," checks the validity of initialization arguments and signals an error if an initialization argument is supplied that is not declared as valid. (For more information, see Section 7.1.2 (Declaring the Validity of Initialization Arguments).) Then it calls the generic function ",(0,i.jsx)(s.strong,{children:"shared-initialize"})," with the following arguments: the ",(0,i.jsx)(s.em,{children:"instance"}),", the list of ",(0,i.jsx)(s.em,{children:"names"})," of the newly added ",(0,i.jsx)(s.em,{children:"slots"}),", and the initialization arguments it received."]})]})}function D(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(F,{...e})}):F(e)}function q(e){const s={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.6.3 Customizing Class Redefinition"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Methods"})," for ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," may be defined to specify actions to be taken when an ",(0,i.jsx)(s.em,{children:"instance"})," is updated. If only ",(0,i.jsx)(s.em,{children:"after methods"})," for ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," are defined, they will be run after the system-supplied primary ",(0,i.jsx)(s.em,{children:"method"})," for initialization and therefore will not interfere with the default behavior of ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"}),". Because no initialization arguments are passed to ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," when it is called by the system, the ",(0,i.jsx)(s.em,{children:"initialization forms"})," for ",(0,i.jsx)(s.em,{children:"slots"})," that are filled by ",(0,i.jsx)(s.em,{children:"before methods"})," for ",(0,i.jsx)(s.strong,{children:"update-instance-for-redefined-class"})," will not be evaluated by ",(0,i.jsx)(s.strong,{children:"shared-initialize"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Methods"})," for ",(0,i.jsx)(s.strong,{children:"shared-initialize"})," may be defined to customize ",(0,i.jsx)(s.em,{children:"class"})," redefinition. For more information, see Section 7.1.5 (Shared-Initialize)."]})]})}function E(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}function L(e){const s={em:"em",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"4.3.7 Integrating Types and Classes"})}),"\n",(0,i.jsxs)(s.p,{children:["The object system maps the space of ",(0,i.jsx)(s.em,{children:"classes"})," into the space of ",(0,i.jsx)(s.em,{children:"types"}),". Every ",(0,i.jsx)(s.em,{children:"class"})," that has a proper name has a corresponding ",(0,i.jsx)(s.em,{children:"type"})," with the same ",(0,i.jsx)(s.em,{children:"name"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The proper name of every ",(0,i.jsx)(s.em,{children:"class"})," is a valid ",(0,i.jsx)(s.em,{children:"type specifier"})," . In addition, every ",(0,i.jsx)(s.em,{children:"class object"})," is a valid ",(0,i.jsx)(s.em,{children:"type specifier"})," . Thus the expression (typep ",(0,i.jsx)(s.em,{children:"object class"}),") evaluates to ",(0,i.jsx)(s.em,{children:"true"})," if the ",(0,i.jsx)(s.em,{children:"class"})," of ",(0,i.jsx)(s.em,{children:"object"})," is ",(0,i.jsx)(s.em,{children:"class"})," itself or a ",(0,i.jsx)(s.em,{children:"subclass"})," of ",(0,i.jsx)(s.em,{children:"class"}),". The evaluation of the expression (subtypep class1 class2) returns the values ",(0,i.jsx)(s.em,{children:"true"})," and ",(0,i.jsx)(s.em,{children:"true"})," if class1 is a subclass of class2 or if they are the same ",(0,i.jsx)(s.em,{children:"class"}),"; otherwise it returns the values ",(0,i.jsx)(s.em,{children:"false"})," and ",(0,i.jsx)(s.em,{children:"true"}),". If ",(0,i.jsx)(s.em,{children:"I"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of some ",(0,i.jsx)(s.em,{children:"class C"})," named ",(0,i.jsx)(s.em,{children:"S"})," and ",(0,i.jsx)(s.em,{children:"C"})]}),"\n",(0,i.jsxs)(s.p,{children:["is an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"standard-class"}),", the evaluation of the expression (type-of ",(0,i.jsx)(s.em,{children:"I"}),") returns ",(0,i.jsx)(s.em,{children:"S"})," if ",(0,i.jsx)(s.em,{children:"S"})," is the ",(0,i.jsx)(s.em,{children:"proper name"})," of ",(0,i.jsx)(s.em,{children:"C"}),"; otherwise, it returns ",(0,i.jsx)(s.em,{children:"C"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Because the names of ",(0,i.jsx)(s.em,{children:"classes"})," and ",(0,i.jsx)(s.em,{children:"class objects"})," are ",(0,i.jsx)(s.em,{children:"type specifiers"}),", they may be used in the special form ",(0,i.jsx)(s.strong,{children:"the"})," and in type declarations."]}),"\n",(0,i.jsxs)(s.p,{children:["Many but not all of the predefined ",(0,i.jsx)(s.em,{children:"type specifiers"})," have a corresponding ",(0,i.jsx)(s.em,{children:"class"})," with the same proper name as the ",(0,i.jsx)(s.em,{children:"type"}),". These type specifiers are listed in Figure 4\u20138. For example, the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"array"})," has a corresponding ",(0,i.jsx)(s.em,{children:"class"})," named ",(0,i.jsx)(s.strong,{children:"array"}),". No ",(0,i.jsx)(s.em,{children:"type specifier"})," that is a list, such as (vector double-float 100), has a corresponding ",(0,i.jsx)(s.em,{children:"class"}),". The ",(0,i.jsx)(s.em,{children:"operator"})," ",(0,i.jsx)(s.strong,{children:"deftype"})," does not create any ",(0,i.jsx)(s.em,{children:"classes"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Each ",(0,i.jsx)(s.em,{children:"class"})," that corresponds to a predefined ",(0,i.jsx)(s.em,{children:"type specifier"})," can be implemented in one of three ways, at the discretion of each implementation. It can be a ",(0,i.jsx)(s.em,{children:"standard class"}),", a ",(0,i.jsx)(s.em,{children:"structure class"}),", or a ",(0,i.jsx)(s.em,{children:"system class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"built-in class"})," is one whose ",(0,i.jsx)(s.em,{children:"generalized instances"})," have restricted capabilities or special representations. Attempting to use ",(0,i.jsx)(s.strong,{children:"defclass"})," to define ",(0,i.jsx)(s.em,{children:"subclasses"})," of a ",(0,i.jsx)(s.strong,{children:"built-in-class"})," signals an error. Calling ",(0,i.jsx)(s.strong,{children:"make-instance"})," to create a ",(0,i.jsx)(s.em,{children:"generalized instance"})," of a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error. Calling ",(0,i.jsx)(s.strong,{children:"slot-value"})," on a ",(0,i.jsx)(s.em,{children:"generalized instance"})," of a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error. Redefining a ",(0,i.jsx)(s.em,{children:"built-in class"})," or using ",(0,i.jsx)(s.strong,{children:"change-class"})," to change the ",(0,i.jsx)(s.em,{children:"class"})," of an ",(0,i.jsx)(s.em,{children:"object"})," to or from a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error. However, ",(0,i.jsx)(s.em,{children:"built-in classes"})," can be used as ",(0,i.jsx)(s.em,{children:"parameter specializers"})," in ",(0,i.jsx)(s.em,{children:"methods"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["It is possible to determine whether a ",(0,i.jsx)(s.em,{children:"class"})," is a ",(0,i.jsx)(s.em,{children:"built-in class"})," by checking the ",(0,i.jsx)(s.em,{children:"metaclass"}),". A ",(0,i.jsx)(s.em,{children:"standard class"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"}),", a ",(0,i.jsx)(s.em,{children:"built-in class"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"built-in-class"}),", and a ",(0,i.jsx)(s.em,{children:"structure class"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"structure-class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Each ",(0,i.jsx)(s.em,{children:"structure type"})," created by ",(0,i.jsx)(s.strong,{children:"defstruct"})," without using the ",":type"," option has a corresponding ",(0,i.jsx)(s.em,{children:"class"}),". This ",(0,i.jsx)(s.em,{children:"class"})," is a ",(0,i.jsx)(s.em,{children:"generalized instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"structure-class"}),". The ",":include"," option of ",(0,i.jsx)(s.strong,{children:"defstruct"})," creates a direct ",(0,i.jsx)(s.em,{children:"subclass"})," of the ",(0,i.jsx)(s.em,{children:"class"})," that corresponds to the included ",(0,i.jsx)(s.em,{children:"structure type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["It is ",(0,i.jsx)(s.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(s.em,{children:"slots"})," are involved in the operation of ",(0,i.jsx)(s.em,{children:"functions"})," defined in this specification on ",(0,i.jsx)(s.em,{children:"instances"})," of ",(0,i.jsx)(s.em,{children:"classes"})," defined in this specification, except when ",(0,i.jsx)(s.em,{children:"slots"})," are explicitly defined by this specification."]}),"\n",(0,i.jsxs)(s.p,{children:["If in a particular ",(0,i.jsx)(s.em,{children:"implementation"})," a ",(0,i.jsx)(s.em,{children:"class"})," defined in this specification has ",(0,i.jsx)(s.em,{children:"slots"})," that are not defined by this specfication, the names of these ",(0,i.jsx)(s.em,{children:"slots"})," must not be ",(0,i.jsx)(s.em,{children:"external symbols"})," of ",(0,i.jsx)(s.em,{children:"packages"})," defined in this specification nor otherwise ",(0,i.jsx)(s.em,{children:"accessible"})," in the CL-USER ",(0,i.jsx)(s.em,{children:"package"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The purpose of specifying that many of the standard ",(0,i.jsx)(s.em,{children:"type specifiers"})," have a corresponding ",(0,i.jsx)(s.em,{children:"class"})," is to enable users to write ",(0,i.jsx)(s.em,{children:"methods"})," that discriminate on these ",(0,i.jsx)(s.em,{children:"types"}),". ",(0,i.jsx)(s.em,{children:"Method"})," selection requires that a ",(0,i.jsx)(s.em,{children:"class precedence list"})," can be determined for each ",(0,i.jsx)(s.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The hierarchical relationships among the ",(0,i.jsx)(s.em,{children:"type specifiers"})," are mirrored by relationships among the ",(0,i.jsx)(s.em,{children:"classes"})," corresponding to those ",(0,i.jsx)(s.em,{children:"types"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Figure 4\u20138 lists the set of ",(0,i.jsx)(s.em,{children:"classes"})," that correspond to predefined ",(0,i.jsx)(s.em,{children:"type specifiers"}),"."]}),"\n",(0,i.jsx)(s.table,{children:(0,i.jsx)(s.thead,{children:(0,i.jsx)(s.tr,{children:(0,i.jsxs)(s.th,{style:{textAlign:"left"},children:["<p>",(0,i.jsx)(s.strong,{children:"arithmetic-error generic-function simple-error array hash-table simple-type-error bit-vector integer simple-warning broadcast-stream list standard-class built-in-class logical-pathname standard-generic-function cell-error method standard-method character method-combination standard-object class null storage-condition complex number stream"})," </p><p>",(0,i.jsx)(s.strong,{children:"concatenated-stream package stream-error condition package-error string"})," </p><p>",(0,i.jsx)(s.strong,{children:"cons parse-error string-stream control-error pathname structure-class division-by-zero print-not-readable structure-object echo-stream program-error style-warning end-of-file random-state symbol"})," </p><p>",(0,i.jsx)(s.strong,{children:"error ratio synonym-stream file-error rational t"})," </p><p>",(0,i.jsx)(s.strong,{children:"file-stream reader-error two-way-stream float readtable type-error floating-point-inexact real unbound-slot floating-point-invalid-operation restart unbound-variable floating-point-overflow sequence undefined-function floating-point-underflow serious-condition vector"})," </p><p>",(0,i.jsx)(s.strong,{children:"function simple-condition warning"}),"</p>"]})})})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Figure 4\u20138. Classes that correspond to pre-defined type specifiers"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class precedence list"})," information specified in the entries for each of these ",(0,i.jsx)(s.em,{children:"classes"})," are those that are required by the object system."]}),"\n",(0,i.jsxs)(s.p,{children:["Individual implementations may be extended to define other type specifiers to have a corresponding ",(0,i.jsx)(s.em,{children:"class"}),". Individual implementations may be extended to add other ",(0,i.jsx)(s.em,{children:"subclass"})," relationships and to add other ",(0,i.jsx)(s.em,{children:"elements"})," to the ",(0,i.jsx)(s.em,{children:"class precedence lists"})," as long as they do not violate the type relationships and disjointness requirements specified by this standard. A standard ",(0,i.jsx)(s.em,{children:"class"})," defined with no direct ",(0,i.jsx)(s.em,{children:"superclasses"})," is guaranteed to be disjoint from all of the ",(0,i.jsx)(s.em,{children:"classes"})," in the table, except for the class named ",(0,i.jsx)(s.strong,{children:"t"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"nil"})," ",(0,i.jsx)(s.em,{children:"Type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Supertypes:"})}),"\n",(0,i.jsxs)(s.p,{children:["all ",(0,i.jsx)(s.em,{children:"types"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"nil"})," contains no ",(0,i.jsx)(s.em,{children:"objects"})," and so is also called the ",(0,i.jsx)(s.em,{children:"empty type"}),". The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"nil"})," is a ",(0,i.jsx)(s.em,{children:"subtype"})," of every ",(0,i.jsx)(s.em,{children:"type"}),". No ",(0,i.jsx)(s.em,{children:"object"})," is of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"nil"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type"})," containing the ",(0,i.jsx)(s.em,{children:"object"})," ",(0,i.jsx)(s.strong,{children:"nil"})," is the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"null"}),", not the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"nil"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"boolean"})," ",(0,i.jsx)(s.em,{children:"Type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Supertypes:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"boolean"}),", ",(0,i.jsx)(s.strong,{children:"symbol"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"boolean"})," contains the ",(0,i.jsx)(s.em,{children:"symbols"})," ",(0,i.jsx)(s.strong,{children:"t"})," and ",(0,i.jsx)(s.strong,{children:"nil"}),", which represent true and false, respectively."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"t"})," (",(0,i.jsx)(s.em,{children:"constant variable"}),"), ",(0,i.jsx)(s.strong,{children:"nil"})," (",(0,i.jsx)(s.em,{children:"constant variable"}),"), ",(0,i.jsx)(s.strong,{children:"if"}),", ",(0,i.jsx)(s.strong,{children:"not"}),", ",(0,i.jsx)(s.strong,{children:"complement"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["Conditional operations, such as ",(0,i.jsx)(s.strong,{children:"if"}),", permit the use of ",(0,i.jsx)(s.em,{children:"generalized booleans"}),", not just ",(0,i.jsx)(s.em,{children:"booleans"}),"; any ",(0,i.jsx)(s.em,{children:"non-nil"})," value, not just ",(0,i.jsx)(s.strong,{children:"t"}),", counts as true for a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),". However, as a matter of convention, the ",(0,i.jsx)(s.em,{children:"symbol"})," ",(0,i.jsx)(s.strong,{children:"t"})," is considered the canonical value to use even for a ",(0,i.jsx)(s.em,{children:"generalized boolean"})," when no better choice presents itself."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"function"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"function"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"function"})," is an ",(0,i.jsx)(s.em,{children:"object"})," that represents code to be executed when an appropriate number of arguments is supplied. A ",(0,i.jsx)(s.em,{children:"function"})," is produced by the ",(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"special form"}),", the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"coerce"}),", or the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"compile"}),". A ",(0,i.jsx)(s.em,{children:"function"})," can be directly invoked by using it as the first argument to ",(0,i.jsx)(s.strong,{children:"funcall"}),", ",(0,i.jsx)(s.strong,{children:"apply"}),", or ",(0,i.jsx)(s.strong,{children:"multiple-value-call"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Specializing."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(function [",(0,i.jsx)(s.em,{children:"arg-typespec"})," [",(0,i.jsx)(s.em,{children:"value-typespec"}),"]])"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"arg-typespec::"}),"=(",(0,i.jsx)(s.em,{children:"{typespec}"}),"*"]}),"\n",(0,i.jsxs)(s.p,{children:["[&optional ",(0,i.jsx)(s.em,{children:"{typespec}"}),"*]"]}),"\n",(0,i.jsxs)(s.p,{children:["[&rest ",(0,i.jsx)(s.em,{children:"typespec"}),"]"]}),"\n",(0,i.jsxs)(s.p,{children:["[&key ",(0,i.jsx)(s.em,{children:"{"}),"(",(0,i.jsx)(s.em,{children:"keyword typespec"}),")",(0,i.jsx)(s.em,{children:"}"}),"*])"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"value-typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The list form of the ",(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"type-specifier"})," can be used only for declaration and not for discrimination. Every element of this ",(0,i.jsx)(s.em,{children:"type"})," is a ",(0,i.jsx)(s.em,{children:"function"})," that accepts arguments of the types specified by the ",(0,i.jsx)(s.em,{children:"argj-types"})," and returns values that are members of the ",(0,i.jsx)(s.em,{children:"types"})," specified by ",(0,i.jsx)(s.em,{children:"value-type"}),". The ",(0,i.jsx)(s.strong,{children:"&optional"}),", ",(0,i.jsx)(s.strong,{children:"&rest"}),", ",(0,i.jsx)(s.strong,{children:"&key"}),", and ",(0,i.jsx)(s.strong,{children:"&allow-other-keys"})," markers can appear in the list of argument types. The ",(0,i.jsx)(s.em,{children:"type specifier"})," provided with ",(0,i.jsx)(s.strong,{children:"&rest"})," is the ",(0,i.jsx)(s.em,{children:"type"})," of each actual argument, not the ",(0,i.jsx)(s.em,{children:"type"})," of the corresponding variable."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.strong,{children:"&key"})," parameters should be supplied as lists of the form (",(0,i.jsx)(s.em,{children:"keyword type"}),"). The ",(0,i.jsx)(s.em,{children:"keyword"})," must be a valid keyword-name symbol as must be supplied in the actual arguments of a call. This is usually a ",(0,i.jsx)(s.em,{children:"symbol"})," in the KEYWORD ",(0,i.jsx)(s.em,{children:"package"})," but can be any ",(0,i.jsx)(s.em,{children:"symbol"}),". When ",(0,i.jsx)(s.strong,{children:"&key"})," is given in a ",(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"type specifier lambda list"}),", the ",(0,i.jsx)(s.em,{children:"keyword parameters"})," given are exhaustive unless ",(0,i.jsx)(s.strong,{children:"&allow-other-keys"})," is also present. ",(0,i.jsx)(s.strong,{children:"&allow-other-keys"})," is an indication that other keyword arguments might actually be supplied and, if supplied, can be used. For example, the ",(0,i.jsx)(s.em,{children:"type"})," of the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"make-list"})," could be declared as follows:"]}),"\n",(0,i.jsxs)(s.p,{children:["(function ((integer 0) &key (",":initial-element"," t)) list)"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"value-type"})," can be a ",(0,i.jsx)(s.strong,{children:"values"})," ",(0,i.jsx)(s.em,{children:"type specifier"})," in order to indicate the ",(0,i.jsx)(s.em,{children:"types"})," of ",(0,i.jsx)(s.em,{children:"multiple values"}),". Consider a declaration of the following form:"]}),"\n",(0,i.jsx)(s.p,{children:"(ftype (function (arg0-type arg1-type ...) val-type) f))"}),"\n",(0,i.jsxs)(s.p,{children:["Any ",(0,i.jsx)(s.em,{children:"form"})," (f arg0 arg1 ...) within the scope of that declaration is equivalent to the following: (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))"]}),"\n",(0,i.jsxs)(s.p,{children:["That is, the consequences are undefined if any of the arguments are not of the specified ",(0,i.jsx)(s.em,{children:"types"})," or the result is not of the specified ",(0,i.jsx)(s.em,{children:"type"}),". In particular, if any argument is not of the correct ",(0,i.jsx)(s.em,{children:"type"}),", the result is not guaranteed to be of the specified ",(0,i.jsx)(s.em,{children:"type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Thus, an ",(0,i.jsx)(s.strong,{children:"ftype"})," declaration for a ",(0,i.jsx)(s.em,{children:"function"})," describes ",(0,i.jsx)(s.em,{children:"calls"})," to the ",(0,i.jsx)(s.em,{children:"function"}),", not the actual definition of the ",(0,i.jsx)(s.em,{children:"function"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Consider a declaration of the following form:"}),"\n",(0,i.jsx)(s.p,{children:"(type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)"}),"\n",(0,i.jsxs)(s.p,{children:["This declaration has the interpretation that, within the scope of the declaration, the consequences are unspecified if the value of fn-valued-variable is called with arguments not of the specified ",(0,i.jsx)(s.em,{children:"types"}),"; the value resulting from a valid call will be of type val-type."]}),"\n",(0,i.jsxs)(s.p,{children:["As with variable type declarations, nested declarations imply intersections of ",(0,i.jsx)(s.em,{children:"types"}),", as follows:"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," Consider the following two declarations of ",(0,i.jsx)(s.strong,{children:"ftype"}),":"]}),"\n",(0,i.jsx)(s.p,{children:"(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))"}),"\n",(0,i.jsx)(s.p,{children:"and"}),"\n",(0,i.jsx)(s.p,{children:"(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))"}),"\n",(0,i.jsx)(s.p,{children:"If both these declarations are in effect, then within the shared scope of the declarations, calls to f can be treated as if f were declared as follows:"}),"\n",(0,i.jsx)(s.p,{children:"(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...) (and val-type1 val-type2))"}),"\n",(0,i.jsx)(s.p,{children:"f))"}),"\n",(0,i.jsxs)(s.p,{children:["It is permitted to ignore one or all of the ",(0,i.jsx)(s.strong,{children:"ftype"})," declarations in force."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2022"})," If two (or more) type declarations are in effect for a variable, and they are both function declarations, the declarations combine similarly."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"compiled-function"})," ",(0,i.jsx)(s.em,{children:"Type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Supertypes:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"compiled-function"}),", ",(0,i.jsx)(s.strong,{children:"function"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Any ",(0,i.jsx)(s.em,{children:"function"})," may be considered by an ",(0,i.jsx)(s.em,{children:"implementation"})," to be a a ",(0,i.jsx)(s.em,{children:"compiled function"})," if it contains no references to ",(0,i.jsx)(s.em,{children:"macros"})," that must be expanded at run time, and it contains no unresolved references to ",(0,i.jsx)(s.em,{children:"load time values"}),". See Section 3.2.2 (Compilation Semantics)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Functions"})," whose definitions appear lexically within a ",(0,i.jsx)(s.em,{children:"file"})," that has been ",(0,i.jsx)(s.em,{children:"compiled"})," with ",(0,i.jsx)(s.strong,{children:"compile-file"})," and then ",(0,i.jsx)(s.em,{children:"loaded"})," with ",(0,i.jsx)(s.strong,{children:"load"})," are of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"compiled-function"}),". ",(0,i.jsx)(s.em,{children:"Functions"})," produced by the ",(0,i.jsx)(s.strong,{children:"compile"})," function are of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"compiled-function"}),". Other ",(0,i.jsx)(s.em,{children:"functions"})," might also be of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"compiled-function"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"generic-function"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"generic-function"}),", ",(0,i.jsx)(s.strong,{children:"function"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"generic function"})," is a ",(0,i.jsx)(s.em,{children:"function"})," whose behavior depends on the ",(0,i.jsx)(s.em,{children:"classes"})," or identities of the ",(0,i.jsx)(s.em,{children:"arguments"})," supplied to it. A generic function object contains a set of ",(0,i.jsx)(s.em,{children:"methods"}),", a ",(0,i.jsx)(s.em,{children:"lambda list"}),", a ",(0,i.jsx)(s.em,{children:"method combination type"}),", and other information. The ",(0,i.jsx)(s.em,{children:"methods"})," define the class-specific behavior and operations of the ",(0,i.jsx)(s.em,{children:"generic function"}),"; a ",(0,i.jsx)(s.em,{children:"method"})," is said to ",(0,i.jsx)(s.em,{children:"specialize"})," a ",(0,i.jsx)(s.em,{children:"generic function"}),". When invoked, a ",(0,i.jsx)(s.em,{children:"generic function"})," executes a subset of its ",(0,i.jsx)(s.em,{children:"methods"})," based on the ",(0,i.jsx)(s.em,{children:"classes"})," or identities of its ",(0,i.jsx)(s.em,{children:"arguments"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"generic function"})," can be used in the same ways that an ordinary ",(0,i.jsx)(s.em,{children:"function"})," can be used; specifically, a ",(0,i.jsx)(s.em,{children:"generic function"})," can be used as an argument to ",(0,i.jsx)(s.strong,{children:"funcall"})," and ",(0,i.jsx)(s.strong,{children:"apply"}),", and can be given a global or a local name."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-generic-function"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-generic-function"}),", ",(0,i.jsx)(s.strong,{children:"generic-function"}),", ",(0,i.jsx)(s.strong,{children:"function"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-generic-function"})," is the default ",(0,i.jsx)(s.em,{children:"class"})," of ",(0,i.jsx)(s.em,{children:"generic functions established"})," by ",(0,i.jsx)(s.strong,{children:"defmethod"}),", ",(0,i.jsx)(s.strong,{children:"ensure-generic-function"}),", ",(0,i.jsx)(s.strong,{children:"defgeneric"}),", and ",(0,i.jsx)(s.strong,{children:"defclass"})," ",(0,i.jsx)(s.em,{children:"forms"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"class"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"class"}),", ",(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"class"})," represents ",(0,i.jsx)(s.em,{children:"objects"})," that determine the structure and behavior of their ",(0,i.jsx)(s.em,{children:"instances"}),". Associated with an ",(0,i.jsx)(s.em,{children:"object"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"class"})," is information describing its place in the directed acyclic graph of ",(0,i.jsx)(s.em,{children:"classes"}),", its ",(0,i.jsx)(s.em,{children:"slots"}),", and its options."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"built-in-class"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"built-in-class"}),", ",(0,i.jsx)(s.strong,{children:"class"}),", ",(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"built-in class"})," is a ",(0,i.jsx)(s.em,{children:"class"})," whose ",(0,i.jsx)(s.em,{children:"instances"})," have restricted capabilities or special representations. Attempting to use ",(0,i.jsx)(s.strong,{children:"defclass"})," to define ",(0,i.jsx)(s.em,{children:"subclasses"})," of a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"}),". Calling ",(0,i.jsx)(s.strong,{children:"make-instance"})," to create an ",(0,i.jsx)(s.em,{children:"instance"})," of a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"}),". Calling ",(0,i.jsx)(s.strong,{children:"slot-value"})," on an ",(0,i.jsx)(s.em,{children:"instance"})," of a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"}),". Redefining a ",(0,i.jsx)(s.em,{children:"built-in class"})," or using ",(0,i.jsx)(s.strong,{children:"change-class"})," to change the ",(0,i.jsx)(s.em,{children:"class"})," of an ",(0,i.jsx)(s.em,{children:"instance"})," to or from a ",(0,i.jsx)(s.em,{children:"built-in class"})," signals an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"}),". However, ",(0,i.jsx)(s.em,{children:"built-in classes"})," can be used as ",(0,i.jsx)(s.em,{children:"parameter specializers"})," in ",(0,i.jsx)(s.em,{children:"methods"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"structure-class"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"structure-class"}),", ",(0,i.jsx)(s.strong,{children:"class"}),", ",(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["All ",(0,i.jsx)(s.em,{children:"classes"})," defined by means of ",(0,i.jsx)(s.strong,{children:"defstruct"})," are ",(0,i.jsx)(s.em,{children:"instances"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"structure-class"}),". ",(0,i.jsx)(s.strong,{children:"standard-class"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-class"}),", ",(0,i.jsx)(s.strong,{children:"class"}),", ",(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-class"})," is the default ",(0,i.jsx)(s.em,{children:"class"})," of ",(0,i.jsx)(s.em,{children:"classes"})," defined by ",(0,i.jsx)(s.strong,{children:"defclass"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"method"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"method"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"method"})," is an ",(0,i.jsx)(s.em,{children:"object"})," that represents a modular part of the behavior of a ",(0,i.jsx)(s.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.em,{children:"method"})," contains ",(0,i.jsx)(s.em,{children:"code"})," to implement the ",(0,i.jsx)(s.em,{children:"method"}),"\u2019s behavior, a sequence of ",(0,i.jsx)(s.em,{children:"parameter specializers"})," that specify when the given ",(0,i.jsx)(s.em,{children:"method"})," is applicable, and a sequence of ",(0,i.jsx)(s.em,{children:"qualifiers"})," that is used by the method combination facility to distinguish among ",(0,i.jsx)(s.em,{children:"methods"}),". Each required parameter of each ",(0,i.jsx)(s.em,{children:"method"})," has an associated ",(0,i.jsx)(s.em,{children:"parameter specializer"})," , and the ",(0,i.jsx)(s.em,{children:"method"})," will be invoked only on arguments that satisfy its ",(0,i.jsx)(s.em,{children:"parameter specializers"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The method combination facility controls the selection of ",(0,i.jsx)(s.em,{children:"methods"}),", the order in which they are run, and the values that are returned by the generic function. The object system offers a default method combination type and provides a facility for declaring new types of method combination."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:"Section 7.6 (Generic Functions and Methods)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-method"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-method"}),", ",(0,i.jsx)(s.strong,{children:"method"}),", ",(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-method"})," is the default ",(0,i.jsx)(s.em,{children:"class"})," of ",(0,i.jsx)(s.em,{children:"methods"})," defined by the ",(0,i.jsx)(s.strong,{children:"defmethod"})," and ",(0,i.jsx)(s.strong,{children:"defgeneric"})," ",(0,i.jsx)(s.em,{children:"forms"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"structure-object"})," ",(0,i.jsx)(s.em,{children:"Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"structure-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"structure-object"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"structure-class"})," and is a ",(0,i.jsx)(s.em,{children:"superclass"})," of every ",(0,i.jsx)(s.em,{children:"class"})," that is an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"structure-class"})," except itself, and is a ",(0,i.jsx)(s.em,{children:"superclass"})," of every ",(0,i.jsx)(s.em,{children:"class"})," that is defined by ",(0,i.jsx)(s.strong,{children:"defstruct"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"defstruct"}),", Section 2.4.8.13 (Sharpsign S), Section 22.1.3.12 (Printing Structures)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-object"})," ",(0,i.jsx)(s.em,{children:"Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"standard-object"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"standard-object"})," is an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"standard-class"})," and is a ",(0,i.jsx)(s.em,{children:"superclass"})," of every ",(0,i.jsx)(s.em,{children:"class"})," that is an ",(0,i.jsx)(s.em,{children:"instance"})," of ",(0,i.jsx)(s.strong,{children:"standard-class"})," except itself."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"method-combination"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"method-combination"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Every ",(0,i.jsx)(s.em,{children:"method combination object"})," is an ",(0,i.jsx)(s.em,{children:"indirect instance"})," of the ",(0,i.jsx)(s.em,{children:"class"})," ",(0,i.jsx)(s.strong,{children:"method-combination"}),". A ",(0,i.jsx)(s.em,{children:"method combination object"})," represents the information about the ",(0,i.jsx)(s.em,{children:"method combination"})," being used by a ",(0,i.jsx)(s.em,{children:"generic function"}),". A ",(0,i.jsx)(s.em,{children:"method combination object"})," contains information about both the type of ",(0,i.jsx)(s.em,{children:"method combination"})," and the arguments being used with that ",(0,i.jsx)(s.em,{children:"type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"t"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"t"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The set of all ",(0,i.jsx)(s.em,{children:"objects"}),". The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"t"})," is a ",(0,i.jsx)(s.em,{children:"supertype"})," of every ",(0,i.jsx)(s.em,{children:"type"}),", including itself. Every ",(0,i.jsx)(s.em,{children:"object"})," is of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"t"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"satisfies"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Predicating."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(satisfies ",(0,i.jsx)(s.em,{children:"predicate-name"}),")"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"predicate-name"}),"\u2014a ",(0,i.jsx)(s.em,{children:"symbol"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This denotes the set of all ",(0,i.jsx)(s.em,{children:"objects"})," that satisfy the ",(0,i.jsx)(s.em,{children:"predicate predicate-name"}),", which must be a ",(0,i.jsx)(s.em,{children:"symbol"})," whose global ",(0,i.jsx)(s.em,{children:"function"})," definition is a one-argument predicate. A name is required for ",(0,i.jsx)(s.em,{children:"predicate-name"}),"; ",(0,i.jsx)(s.em,{children:"lambda expressions"})," are not allowed. For example, the ",(0,i.jsx)(s.em,{children:"type specifier"})," (and integer (satisfies evenp)) denotes the set of all even integers. The form (typep ",(0,i.jsx)(s.em,{children:"x"})," \u2019(satisfies ",(0,i.jsx)(s.em,{children:"p"}),")) is equivalent to (if (",(0,i.jsx)(s.em,{children:"p x"}),") t nil)."]}),"\n",(0,i.jsxs)(s.p,{children:["The argument is required. The ",(0,i.jsx)(s.em,{children:"symbol"})," ",(0,i.jsx)(s.strong,{children:"*"})," can be the argument, but it denotes itself (the ",(0,i.jsx)(s.em,{children:"symbol"})," ",(0,i.jsx)(s.strong,{children:"*"}),"), and does not represent an unspecified value."]}),"\n",(0,i.jsxs)(s.p,{children:["The symbol ",(0,i.jsx)(s.strong,{children:"satisfies"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"member"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Combining."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(member ",(0,i.jsx)(s.em,{children:"{object}"}),"*)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This denotes the set containing the named ",(0,i.jsx)(s.em,{children:"objects"}),". An ",(0,i.jsx)(s.em,{children:"object"})," is of this ",(0,i.jsx)(s.em,{children:"type"})," if and only if it is ",(0,i.jsx)(s.strong,{children:"eql"})," to one of the specified ",(0,i.jsx)(s.em,{children:"objects"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type specifiers"})," (member) and ",(0,i.jsx)(s.strong,{children:"nil"})," are equivalent. ",(0,i.jsx)(s.strong,{children:"*"})," can be among the ",(0,i.jsx)(s.em,{children:"objects"}),", but if so it denotes itself (the symbol ",(0,i.jsx)(s.strong,{children:"*"}),") and does not represent an unspecified value. The symbol ",(0,i.jsx)(s.strong,{children:"member"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," ; and, specifically, it is not an abbreviation for either (member) or (member *)."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:["the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"eql"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"not"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Combining."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(not ",(0,i.jsx)(s.em,{children:"typespec"}),")"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This denotes the set of all ",(0,i.jsx)(s.em,{children:"objects"})," that are not of the ",(0,i.jsx)(s.em,{children:"type typespec"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The argument is required, and cannot be ",(0,i.jsx)(s.strong,{children:"*"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The symbol ",(0,i.jsx)(s.strong,{children:"not"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"and"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Combining."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(and ",(0,i.jsx)(s.em,{children:"{typespec}"}),"*)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This denotes the set of all ",(0,i.jsx)(s.em,{children:"objects"})," of the ",(0,i.jsx)(s.em,{children:"type"})," determined by the intersection of the ",(0,i.jsx)(s.em,{children:"typespecs"}),". ",(0,i.jsx)(s.strong,{children:"*"})," is not permitted as an argument."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type specifiers"})," (and) and ",(0,i.jsx)(s.strong,{children:"t"})," are equivalent. The symbol ",(0,i.jsx)(s.strong,{children:"and"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," , and, specifically, it is not an abbreviation for (and)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"or"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Combining."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(or ",(0,i.jsx)(s.em,{children:"{typespec}"}),"*)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This denotes the set of all ",(0,i.jsx)(s.em,{children:"objects"})," of the ",(0,i.jsx)(s.em,{children:"type"})," determined by the union of the ",(0,i.jsx)(s.em,{children:"typespecs"}),". For example, the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"list"})," by definition is the same as (or null cons). Also, the value returned by ",(0,i.jsx)(s.strong,{children:"position"})," is an ",(0,i.jsx)(s.em,{children:"object"})," of ",(0,i.jsx)(s.em,{children:"type"})," (or null (integer 0 *)); ",(0,i.jsx)(s.em,{children:"i.e."}),", either ",(0,i.jsx)(s.strong,{children:"nil"})," or a non-negative ",(0,i.jsx)(s.em,{children:"integer"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"*"})," is not permitted as an argument."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type specifiers"})," (or) and ",(0,i.jsx)(s.strong,{children:"nil"})," are equivalent. The symbol ",(0,i.jsx)(s.strong,{children:"or"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," ; and, specifically, it is not an abbreviation for (or)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"values"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Specializing."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(values ",(0,i.jsx)(s.em,{children:"\u2193value-typespec"}),")"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"value-typespec::"}),"=",(0,i.jsx)(s.em,{children:"{typespec}"}),"* [&optional ",(0,i.jsx)(s.em,{children:"{typespec}"}),"*] [&rest ",(0,i.jsx)(s.em,{children:"typespec"}),"] [",(0,i.jsx)(s.strong,{children:"&allow-other-keys"}),"]"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["This ",(0,i.jsx)(s.em,{children:"type specifier"})," can be used only as the ",(0,i.jsx)(s.em,{children:"value-type"})," in a ",(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"type specifier"})," or a ",(0,i.jsx)(s.strong,{children:"the"})," ",(0,i.jsx)(s.em,{children:"special form"}),". It is used to specify individual ",(0,i.jsx)(s.em,{children:"types"})," when ",(0,i.jsx)(s.em,{children:"multiple values"})," are involved. The ",(0,i.jsx)(s.strong,{children:"&optional"})," and ",(0,i.jsx)(s.strong,{children:"&rest"})," markers can appear in the ",(0,i.jsx)(s.em,{children:"value-type"})," list; they indicate the parameter list of a ",(0,i.jsx)(s.em,{children:"function"})," that, when given to ",(0,i.jsx)(s.strong,{children:"multiple-value-call"})," along with the values, would correctly receive those values."]}),"\n",(0,i.jsxs)(s.p,{children:["The symbol ",(0,i.jsx)(s.strong,{children:"*"})," may not be among the ",(0,i.jsx)(s.em,{children:"value-types"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The symbol ",(0,i.jsx)(s.strong,{children:"values"})," is not valid as a ",(0,i.jsx)(s.em,{children:"type specifier"})," ; and, specifically, it is not an abbreviation for (values)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"eql"})," ",(0,i.jsx)(s.em,{children:"Type Specifier"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Kind:"})}),"\n",(0,i.jsx)(s.p,{children:"Combining."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:["(eql ",(0,i.jsx)(s.em,{children:"object"}),")"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Arguments:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Compound Type Specifier Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Represents the ",(0,i.jsx)(s.em,{children:"type"})," of all ",(0,i.jsx)(s.em,{children:"x"})," for which (eql ",(0,i.jsx)(s.em,{children:"object x"}),") is true."]}),"\n",(0,i.jsxs)(s.p,{children:["The argument ",(0,i.jsx)(s.em,{children:"object"})," is required. The ",(0,i.jsx)(s.em,{children:"object"})," can be ",(0,i.jsx)(s.strong,{children:"*"}),", but if so it denotes itself (the symbol ",(0,i.jsx)(s.strong,{children:"*"}),") and does not represent an unspecified value. The ",(0,i.jsx)(s.em,{children:"symbol"})," ",(0,i.jsx)(s.strong,{children:"eql"})," is not valid as an ",(0,i.jsx)(s.em,{children:"atomic type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"coerce"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"coerce"})," ",(0,i.jsx)(s.em,{children:"object result-type \u2192 result"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"result-type"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"result"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),", of ",(0,i.jsx)(s.em,{children:"type result-type"})," except in situations described in Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals)."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Coerces"})," the ",(0,i.jsx)(s.em,{children:"object"})," to ",(0,i.jsx)(s.em,{children:"type result-type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.em,{children:"object"})," is already of ",(0,i.jsx)(s.em,{children:"type result-type"}),", the ",(0,i.jsx)(s.em,{children:"object"})," itself is returned, regardless of whether it would have been possible in general to coerce an ",(0,i.jsx)(s.em,{children:"object"})," of some other ",(0,i.jsx)(s.em,{children:"type"})," to ",(0,i.jsx)(s.em,{children:"result-type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Otherwise, the ",(0,i.jsx)(s.em,{children:"object"})," is ",(0,i.jsx)(s.em,{children:"coerced"})," to ",(0,i.jsx)(s.em,{children:"type result-type"})," according to the following rules:"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"coerce"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"sequence"})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of ",(0,i.jsx)(s.strong,{children:"list"}),", and the ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"sequence"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is a ",(0,i.jsx)(s.em,{children:"list"})," that has the ",(0,i.jsx)(s.em,{children:"same elements"})," as ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of ",(0,i.jsx)(s.strong,{children:"vector"}),", and the ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"sequence"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is a ",(0,i.jsx)(s.em,{children:"vector"})," that has the ",(0,i.jsx)(s.em,{children:"same elements"})," as ",(0,i.jsx)(s.em,{children:"object"}),". If ",(0,i.jsx)(s.em,{children:"result-type"})," is a specialized ",(0,i.jsx)(s.em,{children:"type"}),", the ",(0,i.jsx)(s.em,{children:"result"})," has an ",(0,i.jsx)(s.em,{children:"actual array element type"})," that is the result of ",(0,i.jsx)(s.em,{children:"upgrading"})," the element type part of that ",(0,i.jsx)(s.em,{children:"specialized type"}),". If no element type is specified, the element type defaults to ",(0,i.jsx)(s.strong,{children:"t"}),". If the ",(0,i.jsx)(s.em,{children:"implementation"})," cannot determine the element type, an error is signaled."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"character"})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"character"})," and the ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"character designator"})," , the ",(0,i.jsx)(s.em,{children:"result"})," is the ",(0,i.jsx)(s.em,{children:"character"})," it denotes."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"complex"})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"complex"})," and the ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"real"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is obtained by constructing a ",(0,i.jsx)(s.em,{children:"complex"})," whose real part is the ",(0,i.jsx)(s.em,{children:"object"})," and whose imaginary part is the result of ",(0,i.jsx)(s.em,{children:"coercing"})," an ",(0,i.jsx)(s.em,{children:"integer"})," zero to the ",(0,i.jsx)(s.em,{children:"type"})," of the ",(0,i.jsx)(s.em,{children:"object"})," (using ",(0,i.jsx)(s.strong,{children:"coerce"}),"). (If the real part is a ",(0,i.jsx)(s.em,{children:"rational"}),", however, then the result must be represented as a ",(0,i.jsx)(s.em,{children:"rational"})," rather than a ",(0,i.jsx)(s.em,{children:"complex"})," ; see Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals). So, for example, (coerce 3 \u2019complex) is permissible, but will return 3, which is not a ",(0,i.jsx)(s.em,{children:"complex"})," .)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"float"})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is any of ",(0,i.jsx)(s.strong,{children:"float"}),", ",(0,i.jsx)(s.strong,{children:"short-float"}),", ",(0,i.jsx)(s.strong,{children:"single-float"}),", ",(0,i.jsx)(s.strong,{children:"double-float"}),", ",(0,i.jsx)(s.strong,{children:"long-float"}),", and the ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"real"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is a ",(0,i.jsx)(s.em,{children:"float"})," of ",(0,i.jsx)(s.em,{children:"type result-type"})," which is equal in sign and magnitude to the ",(0,i.jsx)(s.em,{children:"object"})," to whatever degree of representational precision is permitted by that ",(0,i.jsx)(s.em,{children:"float"})," representation. (If the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"float"})," and ",(0,i.jsx)(s.em,{children:"object"})," is not already a ",(0,i.jsx)(s.em,{children:"float"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is a ",(0,i.jsx)(s.em,{children:"single float"}),".)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"function"})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"function"}),", and ",(0,i.jsx)(s.em,{children:"object"})," is any ",(0,i.jsx)(s.em,{children:"function name"})," that is ",(0,i.jsx)(s.em,{children:"fbound"})," but that is globally defined neither as a ",(0,i.jsx)(s.em,{children:"macro name"})," nor as a ",(0,i.jsx)(s.em,{children:"special operator"})," , then the ",(0,i.jsx)(s.em,{children:"result"})," is the ",(0,i.jsx)(s.em,{children:"functional value"})," of ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"function"}),", and ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"lambda expression"}),", then the ",(0,i.jsx)(s.em,{children:"result"})," is a ",(0,i.jsx)(s.em,{children:"closure"})," of ",(0,i.jsx)(s.em,{children:"object"})," in the ",(0,i.jsx)(s.em,{children:"null lexical environment"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"t"})}),"\n",(0,i.jsxs)(s.p,{children:["Any ",(0,i.jsx)(s.em,{children:"object"})," can be ",(0,i.jsx)(s.em,{children:"coerced"})," to an ",(0,i.jsx)(s.em,{children:"object"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"t"}),". In this case, the ",(0,i.jsx)(s.em,{children:"object"})," is simply returned. ",(0,i.jsx)(s.strong,{children:"Examples:"})]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce \u2019(a b c) \u2019vector) ",(0,i.jsx)(s.em,{children:"\u2192"})," #(A B C)"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce \u2019a \u2019character) ",(0,i.jsx)(s.em,{children:"\u2192"})," #\\A"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 4.56 \u2019complex) ",(0,i.jsx)(s.em,{children:"\u2192"})," #C(4.56 0.0)"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 4.5s0 \u2019complex) ",(0,i.jsx)(s.em,{children:"\u2192"})," #C(4.5s0 0.0s0)"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 7/2 \u2019complex) ",(0,i.jsx)(s.em,{children:"\u2192"})," 7/2"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 0 \u2019short-float) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0.0s0"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 3.5L0 \u2019float) ",(0,i.jsx)(s.em,{children:"\u2192"})," 3.5L0"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce 7/2 \u2019float) ",(0,i.jsx)(s.em,{children:"\u2192"})," 3.5"]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce (cons 1 2) t) ",(0,i.jsx)(s.em,{children:"\u2192"})," (1 . 2)"]}),"\n",(0,i.jsxs)(s.p,{children:["All the following ",(0,i.jsx)(s.em,{children:"forms"})," should signal an error:"]}),"\n",(0,i.jsx)(s.p,{children:"(coerce \u2019(a b c) \u2019(vector * 4))"}),"\n",(0,i.jsx)(s.p,{children:"(coerce #(a b c) \u2019(vector * 4))"}),"\n",(0,i.jsx)(s.p,{children:"(coerce \u2019(a b c) \u2019(vector * 2))"}),"\n",(0,i.jsx)(s.p,{children:"(coerce #(a b c) \u2019(vector * 2))"}),"\n",(0,i.jsx)(s.p,{children:'(coerce "foo" \u2019(string 2))'}),"\n",(0,i.jsx)(s.p,{children:"(coerce #(#\\a #\\b #\\c) \u2019(string 2))"}),"\n",(0,i.jsx)(s.p,{children:"(coerce \u2019(0 1) \u2019(simple-bit-vector 3))"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["If a coercion is not possible, an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," is signaled."]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce x \u2019nil) always signals an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["An error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"})," is signaled if the ",(0,i.jsx)(s.em,{children:"result-type"})," is ",(0,i.jsx)(s.strong,{children:"function"})," but ",(0,i.jsx)(s.em,{children:"object"})," is a ",(0,i.jsx)(s.em,{children:"symbol"})," that is not ",(0,i.jsx)(s.em,{children:"fbound"})," or if the ",(0,i.jsx)(s.em,{children:"symbol"})," names a ",(0,i.jsx)(s.em,{children:"macro"})," or a ",(0,i.jsx)(s.em,{children:"special operator"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:["An error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," should be signaled if ",(0,i.jsx)(s.em,{children:"result-type"})," specifies the number of elements and ",(0,i.jsx)(s.em,{children:"object"})," is of a different length."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"rational"}),", ",(0,i.jsx)(s.strong,{children:"floor"}),", ",(0,i.jsx)(s.strong,{children:"char-code"}),", ",(0,i.jsx)(s.strong,{children:"char-int"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["Coercions from ",(0,i.jsx)(s.em,{children:"floats"})," to ",(0,i.jsx)(s.em,{children:"rationals"})," and from ",(0,i.jsx)(s.em,{children:"ratios"})," to ",(0,i.jsx)(s.em,{children:"integers"})," are not provided because of rounding problems."]}),"\n",(0,i.jsxs)(s.p,{children:["(coerce x \u2019t) ",(0,i.jsx)(s.em,{children:"\u2261"})," (identity x) ",(0,i.jsx)(s.em,{children:"\u2261"})," x"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"deftype"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"deftype"})," ",(0,i.jsx)(s.em,{children:"Macro"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"deftype"})," ",(0,i.jsx)(s.em,{children:"name lambda-list"})," [[ ",(0,i.jsx)(s.em,{children:"{declaration}"}),"* ",(0,i.jsx)(s.em,{children:"| documentation"})," ]] ",(0,i.jsx)(s.em,{children:"{form}"}),"* ",(0,i.jsx)(s.em,{children:"\u2192 name"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"name"}),"\u2014a ",(0,i.jsx)(s.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"lambda-list"}),"\u2014a ",(0,i.jsx)(s.em,{children:"deftype lambda list"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(s.strong,{children:"declare"})," ",(0,i.jsx)(s.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"documentation"}),"\u2014a ",(0,i.jsx)(s.em,{children:"string"}),"; not evaluated."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"form"}),"\u2014a ",(0,i.jsx)(s.em,{children:"form"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"deftype"})," defines a ",(0,i.jsx)(s.em,{children:"derived type specifier"})," named ",(0,i.jsx)(s.em,{children:"name"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The meaning of the new ",(0,i.jsx)(s.em,{children:"type specifier"})," is given in terms of a function which expands the ",(0,i.jsx)(s.em,{children:"type specifier"})," into another ",(0,i.jsx)(s.em,{children:"type specifier"})," , which itself will be expanded if it contains references to another ",(0,i.jsx)(s.em,{children:"derived type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:["The newly defined ",(0,i.jsx)(s.em,{children:"type specifier"})," may be referenced as a list of the form (",(0,i.jsx)(s.em,{children:"name arg"}),"<sub>1</sub> ",(0,i.jsx)(s.em,{children:"arg"}),"<sub>2</sub> ...). The number of arguments must be appropriate to the ",(0,i.jsx)(s.em,{children:"lambda-list"}),". If the new ",(0,i.jsx)(s.em,{children:"type specifier"})," takes no arguments, or if all of its arguments are optional, the ",(0,i.jsx)(s.em,{children:"type specifier"})," may be used as an ",(0,i.jsx)(s.em,{children:"atomic type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:"The <i>argument expressions</i> to the <i>type specifier</i> , <i>arg</i><sub>1</sub> <i>. . . arg<sub>n</sub></i>, are not <i>evaluated</i>. Instead, these <i>literal objects</i> become the <i>objects</i> to which corresponding <i>parameters</i> become <i>bound</i>."}),"\n",(0,i.jsxs)(s.p,{children:["The body of the ",(0,i.jsx)(s.strong,{children:"deftype"})," ",(0,i.jsx)(s.em,{children:"form"})," (but not the ",(0,i.jsx)(s.em,{children:"lambda-list"}),") is implicitly enclosed in a ",(0,i.jsx)(s.em,{children:"block"})," named ",(0,i.jsx)(s.em,{children:"name"}),", and is evaluated as an ",(0,i.jsx)(s.em,{children:"implicit progn"}),", returning a new ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"lexical environment"})," of the body is the one which was current at the time the ",(0,i.jsx)(s.strong,{children:"deftype"})," form was evaluated, augmented by the ",(0,i.jsx)(s.em,{children:"variables"})," in the ",(0,i.jsx)(s.em,{children:"lambda-list"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Recursive expansion of the ",(0,i.jsx)(s.em,{children:"type specifier"})," returned as the expansion must terminate, including the expansion of ",(0,i.jsx)(s.em,{children:"type specifiers"})," which are nested within the expansion."]}),"\n",(0,i.jsxs)(s.p,{children:["The consequences are undefined if the result of fully expanding a ",(0,i.jsx)(s.em,{children:"type specifier"})," contains any circular structure, except within the ",(0,i.jsx)(s.em,{children:"objects"})," referred to by ",(0,i.jsx)(s.strong,{children:"member"})," and ",(0,i.jsx)(s.strong,{children:"eql"})," ",(0,i.jsx)(s.em,{children:"type specifiers"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Documentation"})," is attached to ",(0,i.jsx)(s.em,{children:"name"})," as a ",(0,i.jsx)(s.em,{children:"documentation string"})," of kind ",(0,i.jsx)(s.strong,{children:"type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If a ",(0,i.jsx)(s.strong,{children:"deftype"})," ",(0,i.jsx)(s.em,{children:"form"})," appears as a ",(0,i.jsx)(s.em,{children:"top level form"}),", the ",(0,i.jsx)(s.em,{children:"compiler"})," must ensure that the ",(0,i.jsx)(s.em,{children:"name"})," is recognized in subsequent ",(0,i.jsx)(s.em,{children:"type"})," declarations. The ",(0,i.jsx)(s.em,{children:"programmer"})," must ensure that the body of a ",(0,i.jsx)(s.strong,{children:"deftype"})," form can be ",(0,i.jsx)(s.em,{children:"evaluated"})," at compile time if the ",(0,i.jsx)(s.em,{children:"name"})," is referenced in subsequent ",(0,i.jsx)(s.em,{children:"type"})," declarations. If the"]}),"\n",(0,i.jsxs)(s.p,{children:["expansion of a ",(0,i.jsx)(s.em,{children:"type specifier"})," is not defined fully at compile time (perhaps because it expands into an unknown ",(0,i.jsx)(s.em,{children:"type specifier"})," or a ",(0,i.jsx)(s.strong,{children:"satisfies"})," of a named ",(0,i.jsx)(s.em,{children:"function"})," that isn\u2019t defined in the compile-time environment), an ",(0,i.jsx)(s.em,{children:"implementation"})," may ignore any references to this ",(0,i.jsx)(s.em,{children:"type"})," in declarations and/or signal a warning."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(s.p,{children:"(defun equidimensional (a)"}),"\n",(0,i.jsx)(s.p,{children:"(or (< (array-rank a) 2)"}),"\n",(0,i.jsxs)(s.p,{children:["(apply #\u2019= (array-dimensions a)))) ",(0,i.jsx)(s.em,{children:"\u2192"})," EQUIDIMENSIONAL"]}),"\n",(0,i.jsx)(s.p,{children:"(deftype square-matrix (&optional type size)"}),"\n",(0,i.jsx)(s.p,{children:"\u2018(and (array ,type (,size ,size))"}),"\n",(0,i.jsxs)(s.p,{children:["(satisfies equidimensional))) ",(0,i.jsx)(s.em,{children:"\u2192"})," SQUARE-MATRIX"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"declare"}),", ",(0,i.jsx)(s.strong,{children:"defmacro"}),", ",(0,i.jsx)(s.strong,{children:"documentation"}),", Section 4.2.3 (Type Specifiers), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"subtypep"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"subtypep"})," ",(0,i.jsx)(s.em,{children:"type-1 type-2"})," &optional ",(0,i.jsx)(s.em,{children:"environment \u2192 subtype-p, valid-p"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"type-1"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"type-2"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"environment"}),"\u2014an ",(0,i.jsx)(s.em,{children:"environment object"}),". The default is ",(0,i.jsx)(s.strong,{children:"nil"}),", denoting the ",(0,i.jsx)(s.em,{children:"null lexical environment"})," and the current ",(0,i.jsx)(s.em,{children:"global environment"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"subtype-p"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"valid-p"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.em,{children:"type-1"})," is a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"}),", the first ",(0,i.jsx)(s.em,{children:"value"})," is ",(0,i.jsx)(s.em,{children:"true"}),". Otherwise, the first ",(0,i.jsx)(s.em,{children:"value"})," is ",(0,i.jsx)(s.em,{children:"false"}),", indicating that either ",(0,i.jsx)(s.em,{children:"type-1"})," is not a ",(0,i.jsx)(s.em,{children:"subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"}),", or else ",(0,i.jsx)(s.em,{children:"type-1"})," is a ",(0,i.jsx)(s.em,{children:"subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"})," but is not a ",(0,i.jsx)(s.em,{children:"recognizable subtype"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["A second ",(0,i.jsx)(s.em,{children:"value"})," is also returned indicating the \u2018certainty\u2019 of the first ",(0,i.jsx)(s.em,{children:"value"}),". If this value is ",(0,i.jsx)(s.em,{children:"true"}),", then the first value is an accurate indication of the ",(0,i.jsx)(s.em,{children:"subtype"})," relationship. (The second ",(0,i.jsx)(s.em,{children:"value"})," is always ",(0,i.jsx)(s.em,{children:"true"})," when the first ",(0,i.jsx)(s.em,{children:"value"})," is ",(0,i.jsx)(s.em,{children:"true"}),".)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"subtypep"})}),"\n",(0,i.jsxs)(s.p,{children:["Figure 4\u20139 summarizes the possible combinations of ",(0,i.jsx)(s.em,{children:"values"})," that might result."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsx)(s.tr,{children:(0,i.jsx)(s.th,{style:{textAlign:"left"},children:(0,i.jsx)(s.strong,{children:"Value 1 Value 2 Meaning"})})})}),(0,i.jsx)(s.tbody,{children:(0,i.jsx)(s.tr,{children:(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["<p>",(0,i.jsx)(s.em,{children:"true true type-1"})," is definitely a ",(0,i.jsx)(s.em,{children:"subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"}),". </p><p>",(0,i.jsx)(s.em,{children:"false true type-1"})," is definitely not a ",(0,i.jsx)(s.em,{children:"subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"}),". ",(0,i.jsx)(s.em,{children:"false false"})," ",(0,i.jsx)(s.strong,{children:"subtypep"})," could not determine the relationship, so ",(0,i.jsx)(s.em,{children:"type-1"})," might or might not be a ",(0,i.jsx)(s.em,{children:"subtype"})," of ",(0,i.jsx)(s.em,{children:"type-2"}),".</p>"]})})})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Figure 4\u20139. Result possibilities for subtypep"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"subtypep"})," is permitted to return the ",(0,i.jsx)(s.em,{children:"values false"})," and ",(0,i.jsx)(s.em,{children:"false"})," only when at least one argument involves one of these ",(0,i.jsx)(s.em,{children:"type specifiers"}),": ",(0,i.jsx)(s.strong,{children:"and"}),", ",(0,i.jsx)(s.strong,{children:"eql"}),", the list form of ",(0,i.jsx)(s.strong,{children:"function"}),", ",(0,i.jsx)(s.strong,{children:"member"}),", ",(0,i.jsx)(s.strong,{children:"not"}),", ",(0,i.jsx)(s.strong,{children:"or"}),", ",(0,i.jsx)(s.strong,{children:"satisfies"}),", or ",(0,i.jsx)(s.strong,{children:"values"}),". (A ",(0,i.jsx)(s.em,{children:"type specifier"})," \u2018involves\u2019 such a ",(0,i.jsx)(s.em,{children:"symbol"})," if, after being ",(0,i.jsx)(s.em,{children:"type expanded"}),", it contains that ",(0,i.jsx)(s.em,{children:"symbol"})," in a position that would call for its meaning as a ",(0,i.jsx)(s.em,{children:"type specifier"})," to be used.) One consequence of this is that if neither ",(0,i.jsx)(s.em,{children:"type-1"})," nor ",(0,i.jsx)(s.em,{children:"type-2"})," involves any of these ",(0,i.jsx)(s.em,{children:"type specifiers"}),", then ",(0,i.jsx)(s.strong,{children:"subtypep"})," is obliged to determine the relationship accurately. In particular, ",(0,i.jsx)(s.strong,{children:"subtypep"})," returns the ",(0,i.jsx)(s.em,{children:"values true"})," and ",(0,i.jsx)(s.em,{children:"true"})," if the arguments are ",(0,i.jsx)(s.strong,{children:"equal"})," and do not involve any of these ",(0,i.jsx)(s.em,{children:"type specifiers"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"subtypep"})," never returns a second value of ",(0,i.jsx)(s.strong,{children:"nil"})," when both ",(0,i.jsx)(s.em,{children:"type-1"})," and ",(0,i.jsx)(s.em,{children:"type-2"})," involve only the names in Figure 4\u20132, or names of ",(0,i.jsx)(s.em,{children:"types"})," defined by ",(0,i.jsx)(s.strong,{children:"defstruct"}),", ",(0,i.jsx)(s.strong,{children:"define-condition"}),", or ",(0,i.jsx)(s.strong,{children:"defclass"}),", or ",(0,i.jsx)(s.em,{children:"derived types"})," that expand into only those names. While ",(0,i.jsx)(s.em,{children:"type specifiers"})," listed in Figure 4\u20132 and names of ",(0,i.jsx)(s.strong,{children:"defclass"})," and ",(0,i.jsx)(s.strong,{children:"defstruct"})," can in some cases be implemented as ",(0,i.jsx)(s.em,{children:"derived types"}),", ",(0,i.jsx)(s.strong,{children:"subtypep"})," regards them as primitive."]}),"\n",(0,i.jsxs)(s.p,{children:["The relationships between ",(0,i.jsx)(s.em,{children:"types"})," reflected by ",(0,i.jsx)(s.strong,{children:"subtypep"})," are those specific to the particular implementation. For example, if an implementation supports only a single type of floating-point numbers, in that implementation (subtypep \u2019float \u2019long-float) returns the ",(0,i.jsx)(s.em,{children:"values true"})," and ",(0,i.jsx)(s.em,{children:"true"})," (since the two ",(0,i.jsx)(s.em,{children:"types"})," are identical)."]}),"\n",(0,i.jsxs)(s.p,{children:["For all ",(0,i.jsx)(s.em,{children:"T1"})," and ",(0,i.jsx)(s.em,{children:"T2"})," other than *, (array ",(0,i.jsx)(s.em,{children:"T1"}),") and (array ",(0,i.jsx)(s.em,{children:"T2"}),") are two different ",(0,i.jsx)(s.em,{children:"type spec ifiers"})," that always refer to the same sets of things if and only if they refer to ",(0,i.jsx)(s.em,{children:"arrays"})," of exactly the same specialized representation, ",(0,i.jsx)(s.em,{children:"i.e."}),", if (upgraded-array-element-type \u2019",(0,i.jsx)(s.em,{children:"T1"}),") and (upgraded-array-element-type \u2019",(0,i.jsx)(s.em,{children:"T2"}),") return two different ",(0,i.jsx)(s.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,i.jsx)(s.em,{children:"objects"}),". This is another way of saying that \u2018(array ",(0,i.jsx)(s.em,{children:"type-specifier"}),") and \u2018(array ,(upgraded-array-element-type \u2019",(0,i.jsx)(s.em,{children:"type-specifier"}),")) refer to the same set of specialized ",(0,i.jsx)(s.em,{children:"array"})," representations. For all ",(0,i.jsx)(s.em,{children:"T1"})," and ",(0,i.jsx)(s.em,{children:"T2"})," other than *, the intersection of (array ",(0,i.jsx)(s.em,{children:"T1"}),") and (array ",(0,i.jsx)(s.em,{children:"T2"}),") is the empty set if and only if they refer to ",(0,i.jsx)(s.em,{children:"arrays"})," of different, distinct specialized representations."]}),"\n",(0,i.jsx)(s.p,{children:"Therefore,"}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(array T1) \u2019(array T2)) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsx)(s.p,{children:"if and only if"}),"\n",(0,i.jsx)(s.p,{children:"(upgraded-array-element-type \u2019T1) and"}),"\n",(0,i.jsx)(s.p,{children:"(upgraded-array-element-type \u2019T2)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"subtypep"})}),"\n",(0,i.jsxs)(s.p,{children:["return two different ",(0,i.jsx)(s.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,i.jsx)(s.em,{children:"objects"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["For all type-specifiers ",(0,i.jsx)(s.em,{children:"T1"})," and ",(0,i.jsx)(s.em,{children:"T2"})," other than *,"]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(complex T1) \u2019(complex T2)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsx)(s.p,{children:"if:"}),"\n",(0,i.jsxs)(s.p,{children:["1. T1 is a ",(0,i.jsx)(s.em,{children:"subtype"})," of T2, or"]}),"\n",(0,i.jsxs)(s.p,{children:["2. (upgraded-complex-part-type \u2019",(0,i.jsx)(s.em,{children:"T1"}),") and (upgraded-complex-part-type \u2019",(0,i.jsx)(s.em,{children:"T2"}),") return two different ",(0,i.jsx)(s.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,i.jsx)(s.em,{children:"objects"}),"; in this case, (complex ",(0,i.jsx)(s.em,{children:"T1"}),") and (complex ",(0,i.jsx)(s.em,{children:"T2"}),") both refer to the same specialized representation."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"values"})," are ",(0,i.jsx)(s.em,{children:"false"})," and ",(0,i.jsx)(s.em,{children:"true"})," otherwise."]}),"\n",(0,i.jsx)(s.p,{children:"The form"}),"\n",(0,i.jsx)(s.p,{children:"(subtypep \u2019(complex single-float) \u2019(complex float))"}),"\n",(0,i.jsxs)(s.p,{children:["must return ",(0,i.jsx)(s.em,{children:"true"})," in all implementations, but"]}),"\n",(0,i.jsx)(s.p,{children:"(subtypep \u2019(array single-float) \u2019(array float))"}),"\n",(0,i.jsxs)(s.p,{children:["returns ",(0,i.jsx)(s.em,{children:"true"})," only in implementations that do not have a specialized ",(0,i.jsx)(s.em,{children:"array"})," representation for ",(0,i.jsx)(s.em,{children:"single floats"})," distinct from that for other ",(0,i.jsx)(s.em,{children:"floats"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019compiled-function \u2019function) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019null \u2019list) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019null \u2019symbol) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019integer \u2019string) ",(0,i.jsx)(s.em,{children:"\u2192 false"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(satisfies dummy) nil) ",(0,i.jsx)(s.em,{children:"\u2192 false"}),", ",(0,i.jsx)(s.em,{children:"implementation-dependent"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(integer 1 3) \u2019(integer 1 4)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(integer (0) (0)) \u2019nil) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019nil \u2019(integer (0) (0))) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(integer (0) (0)) \u2019(member)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})," ;or ",(0,i.jsx)(s.em,{children:"false"}),", ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(member) \u2019nil) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})," ;or ",(0,i.jsx)(s.em,{children:"false"}),", ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019nil \u2019(member)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})," ;or ",(0,i.jsx)(s.em,{children:"false"}),", ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["Let <aet-x> and <aet-y> be two distinct ",(0,i.jsx)(s.em,{children:"type specifiers"})," that do not always refer to the same sets of ",(0,i.jsx)(s.em,{children:"objects"})," in a given implementation, but for which ",(0,i.jsx)(s.strong,{children:"make-array"}),", will return an ",(0,i.jsx)(s.em,{children:"object"})," of the same ",(0,i.jsx)(s.em,{children:"array type"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Thus, in each case,"}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep (array-element-type (make-array 0 ",":element-type"," \u2019<aet-x>))"]}),"\n",(0,i.jsxs)(s.p,{children:["(array-element-type (make-array 0 ",":element-type"," \u2019<aet-y>)))"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep (array-element-type (make-array 0 ",":element-type"," \u2019<aet-y>))"]}),"\n",(0,i.jsxs)(s.p,{children:["(array-element-type (make-array 0 ",":element-type"," \u2019<aet-x>)))"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["If (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of ",(0,i.jsx)(s.em,{children:"objects"}),", these names should always refer to the same sets of ",(0,i.jsx)(s.em,{children:"objects"}),". That implies that the following set of tests are also true:"]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(array <aet-x>) \u2019(array <aet-y>)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep \u2019(array <aet-y>) \u2019(array <aet-x>)) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:"Section 4.2 (Types)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["The small differences between the ",(0,i.jsx)(s.strong,{children:"subtypep"})," specification for the ",(0,i.jsx)(s.strong,{children:"array"})," and ",(0,i.jsx)(s.strong,{children:"complex"})," types are necessary because there is no creation function for ",(0,i.jsx)(s.em,{children:"complexes"})," which allows the specification of the resultant part type independently of the actual types of the parts. Thus in the case of the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"complex"}),", the actual type of the parts is referred to, although a ",(0,i.jsx)(s.em,{children:"number"})," can be a member of more than one ",(0,i.jsx)(s.em,{children:"type"}),". For example, 17 is of ",(0,i.jsx)(s.em,{children:"type"})," (mod 18) as well as ",(0,i.jsx)(s.em,{children:"type"})," (mod 256) and ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"integer"}),"; and 2.3f5 is of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"single-float"})," as well as ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"float"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-of"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-of"})," ",(0,i.jsx)(s.em,{children:"object \u2192 typespec"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"typespec"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns a ",(0,i.jsx)(s.em,{children:"type specifier"})," , ",(0,i.jsx)(s.em,{children:"typespec"}),", for a ",(0,i.jsx)(s.em,{children:"type"})," that has the ",(0,i.jsx)(s.em,{children:"object"})," as an ",(0,i.jsx)(s.em,{children:"element"}),". The ",(0,i.jsx)(s.em,{children:"typespec"})," satisfies the following:"]}),"\n",(0,i.jsxs)(s.p,{children:["1. For any ",(0,i.jsx)(s.em,{children:"object"})," that is an ",(0,i.jsx)(s.em,{children:"element"})," of some ",(0,i.jsx)(s.em,{children:"built-in type"}),":"]}),"\n",(0,i.jsxs)(s.p,{children:["a. the ",(0,i.jsx)(s.em,{children:"type"})," returned is a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of that ",(0,i.jsx)(s.em,{children:"built-in type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["b. the ",(0,i.jsx)(s.em,{children:"type"})," returned does not involve and, eql, member, not, or, satisfies, or values."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"type-of"})}),"\n",(0,i.jsxs)(s.p,{children:["2. For all ",(0,i.jsx)(s.em,{children:"objects"}),", (typep ",(0,i.jsx)(s.em,{children:"object"})," (type-of ",(0,i.jsx)(s.em,{children:"object"}),")) returns ",(0,i.jsx)(s.em,{children:"true"}),". Implicit in this is that ",(0,i.jsx)(s.em,{children:"type specifiers"})," which are not valid for use with ",(0,i.jsx)(s.strong,{children:"typep"}),", such as the ",(0,i.jsx)(s.em,{children:"list"})," form of the ",(0,i.jsx)(s.strong,{children:"function"})," ",(0,i.jsx)(s.em,{children:"type specifier"})," , are never returned by ",(0,i.jsx)(s.strong,{children:"type-of"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["3. The ",(0,i.jsx)(s.em,{children:"type"})," returned by ",(0,i.jsx)(s.strong,{children:"type-of"})," is always a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of the ",(0,i.jsx)(s.em,{children:"class"})," returned by ",(0,i.jsx)(s.strong,{children:"class-of"}),". That is,"]}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep (type-of ",(0,i.jsx)(s.em,{children:"object"}),") (class-of ",(0,i.jsx)(s.em,{children:"object"}),")) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["4. For ",(0,i.jsx)(s.em,{children:"objects"})," of metaclass ",(0,i.jsx)(s.strong,{children:"structure-class"})," or ",(0,i.jsx)(s.strong,{children:"standard-class"}),", and for ",(0,i.jsx)(s.em,{children:"conditions"}),", ",(0,i.jsx)(s.strong,{children:"type-of"})," returns the ",(0,i.jsx)(s.em,{children:"proper name"})," of the ",(0,i.jsx)(s.em,{children:"class"})," returned by ",(0,i.jsx)(s.strong,{children:"class-of"})," if it has a ",(0,i.jsx)(s.em,{children:"proper name"}),", and otherwise returns the ",(0,i.jsx)(s.em,{children:"class"})," itself. In particular, for ",(0,i.jsx)(s.em,{children:"objects"})," created by the constructor function of a structure defined with ",(0,i.jsx)(s.strong,{children:"defstruct"})," without a ",":type"," option, ",(0,i.jsx)(s.strong,{children:"type-of"})," returns the structure name; and for ",(0,i.jsx)(s.em,{children:"objects"})," created by ",(0,i.jsx)(s.strong,{children:"make-condition"}),", the ",(0,i.jsx)(s.em,{children:"typespec"})," is the ",(0,i.jsx)(s.em,{children:"name"})," of the ",(0,i.jsx)(s.em,{children:"condition type"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["5. For each of the ",(0,i.jsx)(s.em,{children:"types"})," ",(0,i.jsx)(s.strong,{children:"short-float"}),", ",(0,i.jsx)(s.strong,{children:"single-float"}),", ",(0,i.jsx)(s.strong,{children:"double-float"}),", or ",(0,i.jsx)(s.strong,{children:"long-float"})," of which the ",(0,i.jsx)(s.em,{children:"object"})," is an ",(0,i.jsx)(s.em,{children:"element"}),", the ",(0,i.jsx)(s.em,{children:"typespec"})," is a ",(0,i.jsx)(s.em,{children:"recognizable subtype"})," of that ",(0,i.jsx)(s.em,{children:"type"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(type-of \u2019a) ",(0,i.jsx)(s.em,{children:"\u2192"})," SYMBOL"]}),"\n",(0,i.jsx)(s.p,{children:"(type-of \u2019(1 . 2))"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," CONS"]}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> (CONS FIXNUM FIXNUM)"}),"\n",(0,i.jsx)(s.p,{children:"(type-of #c(0 1))"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," COMPLEX"]}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> (COMPLEX INTEGER)"}),"\n",(0,i.jsxs)(s.p,{children:["(defstruct temp-struct x y z) ",(0,i.jsx)(s.em,{children:"\u2192"})," TEMP-STRUCT"]}),"\n",(0,i.jsxs)(s.p,{children:["(type-of (make-temp-struct)) ",(0,i.jsx)(s.em,{children:"\u2192"})," TEMP-STRUCT"]}),"\n",(0,i.jsx)(s.p,{children:'(type-of "abc")'}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," STRING"]}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> (STRING 3)"}),"\n",(0,i.jsxs)(s.p,{children:['(subtypep (type-of "abc") \u2019string) ',(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsx)(s.p,{children:"(type-of (expt 2 40))"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," BIGNUM"]}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> INTEGER"}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> (INTEGER 1099511627776 1099511627776)"}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> SYSTEM::TWO-WORD-BIGNUM"}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> FIXNUM"}),"\n",(0,i.jsxs)(s.p,{children:["(subtypep (type-of 112312) \u2019integer) ",(0,i.jsx)(s.em,{children:"\u2192 true"}),", ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(defvar *foo* (make-array 5 ",":element-type"," t)) ",(0,i.jsx)(s.em,{children:"\u2192"})," *FOO*"]}),"\n",(0,i.jsxs)(s.p,{children:["(class-name (class-of *foo*)) ",(0,i.jsx)(s.em,{children:"\u2192"})," VECTOR"]}),"\n",(0,i.jsx)(s.p,{children:"(type-of *foo*)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," VECTOR"]}),"\n",(0,i.jsx)(s.p,{children:"<i><sup>or</sup>\u2192</i> (VECTOR T 5)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"array-element-type"}),", ",(0,i.jsx)(s.strong,{children:"class-of"}),", ",(0,i.jsx)(s.strong,{children:"defstruct"}),", ",(0,i.jsx)(s.strong,{children:"typecase"}),", ",(0,i.jsx)(s.strong,{children:"typep"}),", Section 4.2 (Types)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["Implementors are encouraged to arrange for ",(0,i.jsx)(s.strong,{children:"type-of"})," to return a portable value."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"typep"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"typep"})," ",(0,i.jsx)(s.em,{children:"object type-specifier"})," &optional ",(0,i.jsx)(s.em,{children:"environment \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"type-specifier"}),"\u2014any ",(0,i.jsx)(s.em,{children:"type specifier"})," except ",(0,i.jsx)(s.strong,{children:"values"}),", or a ",(0,i.jsx)(s.em,{children:"type specifier"})," list whose first element is either ",(0,i.jsx)(s.strong,{children:"function"})," or ",(0,i.jsx)(s.strong,{children:"values"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"environment"}),"\u2014an ",(0,i.jsx)(s.em,{children:"environment object"}),". The default is ",(0,i.jsx)(s.strong,{children:"nil"}),", denoting the ",(0,i.jsx)(s.em,{children:"null lexical environment"})," and the and current ",(0,i.jsx)(s.em,{children:"global environment"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns ",(0,i.jsx)(s.em,{children:"true"})," if ",(0,i.jsx)(s.em,{children:"object"})," is of the ",(0,i.jsx)(s.em,{children:"type"})," specified by ",(0,i.jsx)(s.em,{children:"type-specifier"}),"; otherwise, returns ",(0,i.jsx)(s.em,{children:"false"}),". A ",(0,i.jsx)(s.em,{children:"type-specifier"})," of the form (satisfies fn) is handled by applying the function fn to ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["(typep ",(0,i.jsx)(s.em,{children:"object"})," \u2019(array ",(0,i.jsx)(s.em,{children:"type-specifier"}),")), where ",(0,i.jsx)(s.em,{children:"type-specifier"})," is not *, returns ",(0,i.jsx)(s.em,{children:"true"})," if and only if ",(0,i.jsx)(s.em,{children:"object"})," is an ",(0,i.jsx)(s.em,{children:"array"})," that could be the result of supplying ",(0,i.jsx)(s.em,{children:"type-specifier"})," as the ",":element-type"," argument to ",(0,i.jsx)(s.strong,{children:"make-array"}),". (array *) refers to all ",(0,i.jsx)(s.em,{children:"arrays"})," regardless of element type, while (array ",(0,i.jsx)(s.em,{children:"type-specifier"}),") refers only to those ",(0,i.jsx)(s.em,{children:"arrays"})," that can result from giving ",(0,i.jsx)(s.em,{children:"type-specifier"})," as the ",":element-type"," argument to ",(0,i.jsx)(s.strong,{children:"make-array"}),". A similar interpretation applies to (simple-array ",(0,i.jsx)(s.em,{children:"type-specifier"}),") and (vector ",(0,i.jsx)(s.em,{children:"type-specifier"}),"). See Section 15.1.2.1 (Array Upgrading)."]}),"\n",(0,i.jsxs)(s.p,{children:["(typep ",(0,i.jsx)(s.em,{children:"object"})," \u2019(complex ",(0,i.jsx)(s.em,{children:"type-specifier"}),")) returns ",(0,i.jsx)(s.em,{children:"true"})," for all ",(0,i.jsx)(s.em,{children:"complex"})," numbers that can result from giving ",(0,i.jsx)(s.em,{children:"numbers"})," of type ",(0,i.jsx)(s.em,{children:"type-specifier"})," to the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"complex"}),", plus all other ",(0,i.jsx)(s.em,{children:"complex"})," numbers of the same specialized representation. Both the real and the imaginary parts of any such ",(0,i.jsx)(s.em,{children:"complex"})," number must satisfy:"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"typep"})}),"\n",(0,i.jsx)(s.p,{children:"(typep realpart \u2019type-specifier)"}),"\n",(0,i.jsx)(s.p,{children:"(typep imagpart \u2019type-specifier)"}),"\n",(0,i.jsxs)(s.p,{children:["See the ",(0,i.jsx)(s.em,{children:"function"})," ",(0,i.jsx)(s.strong,{children:"upgraded-complex-part-type"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(typep 12 \u2019integer) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(typep (1+ most-positive-fixnum) \u2019fixnum) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(typep nil t) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(typep nil nil) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(typep 1 \u2019(mod 2)) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(typep #c(1 1) \u2019(complex (eql 1))) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsx)(s.p,{children:";; To understand this next example, you might need to refer to"}),"\n",(0,i.jsxs)(s.p,{children:[";; Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals). (typep #c(0 0) \u2019(complex (eql 0))) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsx)(s.p,{children:"Let A<i><sub>x</sub></i> and A<i><sub>y</sub></i> be two <i>type specifiers</i> that denote different <i>types</i>, but for which"}),"\n",(0,i.jsx)(s.p,{children:"(upgraded-array-element-type \u2019A<i><sub>x</sub></i>)"}),"\n",(0,i.jsx)(s.p,{children:"and"}),"\n",(0,i.jsx)(s.p,{children:"(upgraded-array-element-type \u2019A<i><sub>y</sub></i>)"}),"\n",(0,i.jsxs)(s.p,{children:["denote the same ",(0,i.jsx)(s.em,{children:"type"}),". Notice that"]}),"\n",(0,i.jsxs)(s.p,{children:["(typep (make-array 0 ",":element-type"," \u2019A<i><sub>x</sub></i>) \u2019(array A<i><sub>x</sub></i>)) <i>\u2192 true</i>"]}),"\n",(0,i.jsxs)(s.p,{children:["(typep (make-array 0 ",":element-type"," \u2019A<i><sub>y</sub></i>) \u2019(array A<i><sub>y</sub></i>)) <i>\u2192 true</i>"]}),"\n",(0,i.jsxs)(s.p,{children:["(typep (make-array 0 ",":element-type"," \u2019A<i><sub>x</sub></i>) \u2019(array A<i><sub>y</sub></i>)) <i>\u2192 true</i>"]}),"\n",(0,i.jsxs)(s.p,{children:["(typep (make-array 0 ",":element-type"," \u2019A<i><sub>y</sub></i>) \u2019(array A<i><sub>x</sub></i>)) <i>\u2192 true</i>"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["An error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"error"})," is signaled if ",(0,i.jsx)(s.em,{children:"type-specifier"})," is values, or a ",(0,i.jsx)(s.em,{children:"type specifier"})," list whose first element is either ",(0,i.jsx)(s.strong,{children:"function"})," or ",(0,i.jsx)(s.strong,{children:"values"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The consequences are undefined if the ",(0,i.jsx)(s.em,{children:"type-specifier"})," is not a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-of"}),", ",(0,i.jsx)(s.strong,{children:"upgraded-array-element-type"}),", ",(0,i.jsx)(s.strong,{children:"upgraded-complex-part-type"}),", Section 4.2.3 (Type Specifiers)"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Implementations"})," are encouraged to recognize and optimize the case of (typep ",(0,i.jsx)(s.em,{children:"x"})," (the class ",(0,i.jsx)(s.em,{children:"y"}),")), since it does not involve any need for expansion of ",(0,i.jsx)(s.strong,{children:"deftype"})," information at runtime."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error"})," ",(0,i.jsx)(s.em,{children:"Condition Type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error"}),", ",(0,i.jsx)(s.strong,{children:"error"}),", ",(0,i.jsx)(s.strong,{children:"serious-condition"}),", ",(0,i.jsx)(s.strong,{children:"condition"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," represents a situation in which an ",(0,i.jsx)(s.em,{children:"object"})," is not of the expected type. The \u201coffending datum\u201d and \u201cexpected type\u201d are initialized by the initialization arguments named ",":datum"," and ",":expected-type"," to ",(0,i.jsx)(s.strong,{children:"make-condition"}),", and are ",(0,i.jsx)(s.em,{children:"accessed"})," by the functions ",(0,i.jsx)(s.strong,{children:"type-error-datum"})," and ",(0,i.jsx)(s.strong,{children:"type-error-expected-type"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-datum"}),", ",(0,i.jsx)(s.strong,{children:"type-error-expected-type"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-datum, type-error-expected-type"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-datum"})," ",(0,i.jsx)(s.em,{children:"condition \u2192 datum"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-expected-type"})," ",(0,i.jsx)(s.em,{children:"condition \u2192 expected-type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"condition"}),"\u2014a ",(0,i.jsx)(s.em,{children:"condition"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"datum"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"expected-type"}),"\u2014a ",(0,i.jsx)(s.em,{children:"type specifier"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-datum"})," returns the offending datum in the ",(0,i.jsx)(s.em,{children:"situation"})," represented by the ",(0,i.jsx)(s.em,{children:"condition"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error-expected-type"})," returns the expected type of the offending datum in the ",(0,i.jsx)(s.em,{children:"situation"})," represented by the ",(0,i.jsx)(s.em,{children:"condition"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(s.p,{children:"(defun fix-digits (condition)"}),"\n",(0,i.jsx)(s.p,{children:"(check-type condition type-error)"}),"\n",(0,i.jsx)(s.p,{children:"(let* ((digits \u2019(zero one two three four"}),"\n",(0,i.jsx)(s.p,{children:"five six seven eight nine))"}),"\n",(0,i.jsx)(s.p,{children:"(val (position (type-error-datum condition) digits)))"}),"\n",(0,i.jsx)(s.p,{children:"(if (and val (subtypep \u2019fixnum (type-error-expected-type condition)))"}),"\n",(0,i.jsx)(s.p,{children:"(store-value 7))))"}),"\n",(0,i.jsx)(s.p,{children:"(defun foo (x)"}),"\n",(0,i.jsx)(s.p,{children:"(handler-bind ((type-error #\u2019fix-digits))"}),"\n",(0,i.jsx)(s.p,{children:"(check-type x number)"}),"\n",(0,i.jsx)(s.p,{children:"(+ x 3)))"}),"\n",(0,i.jsx)(s.p,{children:"(foo \u2019seven)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," 10"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"type-error"}),", Chapter 9 (Conditions)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"simple-type-error"})," ",(0,i.jsx)(s.em,{children:"Condition Type"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"simple-type-error"}),", ",(0,i.jsx)(s.strong,{children:"simple-condition"}),", ",(0,i.jsx)(s.strong,{children:"type-error"}),", ",(0,i.jsx)(s.strong,{children:"error"}),", ",(0,i.jsx)(s.strong,{children:"serious-condition"}),", ",(0,i.jsx)(s.strong,{children:"condition"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Conditions"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"simple-type-error"})," are like ",(0,i.jsx)(s.em,{children:"conditions"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"}),", except that they provide an alternate mechanism for specifying how the ",(0,i.jsx)(s.em,{children:"condition"})," is to be ",(0,i.jsx)(s.em,{children:"reported"}),"; see the ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"simple-condition"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"simple-condition"}),", ",(0,i.jsx)(s.strong,{children:"simple-condition-format-control"}),", ",(0,i.jsx)(s.strong,{children:"simple-condition-format-arguments"}),", ",(0,i.jsx)(s.strong,{children:"type-error-datum"}),", ",(0,i.jsx)(s.strong,{children:"type-error-expected-type"})]})]})}function N(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(L,{...e})}):L(e)}const M={title:"4.3 Classes"},P="4.3 Classes",O={id:"chap-4/e-d-classes",title:"4.3 Classes",description:"4.3.1 Introduction to Classes",source:"@site/docs/chap-4/e-d-classes.md",sourceDirName:"chap-4",slug:"/chap-4/e-d-classes",permalink:"/cl-language-reference/docs/chap-4/e-d-classes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chap-4/e-d-classes.md",tags:[],version:"current",frontMatter:{title:"4.3 Classes"},sidebar:"tutorialSidebar",previous:{title:"4.2 Types",permalink:"/cl-language-reference/docs/chap-4/e-c-types"},next:{title:"intro",permalink:"/cl-language-reference/docs/chap-4/intro"}},W={},U=[{value:"4.3.1 Introduction to Classes",id:"431-introduction-to-classes",level:2},{value:"4.3.1.1 Standard Metaclasses",id:"4311-standard-metaclasses",level:3},{value:"4.3.2 Defining Classes",id:"432-defining-classes",level:2},{value:"4.3.3 Creating Instances of Classes",id:"433-creating-instances-of-classes",level:2},{value:"4.3.4 Inheritance",id:"434-inheritance",level:2},{value:"4.3.4.1 Examples of Inheritance",id:"4341-examples-of-inheritance",level:3},{value:"4.3.4.2 Inheritance of Class Options",id:"4342-inheritance-of-class-options",level:3},{value:"4.3.5 Determining the Class Precedence List",id:"435-determining-the-class-precedence-list",level:2},{value:"4.3.5.1 Topological Sorting",id:"4351-topological-sorting",level:3},{value:"4.3.5.2 Examples of Class Precedence List Determination",id:"4352-examples-of-class-precedence-list-determination",level:3},{value:"4.3.6 Redefining Classes",id:"436-redefining-classes",level:2},{value:"4.3.6.1 Modifying the Structure of Instances",id:"4361-modifying-the-structure-of-instances",level:3},{value:"4.3.6.2 Initializing Newly Added Local Slots",id:"4362-initializing-newly-added-local-slots",level:3},{value:"4.3.6.3 Customizing Class Redefinition",id:"4363-customizing-class-redefinition",level:3},{value:"4.3.7 Integrating Types and Classes",id:"437-integrating-types-and-classes",level:2}];function V(e){const s={h1:"h1",h2:"h2",h3:"h3",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"43-classes",children:"4.3 Classes"}),"\n","\n",(0,i.jsx)(c,{}),"\n",(0,i.jsx)(s.h2,{id:"431-introduction-to-classes",children:"4.3.1 Introduction to Classes"}),"\n","\n",(0,i.jsx)(d,{}),"\n",(0,i.jsx)(s.h3,{id:"4311-standard-metaclasses",children:"4.3.1.1 Standard Metaclasses"}),"\n","\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(s.h2,{id:"432-defining-classes",children:"4.3.2 Defining Classes"}),"\n","\n",(0,i.jsx)(x,{}),"\n",(0,i.jsx)(s.h2,{id:"433-creating-instances-of-classes",children:"4.3.3 Creating Instances of Classes"}),"\n","\n",(0,i.jsx)(p,{}),"\n",(0,i.jsx)(s.h2,{id:"434-inheritance",children:"4.3.4 Inheritance"}),"\n","\n",(0,i.jsx)(f,{}),"\n",(0,i.jsx)(s.h3,{id:"4341-examples-of-inheritance",children:"4.3.4.1 Examples of Inheritance"}),"\n","\n",(0,i.jsx)(g,{}),"\n",(0,i.jsx)(s.h3,{id:"4342-inheritance-of-class-options",children:"4.3.4.2 Inheritance of Class Options"}),"\n","\n",(0,i.jsx)(b,{}),"\n",(0,i.jsx)(s.h2,{id:"435-determining-the-class-precedence-list",children:"4.3.5 Determining the Class Precedence List"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(s.h3,{id:"4351-topological-sorting",children:"4.3.5.1 Topological Sorting"}),"\n","\n",(0,i.jsx)(C,{}),"\n",(0,i.jsx)(s.h3,{id:"4352-examples-of-class-precedence-list-determination",children:"4.3.5.2 Examples of Class Precedence List Determination"}),"\n","\n",(0,i.jsx)(I,{}),"\n",(0,i.jsx)(s.h2,{id:"436-redefining-classes",children:"4.3.6 Redefining Classes"}),"\n","\n",(0,i.jsx)(z,{}),"\n",(0,i.jsx)(s.h3,{id:"4361-modifying-the-structure-of-instances",children:"4.3.6.1 Modifying the Structure of Instances"}),"\n","\n",(0,i.jsx)(R,{}),"\n",(0,i.jsx)(s.h3,{id:"4362-initializing-newly-added-local-slots",children:"4.3.6.2 Initializing Newly Added Local Slots"}),"\n","\n",(0,i.jsx)(D,{}),"\n",(0,i.jsx)(s.h3,{id:"4363-customizing-class-redefinition",children:"4.3.6.3 Customizing Class Redefinition"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(s.h2,{id:"437-integrating-types-and-classes",children:"4.3.7 Integrating Types and Classes"}),"\n","\n","\n",(0,i.jsx)(N,{})]})}function K(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(V,{...e})}):V(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>l,a:()=>c});var i=n(7294);const r={},t=i.createContext(r);function c(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);