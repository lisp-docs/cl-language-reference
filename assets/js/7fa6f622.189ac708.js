"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[2591],{58292:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>p,frontMatter:()=>d,metadata:()=>o,toc:()=>x});var r=i(85893),s=i(11151);function c(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"define-compiler-macro"})," ",(0,r.jsx)(n.em,{children:"Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"define-compiler-macro"})," ",(0,r.jsx)(n.em,{children:"name lambda-list"})," [[ ",(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"| documentation"})," ]] ",(0,r.jsx)(n.em,{children:"{form}"}),"* ",(0,r.jsx)(n.em,{children:"\u2192 name"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"name"}),"\u2014a ",(0,r.jsx)(n.em,{children:"function name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"lambda-list"}),"\u2014a ",(0,r.jsx)(n.em,{children:"macro lambda list"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,r.jsx)(n.strong,{children:"declare"})," ",(0,r.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"documentation"}),"\u2014a ",(0,r.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["This is the normal mechanism for defining a ",(0,r.jsx)(n.em,{children:"compiler macro function"}),". Its manner of definition is the same as for ",(0,r.jsx)(n.strong,{children:"defmacro"}),"; the only differences are:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",(0,r.jsx)(n.em,{children:"name"})," can be a ",(0,r.jsx)(n.em,{children:"function name"})," naming any ",(0,r.jsx)(n.em,{children:"function"})," or ",(0,r.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The expander function is installed as a ",(0,r.jsx)(n.em,{children:"compiler macro function"})," for the ",(0,r.jsx)(n.em,{children:"name"}),", rather than as a ",(0,r.jsx)(n.em,{children:"macro function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",(0,r.jsx)(n.strong,{children:"&whole"})," argument is bound to the form argument that is passed to the ",(0,r.jsx)(n.em,{children:"compiler macro function"}),". The remaining lambda-list parameters are specified as if this form contained the function name in the ",(0,r.jsx)(n.em,{children:"car"})," and the actual arguments in the ",(0,r.jsx)(n.em,{children:"cdr"})," , but if the ",(0,r.jsx)(n.em,{children:"car"})," of the actual form is the symbol ",(0,r.jsx)(n.strong,{children:"funcall"}),", then the destructuring of the arguments is actually performed using its ",(0,r.jsx)(n.em,{children:"cddr"})," instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022 Documentation"})," is attached as a ",(0,r.jsx)(n.em,{children:"documentation string"})," to ",(0,r.jsx)(n.em,{children:"name"})," (as kind ",(0,r.jsx)(n.strong,{children:"compiler-macro"}),") and to the ",(0,r.jsx)(n.em,{children:"compiler macro function"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"define-compiler-macro"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Unlike an ordinary ",(0,r.jsx)(n.em,{children:"macro"}),", a ",(0,r.jsx)(n.em,{children:"compiler macro"})," can decline to provide an expansion merely by returning a form that is the ",(0,r.jsx)(n.em,{children:"same"})," as the original (which can be obtained by using ",(0,r.jsx)(n.strong,{children:"&whole"}),")."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["(defun square (x) (expt x 2)) ",(0,r.jsx)(n.em,{children:"\u2192"})," SQUARE"]}),"\n",(0,r.jsx)(n.p,{children:"(define-compiler-macro square (&whole form arg)"}),"\n",(0,r.jsx)(n.p,{children:"(if (atom arg)"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(expt ,arg 2)"}),"\n",(0,r.jsx)(n.p,{children:"(case (car arg)"}),"\n",(0,r.jsx)(n.p,{children:"(square (if (= (length arg) 2)"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(expt ,(nth 1 arg) 4)"}),"\n",(0,r.jsx)(n.p,{children:"form))"}),"\n",(0,r.jsx)(n.p,{children:"(expt (if (= (length arg) 3)"}),"\n",(0,r.jsx)(n.p,{children:"(if (numberp (nth 2 arg))"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))"}),"\n",(0,r.jsx)(n.p,{children:"form))"}),"\n",(0,r.jsxs)(n.p,{children:["(otherwise \u2018(expt ,arg 2))))) ",(0,r.jsx)(n.em,{children:"\u2192"})," SQUARE"]}),"\n",(0,r.jsxs)(n.p,{children:["(square (square 3)) ",(0,r.jsx)(n.em,{children:"\u2192"})," 81"]}),"\n",(0,r.jsxs)(n.p,{children:["(macroexpand \u2019(square x)) ",(0,r.jsx)(n.em,{children:"\u2192"})," (SQUARE X), ",(0,r.jsx)(n.em,{children:"false"})]}),"\n",(0,r.jsx)(n.p,{children:"(funcall (compiler-macro-function \u2019square) \u2019(square x) nil)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (EXPT X 2)"]}),"\n",(0,r.jsx)(n.p,{children:"(funcall (compiler-macro-function \u2019square) \u2019(square (square x)) nil)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (EXPT X 4)"]}),"\n",(0,r.jsx)(n.p,{children:"(funcall (compiler-macro-function \u2019square) \u2019(funcall #\u2019square x) nil)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (EXPT X 2)"]}),"\n",(0,r.jsx)(n.p,{children:"(defun distance-positional (x1 y1 x2 y2)"}),"\n",(0,r.jsx)(n.p,{children:"(sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," DISTANCE-POSITIONAL"]}),"\n",(0,r.jsx)(n.p,{children:"(defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))"}),"\n",(0,r.jsx)(n.p,{children:"(distance-positional x1 y1 x2 y2))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," DISTANCE"]}),"\n",(0,r.jsx)(n.p,{children:"(define-compiler-macro distance (&whole form"}),"\n",(0,r.jsx)(n.p,{children:"&rest key-value-pairs"}),"\n",(0,r.jsx)(n.p,{children:"&key (x1 0 x1-p)"}),"\n",(0,r.jsx)(n.p,{children:"(y1 0 y1-p)"}),"\n",(0,r.jsx)(n.p,{children:"(x2 x1 x2-p)"}),"\n",(0,r.jsx)(n.p,{children:"(y2 y1 y2-p)"}),"\n",(0,r.jsx)(n.p,{children:"&allow-other-keys"}),"\n",(0,r.jsx)(n.p,{children:"&environment env)"}),"\n",(0,r.jsx)(n.p,{children:"(flet ((key (n) (nth (* n 2) key-value-pairs))"}),"\n",(0,r.jsx)(n.p,{children:"(arg (n) (nth (1+ (* n 2)) key-value-pairs))"}),"\n",(0,r.jsx)(n.p,{children:"(simplep (x)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"define-compiler-macro"})}),"\n",(0,r.jsx)(n.p,{children:"(let ((expanded-x (macroexpand x env)))"}),"\n",(0,r.jsx)(n.p,{children:"(or (constantp expanded-x env)"}),"\n",(0,r.jsx)(n.p,{children:"(symbolp expanded-x)))))"}),"\n",(0,r.jsx)(n.p,{children:"(let ((n (/ (length key-value-pairs) 2)))"}),"\n",(0,r.jsx)(n.p,{children:"(multiple-value-bind (x1s y1s x2s y2s others)"}),"\n",(0,r.jsx)(n.p,{children:"(loop for (key) on key-value-pairs by #\u2019cddr"}),"\n",(0,r.jsxs)(n.p,{children:["count (eq key \u2019",":x1",") into x1s"]}),"\n",(0,r.jsxs)(n.p,{children:["count (eq key \u2019",":y1",") into y1s"]}),"\n",(0,r.jsxs)(n.p,{children:["count (eq key \u2019",":x2",") into x2s"]}),"\n",(0,r.jsxs)(n.p,{children:["count (eq key \u2019",":y1",") into y2s"]}),"\n",(0,r.jsxs)(n.p,{children:["count (not (member key \u2019(",":x1"," ",":x2"," ",":y1"," ",":y2",")))"]}),"\n",(0,r.jsx)(n.p,{children:"into others"}),"\n",(0,r.jsx)(n.p,{children:"finally (return (values x1s y1s x2s y2s others)))"}),"\n",(0,r.jsx)(n.p,{children:"(cond ((and (= n 4)"}),"\n",(0,r.jsxs)(n.p,{children:["(eq (key 0) ",":x1",")"]}),"\n",(0,r.jsxs)(n.p,{children:["(eq (key 1) ",":y1",")"]}),"\n",(0,r.jsxs)(n.p,{children:["(eq (key 2) ",":x2",")"]}),"\n",(0,r.jsxs)(n.p,{children:["(eq (key 3) ",":y2","))"]}),"\n",(0,r.jsx)(n.p,{children:"\u2018(distance-positional ,x1 ,y1 ,x2 ,y2))"}),"\n",(0,r.jsx)(n.p,{children:"((and (if x1-p (and (= x1s 1) (simplep x1)) t)"}),"\n",(0,r.jsx)(n.p,{children:"(if y1-p (and (= y1s 1) (simplep y1)) t)"}),"\n",(0,r.jsx)(n.p,{children:"(if x2-p (and (= x2s 1) (simplep x2)) t)"}),"\n",(0,r.jsx)(n.p,{children:"(if y2-p (and (= y2s 1) (simplep y2)) t)"}),"\n",(0,r.jsx)(n.p,{children:"(zerop others))"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(distance-positional ,x1 ,y1 ,x2 ,y2))"}),"\n",(0,r.jsx)(n.p,{children:"((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)"}),"\n",(0,r.jsx)(n.p,{children:"(zerop others))"}),"\n",(0,r.jsx)(n.p,{children:"(let ((temps (loop repeat n collect (gensym))))"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(let ,(loop for i below n"}),"\n",(0,r.jsx)(n.p,{children:"collect (list (nth i temps) (arg i)))"}),"\n",(0,r.jsx)(n.p,{children:"(distance"}),"\n",(0,r.jsx)(n.p,{children:",@(loop for i below n"}),"\n",(0,r.jsx)(n.p,{children:"append (list (key i) (nth i temps)))))))"}),"\n",(0,r.jsx)(n.p,{children:"(t form))))))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," DISTANCE"]}),"\n",(0,r.jsx)(n.p,{children:"(dolist (form"}),"\n",(0,r.jsxs)(n.p,{children:["\u2019((distance ",":x1"," (setq x 7) ",":x2"," (decf x) ",":y1"," (decf x) ",":y2"," (decf x)) (distance ",":x1"," (setq x 7) ",":y1"," (decf x) ",":x2"," (decf x) ",":y2"," (decf x))"]}),"\n",(0,r.jsxs)(n.p,{children:["(distance ",":x1"," (setq x 7) ",":y1"," (incf x))"]}),"\n",(0,r.jsxs)(n.p,{children:["(distance ",":x1"," (setq x 7) ",":y1"," (incf x) ",":x1"," (incf x))"]}),"\n",(0,r.jsxs)(n.p,{children:["(distance ",":x1"," a1 ",":y1"," b1 ",":x2"," a2 ",":y2"," b2)"]}),"\n",(0,r.jsxs)(n.p,{children:["(distance ",":x1"," a1 ",":x2"," a2 ",":y1"," b1 ",":y2"," b2)"]}),"\n",(0,r.jsxs)(n.p,{children:["(distance ",":x1"," a1 ",":y1"," b1 ",":z1"," c1 ",":x2"," a2 ",":y2"," b2 ",":z2"," c2)))"]}),"\n",(0,r.jsx)(n.p,{children:"(print (funcall (compiler-macro-function \u2019distance) form nil)))"}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (LET ((#",":G6558"," (SETQ X 7))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (#",":G6559"," (DECF X))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (#",":G6560"," (DECF X))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (#",":G6561"," (DECF X)))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (DISTANCE ",":X1"," #",":G6558"," ",":X2"," #",":G6559"," ",":Y1"," #",":G6560"," ",":Y2"," #",":G6561","))"]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))"}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (LET ((#",":G6567"," (SETQ X 7))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (#",":G6568"," (INCF X)))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (DISTANCE ",":X1"," #",":G6567"," ",":Y1"," #",":G6568","))"]}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (DISTANCE ",":X1"," (SETQ X 7) ",":Y1"," (INCF X) ",":X1"," (INCF X))"]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 (DISTANCE-POSITIONAL A1 B1 A2 B2)"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 (DISTANCE-POSITIONAL A1 B1 A2 B2)"}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 (DISTANCE ",":X1"," A1 ",":Y1"," B1 ",":Z1"," C1 ",":X2"," A2 ",":Y2"," B2 ",":Z2"," C2)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"compiler-macro-function"}),", ",(0,r.jsx)(n.strong,{children:"defmacro"}),", ",(0,r.jsx)(n.strong,{children:"documentation"}),", Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["The consequences of writing a ",(0,r.jsx)(n.em,{children:"compiler macro"})," definition for a function in the COMMON-LISP ",(0,r.jsx)(n.em,{children:"package"})," are undefined; it is quite possible that in some ",(0,r.jsx)(n.em,{children:"implementations"})," such an attempt would override an equivalent or equally important definition. In general, it is recommended that a programmer only write ",(0,r.jsx)(n.em,{children:"compiler macro"})," definitions for ",(0,r.jsx)(n.em,{children:"functions"})," he or she personally maintains\u2013writing a ",(0,r.jsx)(n.em,{children:"compiler macro"})," definition for a function maintained elsewhere is normally considered a violation of traditional rules of modularity and data abstraction."]})]})}function l(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}const d={},a="define-compiler-macro",o={id:"chap-3/d-i-dictionary/definecompilermacro",title:"define-compiler-macro",description:"Expanded Reference: define-compiler-macro",source:"@site/docs/chap-3/d-i-dictionary/definecompilermacro.md",sourceDirName:"chap-3/d-i-dictionary",slug:"/chap-3/d-i-dictionary/definecompilermacro",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/definecompilermacro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-i-dictionary/definecompilermacro.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"compiler-macro-function",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/compilermacrofunction"},next:{title:"define-symbol-macro",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/definesymbolmacro"}},t={},x=[{value:"Expanded Reference: define-compiler-macro",id:"expanded-reference-define-compiler-macro",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"define-compiler-macro",children:"define-compiler-macro"}),"\n","\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-define-compiler-macro",children:"Expanded Reference: define-compiler-macro"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(define-compiler-macro )\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>l});var r=i(67294);const s={},c=r.createContext(s);function l(e){const n=r.useContext(c);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);