"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[65608],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},77280:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>x});const i=JSON.parse('{"id":"chap-3/d-i-dictionary/dynamic-extent_declaration","title":"dynamic-extent","description":"Expanded Reference: dynamic-extent","source":"@site/docs/chap-3/d-i-dictionary/dynamic-extent_declaration.md","sourceDirName":"chap-3/d-i-dictionary","slug":"/chap-3/d-i-dictionary/dynamic-extent_declaration","permalink":"/cl-language-reference/chap-3/d-i-dictionary/dynamic-extent_declaration","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-3/d-i-dictionary/dynamic-extent_declaration.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"dynamic-extent"},"sidebar":"tutorialSidebar","previous":{"title":"defmacro","permalink":"/cl-language-reference/chap-3/d-i-dictionary/defmacro_macro"},"next":{"title":"eval-when","permalink":"/cl-language-reference/chap-3/d-i-dictionary/eval-when_special-operator"}}');var a=t(74848),s=t(28453);function r(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||l("DictionaryLink",!0),i||l("GlossaryTerm",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"dynamic-extent"})," ",(0,a.jsx)(i,{term:"declaration",children:(0,a.jsx)("i",{children:"Declaration"})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,a.jsxs)(n.p,{children:["(dynamic-extent [[ ",(0,a.jsx)(n.em,{children:"{var}"}),"* | (",(0,a.jsx)(t,{term:"function",children:(0,a.jsx)("b",{children:"function"})})," ",(0,a.jsx)(n.em,{children:"fn"}),")* ]])"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Arguments:"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"var"}),"\u2014a ",(0,a.jsx)(n.em,{children:"variable name"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"fn"}),"\u2014a ",(0,a.jsx)(i,{styled:!0,term:"function name",children:(0,a.jsx)("i",{children:"function name"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Valid Context:"})}),"\n",(0,a.jsx)(i,{term:"declaration",children:(0,a.jsx)("i",{children:"declaration"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Binding Types Aected:"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(i,{term:"variable",children:(0,a.jsx)("i",{children:"variable"})}),", ",(0,a.jsx)(i,{term:"function",children:(0,a.jsx)("i",{children:"function"})})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Description:"})}),"\n",(0,a.jsxs)(n.p,{children:["In some containing ",(0,a.jsx)("i",{children:"form"}),", ",(0,a.jsx)("i",{children:"F"}),", this declaration asserts for each ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]})," (which need not be bound by ",(0,a.jsx)("i",{children:"F"}),"), and for each ",(0,a.jsxs)("i",{children:["value v",(0,a.jsx)("sub",{children:"ij"})]})," that ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]})," takes on, and for each ",(0,a.jsxs)("i",{children:["object x",(0,a.jsx)("sub",{children:"ijk"})]})," that is an ",(0,a.jsx)("i",{children:"otherwise inaccessible part"})," of ",(0,a.jsxs)("i",{children:["v",(0,a.jsx)("sub",{children:"ij"})]})," at any time when ",(0,a.jsxs)("i",{children:["v",(0,a.jsx)("sub",{children:"ij"})]})," becomes the value of ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]}),", that just after the execution of ",(0,a.jsx)("i",{children:"F"})," terminates, ",(0,a.jsxs)("i",{children:["x",(0,a.jsx)("sub",{children:"ijk"})]})," is either ",(0,a.jsx)("i",{children:"inaccessible"})," (if ",(0,a.jsx)("i",{children:"F"})," established a ",(0,a.jsx)("i",{children:"binding"})," for ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]}),") or still an ",(0,a.jsx)("i",{children:"otherwise inaccessible part"})," of the current value of ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]})," (if ",(0,a.jsx)("i",{children:"F"})," did not establish a ",(0,a.jsx)("i",{children:"binding"})," for ",(0,a.jsxs)("i",{children:["var",(0,a.jsx)("sub",{children:"i"})]}),"). The same relation holds for each ",(0,a.jsxs)("i",{children:["fn",(0,a.jsx)("sub",{children:"i"})]}),", except that the ",(0,a.jsx)("i",{children:"bindings"})," are in the ",(0,a.jsx)("i",{children:"function namespace"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Evaluation and"}),"\n",(0,a.jsx)(t,{term:"dynamic-extent",children:(0,a.jsx)("b",{children:"dynamic-extent"})}),"\n",(0,a.jsxs)(n.p,{children:["The compiler is permitted to use this information in any way that is appropriate to the ",(0,a.jsx)(i,{term:"implementation",children:(0,a.jsx)("i",{children:"implementation"})})," and that does not conflict with the semantics of Common Lisp."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(t,{term:"dynamic-extent",children:(0,a.jsx)("b",{children:"dynamic-extent"})})," declarations can be ",(0,a.jsx)(i,{styled:!0,term:"free declaration",children:(0,a.jsx)("i",{children:"free declarations"})})," or ",(0,a.jsx)(i,{styled:!0,term:"bound declaration",children:(0,a.jsx)("i",{children:"bound declarations"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.em,{children:"vars"})," and ",(0,a.jsx)(n.em,{children:"fns"})," named in a ",(0,a.jsx)(t,{term:"dynamic-extent",children:(0,a.jsx)("b",{children:"dynamic-extent"})})," declaration must not refer to ",(0,a.jsx)(i,{styled:!0,term:"symbol macro",children:(0,a.jsx)("i",{children:"symbol macro"})})," or ",(0,a.jsx)(i,{term:"macro",children:(0,a.jsx)("i",{children:"macro"})})," bindings."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lisp",children:'Since stack allocation of the initial value entails knowing at the *object*\u2019s creation time that the *object* can be *stack-allocated*, it is not generally useful to make a **dynamic-extent** *declaration* for *variables* which have no lexically apparent initial value. For example, it is probably useful to write: \n(defun f () \n  (let ((x (list 1 2 3))) \n    (declare (dynamic-extent x)) \n    ...)) \nThis would permit those compilers that wish to do so to *stack allocate* the list held by the local variable x. It is permissible, but in practice probably not as useful, to write: \n(defun g (x) (declare (dynamic-extent x)) ...) \n(defun f () (g (list 1 2 3))) \nMost compilers would probably not *stack allocate* the *argument* to g in f because it would be a modularity violation for the compiler to assume facts about g from within f. Only an implementation that was willing to be responsible for recompiling f if the definition of g changed incompatibly could legitimately *stack allocate* the *list* argument to g in f. \nHere is another example: \n(declaim (inline g)) \n(defun g (x) (declare (dynamic-extent x)) ...) \n(defun f () (g (list 1 2 3))) \n(defun f () \n  (flet ((g (x) (declare (dynamic-extent x)) ...)) \n    (g (list 1 2 3)))) \nIn the previous example, some compilers might determine that optimization was possible and others might not. \nA variant of this is the so-called \u201cstack allocated rest list\u201d that can be achieved (in implementations supporting the optimization) by: \n(defun f (&rest x) \n  (declare (dynamic-extent x)) \n  \n  \n  **dynamic-extent** \n  ...) \nNote that although the initial value of x is not explicit, the f function is responsible for assembling the list x from the passed arguments, so the f function can be optimized by the compiler to construct a *stack-allocated* list instead of a heap-allocated list in implementations that support such. \nIn the following example, \n(let ((x (list \u2019a1 \u2019b1 \u2019c1)) \n      (y (cons \u2019a2 (cons \u2019b2 (cons \u2019c2 nil))))) \n  (declare (dynamic-extent x y)) \n  ...) \nThe *otherwise inaccessible parts* of x are three *conses*, and the *otherwise inaccessible parts* of y are three other *conses*. None of the symbols a1, b1, c1, a2, b2, c2, or **nil** is an *otherwise inaccessible part* of x or y because each is *interned* and hence *accessible* by the *package* (or *packages*) in which it is *interned*. However, if a freshly allocated *uninterned symbol* had been used, it would have been an *otherwise inaccessible part* of the *list* which contained it. \n;; In this example, the implementation is permitted to *stack allocate* \n;; the list that is bound to X. \n(let ((x (list 1 2 3))) \n  (declare (dynamic-extent x)) \n  (print x) \n  :done) \n\u25b7 (1 2 3) \n*!* :DONE \n;; In this example, the list to be bound to L can be *stack-allocated*. \n(defun zap (x y z) \n  (do ((l (list x y z) (cdr l))) \n      ((null l)) \n    (declare (dynamic-extent l)) \n    (prin1 (car l)))) *!* ZAP \n(zap 1 2 3) \n\u25b7 123 \n*!* NIL \n;; Some implementations might open-code LIST-ALL-PACKAGES in a way \n;; that permits using *stack allocation* of the list to be bound to L. \n(do ((l (list-all-packages) (cdr l))) \n    ((null l)) \n  (declare (dynamic-extent l)) \n  (let ((name (package-name (car l)))) \n    (when (string-search "COMMON-LISP" name) (print name)))) \n\u25b7 "COMMON-LISP" \nEvaluation and \n\n\u25b7 "COMMON-LISP-USER" \n*!* NIL \n;; Some implementations might have the ability to *stack allocate* \n;; rest lists. A declaration such as the following should be a cue \n;; to such implementations that stack-allocation of the rest list \n;; would be desirable. \n(defun add (&rest x) \n  (declare (dynamic-extent x)) \n  (apply #\u2019+ x)) *!* ADD \n(add 1 2 3) *!* 6 \n(defun zap (n m) \n  ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N). \n  ;; It may be slow, but with a good compiler at least it \n  ;; doesn\u2019t waste much heap storage. :-\\&#125; \n  (let ((a (make-array n))) \n    (declare (dynamic-extent a)) \n    (dotimes (i n) \n      (declare (dynamic-extent i)) \n      (setf (aref a i) (random (+ i 1)))) \n    (aref a m))) *!* ZAP \n(< (zap 5 3) 3) *! true* \nThe following are in error, since the value of x is used outside of its *extent*: \n(length (list (let ((x (list 1 2 3))) ; Invalid \n\t\t(declare (dynamic-extent x)) \n\t\tx))) \n(progn (let ((x (list 1 2 3))) ; Invalid \n\t (declare (dynamic-extent x)) \n\t x) \n       nil) \n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,a.jsx)(t,{term:"declare",children:(0,a.jsx)("b",{children:"declare"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(n.p,{children:["The most common optimization is to ",(0,a.jsx)(i,{styled:!0,term:"stack allocate",children:(0,a.jsx)("i",{children:"stack allocate"})})," the initial value of the ",(0,a.jsx)(i,{term:"object",children:(0,a.jsx)("i",{children:"objects"})})," named by the ",(0,a.jsx)(n.em,{children:"vars"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"It is permissible for an implementation to simply ignore this declaration."}),"\n",(0,a.jsx)(t,{term:"type",children:(0,a.jsx)("b",{children:"type"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}function l(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const o={title:"dynamic-extent"},d="dynamic-extent",h={},x=[{value:"Expanded Reference: dynamic-extent",id:"expanded-reference-dynamic-extent",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"dynamic-extent",children:"dynamic-extent"})}),"\n","\n",(0,a.jsx)(c,{}),"\n",(0,a.jsx)(n.h2,{id:"expanded-reference-dynamic-extent",children:"Expanded Reference: dynamic-extent"}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lisp",children:"(dynamic-extent )\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);