"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[48583],{63828:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>C,contentTitle:()=>I,default:()=>M,frontMatter:()=>T,metadata:()=>S,toc:()=>_});var o=n(85893),i=n(11151);function a(e){const t={a:"a",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"subprotocols",children:"Subprotocols"}),"\n",(0,o.jsx)(t.h2,{id:"subprotocols-1",children:"Subprotocols"}),"\n",(0,o.jsxs)(t.p,{children:["This section provides an overview of the Metaobject Protocols. The detailed behavior of each function, generic function and macro in the Metaobject Protocol is presented in ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/chapter-6",children:"Chapter 6"})," . The remainder of this chapter is intended to emphasize connections among the parts of the Metaobject Protocol, and to provide some examples of the kinds of specializations and extensions the protocols are designed to support."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/meta-object-protocol/metaobject-initialization-protocols",children:"Metaobject initialization protocols."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects",children:"Initialization of class metaobjects"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/reinitialization-of-class-metaobjects",children:"Reinitialization of class metaobjects"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-generic-function-and-method-metaobjects",children:"Initialization of generic function and method metaobjects"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-finalization-protocol",children:"Class finalization protocol."})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/instance-structure-protocol",children:"Instance structure protocol."})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/funcallable-instances",children:"Funcallable instances."})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/generic-function-invocation-protocol",children:"Generic function invocation protocol."})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/dependent-maintenance-protocol",children:"Dependent maintenance protocol."})}),"\n"]})]})}function s(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}function c(e){const t={a:"a",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"metaobject-initialization-protocols",children:"Metaobject initialization protocols"}),"\n",(0,o.jsx)(t.h3,{id:"metaobject-initialization-protocols-1",children:"Metaobject initialization protocols"}),"\n",(0,o.jsxs)(t.p,{children:["Like other objects, metaobjects can be created by calling ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments passed to ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," are used to initialize the metaobject in the usual way. The set of legal initialization arguments, and their interpretation, depends on the kind of metaobject being created. Implementations and portable programs are free to extend the set of legal initialization arguments. Detailed information about the initialization of each kind of metaobject are provided in ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/chapter-6",children:"Chapter 6"}),"; this section provides an overview and examples of this behavior."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects",children:"Initialization of class metaobjects"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/reinitialization-of-class-metaobjects",children:"Reinitialization of class metaobjects"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-generic-function-and-method-metaobjects",children:"Initialization of generic function and method metaobjects"})}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}function r(e){const t={a:"a",code:"code",em:"em",h1:"h1",h4:"h4",h5:"h5",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"initialization-of-class-metaobjects",children:"Initialization of Class Metaobjects"}),"\n",(0,o.jsx)(t.h4,{id:"initialization-of-class-metaobjects-1",children:"Initialization of Class Metaobjects"}),"\n",(0,o.jsxs)(t.p,{children:["Class metaobjects created with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),"{#make-instance-1} are usually ",(0,o.jsx)(t.em,{children:"anonymous"}),"; that is, they have no proper name. An anonymous class metaobject can be given a proper name using ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_find_c.htm#find-class",children:"(setf find-class)"})," and ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/setf-class-name",children:"(setf class-name)"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["When a class metaobject is created with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),", it is initialized in the usual way. The initialization arguments passed to ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," are use to establish the definition of the class. Each initialization argument is checked for errors and associated with the class metaobject. The initialization arguments correspond roughly to the arguments accepted by the ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," macro, and more closely to the arguments accepted by the ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," function."]}),"\n",(0,o.jsxs)(t.p,{children:["Some class metaobject classes allow their instances to be redefined. When permissible, this is done by calling ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". This is discussed in the next section."]}),"\n",(0,o.jsxs)(t.p,{children:["An example of creating an anonymous class directly using ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lisp",children:"    (flet ((zero () 0)\n           (propellor () *propellor*))\n      (make-instance 'standard-class\n        :name '(my-class foo)\n        :direct-superclasses (list (find-class 'plane)\n                                   another-anonymous-class)\n        :direct-slots `((:name x\n                         :initform 0\n                         :initfunction ,#'zero\n                         :initargs (:x)\n                         :readers (position-x)\n                         :writers ((setf position-x)))\n                        (:name y\n                         :initform 0\n                         :initfunction ,#'zero\n                         :initargs (:y)\n                         :readers (position-y)\n                         :writers ((setf position-y))))\n        :direct-default-initargs `((:engine *propellor* ,#'propellor))))\n"})}),"\n",(0,o.jsx)(t.h5,{id:"comments-and-remarks",children:"Comments and remarks"}),"\n",(0,o.jsxs)(t.p,{children:["This section is named ",(0,o.jsx)(t.em,{children:"Initialization of Class Metaobjects"})," and appears in Chapter 5 (Concepts) of the original text. There is ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects2",children:"a section with the same name in Chapter 6 (Generic functions and methods) of the original text."})," When sections are referred to in the text, it is not specified which one."]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}function h(e){const t={a:"a",h1:"h1",h4:"h4",p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"reinitialization-of-class-metaobjects",children:"Reinitialization of Class Metaobjects"}),"\n",(0,o.jsx)(t.h4,{id:"reinitialization-of-class-metaobjects-1",children:"Reinitialization of Class Metaobjects"}),"\n",(0,o.jsxs)(t.p,{children:["Some class metaobject classes allow their instances to be reinitialized. This is done by calling ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". The initialization arguments have the same interpretation as in class initialization."]}),"\n",(0,o.jsxs)(t.p,{children:["If the class metaobject was finalized before the call to ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," will be called again once all the initialization arguments have been processed and associated with the class metaobject. In addition, once finalization is complete, any dependents of the class metaobject will be updated by calling ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}function m(e){const t={a:"a",h1:"h1",h4:"h4",p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"initialization-of-generic-function-and-method-metaobjects",children:"Initialization of generic function and method metaobjects"}),"\n",(0,o.jsx)(t.h4,{id:"initialization-of-generic-function-and-method-metaobjects-1",children:"Initialization of generic function and method metaobjects"}),"\n",(0,o.jsxs)(t.p,{children:["An example of creating a generic function and a method metaobject, and then adding the method to the generic function is shown below. This example is comparable to the method definition shown in ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/fig-defmethod-1",children:"this figure"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["(let* ((gf (make-instance 'standard-generic-function\n",":lambda-list"," '(p l &optional visiblyp &key)))\n(method-class (generic-function-method-class gf)))\n(multiple-value-bind (lambda initargs)\n(make-method-lambda\ngf\n(class-prototype method-class)\n'(lambda (p l &optional (visiblyp t) &key color)\n(set-to-origin p)\n(when visiblyp (show-move p 0 color)))\nnil)\n(add-method gf\n(apply #'make-instance method-class\n",":function"," (compile nil lambda)\n",":specializers"," (list (find-class 'position)\n(intern-eql-specializer 0))\n",":qualifiers"," ()\n",":lambda-list"," '(p l &optional (visiblyp t)\n&key color)\ninitargs))))"]})]})}function f(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}function u(e){const t={a:"a",em:"em",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"class-finalization-protocol",children:"Class finalization protocol"}),"\n",(0,o.jsx)(t.h3,{id:"class-finalization-protocol-1",children:"Class finalization protocol"}),"\n",(0,o.jsxs)(t.p,{children:["Class ",(0,o.jsx)(t.em,{children:"finalization"})," is the process of computing the information a class inherits from its superclasses and preparing to actually allocate instances of the class. The class finalization process includes computing the class precedence list of the class, the full set of slots accessible in instances of the class and the full set of default initialization arguments for the class. These values are associated with the class metaobject and can be accessed by calling the appropriate reader. In addition, the class finalization process makes decisions about how instances of the class will be implemented."]}),"\n",(0,o.jsxs)(t.p,{children:["To support forward-referenced superclasses, and to account for the fact that not all classes are actually instantiated, class finalization is not done as part of the initialization of the class metaobject. Instead, finalization is done as a separate protocol, invoked by calling the generic function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"}),". The exact point at which ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," is called depends on the class of the class metaobject; for ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," it is called sometime after all the superclasses of the class are defined, but no later than when the first instance of the class is allocated (by ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/allocate-instance",children:"allocate-instance"}),")."]}),"\n",(0,o.jsxs)(t.p,{children:["The first step of class finalization is computing the class precedence list. Doing this first allows subsequent steps to access the class precedence list. This step is performed by calling the generic function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-class-precedence-list",children:"compute-class-precedence-list"}),". The value returned from this call is associated with the class metaobject and can be accessed by calling the ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-precedence-list",children:"class-precedence-list"})," generic function."]}),"\n",(0,o.jsxs)(t.p,{children:["The second step is computing the full set of slots that will be accessible in instances of the class. This step is performed by calling the generic function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"}),". The result of this call is a list of effective slot definition metaobjects. This value is associated with the class metaobject and can be accessed by calling the ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-slots",children:"class-slots"})," generic function."]}),"\n",(0,o.jsxs)(t.p,{children:["The behavior of ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," is itself layered, consisting of calls to ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/effective-slot-definition-class",children:"effective-slot-definition-class"})," and ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-slot-definition",children:"compute-effective-slot-definition"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The final step of class finalization is computing the full set of initialization arguments for the class. This is done by calling the generic function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-default-initargs",children:"compute-default-initargs"}),". The value returned by this generic function is associated with the class metaobject and can be accessed by calling ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-default-initargs",children:"class-default-initargs"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["If the class was previously finalized, ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," may call ",(0,o.jsx)(t.a,{href:"/chap-7/h-h-dictionary/make-instances-obsolete_standard-generic-function",children:"make-instances-obsolete"}),". The circumstances under which this happens are describe in ",(0,o.jsx)(t.a,{href:"http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node300.md#SECTION0032110000000000000000",children:"the section of the CLOS specification called ``Redefining Classes.''"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Forward-referenced classes, which provide a temporary definition for a class which has been referenced but not yet defined, can never be finalized. An error is signalled if ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," is called on a forward-referenced class."]})]})}function j(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}function b(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"instance-structure-protocol",children:"Instance Structure Protocol"}),"\n",(0,o.jsx)(t.h3,{id:"instance-structure-protocol-1",children:"Instance Structure Protocol"}),"\n",(0,o.jsxs)(t.p,{children:["The instance structure protocol is responsible for implementing the behavior of the slot access functions like ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"slot-value"})," and ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"(setf slot-value)"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["For each CLOS slot access function other than ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_ex.htm#slot-exists-p",children:"slot-exists-p"}),", there is a corresponding generic function which actually provides the behavior of the function. When called, the slot access function finds the pertinent effective slot definition metaobject, calls the corresponding generic function and returns its result. The arguments passed on to the generic function include one additional value, the class of the ",(0,o.jsx)(t.em,{children:"object"})," argument, which always immediately precedes the ",(0,o.jsx)(t.em,{children:"object"})," argument."]}),"\n",(0,o.jsx)(t.p,{children:"The correspondences between slot access function and underlying slot access generic function are as follows:"}),"\n",(0,o.jsx)(t.p,{children:"Slot access function                                                                                    Corresponding slot access generic function"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_bo.htm#slot-boundp",children:"slot-boundp"}),"           ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/slot-boundp-using-class",children:"slot-boundp-using-class"}),"\n",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_ma.htm#slot-makunbound",children:"slot-makunbound"}),"   ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/slot-makunbound-using-class",children:"slot-makunbound-using-class"}),"\n",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"slot-value"}),"             ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/slot-value-using-class",children:"slot-value-using-class"}),"\n",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"(setf slot-value)"}),"      ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/setf-slot-value-using-class",children:"(setf slot-value-using-class)"})]}),"\n",(0,o.jsx)(t.p,{children:"At the lowest level, the instance structure protocol provides only limited mechanisms for portable programs to control the implementation of instances and to directly access the storage associated with instances without going through the indirection of slot access. This is done to allow portable programs to perform certain commonly requested slot access optimizations."}),"\n",(0,o.jsxs)(t.p,{children:["In particular, portable programs can control the implementation of, and obtain direct access to, slots with allocation ",(0,o.jsx)(t.code,{children:":instance"})," and type ",(0,o.jsx)(t.strong,{children:"t"}),". These are called ",(0,o.jsx)(t.em,{children:"directly accessible slots"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The relevant specified around-method on ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," determines the implementation of instances by deciding how each slot in the instance will be stored. For each directly accessible slot, this method allocates a ",(0,o.jsx)(t.em,{children:"location"})," and associates it with the effective slot definition metaobject. The location can be accessed by calling the ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/slot-definition-location",children:"slot-definition-location"})," generic function. Locations are non-negative integers. For a given class, the locations increase consecutively, in the order that the directly accessible slots appear in the list of effective slots. (Note that here, the next paragraph, and the specification of this around-method are the only places where the value returned by ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," is described as a list rather than a set.)"]}),"\n",(0,o.jsxs)(t.p,{children:["Given the location of a directly accessible slot, the value of that slot in an instance can be accessed with the appropriate accessor. For ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),", this accessor is the function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/standard-instance-access",children:"standard-instance-access"}),". For ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"}),", this accessor is the function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/funcallable-standard-instance-access",children:"funcallable-standard-instance-access"}),". In each case, the arguments to the accessor are the instance and the slot location, in that order. See the definition of each accessor for additional restrictions on the use of these function."]}),"\n",(0,o.jsx)(t.h4,{id:"example",children:"Example:"}),"\n",(0,o.jsxs)(t.p,{children:["The following example shows the use of this mechanism to implement a new class metaobject class, ",(0,o.jsx)(t.code,{children:"ordered-class"})," and class option ",(0,o.jsx)(t.code,{children:":slot-order"}),". This option provides control over the allocation of slot locations. In this simple example implementation, the ",(0,o.jsx)(t.code,{children:":slot-order"})," option is not inherited by subclasses; it controls only instances of the class itself."]}),"\n",(0,o.jsxs)(t.p,{children:["(defclass ordered-class (standard-class)\n((slot-order ",":initform"," ()\n",":initarg"," ",":slot-order","\n",":reader"," class-slot-order)))"]}),"\n",(0,o.jsx)(t.p,{children:"(defmethod compute-slots ((class ordered-class))\n(let ((order (class-slot-order class)))\n(sort (copy-list (call-next-method))\n#'(lambda (a b)\n(< (position (slot-definition-name a) order)\n(position (slot-definition-name b) order))))))"}),"\n",(0,o.jsxs)(t.p,{children:["Following is the source code the user of this extension would write. Note that because the code above doesn't implement inheritance of the ",(0,o.jsx)(t.code,{children:":slot-order"})," option, the function ",(0,o.jsx)(t.code,{children:"distance"})," must not be called on instances of subclasses of ",(0,o.jsx)(t.code,{children:"point"}),"; it can only be called on instances of ",(0,o.jsx)(t.code,{children:"point"})," itself."]}),"\n",(0,o.jsxs)(t.p,{children:["(defclass point ()\n((x ",":initform"," 0)\n(y ",":initform"," 0))\n(",":metaclass"," ordered-class)\n(",":slot-order"," x y))"]}),"\n",(0,o.jsx)(t.p,{children:"(defun distance (point)\n(sqrt (/ (+ (expt (standard-instance-access point 0) 2)\n(expt (standard-instance-access point 1) 2))\n2.0)))"}),"\n",(0,o.jsx)(t.p,{children:"In more realistic uses of this mechanism, the calls to the low-level instance structure accessors would not actually appear textually in the source program, but rather would be generated by a meta-level analysis program run during the process of compiling the source program."})]})}function x(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(b,{...e})}):b(e)}function g(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"funcallable-instances",children:"Funcallable Instances"}),"\n",(0,o.jsx)(t.h3,{id:"funcallable-instances-1",children:"Funcallable Instances"}),"\n",(0,o.jsxs)(t.p,{children:["Instances of classes which are themselves instances of ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," or one of its subclasses are called ",(0,o.jsx)(t.em,{children:"funcallable instances"}),". Funcallable instances can only be created by ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/allocate-instance-funcallable-standard-class",children:"allocate-instance (class funcallable-standard-class)"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Like standard instances, funcallable instances have slots with the normal behavior. They differ from standard instances in that they can be used as functions as well; that is, they can be passed to ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_funcal.htm#funcall",children:"funcall"})," and ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_apply.htm#apply",children:"apply"}),", and they can be stored as the definition of a function name. Associated with each funcallable instance is the function which it runs when it is called. This function can be changed with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/set-funcallable-instance-function",children:"set-funcallable-instance-function"})]}),"\n",(0,o.jsx)(t.h4,{id:"example",children:"Example"}),"\n",(0,o.jsxs)(t.p,{children:["The following simple example shows the use of funcallable instances to create a simple, ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defstr.htm#defstruct",children:"defstruct"}),"-like facility. (Funcallable instances are useful when a program needs to construct and maintain a set of functions and information about those functions. They make it possible to maintain both as the same object rather than two separate objects linked, for example, by hash tables.)"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lisp",children:"    (defclass constructor ()\n         ((name :initarg :name :accessor constructor-name)\n          (fields :initarg :fields :accessor constructor-fields))\n      (:metaclass funcallable-standard-class))\n\n    (defmethod initialize-instance :after ((c constructor) &key)\n      (with-slots (name fields) c\n        (set-funcallable-instance-function\n          c\n          #'(lambda ()\n              (let ((new (make-array (1+ (length fields)))))\n                (setf (aref new 0) name)\n                new)))))\n\n    (setq c1 (make-instance 'constructor\n                            :name 'position :fields '(x y)))\n    #<CONSTRUCTOR 262437>\n\n    (setq p1 (funcall c1))\n    #<ARRAY 3 263674>\n"})})]})}function w(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(g,{...e})}):g(e)}function y(e){const t={a:"a",em:"em",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"generic-function-invocation-protocol",children:"Generic function invocation protocol"}),"\n",(0,o.jsx)(t.h3,{id:"generic-function-invocation-protocol-1",children:"Generic function invocation protocol"}),"\n",(0,o.jsx)(t.p,{children:"Associated with each generic function is its discriminating function. Each time the generic function is called, the discriminating function is called to provide the behavior of the generic function. The discriminating function receives the full set of arguments received by the generic function. It must lookup and execute the appropriate methods, and return the appropriate values."}),"\n",(0,o.jsxs)(t.p,{children:["The discriminating function is computed by the highest layer of the generic function invocation protocol, ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"}),". Whenever a generic function metaobject is initialized, reinitialized, or a method is added or removed, the discriminating function is recomputed. The new discriminating function is then stored with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/set-funcallable-instance-function",children:"set-funcallable-instance-function"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Discriminating functions call ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"})," and ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods-using-classes",children:"compute-applicable-methods-using-classes"})," to compute the methods applicable to the generic functions arguments. Applicable methods are combined by ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," to produce an ",(0,o.jsx)(t.em,{children:"effective method"}),". Provisions are made to allow memoization of the method applicability and effective methods computations. (See the description of ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"})," for details.)"]}),"\n",(0,o.jsxs)(t.p,{children:["The body of method definitions are processed by ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"}),". The result of this generic function is a lambda expression which is processed by either ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm#compile",children:"compile"})," or the file compiler to produce a ",(0,o.jsx)(t.em,{children:"method function"}),". The arguments received by the method function are controlled by the ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"})," forms appearing in the effective methods. By default, method functions accept two arguments: a list of arguments to the generic function, and a list of next methods. The list of next methods corresponds to the next methods argument to ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"}),". If ",(0,o.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_call_m.htm#call-method",children:"call-method"})," appears with additional arguments, these will be passed to the method functions as well; in these cases, ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"})," must have created the method lambdas to expect additional arguments."]})]})}function v(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(y,{...e})}):y(e)}function z(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"dependent-maintenance-protocol",children:"Dependent maintenance protocol"}),"\n",(0,o.jsx)(t.h3,{id:"dependent-maintenance-protocol-1",children:"Dependent maintenance protocol"}),"\n",(0,o.jsx)(t.p,{children:"It is convenient for portable metaobjects to be able to memoize information about other metaobjects, portable or otherwise. Because class and generic function metaobjects can be reinitialized, and generic function metaobjects can be modified by adding and removing methods, a means must be provided to update this memoized information."}),"\n",(0,o.jsxs)(t.p,{children:["The dependent maintenance protocol supports this by providing a way to register an object which should be notified whenever a class or generic function is modified. An object which has been registered this way is called a ",(0,o.jsx)(t.em,{children:"dependent"})," of the class or generic function metaobject. The dependents of class and generic function metaobjects are maintained with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/add-dependent",children:"add-dependent"})," and ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/remove-dependent",children:"remove-dependent"}),". The dependents of a class or generic function metaobject can be accessed with ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/map-dependents",children:"map-dependents"}),". Dependents are notified about a modification by calling ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),". (See the specification of ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"})," for detailed description of the circumstances under which it is called.)"]}),"\n",(0,o.jsx)(t.p,{children:"To prevent conflicts between two portable programs, or between portable programs and the implementation, portable code must not register metaobjects themselves as dependents. Instead, portable programs which need to record a metaobject as a dependent, should encapsulate that metaobject in some other kind of object, and record that object as the dependent. The results are undefined if this restriction is violated."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Example:"})}),"\n",(0,o.jsx)(t.p,{children:"This example shows a general facility for encapsulating metaobjects before recording them as dependents. The facility defines a basic kind of encapsulating object: an updater. Specializations of the basic class can be defined with appropriate special updating behavior. In this way, information about the updating required is associated with each updater rather than with the metaobject being updated."}),"\n",(0,o.jsxs)(t.p,{children:["Updaters are used to encapsulate any metaobject which requires updating when a given class or generic function is modified. The function record-updater is called to both create an updater and add it to the dependents of the class or generic function. Methods on the generic function ",(0,o.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),", specialized to the specific class of updater do the appropriate update work."]}),"\n",(0,o.jsxs)(t.p,{children:["(defclass updater ()\n((dependent ",":initarg"," ",":dependent"," ",":reader"," dependent)))"]}),"\n",(0,o.jsxs)(t.p,{children:["(defun record-updater (class dependee dependent &rest initargs)\n(let ((updater (apply #'make-instance class ",":dependent"," dependent\ninitargs)))\n(add-dependent dependee updater)\nupdater))"]}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.code,{children:"flush-cache-updater"})," simply flushes the cache of the dependent when it is updated."]}),"\n",(0,o.jsx)(t.p,{children:"(defclass flush-cache-updater (updater) ())"}),"\n",(0,o.jsx)(t.p,{children:"(defmethod update-dependent (dependee (updater flush-cache-updater)\n&rest args)\n(declare (ignore args))\n(flush-cache (dependent updater)))"})]})}function k(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(z,{...e})}):z(e)}const T={title:"5.5 Subprotocols"},I=void 0,S={id:"meta-object-protocol/chap-5/5-5-subprotocols",title:"5.5 Subprotocols",description:"5.5.1 Metaobject Initialization Protocols",source:"@site/docs/meta-object-protocol/chap-5/5-5-subprotocols.md",sourceDirName:"meta-object-protocol/chap-5",slug:"/meta-object-protocol/chap-5/5-5-subprotocols",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-5-subprotocols",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/chap-5/5-5-subprotocols.md",tags:[],version:"current",lastUpdatedBy:"daninus14",frontMatter:{title:"5.5 Subprotocols"},sidebar:"tutorialSidebar",previous:{title:"5.4 Processing Of The User Interface Macros",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-4-processing"},next:{title:"Chapter 6 - Generic Functions and Methods",permalink:"/cl-language-reference/category/chapter-6---generic-functions-and-methods"}},C={},_=[{value:"5.5.1 Metaobject Initialization Protocols",id:"551-metaobject-initialization-protocols",level:2},{value:"5.5.1.1 Initialization Of Class Metaobjects",id:"5511-initialization-of-class-metaobjects",level:3},{value:"5.5.1.2 Reinitialization Of Class Metaobjects",id:"5512-reinitialization-of-class-metaobjects",level:3},{value:"5.5.1.3 Initialization Of Generic Function And Method Metaobjects",id:"5513-initialization-of-generic-function-and-method-metaobjects",level:3},{value:"5.5.2 Class Finalization Protocol",id:"552-class-finalization-protocol",level:2},{value:"5.5.3 Instance Structure Protocol",id:"553-instance-structure-protocol",level:2},{value:"5.5.4 Funcallable Instances",id:"554-funcallable-instances",level:2},{value:"5.5.5 Generic Function Invocation Protocol",id:"555-generic-function-invocation-protocol",level:2},{value:"5.5.6 Dependent Maintenance Protocol",id:"556-dependent-maintenance-protocol",level:2}];function F(e){const t={h2:"h2",h3:"h3",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s,{}),"\n",(0,o.jsx)(t.h2,{id:"551-metaobject-initialization-protocols",children:"5.5.1 Metaobject Initialization Protocols"}),"\n","\n",(0,o.jsx)(l,{}),"\n",(0,o.jsx)(t.h3,{id:"5511-initialization-of-class-metaobjects",children:"5.5.1.1 Initialization Of Class Metaobjects"}),"\n","\n",(0,o.jsx)(d,{}),"\n",(0,o.jsx)(t.h3,{id:"5512-reinitialization-of-class-metaobjects",children:"5.5.1.2 Reinitialization Of Class Metaobjects"}),"\n","\n",(0,o.jsx)(p,{}),"\n",(0,o.jsx)(t.h3,{id:"5513-initialization-of-generic-function-and-method-metaobjects",children:"5.5.1.3 Initialization Of Generic Function And Method Metaobjects"}),"\n","\n",(0,o.jsx)(f,{}),"\n",(0,o.jsx)(t.h2,{id:"552-class-finalization-protocol",children:"5.5.2 Class Finalization Protocol"}),"\n","\n",(0,o.jsx)(j,{}),"\n",(0,o.jsx)(t.h2,{id:"553-instance-structure-protocol",children:"5.5.3 Instance Structure Protocol"}),"\n","\n",(0,o.jsx)(x,{}),"\n",(0,o.jsx)(t.h2,{id:"554-funcallable-instances",children:"5.5.4 Funcallable Instances"}),"\n","\n",(0,o.jsx)(w,{}),"\n",(0,o.jsx)(t.h2,{id:"555-generic-function-invocation-protocol",children:"5.5.5 Generic Function Invocation Protocol"}),"\n","\n",(0,o.jsx)(v,{}),"\n",(0,o.jsx)(t.h2,{id:"556-dependent-maintenance-protocol",children:"5.5.6 Dependent Maintenance Protocol"}),"\n","\n","\n",(0,o.jsx)(k,{})]})}function M(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(F,{...e})}):F(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>s});var o=n(67294);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);