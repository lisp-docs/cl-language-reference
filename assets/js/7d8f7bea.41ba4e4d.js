"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[99365],{21458:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>r});var n=t(85893),o=t(11151);const s={},a="Slot definitions",l={id:"meta-object-protocol/slot-definitions",title:"Slot definitions",description:"Slot definitions",source:"@site/docs/meta-object-protocol/slot-definitions.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/slot-definitions",permalink:"/cl-language-reference/meta-object-protocol/slot-definitions",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/slot-definitions.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"slot-definition-writers",permalink:"/cl-language-reference/meta-object-protocol/slot-definition-writers"},next:{title:"slot-makunbound-using-class-built-in-class",permalink:"/cl-language-reference/meta-object-protocol/slot-makunbound-using-class-built-in-class"}},c={},r=[{value:"Slot definitions",id:"slot-definitions-1",level:3}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"slot-definitions",children:"Slot definitions"}),"\n",(0,n.jsx)(i.h3,{id:"slot-definitions-1",children:"Slot definitions"}),"\n",(0,n.jsxs)(i.p,{children:["A ",(0,n.jsx)(i.em,{children:"slot definition metaobject"})," contains information about the definition of a slot. There are two kinds of slot definition metaobjects. A direct slot definition metaobject is used to represent the direct definition of a slot in a class. This corresponds roughly to the slot specifiers found in ",(0,n.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," forms. An effective slot definition metaobject is used to represent information, including inherited information, about a slot which is accessible in instances of a particular class."]}),"\n",(0,n.jsx)(i.p,{children:"Associated with each class metaobject is a list of direct slot definition metaobjects representing the slots defined directly in the class. Also associated with each class metaobject is a list of effective slot definition metaobjects representing the set of slots accessible in instances of that class."}),"\n",(0,n.jsx)(i.p,{children:"The following information is associated with both direct and effective slot definitions metaobjects:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["The name, allocation, and type are available as forms that could appear in a ",(0,n.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," form."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["The initialization form, if there is one, is available as a form that could appear in a ",(0,n.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," form. The initialization form together with its lexical environment is available as a function of no arguments which, when called, returns the result of evaluating the initialization form in its lexical environment. This is called the ",(0,n.jsx)(i.em,{children:"initfunction"})," of the slot."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"The slot filling initialization arguments are available as a list of symbols."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["The documentation is available as a string or ",(0,n.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Certain other information is only associated with direct slot definition metaobjects. This information applies only to the direct definition of the slot in the class (it is not inherited)."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["The function names of those generic functions for which there are automatically generated reader and writer methods. This information is available as lists of function names. Any accessors specified in the ",(0,n.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," form are broken down into their equivalent readers and writers in the direct slot definition."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Information, including inherited information, which applies to the definition of a slot in a particular class in which it is accessible is associated only with effective slot definition metaobjects."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"For certain slots, the location of the slot in instances of the class is available."}),"\n"]})]})}function f(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,i,t)=>{t.d(i,{Z:()=>l,a:()=>a});var n=t(67294);const o={},s=n.createContext(o);function a(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);