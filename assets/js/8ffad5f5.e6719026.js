"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[99266],{13357:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>d,toc:()=>p});var c=s(85893),i=s(11151);function r(n){const e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"})," ",(0,c.jsx)(e.em,{children:"Function"})]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Syntax:"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapc"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 list-1"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapcar"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 result-list"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapcan"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 concatenated-results"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapl"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 list-1"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"maplist"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 result-list"})]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapcon"})," ",(0,c.jsx)(e.em,{children:"function"})," &rest ",(0,c.jsx)(e.em,{children:"lists"}),(0,c.jsx)("sup",{children:"+"})," ",(0,c.jsx)(e.em,{children:"\u2192 concatenated-results"})]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Arguments and Values:"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"function"}),"\u2014a ",(0,c.jsx)(e.em,{children:"designator"})," for a ",(0,c.jsx)(e.em,{children:"function"})," that must take as many ",(0,c.jsx)(e.em,{children:"arguments"})," as there are ",(0,c.jsx)(e.em,{children:"lists"}),". ",(0,c.jsx)(e.em,{children:"list"}),"\u2014a ",(0,c.jsx)(e.em,{children:"proper list"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"list-1"}),"\u2014the first ",(0,c.jsx)(e.em,{children:"list"})," (which must be a ",(0,c.jsx)(e.em,{children:"proper list"}),")."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"result-list"}),"\u2014a ",(0,c.jsx)(e.em,{children:"list"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"concatenated-results"}),"\u2014a ",(0,c.jsx)(e.em,{children:"list"}),"."]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(e.p,{children:["The mapping operation involves applying ",(0,c.jsx)(e.em,{children:"function"})," to successive sets of arguments in which one argument is obtained from each ",(0,c.jsx)(e.em,{children:"sequence"}),". Except for ",(0,c.jsx)(e.strong,{children:"mapc"})," and ",(0,c.jsx)(e.strong,{children:"mapl"}),", the result contains the results returned by ",(0,c.jsx)(e.em,{children:"function"}),". In the cases of ",(0,c.jsx)(e.strong,{children:"mapc"})," and ",(0,c.jsx)(e.strong,{children:"mapl"}),", the resulting ",(0,c.jsx)(e.em,{children:"sequence"})," is ",(0,c.jsx)(e.em,{children:"list"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"function"})," is called first on all the elements with index 0, then on all those with index 1, and so on. ",(0,c.jsx)(e.em,{children:"result-type"})," specifies the ",(0,c.jsx)(e.em,{children:"type"})," of the resulting ",(0,c.jsx)(e.em,{children:"sequence"}),". If ",(0,c.jsx)(e.em,{children:"function"})," is a ",(0,c.jsx)(e.em,{children:"symbol"}),", it is ",(0,c.jsx)(e.strong,{children:"coerce"}),"d to a ",(0,c.jsx)(e.em,{children:"function"})," as if by ",(0,c.jsx)(e.strong,{children:"symbol-function"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapcar"})," operates on successive ",(0,c.jsx)(e.em,{children:"elements"})," of the ",(0,c.jsx)(e.em,{children:"lists"}),". ",(0,c.jsx)(e.em,{children:"function"})," is applied to the first ",(0,c.jsx)(e.em,{children:"element"})," of each ",(0,c.jsx)(e.em,{children:"list"}),", then to the second ",(0,c.jsx)(e.em,{children:"element"})," of each ",(0,c.jsx)(e.em,{children:"list"}),", and so on. The iteration terminates when the shortest ",(0,c.jsx)(e.em,{children:"list"})," runs out, and excess elements in other lists are ignored. The value returned by ",(0,c.jsx)(e.strong,{children:"mapcar"})," is a ",(0,c.jsx)(e.em,{children:"list"})," of the results of successive calls to ",(0,c.jsx)(e.em,{children:"function"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapc"})," is like ",(0,c.jsx)(e.strong,{children:"mapcar"})," except that the results of applying ",(0,c.jsx)(e.em,{children:"function"})," are not accumulated. The ",(0,c.jsx)(e.em,{children:"list"})," argument is returned."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"maplist"})," is like ",(0,c.jsx)(e.strong,{children:"mapcar"})," except that ",(0,c.jsx)(e.em,{children:"function"})," is applied to successive sublists of the ",(0,c.jsx)(e.em,{children:"lists"}),". ",(0,c.jsx)(e.em,{children:"function"})," is first applied to the ",(0,c.jsx)(e.em,{children:"lists"})," themselves, and then to the ",(0,c.jsx)(e.em,{children:"cdr"})," of each ",(0,c.jsx)(e.em,{children:"list"}),", and then to the ",(0,c.jsx)(e.em,{children:"cdr"})," of the ",(0,c.jsx)(e.em,{children:"cdr"})," of each ",(0,c.jsx)(e.em,{children:"list"}),", and so on."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapl"})," is like ",(0,c.jsx)(e.strong,{children:"maplist"})," except that the results of applying ",(0,c.jsx)(e.em,{children:"function"})," are not accumulated; ",(0,c.jsx)(e.em,{children:"list-1"})," is returned."]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"mapcan"})," and ",(0,c.jsx)(e.strong,{children:"mapcon"})," are like ",(0,c.jsx)(e.strong,{children:"mapcar"})," and ",(0,c.jsx)(e.strong,{children:"maplist"})," respectively, except that the results of applying ",(0,c.jsx)(e.em,{children:"function"})," are combined into a ",(0,c.jsx)(e.em,{children:"list"})," by the use of ",(0,c.jsx)(e.strong,{children:"nconc"})," rather than ",(0,c.jsx)(e.strong,{children:"list"}),". That is,"]}),"\n",(0,c.jsx)(e.p,{children:"(mapcon f x1 ... xn)"}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.em,{children:"\u2261"})," (apply #\u2019nconc (maplist f x1 ... xn))"]}),"\n",(0,c.jsxs)(e.p,{children:["and similarly for the relationship between ",(0,c.jsx)(e.strong,{children:"mapcan"})," and ",(0,c.jsx)(e.strong,{children:"mapcar"}),"."]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-lisp",children:" \n\n\n\n(mapcar #\u2019car \u2019((1 a) (2 b) (3 c))) *\u2192* (1 2 3) \n\n\n\n(mapcar #\u2019abs \u2019(3 -4 2 -5 -6)) *\u2192* (3 4 2 5 6) \n\n\n\n\n\n\n\n \n\n\n\n \n\n\n\n(mapcar #\u2019cons \u2019(a b c) \u2019(1 2 3)) *\u2192* ((A . 1) (B . 2) (C . 3)) \n\n\n\n(maplist #\u2019append \u2019(1 2 3 4) \u2019(1 2) \u2019(1 2 3)) \n\n\n\n*\u2192* ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) \n\n\n\n(maplist #\u2019(lambda (x) (cons \u2019foo x)) \u2019(a b c d)) \n\n\n\n*\u2192* ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D)) \n\n\n\n(maplist #\u2019(lambda (x) (if (member (car x) (cdr x)) 0 1)) \u2019(a b a c d b c)) *\u2192* (0 0 1 0 1 1 1) \n\n\n\n;An entry is 1 if the corresponding element of the input \n\n\n\n; list was the last instance of that element in the input list. \n\n\n\n(setq dummy nil) *\u2192* NIL \n\n\n\n(mapc #\u2019(lambda (&rest x) (setq dummy (append dummy x))) \n\n\n\n\u2019(1 2 3 4) \n\n\n\n\u2019(a b c d e) \n\n\n\n\u2019(x y z)) *\u2192* (1 2 3 4) \n\n\n\ndummy *\u2192* (1 A X 2 B Y 3 C Z) \n\n\n\n(setq dummy nil) *\u2192* NIL \n\n\n\n(mapl #\u2019(lambda (x) (push x dummy)) \u2019(1 2 3 4)) *\u2192* (1 2 3 4) \n\n\n\ndummy *\u2192* ((4) (3 4) (2 3 4) (1 2 3 4)) \n\n\n\n(mapcan #\u2019(lambda (x y) (if (null x) nil (list x y))) \n\n\n\n\u2019(nil nil nil d e) \n\n\n\n\u2019(1 2 3 4 5 6)) *\u2192* (D 4 E 5) \n\n\n\n(mapcan #\u2019(lambda (x) (and (numberp x) (list x))) \n\n\n\n\u2019(a 1 b c 3 4 d 5)) \n\n\n\n*\u2192* (1 3 4 5) \n\n\n\nIn this case the function serves as a filter; this is a standard Lisp idiom using **mapcan**. (mapcon #\u2019list \u2019(1 2 3 4)) *\u2192* ((1 2 3 4) (2 3 4) (3 4) (4)) \n\n\n\n\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Exceptional Situations:"})}),"\n",(0,c.jsxs)(e.p,{children:["Should be prepared to signal an error of ",(0,c.jsx)(e.em,{children:"type"})," ",(0,c.jsx)(e.strong,{children:"type-error"})," if any ",(0,c.jsx)(e.em,{children:"list"})," is not a ",(0,c.jsx)(e.em,{children:"proper list"}),"."]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"See Also:"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"dolist"}),", ",(0,c.jsx)(e.strong,{children:"map"}),", Section 3.6 (Traversal Rules and Side Effects)"]})]})}function t(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(r,{...n})}):r(n)}const a={},l="mapc, mapcar, mapcan, mapl, maplist, mapcon",d={id:"chap-14/be-c-dictionary/mapc",title:"mapc, mapcar, mapcan, mapl, maplist, mapcon",description:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon",source:"@site/docs/chap-14/be-c-dictionary/mapc.md",sourceDirName:"chap-14/be-c-dictionary",slug:"/chap-14/be-c-dictionary/mapc",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/mapc",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-14/be-c-dictionary/mapc.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"make-list",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/makelist"},next:{title:"member, member-if, member-if-not",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/member"}},m={},p=[{value:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon",id:"expanded-reference-mapc-mapcar-mapcan-mapl-maplist-mapcon",level:2}];function o(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.h1,{id:"mapc-mapcar-mapcan-mapl-maplist-mapcon",children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"}),"\n","\n","\n",(0,c.jsx)(t,{}),"\n",(0,c.jsx)(e.h2,{id:"expanded-reference-mapc-mapcar-mapcan-mapl-maplist-mapcon",children:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon"}),"\n",(0,c.jsx)(e.admonition,{type:"tip",children:(0,c.jsx)(e.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-lisp",children:"(mapc, mapcar, mapcan, mapl, maplist, mapcon )\n"})})]})}function h(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(o,{...n})}):o(n)}},11151:(n,e,s)=>{s.d(e,{Z:()=>a,a:()=>t});var c=s(67294);const i={},r=c.createContext(i);function t(n){const e=c.useContext(r);return c.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:t(n.components),c.createElement(r.Provider,{value:e},n.children)}}}]);