"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[48705],{48710:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>j,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var i=r(85893),s=r(11151);function t(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"object"})," &optional ",(0,i.jsx)(n.em,{children:"environment \u2192 creation-form"}),"[",(0,i.jsx)(n.em,{children:", initialization-form"}),"]"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"structure-object"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"condition"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"class"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"environment"}),"\u2014an ",(0,i.jsx)(n.em,{children:"environment object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"creation-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initialization-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"})," creates and returns one or two ",(0,i.jsx)(n.em,{children:"forms"}),", a ",(0,i.jsx)(n.em,{children:"creation-form"})," and an ",(0,i.jsx)(n.em,{children:"initialization-form"}),", that enable ",(0,i.jsx)(n.strong,{children:"load"})," to construct an ",(0,i.jsx)(n.em,{children:"object"})," equivalent to ",(0,i.jsx)(n.em,{children:"object"}),". ",(0,i.jsx)(n.em,{children:"Environment"})," is an ",(0,i.jsx)(n.em,{children:"environment object"})," corresponding to the ",(0,i.jsx)(n.em,{children:"lexical environment"})," in which the ",(0,i.jsx)(n.em,{children:"forms"})," will be processed."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"file compiler"})," calls ",(0,i.jsx)(n.strong,{children:"make-load-form"})," to process certain ",(0,i.jsx)(n.em,{children:"classes"})," of ",(0,i.jsx)(n.em,{children:"literal objects"}),"; see Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Conforming programs"})," may call ",(0,i.jsx)(n.strong,{children:"make-load-form"})," directly, providing ",(0,i.jsx)(n.em,{children:"object"})," is a ",(0,i.jsx)(n.em,{children:"generalized instance"})," of ",(0,i.jsx)(n.strong,{children:"standard-object"}),", ",(0,i.jsx)(n.strong,{children:"structure-object"}),", or ",(0,i.jsx)(n.strong,{children:"condition"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The creation form is a ",(0,i.jsx)(n.em,{children:"form"})," that, when evaluated at ",(0,i.jsx)(n.strong,{children:"load"})," time, should return an ",(0,i.jsx)(n.em,{children:"object"})," that is equivalent to ",(0,i.jsx)(n.em,{children:"object"}),". The exact meaning of equivalent depends on the ",(0,i.jsx)(n.em,{children:"type"})," of ",(0,i.jsx)(n.em,{children:"object"})," and is up to the programmer who defines a ",(0,i.jsx)(n.em,{children:"method"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"; see Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsxs)(n.p,{children:["The initialization form is a ",(0,i.jsx)(n.em,{children:"form"})," that, when evaluated at ",(0,i.jsx)(n.strong,{children:"load"})," time, should perform further initialization of the ",(0,i.jsx)(n.em,{children:"object"}),". The value returned by the initialization form is ignored. If ",(0,i.jsx)(n.strong,{children:"make-load-form"})," returns only one value, the initialization form is ",(0,i.jsx)(n.strong,{children:"nil"}),", which has no effect. If ",(0,i.jsx)(n.em,{children:"object"})," appears as a constant in the initialization form, at ",(0,i.jsx)(n.strong,{children:"load"})," time it will be replaced by the equivalent ",(0,i.jsx)(n.em,{children:"object"})," constructed by the creation form; this is how the further initialization gains access to the ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Both the ",(0,i.jsx)(n.em,{children:"creation-form"})," and the ",(0,i.jsx)(n.em,{children:"initialization-form"})," may contain references to any ",(0,i.jsx)(n.em,{children:"externalizable object"}),". However, there must not be any circular dependencies in creation forms. An example of a circular dependency is when the creation form for the object X contains a reference to the object Y, and the creation form for the object Y contains a reference to the object X. Initialization forms are not subject to any restriction against circular dependencies, which is the reason that initialization forms exist; see the example of circular data structures below."]}),"\n",(0,i.jsxs)(n.p,{children:["The creation form for an ",(0,i.jsx)(n.em,{children:"object"})," is always ",(0,i.jsx)(n.em,{children:"evaluated"})," before the initialization form for that ",(0,i.jsx)(n.em,{children:"object"}),". When either the creation form or the initialization form references other ",(0,i.jsx)(n.em,{children:"objects"})," that have not been referenced earlier in the ",(0,i.jsx)(n.em,{children:"file"})," being ",(0,i.jsx)(n.em,{children:"compiled"}),", the ",(0,i.jsx)(n.em,{children:"compiler"})," ensures that all of the referenced ",(0,i.jsx)(n.em,{children:"objects"})," have been created before ",(0,i.jsx)(n.em,{children:"evaluating"})," the referencing ",(0,i.jsx)(n.em,{children:"form"}),". When the referenced ",(0,i.jsx)(n.em,{children:"object"})," is of a ",(0,i.jsx)(n.em,{children:"type"})," which the ",(0,i.jsx)(n.em,{children:"file compiler"})," processes using ",(0,i.jsx)(n.strong,{children:"make-load-form"}),", this involves ",(0,i.jsx)(n.em,{children:"evaluating"})," the creation form returned for it. (This is the reason for the prohibition against circular references among creation forms)."]}),"\n",(0,i.jsxs)(n.p,{children:["Each initialization form is ",(0,i.jsx)(n.em,{children:"evaluated"})," as soon as possible after its associated creation form, as determined by data flow. If the initialization form for an ",(0,i.jsx)(n.em,{children:"object"})," does not reference any other ",(0,i.jsx)(n.em,{children:"objects"})," not referenced earlier in the ",(0,i.jsx)(n.em,{children:"file"})," and processed by the ",(0,i.jsx)(n.em,{children:"file compiler"})," using ",(0,i.jsx)(n.strong,{children:"make-load-form"}),", the initialization form is evaluated immediately after the creation form. If a creation or initialization form ",(0,i.jsx)(n.em,{children:"F"})," does contain references to such ",(0,i.jsx)(n.em,{children:"objects"}),", the creation forms for those other objects are evaluated before ",(0,i.jsx)(n.em,{children:"F"}),", and the initialization forms for those other ",(0,i.jsx)(n.em,{children:"objects"})," are also evaluated before ",(0,i.jsx)(n.em,{children:"F"})," whenever they do not depend on the ",(0,i.jsx)(n.em,{children:"object"})," created or initialized by ",(0,i.jsx)(n.em,{children:"F"}),". Where these rules do not uniquely determine an order of ",(0,i.jsx)(n.em,{children:"evaluation"})," between two creation/initialization forms, the order of ",(0,i.jsx)(n.em,{children:"evaluation"})," is unspecified."]}),"\n",(0,i.jsxs)(n.p,{children:["While these creation and initialization forms are being evaluated, the ",(0,i.jsx)(n.em,{children:"objects"})," are possibly in an uninitialized state, analogous to the state of an ",(0,i.jsx)(n.em,{children:"object"})," between the time it has been created by ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," and it has been processed fully by ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),". Programmers writing"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"})," must take care in manipulating ",(0,i.jsx)(n.em,{children:"objects"})," not to depend on ",(0,i.jsx)(n.em,{children:"slots"})," that have not yet been initialized."]}),"\n",(0,i.jsxs)(n.p,{children:["It is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(n.strong,{children:"load"})," calls ",(0,i.jsx)(n.strong,{children:"eval"})," on the ",(0,i.jsx)(n.em,{children:"forms"})," or does some other operation that has an equivalent effect. For example, the ",(0,i.jsx)(n.em,{children:"forms"})," might be translated into different but equivalent ",(0,i.jsx)(n.em,{children:"forms"})," and then evaluated, they might be compiled and the resulting functions called by ",(0,i.jsx)(n.strong,{children:"load"}),", or they might be interpreted by a special-purpose function different from ",(0,i.jsx)(n.strong,{children:"eval"}),". All that is required is that the effect be equivalent to evaluating the ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"method specialized"})," on ",(0,i.jsx)(n.strong,{children:"class"})," returns a creation ",(0,i.jsx)(n.em,{children:"form"})," using the ",(0,i.jsx)(n.em,{children:"name"})," of the ",(0,i.jsx)(n.em,{children:"class"})," if the ",(0,i.jsx)(n.em,{children:"class"})," has a ",(0,i.jsx)(n.em,{children:"proper name"})," in ",(0,i.jsx)(n.em,{children:"environment"}),", signaling an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," if it does not have a ",(0,i.jsx)(n.em,{children:"proper name"}),". ",(0,i.jsx)(n.em,{children:"Evaluation"})," of the creation ",(0,i.jsx)(n.em,{children:"form"})," uses the ",(0,i.jsx)(n.em,{children:"name"})," to find the ",(0,i.jsx)(n.em,{children:"class"})," with that ",(0,i.jsx)(n.em,{children:"name"}),", as if by"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"calling"})," ",(0,i.jsx)(n.strong,{children:"find-class"}),". If a ",(0,i.jsx)(n.em,{children:"class"})," with that ",(0,i.jsx)(n.em,{children:"name"})," has not been defined, then a ",(0,i.jsx)(n.em,{children:"class"})," may be computed in an ",(0,i.jsx)(n.em,{children:"implementation-defined"})," manner. If a ",(0,i.jsx)(n.em,{children:"class"})," cannot be returned as the result of ",(0,i.jsx)(n.em,{children:"evaluating"})," the creation ",(0,i.jsx)(n.em,{children:"form"}),", then an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.em,{children:"conforming implementations"})," and ",(0,i.jsx)(n.em,{children:"conforming programs"})," may further ",(0,i.jsx)(n.em,{children:"specialize"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass obj ()"}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initarg"," ",":x"," ",":reader"," obj-x)"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initarg"," ",":y"," ",":reader"," obj-y)"]}),"\n",(0,i.jsxs)(n.p,{children:["(dist ",":accessor"," obj-dist)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-CLASS OBJ 250020030>"]}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod shared-initialize ",":after"," ((self obj) slot-names &rest keys)"]}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore slot-names keys))"}),"\n",(0,i.jsx)(n.p,{children:"(unless (slot-boundp self \u2019dist)"}),"\n",(0,i.jsx)(n.p,{children:"(setf (obj-dist self)"}),"\n",(0,i.jsx)(n.p,{children:"(sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD SHARED-INITIALIZE (",":AFTER",") (OBJ T) 26266714>"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self obj) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsx)(n.p,{children:";; Note that this definition only works because X and Y do not"}),"\n",(0,i.jsx)(n.p,{children:";; contain information which refers back to the object itself."}),"\n",(0,i.jsx)(n.p,{children:";; For a more general solution to this problem, see revised example below."}),"\n",(0,i.jsx)(n.p,{children:"\u2018(make-instance \u2019,(class-of self)"}),"\n",(0,i.jsxs)(n.p,{children:[":x"," \u2019,(obj-x self) ",":y"," \u2019,(obj-y self)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq obj1 (make-instance \u2019obj ",":x"," 3.0 ",":y"," 4.0)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<OBJ 26274136>"]}),"\n",(0,i.jsxs)(n.p,{children:["(obj-dist obj1) ",(0,i.jsx)(n.em,{children:"\u2192"})," 5.0"]}),"\n",(0,i.jsxs)(n.p,{children:["(make-load-form obj1) ",(0,i.jsx)(n.em,{children:"\u2192"})," (MAKE-INSTANCE \u2019OBJ ",":X"," \u20193.0 ",":Y"," \u20194.0)"]}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, an equivalent ",(0,i.jsx)(n.em,{children:"instance"})," of obj is reconstructed by using the values of two of its ",(0,i.jsx)(n.em,{children:"slots"}),". The value of the third ",(0,i.jsx)(n.em,{children:"slot"})," is derived from those two values."]}),"\n",(0,i.jsxs)(n.p,{children:["Another way to write the ",(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"method"})," in that example is to use ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"}),". The code it generates might yield a slightly different result from the ",(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"method"})," shown above, but the operational effect will be the same. For example:"]}),"\n",(0,i.jsx)(n.p,{children:";; Redefine method defined above."}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self obj) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(make-load-form-saving-slots self"}),"\n",(0,i.jsxs)(n.p,{children:[":slot-names"," \u2019(x y)"]}),"\n",(0,i.jsxs)(n.p,{children:[":environment"," environment))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsx)(n.p,{children:";; Try MAKE-LOAD-FORM on object created above."}),"\n",(0,i.jsx)(n.p,{children:"(make-load-form obj1)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," (ALLOCATE-INSTANCE \u2019#<STANDARD-CLASS OBJ 250020030>),"]}),"\n",(0,i.jsx)(n.p,{children:"(PROGN"}),"\n",(0,i.jsx)(n.p,{children:"(SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019X) \u20193.0)"}),"\n",(0,i.jsx)(n.p,{children:"(SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019Y) \u20194.0)"}),"\n",(0,i.jsx)(n.p,{children:"(INITIALIZE-INSTANCE \u2019#<OBJ 26274136>))"}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, ",(0,i.jsx)(n.em,{children:"instances"})," of my-frob are \u201cinterned\u201d in some way. An equivalent ",(0,i.jsx)(n.em,{children:"instance"})," is reconstructed by using the value of the name slot as a key for searching existing ",(0,i.jsx)(n.em,{children:"objects"}),". In this case the programmer has chosen to create a new ",(0,i.jsx)(n.em,{children:"object"})," if no existing ",(0,i.jsx)(n.em,{children:"object"})," is found; alternatively an error could have been signaled in that case."]}),"\n",(0,i.jsx)(n.p,{children:"(defclass my-frob ()"}),"\n",(0,i.jsxs)(n.p,{children:["((name ",":initarg"," ",":name"," ",":reader"," my-name)))"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self my-frob) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsxs)(n.p,{children:["\u2018(find-my-frob \u2019,(my-name self) ",":if-does-not-exist"," ",":create","))"]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, the data structure to be dumped is circular, because each parent has a list of its children and each child has a reference back to its parent. If ",(0,i.jsx)(n.strong,{children:"make-load-form"})," is called on one ",(0,i.jsx)(n.em,{children:"object"})," in such a structure, the creation form creates an equivalent ",(0,i.jsx)(n.em,{children:"object"})," and fills in the children slot, which forces creation of equivalent ",(0,i.jsx)(n.em,{children:"objects"})," for all of its children, grandchildren, etc."]}),"\n",(0,i.jsxs)(n.p,{children:["At this point none of the parent ",(0,i.jsx)(n.em,{children:"slots"})," have been filled in. The initialization form fills in the parent ",(0,i.jsx)(n.em,{children:"slot"}),", which forces creation of an equivalent ",(0,i.jsx)(n.em,{children:"object"})," for the parent if it was not already created. Thus the entire tree is recreated at ",(0,i.jsx)(n.strong,{children:"load"})," time. At compile time, ",(0,i.jsx)(n.strong,{children:"make-load-form"})," is called once for each ",(0,i.jsx)(n.em,{children:"object"})," in the tree. All of the creation forms are evaluated, in ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," order, and then all of the initialization forms are evaluated, also in ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," order."]}),"\n",(0,i.jsxs)(n.p,{children:["(defclass tree-with-parent () ((parent ",":accessor"," tree-parent)"]}),"\n",(0,i.jsxs)(n.p,{children:["(children ",":initarg"," ",":children",")))"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((x tree-with-parent) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsx)(n.p,{children:"(values"}),"\n",(0,i.jsx)(n.p,{children:";; creation form"}),"\n",(0,i.jsxs)(n.p,{children:["\u2018(make-instance \u2019,(class-of x) ",":children"," \u2019,(slot-value x \u2019children))"]}),"\n",(0,i.jsx)(n.p,{children:";; initialization form"}),"\n",(0,i.jsx)(n.p,{children:"\u2018(setf (tree-parent \u2019,x) \u2019,(slot-value x \u2019parent))))"}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, the data structure to be dumped has no special properties and an equivalent structure can be reconstructed simply by reconstructing the ",(0,i.jsx)(n.em,{children:"slots"}),"\u2019 contents."]}),"\n",(0,i.jsx)(n.p,{children:"(defstruct my-struct a b c)"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((s my-struct) &optional environment)"}),"\n",(0,i.jsxs)(n.p,{children:["(make-load-form-saving-slots s ",":environment"," environment))"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"methods specialized"})," on ",(0,i.jsx)(n.strong,{children:"standard-object"}),", ",(0,i.jsx)(n.strong,{children:"structure-object"}),", and ",(0,i.jsx)(n.strong,{children:"condition"})," all signal an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(n.em,{children:"calling"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"})," on a ",(0,i.jsx)(n.em,{children:"generalized instance"})," of a ",(0,i.jsx)(n.em,{children:"system class"})," signals an error or returns creation and initialization ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compile-file"}),", ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"}),", Section 3.2.4.4 (Additional Constraints on Externaliz able Objects) Section 3.1 (Evaluation), Section 3.2 (Compilation)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"file compiler"})," calls ",(0,i.jsx)(n.strong,{children:"make-load-form"})," in specific circumstances detailed in Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,i.jsxs)(n.p,{children:["Some ",(0,i.jsx)(n.em,{children:"implementations"})," may provide facilities for defining new ",(0,i.jsx)(n.em,{children:"subclasses"})," of ",(0,i.jsx)(n.em,{children:"classes"})," which are specified as ",(0,i.jsx)(n.em,{children:"system classes"}),". (Some likely candidates include ",(0,i.jsx)(n.strong,{children:"generic-function"}),", ",(0,i.jsx)(n.strong,{children:"method"}),", and ",(0,i.jsx)(n.strong,{children:"stream"}),"). Such ",(0,i.jsx)(n.em,{children:"implementations"})," should document how the ",(0,i.jsx)(n.em,{children:"file compiler"})," processes ",(0,i.jsx)(n.em,{children:"instances"})," of such ",(0,i.jsx)(n.em,{children:"classes"})," when encountered as ",(0,i.jsx)(n.em,{children:"literal objects"}),", and should document any relevant ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"."]})]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}const l={},a="make-load-form",c={id:"chap-7/h-h-dictionary/makeloadform",title:"make-load-form",description:"Expanded Reference: make-load-form",source:"@site/docs/chap-7/h-h-dictionary/makeloadform.md",sourceDirName:"chap-7/h-h-dictionary",slug:"/chap-7/h-h-dictionary/makeloadform",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/makeloadform",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-7/h-h-dictionary/makeloadform.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"make-instances-obsolete",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/makeinstancesobsolete"},next:{title:"make-load-form-saving-slots",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/makeloadformsavingslots"}},d={},h=[{value:"Expanded Reference: make-load-form",id:"expanded-reference-make-load-form",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"make-load-form",children:"make-load-form"}),"\n","\n","\n",(0,i.jsx)(o,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-make-load-form",children:"Expanded Reference: make-load-form"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(make-load-form )\n"})})]})}function j(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>o});var i=r(67294);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);