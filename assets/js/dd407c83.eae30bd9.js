"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[34890],{15966:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>i});var s=o(85893),n=o(11151);const c={},a="Instance Structure Protocol",r={id:"meta-object-protocol/instance-structure-protocol",title:"Instance Structure Protocol",description:"Instance Structure Protocol",source:"@site/docs/meta-object-protocol/instance-structure-protocol.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/instance-structure-protocol",permalink:"/cl-language-reference/meta-object-protocol/instance-structure-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/instance-structure-protocol.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Initialization of Slot Definition Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-slot-definition-metaobjects"},next:{title:"intern-eql-specializer",permalink:"/cl-language-reference/meta-object-protocol/intern-eql-specializer"}},l={},i=[{value:"Instance Structure Protocol",id:"instance-structure-protocol-1",level:3},{value:"Example:",id:"example",level:4}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",p:"p",strong:"strong",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"instance-structure-protocol",children:"Instance Structure Protocol"}),"\n",(0,s.jsx)(t.h3,{id:"instance-structure-protocol-1",children:"Instance Structure Protocol"}),"\n",(0,s.jsxs)(t.p,{children:["The instance structure protocol is responsible for implementing the behavior of the slot access functions like ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"slot-value"})," and ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"(setf slot-value)"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For each CLOS slot access function other than ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_ex.htm#slot-exists-p",children:"slot-exists-p"}),", there is a corresponding generic function which actually provides the behavior of the function. When called, the slot access function finds the pertinent effective slot definition metaobject, calls the corresponding generic function and returns its result. The arguments passed on to the generic function include one additional value, the class of the ",(0,s.jsx)(t.em,{children:"object"})," argument, which always immediately precedes the ",(0,s.jsx)(t.em,{children:"object"})," argument."]}),"\n",(0,s.jsx)(t.p,{children:"The correspondences between slot access function and underlying slot access generic function are as follows:"}),"\n",(0,s.jsx)(t.p,{children:"Slot access function                                                                                    Corresponding slot access generic function"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_bo.htm#slot-boundp",children:"slot-boundp"}),"           ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/slot-boundp-using-class",children:"slot-boundp-using-class"}),"\n",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_ma.htm#slot-makunbound",children:"slot-makunbound"}),"   ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/slot-makunbound-using-class",children:"slot-makunbound-using-class"}),"\n",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"slot-value"}),"             ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/slot-value-using-class",children:"slot-value-using-class"}),"\n",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_slt_va.htm#slot-value",children:"(setf slot-value)"}),"      ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/setf-slot-value-using-class",children:"(setf slot-value-using-class)"})]}),"\n",(0,s.jsx)(t.p,{children:"At the lowest level, the instance structure protocol provides only limited mechanisms for portable programs to control the implementation of instances and to directly access the storage associated with instances without going through the indirection of slot access. This is done to allow portable programs to perform certain commonly requested slot access optimizations."}),"\n",(0,s.jsxs)(t.p,{children:["In particular, portable programs can control the implementation of, and obtain direct access to, slots with allocation ",(0,s.jsx)(t.code,{children:":instance"})," and type ",(0,s.jsx)(t.strong,{children:"t"}),". These are called ",(0,s.jsx)(t.em,{children:"directly accessible slots"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The relevant specified around-method on ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," determines the implementation of instances by deciding how each slot in the instance will be stored. For each directly accessible slot, this method allocates a ",(0,s.jsx)(t.em,{children:"location"})," and associates it with the effective slot definition metaobject. The location can be accessed by calling the ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/slot-definition-location",children:"slot-definition-location"})," generic function. Locations are non-negative integers. For a given class, the locations increase consecutively, in the order that the directly accessible slots appear in the list of effective slots. (Note that here, the next paragraph, and the specification of this around-method are the only places where the value returned by ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," is described as a list rather than a set.)"]}),"\n",(0,s.jsxs)(t.p,{children:["Given the location of a directly accessible slot, the value of that slot in an instance can be accessed with the appropriate accessor. For ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),", this accessor is the function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/standard-instance-access",children:"standard-instance-access"}),". For ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"}),", this accessor is the function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/funcallable-standard-instance-access",children:"funcallable-standard-instance-access"}),". In each case, the arguments to the accessor are the instance and the slot location, in that order. See the definition of each accessor for additional restrictions on the use of these function."]}),"\n",(0,s.jsx)(t.h4,{id:"example",children:"Example:"}),"\n",(0,s.jsxs)(t.p,{children:["The following example shows the use of this mechanism to implement a new class metaobject class, ",(0,s.jsx)(t.code,{children:"ordered-class"})," and class option ",(0,s.jsx)(t.code,{children:":slot-order"}),". This option provides control over the allocation of slot locations. In this simple example implementation, the ",(0,s.jsx)(t.code,{children:":slot-order"})," option is not inherited by subclasses; it controls only instances of the class itself."]}),"\n",(0,s.jsxs)(t.p,{children:["(defclass ordered-class (standard-class)\n((slot-order ",":initform"," ()\n",":initarg"," ",":slot-order","\n",":reader"," class-slot-order)))"]}),"\n",(0,s.jsx)(t.p,{children:"(defmethod compute-slots ((class ordered-class))\n(let ((order (class-slot-order class)))\n(sort (copy-list (call-next-method))\n#'(lambda (a b)\n(< (position (slot-definition-name a) order)\n(position (slot-definition-name b) order))))))"}),"\n",(0,s.jsxs)(t.p,{children:["Following is the source code the user of this extension would write. Note that because the code above doesn't implement inheritance of the ",(0,s.jsx)(t.code,{children:":slot-order"})," option, the function ",(0,s.jsx)(t.code,{children:"distance"})," must not be called on instances of subclasses of ",(0,s.jsx)(t.code,{children:"point"}),"; it can only be called on instances of ",(0,s.jsx)(t.code,{children:"point"})," itself."]}),"\n",(0,s.jsxs)(t.p,{children:["(defclass point ()\n((x ",":initform"," 0)\n(y ",":initform"," 0))\n(",":metaclass"," ordered-class)\n(",":slot-order"," x y))"]}),"\n",(0,s.jsx)(t.p,{children:"(defun distance (point)\n(sqrt (/ (+ (expt (standard-instance-access point 0) 2)\n(expt (standard-instance-access point 1) 2))\n2.0)))"}),"\n",(0,s.jsx)(t.p,{children:"In more realistic uses of this mechanism, the calls to the low-level instance structure accessors would not actually appear textually in the source program, but rather would be generated by a meta-level analysis program run during the process of compiling the source program."})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>r,a:()=>a});var s=o(67294);const n={},c=s.createContext(n);function a(e){const t=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(c.Provider,{value:t},e.children)}}}]);