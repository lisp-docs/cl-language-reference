"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[23517],{6954:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>l,frontMatter:()=>d,metadata:()=>r,toc:()=>s});var a=n(85893),o=n(11151);const d={},c="Dependent maintenance protocol",r={id:"meta-object-protocol/dependent-maintenance-protocol",title:"Dependent maintenance protocol",description:"Dependent maintenance protocol",source:"@site/docs/meta-object-protocol/dependent-maintenance-protocol.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/dependent-maintenance-protocol",permalink:"/cl-language-reference/meta-object-protocol/dependent-maintenance-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/dependent-maintenance-protocol.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"compute-slots",permalink:"/cl-language-reference/meta-object-protocol/compute-slots"},next:{title:"direct-slot-definition-class-funcallable-standard-class",permalink:"/cl-language-reference/meta-object-protocol/direct-slot-definition-class-funcallable-standard-class"}},i={},s=[{value:"Dependent maintenance protocol",id:"dependent-maintenance-protocol-1",level:3}];function p(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",p:"p",strong:"strong",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"dependent-maintenance-protocol",children:"Dependent maintenance protocol"}),"\n",(0,a.jsx)(t.h3,{id:"dependent-maintenance-protocol-1",children:"Dependent maintenance protocol"}),"\n",(0,a.jsx)(t.p,{children:"It is convenient for portable metaobjects to be able to memoize information about other metaobjects, portable or otherwise. Because class and generic function metaobjects can be reinitialized, and generic function metaobjects can be modified by adding and removing methods, a means must be provided to update this memoized information."}),"\n",(0,a.jsxs)(t.p,{children:["The dependent maintenance protocol supports this by providing a way to register an object which should be notified whenever a class or generic function is modified. An object which has been registered this way is called a ",(0,a.jsx)(t.em,{children:"dependent"})," of the class or generic function metaobject. The dependents of class and generic function metaobjects are maintained with ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/add-dependent",children:"add-dependent"})," and ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/remove-dependent",children:"remove-dependent"}),". The dependents of a class or generic function metaobject can be accessed with ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/map-dependents",children:"map-dependents"}),". Dependents are notified about a modification by calling ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),". (See the specification of ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"})," for detailed description of the circumstances under which it is called.)"]}),"\n",(0,a.jsx)(t.p,{children:"To prevent conflicts between two portable programs, or between portable programs and the implementation, portable code must not register metaobjects themselves as dependents. Instead, portable programs which need to record a metaobject as a dependent, should encapsulate that metaobject in some other kind of object, and record that object as the dependent. The results are undefined if this restriction is violated."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example:"})}),"\n",(0,a.jsx)(t.p,{children:"This example shows a general facility for encapsulating metaobjects before recording them as dependents. The facility defines a basic kind of encapsulating object: an updater. Specializations of the basic class can be defined with appropriate special updating behavior. In this way, information about the updating required is associated with each updater rather than with the metaobject being updated."}),"\n",(0,a.jsxs)(t.p,{children:["Updaters are used to encapsulate any metaobject which requires updating when a given class or generic function is modified. The function record-updater is called to both create an updater and add it to the dependents of the class or generic function. Methods on the generic function ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),", specialized to the specific class of updater do the appropriate update work."]}),"\n",(0,a.jsxs)(t.p,{children:["(defclass updater ()\n((dependent ",":initarg"," ",":dependent"," ",":reader"," dependent)))"]}),"\n",(0,a.jsxs)(t.p,{children:["(defun record-updater (class dependee dependent &rest initargs)\n(let ((updater (apply #'make-instance class ",":dependent"," dependent\ninitargs)))\n(add-dependent dependee updater)\nupdater))"]}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.code,{children:"flush-cache-updater"})," simply flushes the cache of the dependent when it is updated."]}),"\n",(0,a.jsx)(t.p,{children:"(defclass flush-cache-updater (updater) ())"}),"\n",(0,a.jsx)(t.p,{children:"(defmethod update-dependent (dependee (updater flush-cache-updater)\n&rest args)\n(declare (ignore args))\n(flush-cache (dependent updater)))"})]})}function l(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>c});var a=n(67294);const o={},d=a.createContext(o);function c(e){const t=a.useContext(d);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(d.Provider,{value:t},e.children)}}}]);