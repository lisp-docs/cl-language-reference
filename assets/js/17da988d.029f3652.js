"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[16807],{97072:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>ze,contentTitle:()=>Me,default:()=>Xe,frontMatter:()=>Ue,metadata:()=>We,toc:()=>Ve});var r=s(85893),i=s(11151);function t(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["If the reader encounters a ",(0,r.jsx)(n.em,{children:"macro character"})," , then its associated ",(0,r.jsx)(n.em,{children:"reader macro function"})," is invoked and may produce an ",(0,r.jsx)(n.em,{children:"object"})," to be returned. This ",(0,r.jsx)(n.em,{children:"function"})," may read the ",(0,r.jsx)(n.em,{children:"characters"})," following the ",(0,r.jsx)(n.em,{children:"macro character"})," in the ",(0,r.jsx)(n.em,{children:"stream"})," in any syntax and return the ",(0,r.jsx)(n.em,{children:"object"})," represented by that syntax."]}),"\n",(0,r.jsxs)(n.p,{children:["Any ",(0,r.jsx)(n.em,{children:"character"})," can be made to be a ",(0,r.jsx)(n.em,{children:"macro character"})," . The ",(0,r.jsx)(n.em,{children:"macro characters"})," defined initially in a ",(0,r.jsx)(n.em,{children:"conforming implementation"})," include the following:"]})]})}function a(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}function o(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"left-parenthesis"})," initiates reading of a ",(0,r.jsx)(n.em,{children:"list"}),". ",(0,r.jsx)(n.strong,{children:"read"})," is called recursively to read successive ",(0,r.jsx)(n.em,{children:"objects"})," until a right parenthesis is found in the input ",(0,r.jsx)(n.em,{children:"stream"}),". A ",(0,r.jsx)(n.em,{children:"list"})," of the ",(0,r.jsx)(n.em,{children:"objects"})," read is returned. Thus"]}),"\n",(0,r.jsx)(n.p,{children:"(a b c)"}),"\n",(0,r.jsxs)(n.p,{children:["is read as a ",(0,r.jsx)(n.em,{children:"list"})," of three ",(0,r.jsx)(n.em,{children:"objects"})," (the ",(0,r.jsx)(n.em,{children:"symbols"})," a, b, and c). The right parenthesis need not immediately follow the printed representation of the last ",(0,r.jsx)(n.em,{children:"object"}),"; ",(0,r.jsx)(n.em,{children:"whitespace"}),(0,r.jsx)("sub",{children:"2"})," characters and comments may precede it."]}),"\n",(0,r.jsxs)(n.p,{children:["If no ",(0,r.jsx)(n.em,{children:"objects"})," precede the right parenthesis, it reads as a ",(0,r.jsx)(n.em,{children:"list"})," of zero ",(0,r.jsx)(n.em,{children:"objects"})," (the ",(0,r.jsx)(n.em,{children:"empty list"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.em,{children:"token"})," that is just a dot not immediately preceded by an escape character is read after some ",(0,r.jsx)(n.em,{children:"object"})," then exactly one more ",(0,r.jsx)(n.em,{children:"object"})," must follow the dot, possibly preceded or followed by ",(0,r.jsx)(n.em,{children:"whitespace"}),(0,r.jsx)("sub",{children:"2"})," or a comment, followed by the right parenthesis:"]}),"\n",(0,r.jsx)(n.p,{children:"(a b c . d)"}),"\n",(0,r.jsxs)(n.p,{children:["This means that the ",(0,r.jsx)(n.em,{children:"cdr"})," of the last ",(0,r.jsx)(n.em,{children:"cons"})," in the ",(0,r.jsx)(n.em,{children:"list"})," is not ",(0,r.jsx)(n.strong,{children:"nil"}),", but rather the ",(0,r.jsx)(n.em,{children:"object"})," whose representation followed the dot. The above example might have been the result of evaluating"]}),"\n",(0,r.jsx)(n.p,{children:"(cons \u2019a (cons \u2019b (cons \u2019c \u2019d)))"}),"\n",(0,r.jsx)(n.p,{children:"Similarly,"}),"\n",(0,r.jsx)(n.p,{children:"(cons \u2019this-one \u2019that-one) \u2192 (this-one . that-one)"}),"\n",(0,r.jsxs)(n.p,{children:["It is permissible for the ",(0,r.jsx)(n.em,{children:"object"})," following the dot to be a ",(0,r.jsx)(n.em,{children:"list"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:["(a b c d . (e f . (g))) ",(0,r.jsx)(n.em,{children:"\u2261"})," (a b c d e f g)"]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"lists"})," and ",(0,r.jsx)(n.em,{children:"conses"}),", see Section 22.1.3.5 (Printing Lists and Conses)."]})]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}function l(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"right-parenthesis"})," is invalid except when used in conjunction with the left parenthesis character. For more information, see Section 2.2 (Reader Algorithm)."]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}function d(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," \u2019\u27e8exp\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"single-quote"})," introduces an ",(0,r.jsx)(n.em,{children:"expression"})," to be \u201cquoted.\u201d ",(0,r.jsx)(n.em,{children:"Single-quote"})," followed by an ",(0,r.jsx)(n.em,{children:"expression exp"})," is treated by the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," as an abbreviation for and is parsed identically to the ",(0,r.jsx)(n.em,{children:"expression"})," (quote ",(0,r.jsx)(n.em,{children:"exp"}),"). See the ",(0,r.jsx)(n.em,{children:"special operator"})," ",(0,r.jsx)(n.strong,{children:"quote"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function p(e){const n={code:"code",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"\n\n\u2019foo \u2192 FOO \n\n\u201dfoo \u2192 (QUOTE FOO) \n\n(car \u201dfoo) \u2192 QUOTE \n\n\n"})})}function x(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}function j(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," ;\u27e8text\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"semicolon"})," introduces ",(0,r.jsx)(n.em,{children:"characters"})," that are to be ignored, such as comments. The ",(0,r.jsx)(n.em,{children:"semicolon"})," and all ",(0,r.jsx)(n.em,{children:"characters"})," up to and including the next ",(0,r.jsx)(n.em,{children:"newline"})," or end of file are ignored."]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}function f(e){const n={code:"code",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"\n\n(+ 3 ; three \n\n   \\4) \n\n\u2192 7 \n\n\n"})})}function g(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}function b(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Some text editors make assumptions about desired indentation based on the number of ",(0,r.jsx)(n.em,{children:"semicolons"})," that begin a comment. The following style conventions are common, although not by any means universal."]})}function y(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}function w(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Comments that begin with a single ",(0,r.jsx)(n.em,{children:"semicolon"})," are all aligned to the same column at the right (sometimes called the \u201ccomment column\u201d). The text of such a comment generally applies only to the line on which it appears. Occasionally two or three contain a single sentence together; this is sometimes indicated by indenting all but the first with an additional space (after the ",(0,r.jsx)(n.em,{children:"semicolon"}),")."]})}function v(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(w,{...e})}):w(e)}function S(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Comments that begin with a double ",(0,r.jsx)(n.em,{children:"semicolon"})," are all aligned to the same level of indentation as a ",(0,r.jsx)(n.em,{children:"form"})," would be at that same position in the ",(0,r.jsx)(n.em,{children:"code"}),". The text of such a comment usually describes the state of the ",(0,r.jsx)(n.em,{children:"program"})," at the point where the comment occurs, the ",(0,r.jsx)(n.em,{children:"code"})," which follows the comment, or both."]})}function k(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}function F(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Comments that begin with a triple ",(0,r.jsx)(n.em,{children:"semicolon"})," are all aligned to the left margin. Usually they are used prior to a definition or set of definitions, rather than within a definition."]})}function q(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(F,{...e})}):F(e)}function T(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Comments that begin with a quadruple ",(0,r.jsx)(n.em,{children:"semicolon"})," are all aligned to the left margin, and generally contain only a short piece of text that serve as a title for the code which follows, and might be used in the header or footer of a program that prepares code for presentation as a hardcopy document."]})}function A(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(T,{...e})}):T(e)}function C(e){const n={code:"code",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:'\n\n;;;; Math Utilities \n\n;;; FIB computes the the Fibonacci function in the traditional \n\n;;; recursive way. \n\n(defun fib (n) \n\n  (check-type n integer) \n\n  ;; At this point we\u2019re sure we have an integer argument. \n\n  ;; Now we can get down to some serious computation. \n\n  (cond ((< n 0) \n\n\t ;; Hey, this is just supposed to be a simple example. \n\n\t ;; Did you really expect me to handle the general case? \n\n\t (error "FIB got ~D as an argument." n)) \n\n\t((< n 2) n) ;fib[0]=0 and fib[1]=1 \n\n\t;; The cheap cases didn\u2019t work. \n\n\t;; Nothing more to do but recurse. \n\n\t(t (+ (fib (- n 1)) ;The traditional formula \n\n\t      (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].  \n\n\n\n\n'})})}function I(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(C,{...e})}):C(e)}function N(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"}),' "\u27e8text\u27e9"']}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"double-quote"})," is used to begin and end a ",(0,r.jsx)(n.em,{children:"string"}),". When a ",(0,r.jsx)(n.em,{children:"double-quote"})," is encountered, ",(0,r.jsx)(n.em,{children:"characters"})," are read from the ",(0,r.jsx)(n.em,{children:"input stream"})," and accumulated until another ",(0,r.jsx)(n.em,{children:"double-quote"})," is encountered. If a ",(0,r.jsx)(n.em,{children:"single escape character"})," is seen, the ",(0,r.jsx)(n.em,{children:"single escape character"})," is discarded, the next ",(0,r.jsx)(n.em,{children:"character"})," is accumulated, and accumulation continues. The accumulated ",(0,r.jsx)(n.em,{children:"characters"})," up to but not including the matching ",(0,r.jsx)(n.em,{children:"double-quote"})," are made into a ",(0,r.jsx)(n.em,{children:"simple string"})," and returned. It is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," which ",(0,r.jsx)(n.em,{children:"attributes"})," of the accumulated characters are removed in this process."]}),"\n",(0,r.jsxs)(n.p,{children:["Examples of the use of the ",(0,r.jsx)(n.em,{children:"double-quote"})," character are in Figure 2\u201318."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)("p",{children:'"Foo" ;A string with three characters in it "" ;An empty string '}),(0,r.jsx)("p",{children:'""APL\\360?" he cried." ;A string with twenty characters '}),(0,r.jsx)("p",{children:'"|x| = |-x|" ;A ten-character string'}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 2\u201318. Examples of the use of double-quote"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that to place a single escape character or a ",(0,r.jsx)(n.em,{children:"double-quote"})," into a string, such a character must be preceded by a single escape character. Note, too, that a multiple escape character need not be quoted by a single escape character within a string."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"strings"}),", see Section 22.1.3.4 (Printing Strings)."]})]})}function L(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(N,{...e})}):N(e)}function E(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"backquote"})," introduces a template of a data structure to be built. For example, writing \u2018(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))"]}),"\n",(0,r.jsx)(n.p,{children:"is roughly equivalent to writing"}),"\n",(0,r.jsx)(n.p,{children:"(list \u2019cond"}),"\n",(0,r.jsx)(n.p,{children:"(cons (list \u2019numberp x) y)"}),"\n",(0,r.jsx)(n.p,{children:"(list* \u2019t (list \u2019print x) y))"}),"\n",(0,r.jsxs)(n.p,{children:["Where a comma occurs in the template, the ",(0,r.jsx)(n.em,{children:"expression"})," following the comma is to be evaluated to produce an ",(0,r.jsx)(n.em,{children:"object"})," to be inserted at that point. Assume b has the value 3, for example, then evaluating the ",(0,r.jsx)(n.em,{children:"form"})," denoted by \u2018(a b ,b ,(+ b 1) b) produces the result (a b 3 4 b)."]}),"\n",(0,r.jsxs)(n.p,{children:["If a comma is immediately followed by an ",(0,r.jsx)(n.em,{children:"at-sign"}),", then the ",(0,r.jsx)(n.em,{children:"form"})," following the ",(0,r.jsx)(n.em,{children:"at-sign"})," is evaluated to produce a ",(0,r.jsx)(n.em,{children:"list"})," of ",(0,r.jsx)(n.em,{children:"objects"}),". These ",(0,r.jsx)(n.em,{children:"objects"})," are then \u201cspliced\u201d into place in the template. For example, if x has the value (a b c), then"]}),"\n",(0,r.jsx)(n.p,{children:"\u2018(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))"}),"\n",(0,r.jsx)(n.p,{children:"\u2192 (x (a b c) a b c foo b bar (b c) baz b c)"}),"\n",(0,r.jsx)(n.p,{children:"The backquote syntax can be summarized formally as follows."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018",(0,r.jsx)(n.em,{children:"basic"})," is the same as \u2019",(0,r.jsx)(n.em,{children:"basic"}),", that is, (quote ",(0,r.jsx)(n.em,{children:"basic"}),"), for any ",(0,r.jsx)(n.em,{children:"expression basic"})," that is not a ",(0,r.jsx)(n.em,{children:"list"})," or a general ",(0,r.jsx)(n.em,{children:"vector"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018,",(0,r.jsx)(n.em,{children:"form"})," is the same as ",(0,r.jsx)(n.em,{children:"form"}),", for any ",(0,r.jsx)(n.em,{children:"form"}),", provided that the representation of ",(0,r.jsx)(n.em,{children:"form"})," does not begin with ",(0,r.jsx)(n.em,{children:"at-sign"})," or ",(0,r.jsx)(n.em,{children:"dot"}),". (A similar caveat holds for all occurrences of a form after a ",(0,r.jsx)(n.em,{children:"comma"}),".)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018,@",(0,r.jsx)(n.em,{children:"form"})," has undefined consequences."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018(x1 x2 x3 ... xn . atom) may be interpreted to mean"]}),"\n",(0,r.jsx)(n.p,{children:"(append [x1] [x2] [x3] ... [xn] (quote atom))"}),"\n",(0,r.jsxs)(n.p,{children:["where the brackets are used to indicate a transformation of an ",(0,r.jsx)(n.em,{children:"xj"})," as follows:"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 [",(0,r.jsx)(n.em,{children:"form"}),"] is interpreted as (list \u2018",(0,r.jsx)(n.em,{children:"form"}),"), which contains a backquoted form that must then be further interpreted."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 [,",(0,r.jsx)(n.em,{children:"form"}),"] is interpreted as (list ",(0,r.jsx)(n.em,{children:"form"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 [,@",(0,r.jsx)(n.em,{children:"form"}),"] is interpreted as ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018(x1 x2 x3 ... xn) may be interpreted to mean the same as the backquoted form \u2018(x1 x2 x3 ... xn . ",(0,r.jsx)(n.strong,{children:"nil"}),"), thereby reducing it to the previous case."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018(x1 x2 x3 ... xn . ,form) may be interpreted to mean"]}),"\n",(0,r.jsx)(n.p,{children:"(append [x1] [x2] [x3] ... [xn] form)"}),"\n",(0,r.jsx)(n.p,{children:"where the brackets indicate a transformation of an xj as described above."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018(x1 x2 x3 ... xn . ,@form) has undefined consequences."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," \u2018#(x1 x2 x3 ... xn) may be interpreted to mean (apply #\u2019vector \u2018(x1 x2 x3 ... xn))."]}),"\n",(0,r.jsxs)(n.p,{children:["Anywhere \u201c,@\u201d may be used, the syntax \u201c,.\u201d may be used instead to indicate that it is permissible to operate ",(0,r.jsx)(n.em,{children:"destructively"})," on the ",(0,r.jsx)(n.em,{children:"list structure"})," produced by the form following the \u201c,.\u201d (in effect, to use ",(0,r.jsx)(n.strong,{children:"nconc"})," instead of ",(0,r.jsx)(n.strong,{children:"append"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["If the backquote syntax is nested, the innermost backquoted form should be expanded first. This means that if several commas occur in a row, the leftmost one belongs to the innermost ",(0,r.jsx)(n.em,{children:"backquote"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"implementation"})," is free to interpret a backquoted ",(0,r.jsx)(n.em,{children:"form F"}),(0,r.jsx)("sub",{children:"1"})," as any ",(0,r.jsx)(n.em,{children:"form F"}),(0,r.jsx)("sub",{children:"2"})," that, when evaluated, will produce a result that is the ",(0,r.jsx)(n.em,{children:"same"})," under ",(0,r.jsx)(n.strong,{children:"equal"})," as the result implied by the above definition, provided that the side-effect behavior of the substitute ",(0,r.jsx)(n.em,{children:"form F"}),(0,r.jsx)("sub",{children:"2"})," is also consistent with the"]}),"\n",(0,r.jsxs)(n.p,{children:["description given above. The constructed copy of the template might or might not share ",(0,r.jsx)(n.em,{children:"list"})," structure with the template itself. As an example, the above definition implies that"]}),"\n",(0,r.jsx)(n.p,{children:"\u2018((,a b) ,c ,@d)"}),"\n",(0,r.jsx)(n.p,{children:"will be interpreted as if it were"}),"\n",(0,r.jsxs)(n.p,{children:["(append (list (append (list a) (list \u2019b) \u2019",(0,r.jsx)(n.strong,{children:"nil"}),")) (list c) d \u2019",(0,r.jsx)(n.strong,{children:"nil"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"but it could also be legitimately interpreted to mean any of the following:"}),"\n",(0,r.jsx)(n.p,{children:"(append (list (append (list a) (list \u2019b))) (list c) d)"}),"\n",(0,r.jsx)(n.p,{children:"(append (list (append (list a) \u2019(b))) (list c) d)"}),"\n",(0,r.jsx)(n.p,{children:"(list* (cons a \u2019(b)) c d)"}),"\n",(0,r.jsx)(n.p,{children:"(list* (cons a (list \u2019b)) c d)"}),"\n",(0,r.jsx)(n.p,{children:"(append (list (cons a \u2019(b))) (list c) d)"}),"\n",(0,r.jsx)(n.p,{children:"(list* (cons a \u2019(b)) c (copy-list d))"})]})}function D(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(E,{...e})}):E(e)}function P(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Since the exact manner in which the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," will parse an ",(0,r.jsx)(n.em,{children:"expression"})," involving the ",(0,r.jsx)(n.em,{children:"backquote reader macro"})," is not specified, an ",(0,r.jsx)(n.em,{children:"implementation"})," is free to choose any representation that preserves the semantics described."]}),"\n",(0,r.jsxs)(n.p,{children:["Often an ",(0,r.jsx)(n.em,{children:"implementation"})," will choose a representation that facilitates pretty printing of the expression, so that (pprint \u2018(a ,b)) will display \u2018(a ,b) and not, for example, (list \u2019a b). However, this is not a requirement."]}),"\n",(0,r.jsxs)(n.p,{children:["Implementors who have no particular reason to make one choice or another might wish to refer to ",(0,r.jsx)(n.em,{children:"IEEE Standard for the Scheme Programming Language"}),", which identifies a popular choice of representation for such expressions that might provide useful to be useful compatibility for some user communities. There is no requirement, however, that any ",(0,r.jsx)(n.em,{children:"conforming implementation"})," use this particular representation. This information is provided merely for cross-reference purposes."]})]})}function O(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(P,{...e})}):P(e)}function R(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"comma"})," is part of the backquote syntax; see Section 2.4.6 (Backquote). ",(0,r.jsx)(n.em,{children:"Comma"})," is invalid if used other than inside the body of a backquote ",(0,r.jsx)(n.em,{children:"expression"})," as described above."]})}function B(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(R,{...e})}):R(e)}function U(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Sharpsign"})," is a ",(0,r.jsx)(n.em,{children:"non-terminating dispatching macro character"})," . It reads an optional sequence of digits and then one more character, and uses that character to select a ",(0,r.jsx)(n.em,{children:"function"})," to run as a ",(0,r.jsx)(n.em,{children:"reader macro function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"standard syntax"})," includes constructs introduced by the # character. The syntax of these constructs is as follows: a character that identifies the type of construct is followed by arguments in some form. If the character is a letter, its ",(0,r.jsx)(n.em,{children:"case"})," is not important; #O and #o are considered to be equivalent, for example."]}),"\n",(0,r.jsx)(n.p,{children:"Certain # constructs allow an unsigned decimal number to appear between the # and the character."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"reader macros"})," associated with the ",(0,r.jsx)(n.em,{children:"dispatching macro character"})," # are described later in this section and summarized in Figure 2\u201319."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"dispatch char purpose dispatch char purpose"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)("p",{children:"Backspace signals error { undefined* Tab signals error } undefined* Newline signals error + read-time conditional Linefeed signals error - read-time conditional Page signals error . read-time evaluation Return signals error / undefined Space signals error A, a array "}),(0,r.jsxs)("p",{children:['! undefined* B, b binary rational " undefined C, c complex number # reference to = label D, d undefined $ undefined E, e undefined % undefined F, f undefined & undefined G, g undefined \u2019 function abbreviation H, h undefined ( simple vector I, i undefined ) signals error J, j undefined * bit vector K, k undefined , undefined L, l undefined : uninterned symbol M, m undefined ; undefined N, n undefined < signals error O, o octal rational = labels following object P, p pathname > undefined Q, q undefined ? undefined* R, r radix-',(0,r.jsx)("i",{children:"n"})," rational @ undefined S, s structure [ undefined* T, t undefined \\ character object U, u undefined ] undefined* V, v undefined ",(0,r.jsx)("i",{children:(0,r.jsx)("sup",{children:"^"})})," undefined W, w undefined undefined X, x hexadecimal rational "]}),(0,r.jsx)("p",{children:"\u2018 undefined Y, y undefined | balanced comment Z, z undefined ~ undefined Rubout undefined"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 2\u201319. Standard # Dispatching Macro Character Syntax"})}),"\n",(0,r.jsxs)(n.p,{children:["The combinations marked by an asterisk (*) are explicitly reserved to the user. No ",(0,r.jsx)(n.em,{children:"conforming implementation"})," defines them."]}),"\n",(0,r.jsxs)(n.p,{children:["Note also that ",(0,r.jsx)(n.em,{children:"digits"})," do not appear in the preceding table. This is because the notations #0, #1, ..., #9 are reserved for another purpose which occupies the same syntactic space. When a ",(0,r.jsx)(n.em,{children:"digit"})," follows a ",(0,r.jsx)(n.em,{children:"sharpsign"}),", it is not treated as a dispatch character. Instead, an unsigned integer argument is"]}),"\n",(0,r.jsxs)(n.p,{children:["accumulated and passed as an ",(0,r.jsx)(n.em,{children:"argument"})," to the ",(0,r.jsx)(n.em,{children:"reader macro"})," for the ",(0,r.jsx)(n.em,{children:"character"})," that follows the digits. For example, #2A((1 2) (3 4)) is a use of #A with an argument of 2."]})]})}function M(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(U,{...e})}):U(e)}function W(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," #\\\u27e8x\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["When the ",(0,r.jsx)(n.em,{children:"token x"})," is a single ",(0,r.jsx)(n.em,{children:"character"})," long, this parses as the literal ",(0,r.jsx)(n.em,{children:"character char"}),". ",(0,r.jsx)(n.em,{children:"Uppercase"})," and ",(0,r.jsx)(n.em,{children:"lowercase"})," letters are distinguished after #; #\\A and #\\a denote different ",(0,r.jsx)(n.em,{children:"character objects"}),". Any single ",(0,r.jsx)(n.em,{children:"character"})," works after #, even those that are normally special to ",(0,r.jsx)(n.strong,{children:"read"}),", such as ",(0,r.jsx)(n.em,{children:"left-parenthesis"})," and ",(0,r.jsx)(n.em,{children:"right-parenthesis"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In the single ",(0,r.jsx)(n.em,{children:"character"})," case, the ",(0,r.jsx)(n.em,{children:"x"})," must be followed by a non-constituent ",(0,r.jsx)(n.em,{children:"character"})," . After #\\ is read, the reader backs up over the ",(0,r.jsx)(n.em,{children:"slash"})," and then reads a ",(0,r.jsx)(n.em,{children:"token"}),", treating the initial ",(0,r.jsx)(n.em,{children:"slash"})," as a ",(0,r.jsx)(n.em,{children:"single escape character"})," (whether it really is or not in the ",(0,r.jsx)(n.em,{children:"current readtable"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["When the ",(0,r.jsx)(n.em,{children:"token x"})," is more than one ",(0,r.jsx)(n.em,{children:"character"})," long, the ",(0,r.jsx)(n.em,{children:"x"})," must have the syntax of a ",(0,r.jsx)(n.em,{children:"symbol"})," with no embedded ",(0,r.jsx)(n.em,{children:"package markers"}),". In this case, the ",(0,r.jsx)(n.em,{children:"sharpsign backslash"})," notation parses as the ",(0,r.jsx)(n.em,{children:"character"})," whose ",(0,r.jsx)(n.em,{children:"name"})," is (string-upcase ",(0,r.jsx)(n.em,{children:"x"}),"); see Section 13.1.7 (Character Names)."]}),"\n",(0,r.jsxs)(n.p,{children:["For information about how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"character objects"}),", see Section 22.1.3.2 (Printing Characters)."]})]})}function z(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(W,{...e})}):W(e)}function V(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Any ",(0,r.jsx)(n.em,{children:"expression"})," preceded by #\u2019 (",(0,r.jsx)(n.em,{children:"sharpsign"})," followed by ",(0,r.jsx)(n.em,{children:"single-quote"}),"), as in #\u2019",(0,r.jsx)(n.em,{children:"expression"}),", is treated by the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," as an abbreviation for and parsed identically to the ",(0,r.jsx)(n.em,{children:"expression"})," (function ",(0,r.jsx)(n.em,{children:"expression"}),"). See ",(0,r.jsx)(n.strong,{children:"function"}),". For example,"]}),"\n",(0,r.jsxs)(n.p,{children:["(apply #\u2019+ l) ",(0,r.jsx)(n.em,{children:"\u2261"})," (apply (function +) l)"]})]})}function H(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(V,{...e})}):V(e)}function X(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#( and ) are used to notate a ",(0,r.jsx)(n.em,{children:"simple vector"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["If an unsigned decimal integer appears between the # and (, it specifies explicitly the length of the ",(0,r.jsx)(n.em,{children:"vector"})," . The consequences are undefined if the number of ",(0,r.jsx)(n.em,{children:"objects"})," specified before the closing ) exceeds the unsigned decimal integer. If the number of ",(0,r.jsx)(n.em,{children:"objects"})," supplied before the closing ) is less than the unsigned decimal integer but greater than zero, the last ",(0,r.jsx)(n.em,{children:"object"})," is used to fill all remaining elements of the ",(0,r.jsx)(n.em,{children:"vector"})," . The consequences are undefined if the unsigned decimal integer is non-zero and number of ",(0,r.jsx)(n.em,{children:"objects"})," supplied before the closing ) is zero. For example,"]}),"\n",(0,r.jsx)(n.p,{children:"#(a b c c c c)"}),"\n",(0,r.jsx)(n.p,{children:"#6(a b c c c c)"}),"\n",(0,r.jsx)(n.p,{children:"#6(a b c)"}),"\n",(0,r.jsx)(n.p,{children:"#6(a b c c)"}),"\n",(0,r.jsxs)(n.p,{children:["all mean the same thing: a ",(0,r.jsx)(n.em,{children:"vector"})," of length 6 with ",(0,r.jsx)(n.em,{children:"elements"})," a, b, and four occurrences of c. Other examples follow:"]}),"\n",(0,r.jsx)(n.p,{children:"#(a b c) ;A vector of length 3"}),"\n",(0,r.jsx)(n.p,{children:"#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)"}),"\n",(0,r.jsx)(n.p,{children:";A vector containing the primes below 50"}),"\n",(0,r.jsx)(n.p,{children:"#() ;An empty vector"}),"\n",(0,r.jsxs)(n.p,{children:["The notation #() denotes an empty ",(0,r.jsx)(n.em,{children:"vector"})," , as does #0()."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"vectors"}),", see Section 22.1.3.4 (Printing Strings), Section 22.1.3.6 (Printing Bit Vectors), or Section 22.1.3.7 (Printing Other Vectors)."]})]})}function Q(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(X,{...e})}):X(e)}function _(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," #*\u27e8bits\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"simple bit vector"})," is constructed containing the indicated ",(0,r.jsx)(n.em,{children:"bits"})," (0\u2019s and 1\u2019s), where the leftmost ",(0,r.jsx)(n.em,{children:"bit"})," has index zero and the subsequent ",(0,r.jsx)(n.em,{children:"bits"})," have increasing indices."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," #\u27e8n\u27e9*\u27e8bits\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["With an argument ",(0,r.jsx)(n.em,{children:"n"}),", the ",(0,r.jsx)(n.em,{children:"vector"})," to be created is of ",(0,r.jsx)(n.em,{children:"length n"}),". If the number of ",(0,r.jsx)(n.em,{children:"bits"})," is less than ",(0,r.jsx)(n.em,{children:"n"})," but greater than zero, the last bit is used to fill all remaining bits of the ",(0,r.jsx)(n.em,{children:"bit vector"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["The notations #* and #0* each denote an empty ",(0,r.jsx)(n.em,{children:"bit vector"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["Regardless of whether the optional numeric argument ",(0,r.jsx)(n.em,{children:"n"})," is provided, the ",(0,r.jsx)(n.em,{children:"token"})," that follows the ",(0,r.jsx)(n.em,{children:"asterisk"})," is delimited by a normal ",(0,r.jsx)(n.em,{children:"token"})," delimiter. However, (unless the ",(0,r.jsx)(n.em,{children:"value"})," of ",(0,r.jsx)(n.strong,{children:"*read-suppress*"})," is ",(0,r.jsx)(n.em,{children:"true"}),") an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," is signaled if that ",(0,r.jsx)(n.em,{children:"token"})," is not composed entirely of 0\u2019s and 1\u2019s, or if ",(0,r.jsx)(n.em,{children:"n"})," was supplied and the ",(0,r.jsx)(n.em,{children:"token"})," is composed of more than ",(0,r.jsx)(n.em,{children:"n bits"}),", or if ",(0,r.jsx)(n.em,{children:"n"})," is greater than one, but no ",(0,r.jsx)(n.em,{children:"bits"})," were specified. Neither a ",(0,r.jsx)(n.em,{children:"single escape"})," nor a ",(0,r.jsx)(n.em,{children:"multiple escape"})," is permitted in this ",(0,r.jsx)(n.em,{children:"token"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"bit vectors"}),", see Section 22.1.3.6 (Printing Bit Vectors)."]})]})}function K(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}function Y(e){const n={code:"code",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"\n\nFor example, #\\*101111 \n\n#6\\*101111 \n\n#6\\*101 \n\n#6\\*1011 \n\nall mean the same thing: a *vector* of length 6 with *elements* 1, 0, 1, 1, 1, and 1. \n\nFor example: \n\n#\\* ;An empty bit-vector  \n\n\n\n\n"})})}function G(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Y,{...e})}):Y(e)}function Z(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax:"})," #:\u27e8symbol-name\u27e9"]}),"\n",(0,r.jsxs)(n.p,{children:["#: introduces an ",(0,r.jsx)(n.em,{children:"uninterned symbol"})," whose ",(0,r.jsx)(n.em,{children:"name"})," is ",(0,r.jsx)(n.em,{children:"symbol-name"}),". Every time this syntax is encountered, a ",(0,r.jsx)(n.em,{children:"distinct uninterned symbol"})," is created. The ",(0,r.jsx)(n.em,{children:"symbol-name"})," must have the syntax of a ",(0,r.jsx)(n.em,{children:"symbol"})," with no ",(0,r.jsx)(n.em,{children:"package prefix"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," prints ",(0,r.jsx)(n.em,{children:"uninterned symbols"}),", see Section 22.1.3.3 (Printing Symbols)."]})]})}function J(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Z,{...e})}):Z(e)}function $(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#.",(0,r.jsx)(n.em,{children:"foo"})," is read as the ",(0,r.jsx)(n.em,{children:"object"})," resulting from the evaluation of the ",(0,r.jsx)(n.em,{children:"object"})," represented by ",(0,r.jsx)(n.em,{children:"foo"}),". The evaluation is done during the ",(0,r.jsx)(n.strong,{children:"read"})," process, when the #. notation is encountered. The #. syntax therefore performs a read-time evaluation of ",(0,r.jsx)(n.em,{children:"foo"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The normal effect of #. is inhibited when the ",(0,r.jsx)(n.em,{children:"value"})," of ",(0,r.jsx)(n.strong,{children:"*read-eval*"})," is ",(0,r.jsx)(n.em,{children:"false"}),". In that situation, an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["For an ",(0,r.jsx)(n.em,{children:"object"})," that does not have a convenient printed representation, a ",(0,r.jsx)(n.em,{children:"form"})," that computes the ",(0,r.jsx)(n.em,{children:"object"})," can be given using the #. notation."]})]})}function ee(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#B",(0,r.jsx)(n.em,{children:"rational"})," reads ",(0,r.jsx)(n.em,{children:"rational"})," in binary (radix 2). For example,"]}),"\n",(0,r.jsxs)(n.p,{children:["#B1101 ",(0,r.jsx)(n.em,{children:"\u2261"})," 13 ;1101",(0,r.jsx)("sub",{children:"2"})]}),"\n",(0,r.jsxs)(n.p,{children:["#b101/11 ",(0,r.jsx)(n.em,{children:"\u2261"})," 5/3"]}),"\n",(0,r.jsxs)(n.p,{children:["The consequences are undefined if the token immediately following the #B does not have the syntax of a binary (",(0,r.jsx)(n.em,{children:"i.e."}),", radix 2) ",(0,r.jsx)(n.em,{children:"rational"}),"."]})]})}function se(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ne,{...e})}):ne(e)}function re(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#O",(0,r.jsx)(n.em,{children:"rational"})," reads ",(0,r.jsx)(n.em,{children:"rational"})," in octal (radix 8). For example,"]}),"\n",(0,r.jsxs)(n.p,{children:["#o37/15 ",(0,r.jsx)(n.em,{children:"\u2261"})," 31/13"]}),"\n",(0,r.jsxs)(n.p,{children:["#o777 ",(0,r.jsx)(n.em,{children:"\u2261"})," 511"]}),"\n",(0,r.jsxs)(n.p,{children:["#o105 ",(0,r.jsx)(n.em,{children:"\u2261"})," 69 ;105",(0,r.jsx)("sub",{children:"8"})]}),"\n",(0,r.jsxs)(n.p,{children:["The consequences are undefined if the token immediately following the #O does not have the syntax of an octal (",(0,r.jsx)(n.em,{children:"i.e."}),", radix 8) ",(0,r.jsx)(n.em,{children:"rational"}),"."]})]})}function ie(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(re,{...e})}):re(e)}function te(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#X",(0,r.jsx)(n.em,{children:"rational"})," reads ",(0,r.jsx)(n.em,{children:"rational"})," in hexadecimal (radix 16). The digits above 9 are the letters A through F (the lowercase letters a through f are also acceptable). For example,"]}),"\n",(0,r.jsxs)(n.p,{children:["#xF00 ",(0,r.jsx)(n.em,{children:"\u2261"})," 3840"]}),"\n",(0,r.jsxs)(n.p,{children:["#x105 ",(0,r.jsx)(n.em,{children:"\u2261"})," 261 ;105",(0,r.jsx)("sub",{children:"16"})]}),"\n",(0,r.jsxs)(n.p,{children:["The consequences are undefined if the token immediately following the #X does not have the syntax of a hexadecimal (",(0,r.jsx)(n.em,{children:"i.e."}),", radix 16) ",(0,r.jsx)(n.em,{children:"rational"}),"."]})]})}function ae(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(te,{...e})}):te(e)}function oe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"R"]}),"\n",(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"radix"}),"R",(0,r.jsx)(n.em,{children:"rational"})," reads ",(0,r.jsx)(n.em,{children:"rational"})," in radix ",(0,r.jsx)(n.em,{children:"radix"}),". ",(0,r.jsx)(n.em,{children:"radix"})," must consist of only digits that are interpreted as an ",(0,r.jsx)(n.em,{children:"integer"})," in decimal radix; its value must be between 2 and 36 (inclusive). Only valid digits for the specified radix may be used."]}),"\n",(0,r.jsx)(n.p,{children:"For example, #3r102 is another way of writing 11 (decimal), and #11R32 is another way of writing 35 (decimal). For radices larger than 10, letters of the alphabet are used in order for the digits after 9. No alternate # notation exists for the decimal radix since a decimal point suffices."}),"\n",(0,r.jsx)(n.p,{children:"Figure 2\u201320 contains examples of the use of #B, #O, #X, and #R."}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)("p",{children:"#2r11010101 ;Another way of writing 213 decimal "}),(0,r.jsx)("p",{children:"#b11010101 ;Ditto "}),(0,r.jsx)("p",{children:"#b+11010101 ;Ditto "}),(0,r.jsx)("p",{children:"#o325 ;Ditto, in octal radix "}),(0,r.jsx)("p",{children:"#xD5 ;Ditto, in hexadecimal radix "}),(0,r.jsx)("p",{children:"#16r+D5 ;Ditto "}),(0,r.jsx)("p",{children:"#o-300 ;Decimal -192, written in base 8 "}),(0,r.jsx)("p",{children:"#3r-21010 ;Same thing in base 3 "}),(0,r.jsx)("p",{children:"#25R-7H ;Same thing in base 25 "}),(0,r.jsx)("p",{children:"#xACCEDED ;181202413, in hexadecimal radix"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 2\u201320. Radix Indicator Example"})}),"\n",(0,r.jsxs)(n.p,{children:["The consequences are undefined if the token immediately following the #",(0,r.jsx)(n.em,{children:"n"}),"R does not have the syntax of a ",(0,r.jsx)(n.em,{children:"rational"})," in radix ",(0,r.jsx)(n.em,{children:"n"}),"."]})]})}function ce(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(oe,{...e})}):oe(e)}function le(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#C reads a following ",(0,r.jsx)(n.em,{children:"object"}),", which must be a ",(0,r.jsx)(n.em,{children:"list"})," of length two whose ",(0,r.jsx)(n.em,{children:"elements"})," are both ",(0,r.jsx)(n.em,{children:"reals"}),". These ",(0,r.jsx)(n.em,{children:"reals"})," denote, respectively, the real and imaginary parts of a ",(0,r.jsx)(n.em,{children:"complex"})," number. If the two parts as notated are not of the same data type, then they are converted according to the rules of floating-point ",(0,r.jsx)(n.em,{children:"contagion"})," described in Section 12.1.1.2 (Contagion in Numeric Operations)."]}),"\n",(0,r.jsxs)(n.p,{children:["#C(",(0,r.jsx)(n.em,{children:"real imag"}),") is equivalent to #.(complex (quote ",(0,r.jsx)(n.em,{children:"real"}),") (quote ",(0,r.jsx)(n.em,{children:"imag"}),")), except that #C is not affected by ",(0,r.jsx)(n.strong,{children:"*read-eval*"}),". See the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"complex"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Figure 2\u201321 contains examples of the use of #C."}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:["#C(3.0s1 2.0s-1) ;A ",(0,r.jsx)(n.em,{children:"complex"})," with ",(0,r.jsx)(n.em,{children:"small float"})," parts. "]}),(0,r.jsx)("p",{children:"#C(5 -3) ;A \u201cGaussian integer\u201d "}),(0,r.jsx)("p",{children:"#C(5/3 7.0) ;Will be converted internally to #C(1.66666 7.0) #C(0 1) ;The imaginary unit; that is, i."}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 2\u201321. Complex Number Example"})}),"\n",(0,r.jsx)(n.p,{children:"For further information, see Section 22.1.3.1.4 (Printing Complexes) and Section 2.3.2.3 (Syntax of a Complex)."})]})}function he(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(le,{...e})}):le(e)}function de(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"A"]}),"\n",(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"A",(0,r.jsx)(n.em,{children:"object"})," constructs an ",(0,r.jsx)(n.em,{children:"n"}),"-dimensional ",(0,r.jsx)(n.em,{children:"array"}),", using ",(0,r.jsx)(n.em,{children:"object"})," as the value of the ",":initial-contents"," argument to ",(0,r.jsx)(n.strong,{children:"make-array"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"For example, #2A((0 1 5) (foo 2 (hot dog))) represents a 2-by-3 matrix:"}),"\n",(0,r.jsx)(n.p,{children:"0 1 5"}),"\n",(0,r.jsx)(n.p,{children:"foo 2 (hot dog)"}),"\n",(0,r.jsxs)(n.p,{children:["In contrast, #1A((0 1 5) (foo 2 (hot dog))) represents a ",(0,r.jsx)(n.em,{children:"vector"})," of ",(0,r.jsx)(n.em,{children:"length"})," 2 whose ",(0,r.jsx)(n.em,{children:"elements"})," are ",(0,r.jsx)(n.em,{children:"lists"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"(0 1 5) (foo 2 (hot dog))"}),"\n",(0,r.jsxs)(n.p,{children:["#0A((0 1 5) (foo 2 (hot dog))) represents a zero-dimensional ",(0,r.jsx)(n.em,{children:"array"})," whose sole element is a ",(0,r.jsx)(n.em,{children:"list"}),": ((0 1 5) (foo 2 (hot dog)))"]}),"\n",(0,r.jsxs)(n.p,{children:["#0A foo represents a zero-dimensional ",(0,r.jsx)(n.em,{children:"array"})," whose sole element is the ",(0,r.jsx)(n.em,{children:"symbol"})," foo. The notation #1A foo is not valid because foo is not a ",(0,r.jsx)(n.em,{children:"sequence"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If some ",(0,r.jsx)(n.em,{children:"dimension"})," of the ",(0,r.jsx)(n.em,{children:"array"})," whose representation is being parsed is found to be 0, all ",(0,r.jsx)(n.em,{children:"dimensions"})," to the right (",(0,r.jsx)(n.em,{children:"i.e."}),", the higher numbered ",(0,r.jsx)(n.em,{children:"dimensions"}),") are also considered to be 0."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"arrays"}),", see Section 22.1.3.4 (Printing Strings), Section 22.1.3.6 (Printing Bit Vectors), Section 22.1.3.7 (Printing Other Vectors), or Section 22.1.3.8 (Printing Other Arrays)."]})]})}function me(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(de,{...e})}):de(e)}function pe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#s(name slot1 value1 slot2 value2 ...) denotes a ",(0,r.jsx)(n.em,{children:"structure"}),". This is valid only if ",(0,r.jsx)(n.em,{children:"name"})," is the name of a ",(0,r.jsx)(n.em,{children:"structure type"})," already defined by ",(0,r.jsx)(n.strong,{children:"defstruct"})," and if the ",(0,r.jsx)(n.em,{children:"structure type"})," has a standard constructor function. Let ",(0,r.jsx)(n.em,{children:"cm"})," stand for the name of this constructor function; then this syntax is equivalent to"]}),"\n",(0,r.jsx)(n.p,{children:"#.(cm keyword1 \u2019value1 keyword2 \u2019value2 ...)"}),"\n",(0,r.jsxs)(n.p,{children:["where each ",(0,r.jsx)(n.em,{children:"keywordj"})," is the result of computing"]}),"\n",(0,r.jsx)(n.p,{children:"(intern (string slotj) (find-package \u2019keyword))"}),"\n",(0,r.jsxs)(n.p,{children:["The net effect is that the constructor function is called with the specified slots having the specified values. (This coercion feature is deprecated; in the future, keyword names will be taken in the package they are read in, so ",(0,r.jsx)(n.em,{children:"symbols"})," that are actually in the KEYWORD ",(0,r.jsx)(n.em,{children:"package"})," should be used if that is what is desired.)"]}),"\n",(0,r.jsxs)(n.p,{children:["Whatever ",(0,r.jsx)(n.em,{children:"object"})," the constructor function returns is returned by the #S syntax."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"structures"}),", see Section 22.1.3.12 (Printing Structures)."]})]})}function xe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(pe,{...e})}):pe(e)}function je(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#P reads a following ",(0,r.jsx)(n.em,{children:"object"}),", which must be a ",(0,r.jsx)(n.em,{children:"string"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["#P\u27e8expression\u27e9 is equivalent to #.(parse-namestring \u2019\u27e8expression\u27e9), except that #P is not affected by ",(0,r.jsx)(n.strong,{children:"*read-eval*"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For information on how the ",(0,r.jsx)(n.em,{children:"Lisp printer"})," prints ",(0,r.jsx)(n.em,{children:"pathnames"}),", see Section 22.1.3.11 (Printing Pathnames)."]})]})}function ue(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(je,{...e})}):je(e)}function fe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"="]}),"\n",(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"=",(0,r.jsx)(n.em,{children:"object"})," reads as whatever ",(0,r.jsx)(n.em,{children:"object"})," has ",(0,r.jsx)(n.em,{children:"object"})," as its printed representation. However, that ",(0,r.jsx)(n.em,{children:"object"})," is labeled by ",(0,r.jsx)(n.em,{children:"n"}),", a required unsigned decimal integer, for possible reference by the syntax #",(0,r.jsx)(n.em,{children:"n"}),"#. The scope of the label is the ",(0,r.jsx)(n.em,{children:"expression"})," being read by the outermost call to ",(0,r.jsx)(n.strong,{children:"read"}),"; within this ",(0,r.jsx)(n.em,{children:"expression"}),", the same label may not appear twice."]})]})}function ge(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(fe,{...e})}):fe(e)}function be(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"#"]}),"\n",(0,r.jsxs)(n.p,{children:["#",(0,r.jsx)(n.em,{children:"n"}),"#, where ",(0,r.jsx)(n.em,{children:"n"})," is a required unsigned decimal ",(0,r.jsx)(n.em,{children:"integer"})," , provides a reference to some ",(0,r.jsx)(n.em,{children:"object"})," labeled by #",(0,r.jsx)(n.em,{children:"n"}),"=; that is, #",(0,r.jsx)(n.em,{children:"n"}),"# represents a pointer to the same (",(0,r.jsx)(n.strong,{children:"eq"}),") ",(0,r.jsx)(n.em,{children:"object"})," labeled by #",(0,r.jsx)(n.em,{children:"n"}),"=. For example, a structure created in the variable y by this code:"]}),"\n",(0,r.jsx)(n.p,{children:"(setq x (list \u2019p \u2019q))"}),"\n",(0,r.jsx)(n.p,{children:"(setq y (list (list \u2019a \u2019b) x \u2019foo x))"}),"\n",(0,r.jsx)(n.p,{children:"(rplacd (last y) (cdr y))"}),"\n",(0,r.jsx)(n.p,{children:"could be represented in this way:"}),"\n",(0,r.jsx)(n.p,{children:"((a b) . #1=(#2=(p q) foo #2# . #1#))"}),"\n",(0,r.jsxs)(n.p,{children:["Without this notation, but with ",(0,r.jsx)(n.strong,{children:"*print-length*"})," set to 10 and ",(0,r.jsx)(n.strong,{children:"*print-circle*"})," set to ",(0,r.jsx)(n.strong,{children:"nil"}),", the structure would print in this way:"]}),"\n",(0,r.jsx)(n.p,{children:"((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)"}),"\n",(0,r.jsxs)(n.p,{children:["A reference #",(0,r.jsx)(n.em,{children:"n"}),"# may only occur after a label #",(0,r.jsx)(n.em,{children:"n"}),"=; forward references are not permitted. The reference may not appear as the labeled object itself (that is, #",(0,r.jsx)(n.em,{children:"n"}),"=#",(0,r.jsx)(n.em,{children:"n"}),"#) may not be written because the ",(0,r.jsx)(n.em,{children:"object"})," labeled by #",(0,r.jsx)(n.em,{children:"n"}),"= is not well defined in this case."]})]})}function ye(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(be,{...e})}):be(e)}function we(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#+ provides a read-time conditionalization facility; the syntax is #+",(0,r.jsx)(n.em,{children:"test expression"}),". If the ",(0,r.jsx)(n.em,{children:"feature expression test"})," succeeds, then this textual notation represents an ",(0,r.jsx)(n.em,{children:"object"})," whose printed representation is ",(0,r.jsx)(n.em,{children:"expression"}),". If the ",(0,r.jsx)(n.em,{children:"feature expression test"})," fails, then this textual notation is treated as ",(0,r.jsx)(n.em,{children:"whitespace"}),(0,r.jsx)("sub",{children:"2"}),"; that is, it is as if the \u201c#+ ",(0,r.jsx)(n.em,{children:"test expression"}),"\u201d did not appear and only a ",(0,r.jsx)(n.em,{children:"space"})," appeared in its place."]}),"\n",(0,r.jsxs)(n.p,{children:["For a detailed description of success and failure in ",(0,r.jsx)(n.em,{children:"feature expressions"}),", see Section 24.1.2.1 (Feature Expressions)."]}),"\n",(0,r.jsxs)(n.p,{children:["#+ operates by first reading the ",(0,r.jsx)(n.em,{children:"feature expression"})," and then skipping over the ",(0,r.jsx)(n.em,{children:"form"})," if the ",(0,r.jsx)(n.em,{children:"feature expression"})," fails. While reading the ",(0,r.jsx)(n.em,{children:"test"}),", the ",(0,r.jsx)(n.em,{children:"current package"})," is the KEYWORD ",(0,r.jsx)(n.em,{children:"package"}),". Skipping over the ",(0,r.jsx)(n.em,{children:"form"})," is accomplished by ",(0,r.jsx)(n.em,{children:"binding"})," ",(0,r.jsx)(n.strong,{children:"*read-suppress*"})," to ",(0,r.jsx)(n.em,{children:"true"})," and then calling ",(0,r.jsx)(n.strong,{children:"read"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"For examples, see Section 24.1.2.1.1 (Examples of Feature Expressions)."})]})}function ve(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(we,{...e})}):we(e)}function Se(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["#- is like #+ except that it skips the ",(0,r.jsx)(n.em,{children:"expression"})," if the ",(0,r.jsx)(n.em,{children:"test"})," succeeds; that is,"]}),"\n",(0,r.jsxs)(n.p,{children:["#-",(0,r.jsx)(n.em,{children:"test expression \u2261"})," #+(not ",(0,r.jsx)(n.em,{children:"test"}),") ",(0,r.jsx)(n.em,{children:"expression"})]}),"\n",(0,r.jsx)(n.p,{children:"For examples, see Section 24.1.2.1.1 (Examples of Feature Expressions)."})]})}function ke(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Se,{...e})}):Se(e)}function Fe(e){const n={p:"p",...(0,i.a)(),...e.components};return(0,r.jsx)(n.p,{children:"#|...|# is treated as a comment by the reader. It must be balanced with respect to other occurrences of #| and |#, but otherwise may contain any characters whatsoever."})}function qe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Fe,{...e})}):Fe(e)}function Te(e){const n={code:"code",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:'\n\nThe following are some examples that exploit the #|...|# notation: \n\n;;; In this example, some debugging code is commented out with #|...|# \n\n;;; Note that this kind of comment can occur in the middle of a line \n\n;;; (because a delimiter marks where the end of the comment occurs) \n\n;;; where a semicolon comment can only occur at the end of a line \n\n;;; (because it comments out the rest of the line). \n\n(defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3)) \n\n;;; The examples that follow show issues related to #| ... |# nesting. \n\n;;; In this first example, #| and |# always occur properly paired, \n\n;;; so nesting works naturally. \n\n(defun mention-fun-fact-1a () \n\n  (format t "CL uses ; and #|...|# in comments.")) \n\n\u2192 MENTION-FUN-FACT-1A \n\n(mention-fun-fact-1a) \n\n\u25b7 CL uses ; and #|...|# in comments. \n\n\u2192 NIL \n\n#| (defun mention-fun-fact-1b () \n\n(format t "CL uses ; and #|...|# in comments.")) |# \n\n(fboundp \u2019mention-fun-fact-1b) \u2192 NIL \n\n;;; In this example, vertical-bar followed by sharpsign needed to appear \n\n;;; in a string without any matching sharpsign followed by vertical-bar \n\n;;; having preceded this. To compensate, the programmer has included a \n\n;;; slash separating the two characters. In case 2a, the slash is \n\n;;; unnecessary but harmless, but in case 2b, the slash is critical to \n\n;;; allowing the outer #| ... |# pair match. If the slash were not present, ;;; the outer comment would terminate prematurely. \n\n(defun mention-fun-fact-2a () \n\n  (format t "Don\u2019t use |\\# unmatched or you\u2019ll get in trouble!")) \n\n\u2192 MENTION-FUN-FACT-2A \n\n(mention-fun-fact-2a) \n\n\u25b7 Don\u2019t use |# unmatched or you\u2019ll get in trouble! \n\n\u2192 NIL \n\n#| (defun mention-fun-fact-2b ()  \n\n\n\n     (format t "Don\u2019t use |\\# unmatched or you\u2019ll get in trouble!") |# \n\n(fboundp \u2019mention-fun-fact-2b) \u2192 NIL \n\n;;; In this example, the programmer attacks the mismatch problem in a \n\n;;; different way. The sharpsign vertical bar in the comment is not needed \n\n;;; for the correct parsing of the program normally (as in case 3a), but \n\n;;; becomes important to avoid premature termination of a comment when such \n\n;;; a program is commented out (as in case 3b). \n\n(defun mention-fun-fact-3a () ; #| \n\n     (format t "Don\u2019t use |# unmatched or you\u2019ll get in trouble!")) \n\n\u2192 MENTION-FUN-FACT-3A \n\n(mention-fun-fact-3a) \n\n\u25b7 Don\u2019t use |# unmatched or you\u2019ll get in trouble! \n\n\u2192 NIL \n\n#| \n\n(defun mention-fun-fact-3b () ; #| \n\n  (format t "Don\u2019t use |# unmatched or you\u2019ll get in trouble!")) \n\n|# \n\n(fboundp \u2019mention-fun-fact-3b) \u2192 NIL \n\n\n'})})}function Ae(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Te,{...e})}):Te(e)}function Ce(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Some text editors that purport to understand Lisp syntax treat any |...| as balanced pairs that cannot nest (as if they were just balanced pairs of the multiple escapes used in notating certain symbols). To compensate for this deficiency, some programmers use the notation #||...#||...||#...||# instead of #|...#|...|#...|#. Note that this alternate usage is not a different ",(0,r.jsx)(n.em,{children:"reader macro"}),"; it merely exploits the fact that the additional vertical-bars occur within the comment in a way that tricks certain text editor into better supporting nested comments. As such, one might sometimes see code like:"]}),"\n",(0,r.jsx)(n.p,{children:"#|| (+ #|| 3 ||# 4 5) ||#"}),"\n",(0,r.jsx)(n.p,{children:"Such code is equivalent to:"}),"\n",(0,r.jsx)(n.p,{children:"#| (+ #| 3 |# 4 5) |#"})]})}function Ie(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ce,{...e})}):Ce(e)}function Ne(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["#< is not valid reader syntax. The ",(0,r.jsx)(n.em,{children:"Lisp reader"})," will signal an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," on encountering #<. This syntax is typically used in the printed representation of ",(0,r.jsx)(n.em,{children:"objects"})," that cannot be read back in."]})}function Le(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ne,{...e})}):Ne(e)}function Ee(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["# followed immediately by ",(0,r.jsx)(n.em,{children:"whitespace"}),(0,r.jsx)("sub",{children:"1"})," is not valid reader syntax. The ",(0,r.jsx)(n.em,{children:"Lisp reader"})," will signal an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," if it encounters the reader macro notation #",(0,r.jsx)(n.em,{children:"hNewlinei"})," or #",(0,r.jsx)(n.em,{children:"hSpacei"}),"."]})}function De(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ee,{...e})}):Ee(e)}function Pe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This is not valid reader syntax."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"Lisp reader"})," will signal an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," upon encountering #)."]})]})}function Oe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Pe,{...e})}):Pe(e)}function Re(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Note that the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," will generally signal an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"reader-error"})," when reading an ",(0,r.jsx)(n.em,{children:"expression"}),(0,r.jsx)("sub",{children:"2"})," that has been abbreviated because of length or level limits (see ",(0,r.jsx)(n.strong,{children:"*print-level*"}),", ",(0,r.jsx)(n.strong,{children:"*print-length*"}),", and ",(0,r.jsx)(n.strong,{children:"*print-lines*"}),") due to restrictions on \u201c..\u201d, \u201c...\u201d, \u201c#\u201d followed by ",(0,r.jsx)(n.em,{children:"whitespace"}),(0,r.jsx)("sub",{children:"1"}),", and \u201c#)\u201d."]})}function Be(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Re,{...e})}):Re(e)}const Ue={title:"2.4 Standard Macro Characters"},Me="2.4 Standard Macro Characters",We={id:"chap-2/c-e-standard-macro-characters",title:"2.4 Standard Macro Characters",description:"2.4.1 Left",source:"@site/docs/chap-2/c-e-standard-macro-characters.md",sourceDirName:"chap-2",slug:"/chap-2/c-e-standard-macro-characters",permalink:"/cl-language-reference/docs/chap-2/c-e-standard-macro-characters",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-2/c-e-standard-macro-characters.md",tags:[],version:"current",frontMatter:{title:"2.4 Standard Macro Characters"},sidebar:"tutorialSidebar",previous:{title:"2.3 Interpretation of Tokens",permalink:"/cl-language-reference/docs/chap-2/c-d-interpretation-of-tokens"},next:{title:"3. Evaluation and Compilation",permalink:"/cl-language-reference/docs/category/3-evaluation-and-compilation"}},ze={},Ve=[{value:"2.4.1 Left",id:"241-left",level:2},{value:"2.4.2 Right",id:"242-right",level:2},{value:"2.4.3 Single",id:"243-single",level:2},{value:"2.4.3.1 Examples of Single",id:"2431-examples-of-single",level:3},{value:"2.4.4 Semicolon",id:"244-semicolon",level:2},{value:"2.4.4.1 Examples of Semicolon",id:"2441-examples-of-semicolon",level:3},{value:"2.4.4.2 Notes about Style for Semicolon",id:"2442-notes-about-style-for-semicolon",level:3},{value:"2.4.4.2.1 Use of Single Semicolon",id:"24421-use-of-single-semicolon",level:4},{value:"2.4.4.2.2 Use of Double Semicolon",id:"24422-use-of-double-semicolon",level:4},{value:"2.4.4.2.3 Use of Triple Semicolon",id:"24423-use-of-triple-semicolon",level:4},{value:"2.4.4.2.4 Use of Quadruple Semicolon",id:"24424-use-of-quadruple-semicolon",level:4},{value:"2.4.4.2.5 Examples of Style for Semicolon",id:"24425-examples-of-style-for-semicolon",level:4},{value:"2.4.5 Double",id:"245-double",level:2},{value:"2.4.6 Backquote",id:"246-backquote",level:2},{value:"2.4.6.1 Notes about Backquote",id:"2461-notes-about-backquote",level:3},{value:"2.4.7 Comma",id:"247-comma",level:2},{value:"2.4.8 Sharpsign",id:"248-sharpsign",level:2},{value:"2.4.8.1 Sharpsign Backslash",id:"2481-sharpsign-backslash",level:3},{value:"2.4.8.2 Sharpsign Single",id:"2482-sharpsign-single",level:3},{value:"2.4.8.3 Sharpsign Left",id:"2483-sharpsign-left",level:3},{value:"2.4.8.4 Sharpsign Asterisk",id:"2484-sharpsign-asterisk",level:3},{value:"2.4.8.4.1 Examples of Sharpsign Asterisk",id:"24841-examples-of-sharpsign-asterisk",level:4},{value:"2.4.8.5 Sharpsign Colon",id:"2485-sharpsign-colon",level:3},{value:"2.4.8.6 Sharpsign Dot",id:"2486-sharpsign-dot",level:3},{value:"2.4.8.7 Sharpsign B",id:"2487-sharpsign-b",level:3},{value:"2.4.8.8 Sharpsign O",id:"2488-sharpsign-o",level:3},{value:"2.4.8.9 Sharpsign X",id:"2489-sharpsign-x",level:3},{value:"2.4.8.10 Sharpsign R",id:"24810-sharpsign-r",level:3},{value:"2.4.8.11 Sharpsign C",id:"24811-sharpsign-c",level:3},{value:"2.4.8.12 Sharpsign A",id:"24812-sharpsign-a",level:3},{value:"2.4.8.13 Sharpsign S",id:"24813-sharpsign-s",level:3},{value:"2.4.8.14 Sharpsign P",id:"24814-sharpsign-p",level:3},{value:"2.4.8.15 Sharpsign Equal",id:"24815-sharpsign-equal",level:3},{value:"2.4.8.16 Sharpsign Sharpsign",id:"24816-sharpsign-sharpsign",level:3},{value:"2.4.8.17 Sharpsign Plus",id:"24817-sharpsign-plus",level:3},{value:"2.4.8.18 Sharpsign Minus",id:"24818-sharpsign-minus",level:3},{value:"2.4.8.19 Sharpsign Vertical",id:"24819-sharpsign-vertical",level:3},{value:"2.4.8.19.1 Examples of Sharpsign Vertical",id:"248191-examples-of-sharpsign-vertical",level:4},{value:"2.4.8.19.2 Notes about Style for Sharpsign Vertical",id:"248192-notes-about-style-for-sharpsign-vertical",level:4},{value:"2.4.8.20 Sharpsign Less",id:"24820-sharpsign-less",level:3},{value:"2.4.8.21 Sharpsign Whitespace",id:"24821-sharpsign-whitespace",level:3},{value:"2.4.8.22 Sharpsign Right",id:"24822-sharpsign-right",level:3},{value:"2.4.9 Re",id:"249-re",level:2}];function He(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"24-standard-macro-characters",children:"2.4 Standard Macro Characters"}),"\n","\n",(0,r.jsx)(a,{}),"\n",(0,r.jsx)(n.h2,{id:"241-left",children:"2.4.1 Left"}),"\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h2,{id:"242-right",children:"2.4.2 Right"}),"\n","\n",(0,r.jsx)(h,{}),"\n",(0,r.jsx)(n.h2,{id:"243-single",children:"2.4.3 Single"}),"\n","\n",(0,r.jsx)(m,{}),"\n",(0,r.jsx)(n.h3,{id:"2431-examples-of-single",children:"2.4.3.1 Examples of Single"}),"\n","\n",(0,r.jsx)(x,{}),"\n",(0,r.jsx)(n.h2,{id:"244-semicolon",children:"2.4.4 Semicolon"}),"\n","\n",(0,r.jsx)(u,{}),"\n",(0,r.jsx)(n.h3,{id:"2441-examples-of-semicolon",children:"2.4.4.1 Examples of Semicolon"}),"\n","\n",(0,r.jsx)(g,{}),"\n",(0,r.jsx)(n.h3,{id:"2442-notes-about-style-for-semicolon",children:"2.4.4.2 Notes about Style for Semicolon"}),"\n","\n",(0,r.jsx)(y,{}),"\n",(0,r.jsx)(n.h4,{id:"24421-use-of-single-semicolon",children:"2.4.4.2.1 Use of Single Semicolon"}),"\n","\n",(0,r.jsx)(v,{}),"\n",(0,r.jsx)(n.h4,{id:"24422-use-of-double-semicolon",children:"2.4.4.2.2 Use of Double Semicolon"}),"\n","\n",(0,r.jsx)(k,{}),"\n",(0,r.jsx)(n.h4,{id:"24423-use-of-triple-semicolon",children:"2.4.4.2.3 Use of Triple Semicolon"}),"\n","\n",(0,r.jsx)(q,{}),"\n",(0,r.jsx)(n.h4,{id:"24424-use-of-quadruple-semicolon",children:"2.4.4.2.4 Use of Quadruple Semicolon"}),"\n","\n",(0,r.jsx)(A,{}),"\n",(0,r.jsx)(n.h4,{id:"24425-examples-of-style-for-semicolon",children:"2.4.4.2.5 Examples of Style for Semicolon"}),"\n","\n",(0,r.jsx)(I,{}),"\n",(0,r.jsx)(n.h2,{id:"245-double",children:"2.4.5 Double"}),"\n","\n",(0,r.jsx)(L,{}),"\n",(0,r.jsx)(n.h2,{id:"246-backquote",children:"2.4.6 Backquote"}),"\n","\n",(0,r.jsx)(D,{}),"\n",(0,r.jsx)(n.h3,{id:"2461-notes-about-backquote",children:"2.4.6.1 Notes about Backquote"}),"\n","\n",(0,r.jsx)(O,{}),"\n",(0,r.jsx)(n.h2,{id:"247-comma",children:"2.4.7 Comma"}),"\n","\n",(0,r.jsx)(B,{}),"\n",(0,r.jsx)(n.h2,{id:"248-sharpsign",children:"2.4.8 Sharpsign"}),"\n","\n",(0,r.jsx)(M,{}),"\n",(0,r.jsx)(n.h3,{id:"2481-sharpsign-backslash",children:"2.4.8.1 Sharpsign Backslash"}),"\n","\n",(0,r.jsx)(z,{}),"\n",(0,r.jsx)(n.h3,{id:"2482-sharpsign-single",children:"2.4.8.2 Sharpsign Single"}),"\n","\n",(0,r.jsx)(H,{}),"\n",(0,r.jsx)(n.h3,{id:"2483-sharpsign-left",children:"2.4.8.3 Sharpsign Left"}),"\n","\n",(0,r.jsx)(Q,{}),"\n",(0,r.jsx)(n.h3,{id:"2484-sharpsign-asterisk",children:"2.4.8.4 Sharpsign Asterisk"}),"\n","\n",(0,r.jsx)(K,{}),"\n",(0,r.jsx)(n.h4,{id:"24841-examples-of-sharpsign-asterisk",children:"2.4.8.4.1 Examples of Sharpsign Asterisk"}),"\n","\n",(0,r.jsx)(G,{}),"\n",(0,r.jsx)(n.h3,{id:"2485-sharpsign-colon",children:"2.4.8.5 Sharpsign Colon"}),"\n","\n",(0,r.jsx)(J,{}),"\n",(0,r.jsx)(n.h3,{id:"2486-sharpsign-dot",children:"2.4.8.6 Sharpsign Dot"}),"\n","\n",(0,r.jsx)(ee,{}),"\n",(0,r.jsx)(n.h3,{id:"2487-sharpsign-b",children:"2.4.8.7 Sharpsign B"}),"\n","\n",(0,r.jsx)(se,{}),"\n",(0,r.jsx)(n.h3,{id:"2488-sharpsign-o",children:"2.4.8.8 Sharpsign O"}),"\n","\n",(0,r.jsx)(ie,{}),"\n",(0,r.jsx)(n.h3,{id:"2489-sharpsign-x",children:"2.4.8.9 Sharpsign X"}),"\n","\n",(0,r.jsx)(ae,{}),"\n",(0,r.jsx)(n.h3,{id:"24810-sharpsign-r",children:"2.4.8.10 Sharpsign R"}),"\n","\n",(0,r.jsx)(ce,{}),"\n",(0,r.jsx)(n.h3,{id:"24811-sharpsign-c",children:"2.4.8.11 Sharpsign C"}),"\n","\n",(0,r.jsx)(he,{}),"\n",(0,r.jsx)(n.h3,{id:"24812-sharpsign-a",children:"2.4.8.12 Sharpsign A"}),"\n","\n",(0,r.jsx)(me,{}),"\n",(0,r.jsx)(n.h3,{id:"24813-sharpsign-s",children:"2.4.8.13 Sharpsign S"}),"\n","\n",(0,r.jsx)(xe,{}),"\n",(0,r.jsx)(n.h3,{id:"24814-sharpsign-p",children:"2.4.8.14 Sharpsign P"}),"\n","\n",(0,r.jsx)(ue,{}),"\n",(0,r.jsx)(n.h3,{id:"24815-sharpsign-equal",children:"2.4.8.15 Sharpsign Equal"}),"\n","\n",(0,r.jsx)(ge,{}),"\n",(0,r.jsx)(n.h3,{id:"24816-sharpsign-sharpsign",children:"2.4.8.16 Sharpsign Sharpsign"}),"\n","\n",(0,r.jsx)(ye,{}),"\n",(0,r.jsx)(n.h3,{id:"24817-sharpsign-plus",children:"2.4.8.17 Sharpsign Plus"}),"\n","\n",(0,r.jsx)(ve,{}),"\n",(0,r.jsx)(n.h3,{id:"24818-sharpsign-minus",children:"2.4.8.18 Sharpsign Minus"}),"\n","\n",(0,r.jsx)(ke,{}),"\n",(0,r.jsx)(n.h3,{id:"24819-sharpsign-vertical",children:"2.4.8.19 Sharpsign Vertical"}),"\n","\n",(0,r.jsx)(qe,{}),"\n",(0,r.jsx)(n.h4,{id:"248191-examples-of-sharpsign-vertical",children:"2.4.8.19.1 Examples of Sharpsign Vertical"}),"\n","\n",(0,r.jsx)(Ae,{}),"\n",(0,r.jsx)(n.h4,{id:"248192-notes-about-style-for-sharpsign-vertical",children:"2.4.8.19.2 Notes about Style for Sharpsign Vertical"}),"\n","\n",(0,r.jsx)(Ie,{}),"\n",(0,r.jsx)(n.h3,{id:"24820-sharpsign-less",children:"2.4.8.20 Sharpsign Less"}),"\n","\n",(0,r.jsx)(Le,{}),"\n",(0,r.jsx)(n.h3,{id:"24821-sharpsign-whitespace",children:"2.4.8.21 Sharpsign Whitespace"}),"\n","\n",(0,r.jsx)(De,{}),"\n",(0,r.jsx)(n.h3,{id:"24822-sharpsign-right",children:"2.4.8.22 Sharpsign Right"}),"\n","\n",(0,r.jsx)(Oe,{}),"\n",(0,r.jsx)(n.h2,{id:"249-re",children:"2.4.9 Re"}),"\n","\n","\n",(0,r.jsx)(Be,{})]})}function Xe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(He,{...e})}):He(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>a});var r=s(67294);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);