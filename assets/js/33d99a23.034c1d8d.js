"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[98647],{92478:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>x,frontMatter:()=>s,metadata:()=>d,toc:()=>b});var r=o(85893),l=o(11151);function i(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,l.a)(),...e.components},{ClLinks:o}=n;return o||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"boole"})," ",(0,r.jsx)(o,{term:"function",children:(0,r.jsx)("i",{children:"Function"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(o,{term:"boole",children:(0,r.jsx)("b",{children:"boole"})})," ",(0,r.jsx)(n.em,{children:"op integer-1 integer-2 \u2192 result-integer"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Op"}),"\u2014a ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifier"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"integer-1"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(o,{term:"boole",children:(0,r.jsx)("b",{children:"boole"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"integer-2"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result-integer"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(o,{term:"boole",children:(0,r.jsx)("b",{children:"boole"})})," performs bit-wise logical operations on ",(0,r.jsx)(n.em,{children:"integer-1"})," and ",(0,r.jsx)(n.em,{children:"integer-2"}),", which are treated as if they were binary and in two\u2019s complement representation."]}),"\n",(0,r.jsxs)(n.p,{children:["The operation to be performed and the return value are determined by ",(0,r.jsx)(n.em,{children:"op"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(o,{term:"boole",children:(0,r.jsx)("b",{children:"boole"})})," returns the values specified for any ",(0,r.jsx)(n.em,{children:"op"})," in Figure 12\u201317."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Op Result"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-1",children:(0,r.jsx)("b",{children:"boole-1"})})," ",(0,r.jsx)(n.em,{children:"integer-1"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-2",children:(0,r.jsx)("b",{children:"boole-2"})})," ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-andc1",children:(0,r.jsx)("b",{children:"boole-andc1"})})," and complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," with ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-andc2",children:(0,r.jsx)("b",{children:"boole-andc2"})})," and ",(0,r.jsx)(n.em,{children:"integer-1"})," with complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-and",children:(0,r.jsx)("b",{children:"boole-and"})})," and "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-c1",children:(0,r.jsx)("b",{children:"boole-c1"})})," complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-c2",children:(0,r.jsx)("b",{children:"boole-c2"})})," complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-clr",children:(0,r.jsx)("b",{children:"boole-clr"})})," always 0 (all zero bits) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-eqv",children:(0,r.jsx)("b",{children:"boole-eqv"})})," equivalence (exclusive nor) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-ior",children:(0,r.jsx)("b",{children:"boole-ior"})})," inclusive or "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-nand",children:(0,r.jsx)("b",{children:"boole-nand"})})," not-and "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-nor",children:(0,r.jsx)("b",{children:"boole-nor"})})," not-or "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-orc1",children:(0,r.jsx)("b",{children:"boole-orc1"})})," or complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," with ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-orc2",children:(0,r.jsx)("b",{children:"boole-orc2"})})," or ",(0,r.jsx)(n.em,{children:"integer-1"})," with complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-set",children:(0,r.jsx)("b",{children:"boole-set"})})," always -1 (all one bits) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(o,{term:"boole-xor",children:(0,r.jsx)("b",{children:"boole-xor"})})," exclusive or"]}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 12\u201317. Bit-Wise Logical Operations"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:' \n(boole boole-ior 1 16) \u2192 17 \n(boole boole-and -2 5) \u2192 4 \n(boole boole-eqv 17 15) \u2192 -31 \n;;; These examples illustrate the result of applying BOOLE and each \n;;; of the possible values of OP to each possible combination of bits. \n(progn \n(format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~ \n~%\u2013-Op\u2013\u2013\u2013-Decimal\u2013\u2013-Binary\u2013\u2013Bits\u2013-~%") \n(dolist (symbol \u2019(boole-1 boole-2 boole-and boole-andc1 \nboole-andc2 boole-c1 boole-c2 boole-clr \nboole-eqv boole-ior boole-nand boole-nor \n \n \n**boole** \nboole-orc1 boole-orc2 boole-set boole-xor)) \n(let ((result (boole (symbol-value symbol) #b0011 #b0101))) \n(format t "~& ~A~13T~3,\u2019 D~23T~:\\*~5,\u2019 B~31T ...~4,\u20190B~%" \nsymbol result (logand result #b1111))))) \n\u25b7 Results of (BOOLE <op> #b0011 #b0101) ... \n\u25b7 \u2013-Op\u2013\u2013\u2013-Decimal\u2013\u2013-Binary\u2013\u2013Bits\u2013- \n\u25b7 BOOLE-1 3 11 ...0011 \n\u25b7 BOOLE-2 5 101 ...0101 \n\u25b7 BOOLE-AND 1 1 ...0001 \n\u25b7 BOOLE-ANDC1 4 100 ...0100 \n\u25b7 BOOLE-ANDC2 2 10 ...0010 \n\u25b7 BOOLE-C1 -4 -100 ...1100 \n\u25b7 BOOLE-C2 -6 -110 ...1010 \n\u25b7 BOOLE-CLR 0 0 ...0000 \n\u25b7 BOOLE-EQV -7 -111 ...1001 \n\u25b7 BOOLE-IOR 7 111 ...0111 \n\u25b7 BOOLE-NAND -2 -10 ...1110 \n\u25b7 BOOLE-NOR -8 -1000 ...1000 \n\u25b7 BOOLE-ORC1 -3 -11 ...1101 \n\u25b7 BOOLE-ORC2 -5 -101 ...1011 \n\u25b7 BOOLE-SET -1 -1 ...1111 \n\u25b7 BOOLE-XOR 6 110 ...0110 \n\u2192 NIL \n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["Should signal ",(0,r.jsx)(o,{term:"type-error",children:(0,r.jsx)("b",{children:"type-error"})})," if its first argument is not a ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifier"})," or if any subsequent argument is not an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsx)(o,{term:"logand",children:(0,r.jsx)("b",{children:"logand"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsx)(n.p,{children:"In general,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(boole boole-and x y) *\u2261* (logand x y)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(o,{term:"programmer",children:(0,r.jsx)("i",{children:"Programmers"})})," who would prefer to use numeric indices rather than ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifiers"})," can get an equivalent effect by a technique such as the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:";; The order of the values in this \u2018table\u2019 are such that\n;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) =&gt; n\n(defconstant boole-n-vector\n  (vector boole-clr boole-and boole-andc1 boole-2\n\t  boole-andc2 boole-1 boole-xor boole-ior\n\t  boole-nor boole-eqv boole-c1 boole-orc1\n\t  boole-c2 boole-orc2 boole-nand boole-set))\n\u2192 BOOLE-N-VECTOR\n(proclaim \u2019(inline boole-n))\n\u2192 implementation-dependent\n(defun boole-n (n integer &amp;rest more-integers)\n\t\t(apply #\u2019boole (elt boole-n-vector n) integer more-integers))\n  \u2192 BOOLE-N\n  (boole-n #b0111 5 3) \u2192 7\n  (boole-n #b0001 5 3) \u2192 1\n  (boole-n #b1101 5 3) \u2192 -3\n  (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))\n  \u2192 (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)\n"})})]})}function c(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}const s={title:"boole"},t="boole",d={id:"chap-12/bc-c-dictionary/boole_function",title:"boole",description:"Expanded Reference: boole",source:"@site/docs/chap-12/bc-c-dictionary/boole_function.md",sourceDirName:"chap-12/bc-c-dictionary",slug:"/chap-12/bc-c-dictionary/boole_function",permalink:"/cl-language-reference/chap-12/bc-c-dictionary/boole_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-12/bc-c-dictionary/boole_function.md",tags:[],version:"current",frontMatter:{title:"boole"},sidebar:"tutorialSidebar",previous:{title:"bit",permalink:"/cl-language-reference/chap-12/bc-c-dictionary/bit_type"},next:{title:"boole-1, boole-2, boole-and, boole-andc1, boole-andc2, boole-c1, boole-c2, boole-clr, boole-eqv, boole-ior, boole-nand, boole-nor, boole-orc1, boole-orc2, boole-set, boole-xor",permalink:"/cl-language-reference/chap-12/bc-c-dictionary/boole_one_constant_variable"}},a={},b=[{value:"Expanded Reference: boole",id:"expanded-reference-boole",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"boole",children:"boole"}),"\n","\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-boole",children:"Expanded Reference: boole"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(boole )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>s,a:()=>c});var r=o(67294);const l={},i=r.createContext(l);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);