"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[84258],{9777:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>ee,contentTitle:()=>_,default:()=>se,frontMatter:()=>Y,metadata:()=>$,toc:()=>re});var s=n(85893),c=n(11151);function t(e){return(0,s.jsx)(s.Fragment,{})}function a(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(t,{...e})}):t()}function i(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"character"})," is an ",(0,s.jsx)(r.em,{children:"object"})," that represents a unitary token (",(0,s.jsx)(r.em,{children:"e.g."}),", a letter, a special symbol, or a \u201ccontrol character\u201d) in an aggregate quantity of text (",(0,s.jsx)(r.em,{children:"e.g."}),", a ",(0,s.jsx)(r.em,{children:"string"})," or a text ",(0,s.jsx)(r.em,{children:"stream"}),")."]}),"\n",(0,s.jsxs)(r.p,{children:["Common Lisp allows an implementation to provide support for international language ",(0,s.jsx)(r.em,{children:"characters"})," as well as ",(0,s.jsx)(r.em,{children:"characters"})," used in specialized arenas (",(0,s.jsx)(r.em,{children:"e.g."}),", mathematics)."]}),"\n",(0,s.jsxs)(r.p,{children:["The following figures contain lists of ",(0,s.jsx)(r.em,{children:"defined names"})," applicable to ",(0,s.jsx)(r.em,{children:"characters"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Figure 13\u20131 lists some ",(0,s.jsx)(r.em,{children:"defined names"})," relating to ",(0,s.jsx)(r.em,{children:"character attributes"})," and ",(0,s.jsx)(r.em,{children:"character predicates"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"alpha-char-p char-not-equal char"}),"> "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"alphanumericp char-not-greaterp char"}),">",(0,s.jsx)(r.strong,{children:"="})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"both-case-p char-not-lessp digit-char-p"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"char-code-limit char/= graphic-char-p char-equal char"}),"< ",(0,s.jsx)(r.strong,{children:"lower-case-p"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"char-greaterp char"}),"<",(0,s.jsx)(r.strong,{children:"= standard-char-p char-lessp char= upper-case-p"})]}),"|"]}),"\n",(0,s.jsx)(r.p,{children:"| :- |"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Figure 13\u20131. Character defined names \u2013 1"})}),"\n",(0,s.jsxs)(r.p,{children:["Figure 13\u20132 lists some ",(0,s.jsx)(r.em,{children:"character"})," construction and conversion ",(0,s.jsx)(r.em,{children:"defined names"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"char-code char-name code-char"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.strong,{children:"char-downcase char-upcase digit-char"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(r.strong,{children:"char-int character name-char"})}),"|"]}),"\n",(0,s.jsx)(r.p,{children:"| :- |"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Figure 13\u20132. Character defined names \u2013 2"})})]})}function h(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}function o(e){return(0,s.jsx)(s.Fragment,{})}function d(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(o,{...e})}):o()}function l(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"script"})," is one of possibly several sets that form an ",(0,s.jsx)(r.em,{children:"exhaustive partition"})," of the type ",(0,s.jsx)(r.strong,{children:"character"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["The number of such sets and boundaries between them is ",(0,s.jsx)(r.em,{children:"implementation-defined"}),". Common Lisp does not require these sets to be ",(0,s.jsx)(r.em,{children:"types"}),", but an ",(0,s.jsx)(r.em,{children:"implementation"})," is permitted to define such ",(0,s.jsx)(r.em,{children:"types"})," as an extension. Since no ",(0,s.jsx)(r.em,{children:"character"})," from one ",(0,s.jsx)(r.em,{children:"script"})," can ever be a member of another ",(0,s.jsx)(r.em,{children:"script"}),", it is generally more useful to speak about ",(0,s.jsx)(r.em,{children:"character repertoires"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Although the term \u201c",(0,s.jsx)(r.em,{children:"script"}),"\u201d is chosen for definitional compatibility with ISO terminology, no ",(0,s.jsx)(r.em,{children:"conforming implementation"})," is required to use any particular ",(0,s.jsx)(r.em,{children:"scripts"})," standardized by ISO or by any other standards organization."]}),"\n",(0,s.jsxs)(r.p,{children:["Whether and how the ",(0,s.jsx)(r.em,{children:"script"})," or ",(0,s.jsx)(r.em,{children:"scripts"})," used by any given ",(0,s.jsx)(r.em,{children:"implementation"})," are named is ",(0,s.jsx)(r.em,{children:"implementation-dependent"}),"."]})]})}function m(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function p(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"repertoire"})," is a ",(0,s.jsx)(r.em,{children:"type specifier"})," for a ",(0,s.jsx)(r.em,{children:"subtype"})," of ",(0,s.jsx)(r.em,{children:"type"})," ",(0,s.jsx)(r.strong,{children:"character"}),". This term is generally used when describing a collection of ",(0,s.jsx)(r.em,{children:"characters"})," independent of their coding. ",(0,s.jsx)(r.em,{children:"Characters"})," in ",(0,s.jsx)(r.em,{children:"repertoires"})," are only identified by name, by ",(0,s.jsx)(r.em,{children:"glyph"}),", or by character description."]}),"\n",(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"repertoire"})," can contain ",(0,s.jsx)(r.em,{children:"characters"})," from several ",(0,s.jsx)(r.em,{children:"scripts"}),", and a ",(0,s.jsx)(r.em,{children:"character"})," can appear in more than one ",(0,s.jsx)(r.em,{children:"repertoire"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["For some examples of ",(0,s.jsx)(r.em,{children:"repertoires"}),", see the coded character standards ISO 8859/1, ISO 8859/2, and ISO 6937/2. Note, however, that although the term \u201c",(0,s.jsx)(r.em,{children:"repertoire"}),"\u201d is chosen for definitional compatibility with ISO terminology, no ",(0,s.jsx)(r.em,{children:"conforming implementation"})," is required to use ",(0,s.jsx)(r.em,{children:"repertoires"})," standardized by ISO or any other standards organization."]})]})}function x(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function j(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"Characters"})," have only one ",(0,s.jsx)(r.em,{children:"standardized attribute"}),": a ",(0,s.jsx)(r.em,{children:"code"}),". A ",(0,s.jsx)(r.em,{children:"character"})," \u2019s ",(0,s.jsx)(r.em,{children:"code"})," is a non-negative ",(0,s.jsx)(r.em,{children:"integer"})," . This ",(0,s.jsx)(r.em,{children:"code"})," is composed from a character ",(0,s.jsx)(r.em,{children:"script"})," and a character label in an ",(0,s.jsx)(r.em,{children:"implementation dependent"})," way. See the ",(0,s.jsx)(r.em,{children:"functions"})," ",(0,s.jsx)(r.strong,{children:"char-code"})," and ",(0,s.jsx)(r.strong,{children:"code-char"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Additional, ",(0,s.jsx)(r.em,{children:"implementation-defined attributes"})," of ",(0,s.jsx)(r.em,{children:"characters"})," are also permitted so that, for example, two ",(0,s.jsx)(r.em,{children:"characters"})," with the same ",(0,s.jsx)(r.em,{children:"code"})," may differ in some other, ",(0,s.jsx)(r.em,{children:"implementation-defined"})," way."]}),"\n",(0,s.jsxs)(r.p,{children:["For any ",(0,s.jsx)(r.em,{children:"implementation-defined attribute"})," there is a distinguished value called the ",(0,s.jsx)(r.em,{children:"null"})," value for that ",(0,s.jsx)(r.em,{children:"attribute"}),". A ",(0,s.jsx)(r.em,{children:"character"})," for which each ",(0,s.jsx)(r.em,{children:"implementation-defined attribute"})," has the null value for that ",(0,s.jsx)(r.em,{children:"attribute"})," is called a ",(0,s.jsx)(r.em,{children:"simple character"})," . If the ",(0,s.jsx)(r.em,{children:"implementation"})," has no ",(0,s.jsx)(r.em,{children:"implementation-defined attributes"}),", then all ",(0,s.jsx)(r.em,{children:"characters"})," are ",(0,s.jsx)(r.em,{children:"simple characters"}),"."]})]})}function u(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}function f(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["There are several (overlapping) categories of ",(0,s.jsx)(r.em,{children:"characters"})," that have no formally associated ",(0,s.jsx)(r.em,{children:"type"})," but that are nevertheless useful to name. They include ",(0,s.jsx)(r.em,{children:"graphic characters"}),", ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"characters"}),", ",(0,s.jsx)(r.em,{children:"characters"})," with ",(0,s.jsx)(r.em,{children:"case"})," (",(0,s.jsx)(r.em,{children:"uppercase"})," and ",(0,s.jsx)(r.em,{children:"lowercase characters"}),"), ",(0,s.jsx)(r.em,{children:"numeric characters"}),", ",(0,s.jsx)(r.em,{children:"alphanumeric characters"}),", and ",(0,s.jsx)(r.em,{children:"digits"})," (in a given ",(0,s.jsx)(r.em,{children:"radix"})," )."]}),"\n",(0,s.jsxs)(r.p,{children:["For each ",(0,s.jsx)(r.em,{children:"implementation-defined attribute"})," of a ",(0,s.jsx)(r.em,{children:"character"})," , the documentation for that ",(0,s.jsx)(r.em,{children:"implementa tion"})," must specify whether ",(0,s.jsx)(r.em,{children:"characters"})," that differ only in that ",(0,s.jsx)(r.em,{children:"attribute"})," are permitted to differ in whether are not they are members of one of the aforementioned categories."]}),"\n",(0,s.jsxs)(r.p,{children:["Note that these terms are defined independently of any special syntax which might have been enabled in the ",(0,s.jsx)(r.em,{children:"current readtable"}),"."]})]})}function g(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}function b(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"Characters"})," that are classified as ",(0,s.jsx)(r.em,{children:"graphic"}),", or displayable, are each associated with a glyph, a visual representation of the ",(0,s.jsx)(r.em,{children:"character"})," ."]}),"\n",(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"graphic character"})," is one that has a standard textual representation as a single ",(0,s.jsx)(r.em,{children:"glyph"}),", such as A or * or =. ",(0,s.jsx)(r.em,{children:"Space"}),", which effectively has a blank ",(0,s.jsx)(r.em,{children:"glyph"}),", is defined to be a ",(0,s.jsx)(r.em,{children:"graphic"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", ",(0,s.jsx)(r.em,{children:"newline"})," is ",(0,s.jsx)(r.em,{children:"non-graphic"})," and all others are ",(0,s.jsx)(r.em,{children:"graphic"}),"; see Section 2.1.3 (Standard Characters)."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"Characters"})," that are not ",(0,s.jsx)(r.em,{children:"graphic"})," are called ",(0,s.jsx)(r.em,{children:"non-graphic"}),". ",(0,s.jsx)(r.em,{children:"Non-graphic characters"})," are sometimes informally called \u201cformatting characters\u201d or \u201ccontrol characters.\u201d"]}),"\n",(0,s.jsxs)(r.p,{children:["#\\Backspace, #\\Tab, #\\Rubout, #\\Linefeed, #\\Return, and #\\Page, if they are supported by the ",(0,s.jsx)(r.em,{children:"implementation"}),", are ",(0,s.jsx)(r.em,{children:"non-graphic"}),"."]})]})}function w(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}function v(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"characters"})," are a subset of the ",(0,s.jsx)(r.em,{children:"graphic characters"}),". Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", only these are the ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"characters"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"}),"\n",(0,s.jsx)(r.p,{children:"a b c d e f g h i j k l m n o p q r s t u v w x y z"}),"\n",(0,s.jsxs)(r.p,{children:["Any ",(0,s.jsx)("i",{children:"implementation-defined character"})," that has ",(0,s.jsx)("i",{children:"case"})," must be ",(0,s.jsx)("i",{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"}),(0,s.jsxs)("sup",{children:[". For each ",(0,s.jsx)("i",{children:"implementation"})]})," defined graphic character that has no ",(0,s.jsx)("i",{children:"case"}),", it is ",(0,s.jsx)("i",{children:"implementation-defined"})," whether that ",(0,s.jsx)("i",{children:"character"})," is ",(0,s.jsx)("i",{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"}),"."]})]})}function y(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(v,{...e})}):v(e)}function C(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.em,{children:"characters"})," with ",(0,s.jsx)(r.em,{children:"case"})," are a subset of the ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"characters"}),". A ",(0,s.jsx)(r.em,{children:"character"})," with ",(0,s.jsx)(r.em,{children:"case"})," has the property of being either ",(0,s.jsx)(r.em,{children:"uppercase"})," or ",(0,s.jsx)(r.em,{children:"lowercase"}),". Every ",(0,s.jsx)(r.em,{children:"character"})," with ",(0,s.jsx)(r.em,{children:"case"})," is in one-to-one correspondence with some other ",(0,s.jsx)(r.em,{children:"character"})," with the opposite ",(0,s.jsx)(r.em,{children:"case"}),"."]})}function T(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}function F(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["An uppercase ",(0,s.jsx)(r.em,{children:"character"})," is one that has a corresponding ",(0,s.jsx)(r.em,{children:"lowercase character"})," that is ",(0,s.jsx)(r.em,{children:"different"})," (and can be obtained using ",(0,s.jsx)(r.strong,{children:"char-downcase"}),")."]}),"\n",(0,s.jsxs)(r.p,{children:["Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", only these are ",(0,s.jsx)(r.em,{children:"uppercase characters"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"})]})}function A(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(F,{...e})}):F(e)}function I(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["A lowercase ",(0,s.jsx)(r.em,{children:"character"})," is one that has a corresponding ",(0,s.jsx)(r.em,{children:"uppercase character"})," that is ",(0,s.jsx)(r.em,{children:"different"})," (and can be obtained using ",(0,s.jsx)(r.strong,{children:"char-upcase"}),")."]}),"\n",(0,s.jsxs)(r.p,{children:["Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", only these are ",(0,s.jsx)(r.em,{children:"lowercase characters"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"a b c d e f g h i j k l m n o p q r s t u v w x y z"})]})}function k(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(I,{...e})}):I(e)}function O(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.em,{children:"uppercase standard characters"})," A through Z mentioned above respectively correspond to the ",(0,s.jsx)(r.em,{children:"lowercase standard characters"})," a through z mentioned above. For example, the ",(0,s.jsx)(r.em,{children:"uppercase character"})," E corresponds to the ",(0,s.jsx)(r.em,{children:"lowercase character"})," e, and vice versa."]})}function S(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}function N(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["An ",(0,s.jsx)(r.em,{children:"implementation"})," may define that other ",(0,s.jsx)(r.em,{children:"implementation-defined graphic characters"})," have ",(0,s.jsx)(r.em,{children:"case"}),". Such definitions must always be done in pairs\u2014one ",(0,s.jsx)(r.em,{children:"uppercase character"})," in one-to-one ",(0,s.jsx)(r.em,{children:"correspondence"})," with one ",(0,s.jsx)(r.em,{children:"lowercase character"})," ."]})}function q(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(N,{...e})}):N(e)}function R(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.em,{children:"numeric characters"})," are a subset of the ",(0,s.jsx)(r.em,{children:"graphic characters"}),". Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", only these are ",(0,s.jsx)(r.em,{children:"numeric characters"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"0 1 2 3 4 5 6 7 8 9"}),"\n",(0,s.jsxs)(r.p,{children:["For each ",(0,s.jsx)(r.em,{children:"implementation-defined graphic character"})," that has no ",(0,s.jsx)(r.em,{children:"case"}),", the ",(0,s.jsx)(r.em,{children:"implementation"})," must define whether or not it is a ",(0,s.jsx)(r.em,{children:"numeric character"})," ."]})]})}function L(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(R,{...e})}):R(e)}function z(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["The set of ",(0,s.jsx)(r.em,{children:"alphanumeric characters"})," is the union of the set of ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"characters"})," and the set of ",(0,s.jsx)(r.em,{children:"numeric characters"}),"."]})}function W(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(z,{...e})}):z(e)}function D(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["What qualifies as a ",(0,s.jsx)(r.em,{children:"digit"})," depends on the ",(0,s.jsx)(r.em,{children:"radix"})," (an ",(0,s.jsx)(r.em,{children:"integer"})," between 2 and 36, inclusive). The potential ",(0,s.jsx)(r.em,{children:"digits"})," are:"]}),"\n",(0,s.jsx)(r.p,{children:"0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"}),"\n",(0,s.jsxs)(r.p,{children:["Their respective weights are 0, 1, 2, ",(0,s.jsx)(r.em,{children:". . ."})," 35. In any given radix ",(0,s.jsx)(r.em,{children:"n"}),", only the first ",(0,s.jsx)(r.em,{children:"n"})," potential ",(0,s.jsx)(r.em,{children:"digits"})," are considered to be ",(0,s.jsx)(r.em,{children:"digits"}),". For example, the digits in radix 2 are 0 and 1, the digits in radix 10 are 0 through 9, and the digits in radix 16 are 0 through F."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"Case"})," is not significant in ",(0,s.jsx)(r.em,{children:"digits"}),"; for example, in radix 16, both F and f are ",(0,s.jsx)(r.em,{children:"digits"})," with weight 15."]})]})}function E(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(D,{...e})}):D(e)}function P(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["Two ",(0,s.jsx)(r.em,{children:"characters"})," that are ",(0,s.jsx)(r.strong,{children:"eql"}),", ",(0,s.jsx)(r.strong,{children:"char="}),", or ",(0,s.jsx)(r.strong,{children:"char-equal"})," are not necessarily ",(0,s.jsx)(r.strong,{children:"eq"}),"."]})}function B(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}function U(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["The total ordering on ",(0,s.jsx)(r.em,{children:"characters"})," is guaranteed to have the following properties:"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," If two ",(0,s.jsx)(r.em,{children:"characters"})," have the same ",(0,s.jsx)(r.em,{children:"implementation-defined attributes"}),", then their ordering by ",(0,s.jsx)(r.strong,{children:"char"}),"< is consistent with the numerical ordering by the predicate < on their code ",(0,s.jsx)(r.em,{children:"attributes"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," If two ",(0,s.jsx)(r.em,{children:"characters"})," differ in any ",(0,s.jsx)(r.em,{children:"attribute"}),", then they are not ",(0,s.jsx)(r.strong,{children:"char="}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," The total ordering is not necessarily the same as the total ordering on the ",(0,s.jsx)(r.em,{children:"integers"})," produced by applying ",(0,s.jsx)(r.strong,{children:"char-int"})," to the ",(0,s.jsx)(r.em,{children:"characters"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," While ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)("sub",{children:"1"})," ",(0,s.jsx)(r.em,{children:"standard characters"})," of a given ",(0,s.jsx)(r.em,{children:"case"})," must obey a partial ordering, they need not be contiguous; it is permissible for ",(0,s.jsx)(r.em,{children:"uppercase"})," and ",(0,s.jsx)(r.em,{children:"lowercase characters"})," to be interleaved. Thus ",(0,s.jsx)(r.code,{children:"(char<= #\\a x #\\z)"})," is not a valid way of determining whether or not x is a ",(0,s.jsx)(r.em,{children:"lowercase character"})," ."]}),"\n",(0,s.jsxs)(r.p,{children:["Of the ",(0,s.jsx)(r.em,{children:"standard characters"}),", those which are ",(0,s.jsx)(r.em,{children:"alphanumeric"})," obey the following partial ordering:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.code,{children:"A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.code,{children:"a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.code,{children:"0<1<2<3<4<5<6<7<8<9"})}),"\n",(0,s.jsxs)(r.li,{children:["either ",(0,s.jsx)(r.code,{children:"9<A"})," or ",(0,s.jsx)(r.code,{children:"Z<0"})]}),"\n",(0,s.jsxs)(r.li,{children:["either ",(0,s.jsx)(r.code,{children:"9<a"})," or ",(0,s.jsx)(r.code,{children:"z<0"})]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["This implies that, for ",(0,s.jsx)(r.em,{children:"standard characters"}),", ",(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)(r.sup,{children:(0,s.jsx)(r.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," ordering holds within each ",(0,s.jsx)(r.em,{children:"case"})," (",(0,s.jsx)(r.em,{children:"uppercase"})," and ",(0,s.jsx)(r.em,{children:"lowercase"}),"), and that the ",(0,s.jsx)(r.em,{children:"numeric characters"})," as a group are not interleaved with ",(0,s.jsx)(r.em,{children:"alphabetic characters"}),". However, the ordering or possible interleaving of ",(0,s.jsx)(r.em,{children:"uppercase characters"})," and ",(0,s.jsx)(r.em,{children:"lowercase characters"})," is ",(0,s.jsx)(r.em,{children:"implementation-defined"}),"."]}),"\n",(0,s.jsx)(r.admonition,{type:"warning",children:(0,s.jsxs)(r.p,{children:['We have a missing footnote "',(0,s.jsx)(r.em,{children:"alphabetic"}),(0,s.jsx)(r.sup,{children:(0,s.jsx)(r.a,{href:"#user-content-fn-1",id:"user-content-fnref-1-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),'" from the specification. Please help us find it!']})}),"\n",(0,s.jsxs)(r.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(r.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(r.p,{children:["Unclear where this footnote is in the specification ",(0,s.jsx)(r.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})," ",(0,s.jsxs)(r.a,{href:"#user-content-fnref-1-2","data-footnote-backref":"","aria-label":"Back to reference 1-2",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(r.sup,{children:"2"})]})]}),"\n"]}),"\n"]}),"\n"]})]})}function Z(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(U,{...e})}):U(e)}function M(e){const r={em:"em",p:"p",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["The following ",(0,s.jsx)(r.em,{children:"character names"})," must be present in all ",(0,s.jsx)(r.em,{children:"conforming implementations"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"Newline"}),"\n",(0,s.jsx)(r.p,{children:"The character that represents the division between lines. An implementation must translate between #\\Newline, a single-character representation, and whatever external representation(s) may be used."}),"\n",(0,s.jsx)(r.p,{children:"Space"}),"\n",(0,s.jsx)(r.p,{children:"The space or blank character."}),"\n",(0,s.jsxs)(r.p,{children:["The following names are ",(0,s.jsx)(r.em,{children:"semi-standard"}),"; if an ",(0,s.jsx)(r.em,{children:"implementation"})," supports them, they should be used for the described ",(0,s.jsx)(r.em,{children:"characters"})," and no others."]}),"\n",(0,s.jsx)(r.p,{children:"Rubout"}),"\n",(0,s.jsx)(r.p,{children:"The rubout or delete character."}),"\n",(0,s.jsx)(r.p,{children:"Page"}),"\n",(0,s.jsx)(r.p,{children:"The form-feed or page-separator character."}),"\n",(0,s.jsx)(r.p,{children:"Tab"}),"\n",(0,s.jsx)(r.p,{children:"The tabulate character."}),"\n",(0,s.jsx)(r.p,{children:"Backspace"}),"\n",(0,s.jsx)(r.p,{children:"The backspace character."}),"\n",(0,s.jsx)(r.p,{children:"Return"}),"\n",(0,s.jsx)(r.p,{children:"The carriage return character."}),"\n",(0,s.jsx)(r.p,{children:"Linefeed"}),"\n",(0,s.jsx)(r.p,{children:"The line-feed character."}),"\n",(0,s.jsxs)(r.p,{children:["In some ",(0,s.jsx)(r.em,{children:"implementations"}),", one or more of these ",(0,s.jsx)(r.em,{children:"character names"})," might denote a ",(0,s.jsx)(r.em,{children:"standard character"})," ; for example, #\\Linefeed and #\\Newline might be the ",(0,s.jsx)(r.em,{children:"same character"})," in some ",(0,s.jsx)(r.em,{children:"implementations"}),"."]})]})}function G(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(M,{...e})}):M(e)}function H(e){const r={p:"p",...(0,c.a)(),...e.components};return(0,s.jsx)(r.p,{children:"When the character #\\Newline is written to an output file, the implementation must take the appropriate action to produce a line division. This might involve writing out a record or translating #\\Newline to a CR/LF sequence. When reading, a corresponding reverse transformation must take place."})}function J(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(H,{...e})}):H(e)}function K(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(r.p,{children:["A ",(0,s.jsx)(r.em,{children:"character"})," is sometimes represented merely by its ",(0,s.jsx)(r.em,{children:"code"}),", and sometimes by another ",(0,s.jsx)(r.em,{children:"integer"})," value which is composed from the ",(0,s.jsx)(r.em,{children:"code"})," and all ",(0,s.jsx)(r.em,{children:"implementation-defined attributes"})," (in an ",(0,s.jsx)(r.em,{children:"implementation defined"})," way that might vary between ",(0,s.jsx)(r.em,{children:"Lisp images"})," even in the same ",(0,s.jsx)(r.em,{children:"implementation"}),"). This ",(0,s.jsx)(r.em,{children:"integer"})," , returned by the function ",(0,s.jsx)(r.strong,{children:"char-int"}),", is called the character\u2019s \u201cencoding.\u201d There is no corresponding function from a character\u2019s encoding back to the ",(0,s.jsx)(r.em,{children:"character"})," , since its primary intended uses include things like hashing where an inverse operation is not really called for."]})}function Q(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(K,{...e})}):K(e)}function V(e){const r={em:"em",p:"p",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["An ",(0,s.jsx)(r.em,{children:"implementation"})," must document the ",(0,s.jsx)(r.em,{children:"character scripts"})," it supports. For each ",(0,s.jsx)(r.em,{children:"character script"})," supported, the documentation must describe at least the following:"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," Character labels, glyphs, and descriptions. Character labels must be uniquely named using only Latin capital letters A\u2013Z, hyphen (-), and digits 0\u20139."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," Reader canonicalization. Any mechanisms by which ",(0,s.jsx)(r.strong,{children:"read"})," treats ",(0,s.jsx)(r.em,{children:"different"})," characters as equivalent must be documented."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," The impact on ",(0,s.jsx)(r.strong,{children:"char-upcase"}),", ",(0,s.jsx)(r.strong,{children:"char-downcase"}),", and the case-sensitive ",(0,s.jsx)(r.em,{children:"format directives"}),". In particular, for each ",(0,s.jsx)(r.em,{children:"character"})," with ",(0,s.jsx)(r.em,{children:"case"}),", whether it is ",(0,s.jsx)(r.em,{children:"uppercase"})," or ",(0,s.jsx)(r.em,{children:"lowercase"}),", and which ",(0,s.jsx)(r.em,{children:"character"})," is its equivalent in the opposite case."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," The behavior of the case-insensitive ",(0,s.jsx)(r.em,{children:"functions"})," ",(0,s.jsx)(r.strong,{children:"char-equal"}),", ",(0,s.jsx)(r.strong,{children:"char-not-equal"}),", ",(0,s.jsx)(r.strong,{children:"char-lessp"}),", ",(0,s.jsx)(r.strong,{children:"char-greaterp"}),", ",(0,s.jsx)(r.strong,{children:"char-not-greaterp"}),", and ",(0,s.jsx)(r.strong,{children:"char-not-lessp"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," The behavior of any ",(0,s.jsx)(r.em,{children:"character predicates"}),"; in particular, the effects of ",(0,s.jsx)(r.strong,{children:"alpha-char-p"}),", ",(0,s.jsx)(r.strong,{children:"lower-case-p"}),", ",(0,s.jsx)(r.strong,{children:"upper-case-p"}),", ",(0,s.jsx)(r.strong,{children:"both-case-p"}),", ",(0,s.jsx)(r.strong,{children:"graphic-char-p"}),", and ",(0,s.jsx)(r.strong,{children:"alphanumericp"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"\u2022"})," The interaction with file I/O, in particular, the supported coded character sets (for example, ISO8859/1-1987) and external encoding schemes supported are documented."]})]})}function X(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(V,{...e})}):V(e)}const Y={title:"13.1 Character Concepts"},_="13.1 Character Concepts",$={id:"chap-13/bd-b-character-concepts",title:"13.1 Character Concepts",description:"13.1.1 Introduction to Characters",source:"@site/docs/chap-13/bd-b-character-concepts.md",sourceDirName:"chap-13",slug:"/chap-13/bd-b-character-concepts",permalink:"/cl-language-reference/docs/chap-13/bd-b-character-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-13/bd-b-character-concepts.md",tags:[],version:"current",frontMatter:{title:"13.1 Character Concepts"},sidebar:"tutorialSidebar",previous:{title:"13. Characters",permalink:"/cl-language-reference/docs/category/13-characters"},next:{title:"13.2 Characters Dictionary",permalink:"/cl-language-reference/docs/category/132-characters-dictionary"}},ee={},re=[{value:"13.1.1 Introduction to Characters",id:"1311-introduction-to-characters",level:2},{value:"13.1.2 Introduction to Scripts and Repertoires",id:"1312-introduction-to-scripts-and-repertoires",level:2},{value:"13.1.2.1 Character Scripts",id:"13121-character-scripts",level:3},{value:"13.1.2.2 Character Repertoires",id:"13122-character-repertoires",level:3},{value:"13.1.3 Character Attributes",id:"1313-character-attributes",level:2},{value:"13.1.4 Character Categories",id:"1314-character-categories",level:2},{value:"13.1.4.1 Graphic Characters",id:"13141-graphic-characters",level:3},{value:"13.1.4.2 Alphabetic Characters",id:"13142-alphabetic-characters",level:3},{value:"13.1.4.3 Characters With Case",id:"13143-characters-with-case",level:3},{value:"13.1.4.3.1 Uppercase Characters",id:"131431-uppercase-characters",level:4},{value:"13.1.4.3.2 Lowercase Characters",id:"131432-lowercase-characters",level:4},{value:"13.1.4.3.3 Corresponding Characters in the Other Case",id:"131433-corresponding-characters-in-the-other-case",level:4},{value:"13.1.4.3.4 Case of Implementation",id:"131434-case-of-implementation",level:4},{value:"13.1.4.4 Numeric Characters",id:"13144-numeric-characters",level:3},{value:"13.1.4.5 Alphanumeric Characters",id:"13145-alphanumeric-characters",level:3},{value:"13.1.4.6 Digits in a Radix",id:"13146-digits-in-a-radix",level:3},{value:"13.1.5 Identity of Characters",id:"1315-identity-of-characters",level:2},{value:"13.1.6 Ordering of Characters",id:"1316-ordering-of-characters",level:2},{value:"13.1.7 Character Names",id:"1317-character-names",level:2},{value:"13.1.8 Treatment of Newline during Input and Output",id:"1318-treatment-of-newline-during-input-and-output",level:2},{value:"13.1.9 Character Encodings",id:"1319-character-encodings",level:2},{value:"13.1.10 Documentation of Implementation",id:"13110-documentation-of-implementation",level:2}];function ne(e){const r={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"131-character-concepts",children:"13.1 Character Concepts"}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(r.h2,{id:"1311-introduction-to-characters",children:"13.1.1 Introduction to Characters"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(r.h2,{id:"1312-introduction-to-scripts-and-repertoires",children:"13.1.2 Introduction to Scripts and Repertoires"}),"\n","\n",(0,s.jsx)(d,{}),"\n",(0,s.jsx)(r.h3,{id:"13121-character-scripts",children:"13.1.2.1 Character Scripts"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(r.h3,{id:"13122-character-repertoires",children:"13.1.2.2 Character Repertoires"}),"\n","\n",(0,s.jsx)(x,{}),"\n",(0,s.jsx)(r.h2,{id:"1313-character-attributes",children:"13.1.3 Character Attributes"}),"\n","\n",(0,s.jsx)(u,{}),"\n",(0,s.jsx)(r.h2,{id:"1314-character-categories",children:"13.1.4 Character Categories"}),"\n","\n",(0,s.jsx)(g,{}),"\n",(0,s.jsx)(r.h3,{id:"13141-graphic-characters",children:"13.1.4.1 Graphic Characters"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(r.h3,{id:"13142-alphabetic-characters",children:"13.1.4.2 Alphabetic Characters"}),"\n","\n",(0,s.jsx)(y,{}),"\n",(0,s.jsx)(r.h3,{id:"13143-characters-with-case",children:"13.1.4.3 Characters With Case"}),"\n","\n",(0,s.jsx)(T,{}),"\n",(0,s.jsx)(r.h4,{id:"131431-uppercase-characters",children:"13.1.4.3.1 Uppercase Characters"}),"\n","\n",(0,s.jsx)(A,{}),"\n",(0,s.jsx)(r.h4,{id:"131432-lowercase-characters",children:"13.1.4.3.2 Lowercase Characters"}),"\n","\n",(0,s.jsx)(k,{}),"\n",(0,s.jsx)(r.h4,{id:"131433-corresponding-characters-in-the-other-case",children:"13.1.4.3.3 Corresponding Characters in the Other Case"}),"\n","\n",(0,s.jsx)(S,{}),"\n",(0,s.jsx)(r.h4,{id:"131434-case-of-implementation",children:"13.1.4.3.4 Case of Implementation"}),"\n","\n",(0,s.jsx)(q,{}),"\n",(0,s.jsx)(r.h3,{id:"13144-numeric-characters",children:"13.1.4.4 Numeric Characters"}),"\n","\n",(0,s.jsx)(L,{}),"\n",(0,s.jsx)(r.h3,{id:"13145-alphanumeric-characters",children:"13.1.4.5 Alphanumeric Characters"}),"\n","\n",(0,s.jsx)(W,{}),"\n",(0,s.jsx)(r.h3,{id:"13146-digits-in-a-radix",children:"13.1.4.6 Digits in a Radix"}),"\n","\n",(0,s.jsx)(E,{}),"\n",(0,s.jsx)(r.h2,{id:"1315-identity-of-characters",children:"13.1.5 Identity of Characters"}),"\n","\n",(0,s.jsx)(B,{}),"\n",(0,s.jsx)(r.h2,{id:"1316-ordering-of-characters",children:"13.1.6 Ordering of Characters"}),"\n","\n",(0,s.jsx)(Z,{}),"\n",(0,s.jsx)(r.h2,{id:"1317-character-names",children:"13.1.7 Character Names"}),"\n","\n",(0,s.jsx)(G,{}),"\n",(0,s.jsx)(r.h2,{id:"1318-treatment-of-newline-during-input-and-output",children:"13.1.8 Treatment of Newline during Input and Output"}),"\n","\n",(0,s.jsx)(J,{}),"\n",(0,s.jsx)(r.h2,{id:"1319-character-encodings",children:"13.1.9 Character Encodings"}),"\n","\n",(0,s.jsx)(Q,{}),"\n",(0,s.jsx)(r.h2,{id:"13110-documentation-of-implementation",children:"13.1.10 Documentation of Implementation"}),"\n","\n","\n",(0,s.jsx)(X,{})]})}function se(e={}){const{wrapper:r}={...(0,c.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(ne,{...e})}):ne(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>i,a:()=>a});var s=n(67294);const c={},t=s.createContext(c);function a(e){const r=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);