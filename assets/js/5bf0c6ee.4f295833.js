"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[4773],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(96540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},41536:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>x,frontMatter:()=>l,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"chap-9/j-c-dictionary/error_function","title":"error","description":"Expanded Reference: error","source":"@site/docs/chap-9/j-c-dictionary/error_function.md","sourceDirName":"chap-9/j-c-dictionary","slug":"/chap-9/j-c-dictionary/error_function","permalink":"/cl-language-reference/chap-9/j-c-dictionary/error_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-9/j-c-dictionary/error_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"error"},"sidebar":"tutorialSidebar","previous":{"title":"error","permalink":"/cl-language-reference/chap-9/j-c-dictionary/error_condition-type"},"next":{"title":"find-restart","permalink":"/cl-language-reference/chap-9/j-c-dictionary/find-restart_function"}}');var i=r(74848),o=r(28453);function s(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components},{DictionaryLink:r,GlossaryTerm:t}=n;return r||c("DictionaryLink",!0),t||c("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"error"})," ",(0,i.jsx)(t,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"Function"})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{styled:!0,term:"error",children:(0,i.jsx)("b",{children:"error"})})," ",(0,i.jsx)(n.em,{children:"datum"})," &rest ",(0,i.jsx)(n.em,{children:"arguments \u2192"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"datum"}),", ",(0,i.jsx)(t,{styled:!0,term:"argument",children:(0,i.jsx)("i",{children:"arguments"})}),"\u2014",(0,i.jsx)(t,{styled:!0,term:"designator",children:(0,i.jsx)("i",{children:"designators"})})," for a ",(0,i.jsx)(t,{styled:!0,term:"condition",children:(0,i.jsx)("i",{children:"condition"})})," of default type ",(0,i.jsx)(r,{styled:!0,term:"simple-error",children:(0,i.jsx)("b",{children:"simple-error"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{styled:!0,term:"error",children:(0,i.jsx)("b",{children:"error"})})," effectively invokes ",(0,i.jsx)(r,{styled:!0,term:"signal",children:(0,i.jsx)("b",{children:"signal"})})," on the denoted ",(0,i.jsx)(t,{styled:!0,term:"condition",children:(0,i.jsx)("i",{children:"condition"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(t,{styled:!0,term:"condition",children:(0,i.jsx)("i",{children:"condition"})})," is not handled, (invoke-debugger ",(0,i.jsx)(t,{styled:!0,term:"condition",children:(0,i.jsx)("i",{children:"condition"})}),") is done. As a consequence of calling ",(0,i.jsx)(r,{styled:!0,term:"invoke-debugger",children:(0,i.jsx)("b",{children:"invoke-debugger"})}),", ",(0,i.jsx)(r,{styled:!0,term:"error",children:(0,i.jsx)("b",{children:"error"})})," cannot directly return; the only exit from ",(0,i.jsx)(r,{styled:!0,term:"error",children:(0,i.jsx)("b",{children:"error"})})," can come by non-local transfer of control in a handler or by use of an interactive debugging command."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(defun factorial (x) \n  (cond ((or (not (typep x \u2019integer)) (minusp x)) \n\t (error "~S is not a valid argument to FACTORIAL." x)) \n\t((zerop x) 1) \n\t\n\t\n\t**error** \n\t(t (\\* x (factorial (- x 1)))))) \n\u2192 FACTORIAL \n(factorial 20) \n\u2192 2432902008176640000 \n(factorial -1) \n\u25b7 Error: -1 is not a valid argument to FACTORIAL. \n\u25b7 To continue, type :CONTINUE followed by an option number: \n\u25b7 1: Return to Lisp Toplevel. \n\u25b7 Debug> \n(setq a \u2019fred) \n\u2192 FRED \n(if (numberp a) (1+ a) (error "~S is not a number." A)) \n\u25b7 Error: FRED is not a number. \n\u25b7 To continue, type :CONTINUE followed by an option number: \n\u25b7 1: Return to Lisp Toplevel. \n\u25b7 Debug> :Continue 1 \n\u25b7 Return to Lisp Toplevel. \n(define-condition not-a-number (error) \n  ((argument :reader not-a-number-argument :initarg :argument)) \n  (:report (lambda (condition stream) \n\t     (format stream "~S is not a number." \n\t\t     (not-a-number-argument condition))))) \n\u2192 NOT-A-NUMBER \n(if (numberp a) (1+ a) (error \u2019not-a-number :argument a)) \n\u25b7 Error: FRED is not a number. \n\u25b7 To continue, type :CONTINUE followed by an option number: \n\u25b7 1: Return to Lisp Toplevel. \n\u25b7 Debug> :Continue 1 \n\u25b7 Return to Lisp Toplevel. \n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(t,{styled:!0,term:"handler",children:(0,i.jsx)("i",{children:"Handlers"})})," for the specified condition, if any, are invoked and might have side effects. Program execution might stop, and the debugger might be entered."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsx)(n.p,{children:"Existing handler bindings."}),"\n",(0,i.jsx)(r,{styled:!0,term:"break-on-signals",children:(0,i.jsx)("b",{children:"*break-on-signals*"})}),"\n",(0,i.jsxs)(n.p,{children:["Signals an error of ",(0,i.jsx)(t,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})})," ",(0,i.jsx)(r,{styled:!0,term:"type-error",children:(0,i.jsx)("b",{children:"type-error"})})," if ",(0,i.jsx)(n.em,{children:"datum"})," and ",(0,i.jsx)(t,{styled:!0,term:"argument",children:(0,i.jsx)("i",{children:"arguments"})})," are not ",(0,i.jsx)(t,{styled:!0,term:"designator",children:(0,i.jsx)("i",{children:"designators"})})," for a ",(0,i.jsx)(t,{styled:!0,term:"condition",children:(0,i.jsx)("i",{children:"condition"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{styled:!0,term:"cerror",children:(0,i.jsx)("b",{children:"cerror"})}),", ",(0,i.jsx)(r,{styled:!0,term:"signal",children:(0,i.jsx)("b",{children:"signal"})}),", ",(0,i.jsx)(r,{styled:!0,term:"format",children:(0,i.jsx)("b",{children:"format"})}),", ",(0,i.jsx)(r,{styled:!0,term:"ignore-errors",children:(0,i.jsx)("b",{children:"ignore-errors"})}),", ",(0,i.jsx)(r,{styled:!0,term:"break-on-signals",children:(0,i.jsx)("b",{children:"*break-on-signals*"})}),", ",(0,i.jsx)(r,{styled:!0,term:"handler-bind",children:(0,i.jsx)("b",{children:"handler-bind"})}),", Section 9.1 (Condition"]}),"\n",(0,i.jsx)(n.p,{children:"System Concepts)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsx)(n.p,{children:"Some implementations may provide debugger commands for interactively returning from individual stack frames. However, it should be possible for the programmer to feel confident about writing code like:"}),"\n",(0,i.jsxs)(n.p,{children:["(defun wargames",":no-win-scenario"," ()"]}),"\n",(0,i.jsx)(n.p,{children:'(if (error "pushing the button would be stupid."))'}),"\n",(0,i.jsx)(n.p,{children:"(push-the-button))"}),"\n",(0,i.jsxs)(n.p,{children:["In this scenario, there should be no chance that ",(0,i.jsx)(r,{styled:!0,term:"error",children:(0,i.jsx)("b",{children:"error"})})," will return and the button will get pushed."]}),"\n",(0,i.jsx)(n.p,{children:"While the meaning of this program is clear and it might be proven \u2018safe\u2019 by a formal theorem prover, such a proof is no guarantee that the program is safe to execute. Compilers have been known to have bugs, computers to have signal glitches, and human beings to manually intervene in ways that are not always possible to predict. Those kinds of errors, while beyond the scope of the condition system to formally model, are not beyond the scope of things that should seriously be considered when writing code that could have the kinds of sweeping effects hinted at by this example."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const l={title:"error"},a="error",h={},p=[{value:"Expanded Reference: error",id:"expanded-reference-error",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"error",children:"error"})}),"\n","\n",(0,i.jsx)(d,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-error",children:"Expanded Reference: error"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(error )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);