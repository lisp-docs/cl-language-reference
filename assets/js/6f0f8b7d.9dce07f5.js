"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[70979],{87723:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>c,default:()=>o,frontMatter:()=>d,metadata:()=>a,toc:()=>j});var s=n(85893),l=n(11151);function i(e){const r={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,l.a)(),...e.components},{ClLinks:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"equal"})," ",(0,s.jsx)(n,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"Function"})})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," ",(0,s.jsx)(r.em,{children:"x y \u2192 generalized-boolean"})]}),"\n",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"x"}),"\u2014an ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"y"}),"\u2014an ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"generalized-boolean"}),"\u2014a ",(0,s.jsx)(r.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(r.p,{children:["Returns ",(0,s.jsx)(n,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})})," if ",(0,s.jsx)(r.em,{children:"x"})," and ",(0,s.jsx)(r.em,{children:"y"})," are structurally similar (isomorphic) ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})}),". ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"Objects"})})," are treated as follows by ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"symbol",children:(0,s.jsx)("i",{children:"Symbols"})}),", ",(0,s.jsx)(n,{styled:!0,term:"number",children:(0,s.jsx)("i",{children:"Numbers"})}),", and ",(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"Characters"})})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," is ",(0,s.jsx)(n,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})})," of two ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," if they are ",(0,s.jsx)(n,{styled:!0,term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," that are ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})}),", if they are ",(0,s.jsx)(n,{styled:!0,term:"number",children:(0,s.jsx)("i",{children:"numbers"})})," that are ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),", or if they are ",(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"characters"})})," that are ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.em,{children:"Conses"})}),"\n",(0,s.jsxs)(r.p,{children:["For ",(0,s.jsx)(r.em,{children:"conses"}),", ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," is defined recursively as the two ",(0,s.jsx)(n,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"cars"})})," being ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," and the two ",(0,s.jsx)(n,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdrs"})})," being ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"."]}),"\n",(0,s.jsx)(n,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"Arrays"})}),"\n",(0,s.jsxs)(r.p,{children:["Two ",(0,s.jsx)(n,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"arrays"})})," are ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," only if they are ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})}),", with one exception: ",(0,s.jsx)(n,{styled:!0,term:"string",children:(0,s.jsx)("i",{children:"strings"})})," and ",(0,s.jsx)(r.em,{children:"bit vectors"})," are compared element-by-element (using ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),"). If either ",(0,s.jsx)(r.em,{children:"x"})," or ",(0,s.jsx)(r.em,{children:"y"})," has a ",(0,s.jsx)(r.em,{children:"fill pointer"})," , the ",(0,s.jsx)(r.em,{children:"fill pointer"})," limits the number of elements examined by ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),". Uppercase and lowercase letters in ",(0,s.jsx)(n,{styled:!0,term:"string",children:(0,s.jsx)("i",{children:"strings"})})," are considered by ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," to be different."]}),"\n",(0,s.jsx)(n,{styled:!0,term:"pathname",children:(0,s.jsx)("i",{children:"Pathnames"})}),"\n",(0,s.jsxs)(r.p,{children:["Two ",(0,s.jsx)(n,{styled:!0,term:"pathname",children:(0,s.jsx)("i",{children:"pathnames"})})," are ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," if and only if all the corresponding components (host, device, and so on) are equivalent. Whether or not uppercase and lowercase letters are considered equivalent in ",(0,s.jsx)(n,{styled:!0,term:"string",children:(0,s.jsx)("i",{children:"strings"})})," appearing in components is ",(0,s.jsx)(n,{styled:!0,term:"implementation-dependent",children:(0,s.jsx)("i",{children:"implementation-dependent"})}),". ",(0,s.jsx)(n,{styled:!0,term:"pathname",children:(0,s.jsx)("i",{children:"pathnames"})})," that are ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," should be functionally equivalent."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Other (Structures, hash-tables, instances,"})," ",(0,s.jsx)(r.em,{children:". . ."}),(0,s.jsx)(r.strong,{children:")"})]}),"\n",(0,s.jsxs)(r.p,{children:["Two other ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," are ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," only if they are ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," does not descend any ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," other than the ones explicitly specified above. Figure 5\u201312 summarizes the information given in the previous list. In addition, the figure specifies the priority of the behavior of ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),", with upper entries taking priority over lower ones."]}),"\n",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsx)(r.strong,{children:"Type Behavior"}),"|"]}),"\n",(0,s.jsx)(r.p,{children:"| :- |"}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"number",children:(0,s.jsx)("i",{children:"number"})})," uses ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"character"})})," uses ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"cons",children:(0,s.jsx)("i",{children:"cons"})})," descends "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.em,{children:"bit vector"})," descends "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"string",children:(0,s.jsx)("i",{children:"string"})})," descends "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"pathname",children:(0,s.jsx)("i",{children:"pathname"})})," \u201cfunctionally equivalent\u201d "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n,{styled:!0,term:"structure",children:(0,s.jsx)("i",{children:"structure"})})," uses ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})})," "]}),(0,s.jsxs)("p",{children:["Other ",(0,s.jsx)(n,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"array"})})," uses ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.em,{children:"hash table"})," uses ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})})," "]}),(0,s.jsxs)("p",{children:["Other ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," uses ",(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})})]}),"|"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Figure 5\u201312. Summary and priorities of behavior of equal"})}),"\n",(0,s.jsxs)(r.p,{children:["Any two ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," that are ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})})," are also ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," may fail to terminate if ",(0,s.jsx)(r.em,{children:"x"})," or ",(0,s.jsx)(r.em,{children:"y"})," is circular."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:'\n(equal \u2019a \u2019b) \u2192 false \n(equal \u2019a \u2019a) \u2192 true \n(equal 3 3) \u2192 true \n(equal 3 3.0) \u2192 false \n(equal 3.0 3.0) \u2192 true \n(equal #c(3 -4) #c(3 -4)) \u2192 true \n(equal #c(3 -4.0) #c(3 -4)) \u2192 false \n(equal (cons \u2019a \u2019b) (cons \u2019a \u2019c)) \u2192 false \n(equal (cons \u2019a \u2019b) (cons \u2019a \u2019b)) \u2192 true \n(equal #\\A #\\A) \u2192 true \n(equal #\\A #\\a) \u2192 false \n(equal "Foo" "Foo") \u2192 true \n(equal "Foo" (copy-seq "Foo")) \u2192 true \n(equal "FOO" "foo") \u2192 false \n(equal "This-string" "This-string") \u2192 true \n(equal "This-string" "this-string") \u2192 false \n\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})}),", ",(0,s.jsx)(n,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),", ",(0,s.jsx)(n,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),", ",(0,s.jsx)(n,{styled:!0,term:"=",children:(0,s.jsx)("b",{children:"="})}),", ",(0,s.jsx)(n,{styled:!0,term:"string",children:(0,s.jsx)("b",{children:"string="})}),", ",(0,s.jsx)(r.strong,{children:"string-equal"}),", ",(0,s.jsx)(n,{styled:!0,term:"char=",children:(0,s.jsx)("b",{children:"char="})}),", ",(0,s.jsx)(n,{styled:!0,term:"char-equal",children:(0,s.jsx)("b",{children:"char-equal"})}),", ",(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"Object"})})," equality is not a concept for which there is a uniquely determined correct algorithm. The appropriateness of an equality predicate can be judged only in the context of the needs of some particular program. Although these functions take any type of argument and their names sound very generic, ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," and ",(0,s.jsx)(n,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})})," are not appropriate for every application."]}),"\n",(0,s.jsxs)(r.p,{children:["A rough rule of thumb is that two ",(0,s.jsx)(n,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," are ",(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," if and only if their printed representations are the same."]})]})}function t(e={}){const{wrapper:r}={...(0,l.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}const d={title:"equal"},c="equal",a={id:"chap-5/f-d-dictionary/equal_function",title:"equal",description:"Expanded Reference: equal",source:"@site/docs/chap-5/f-d-dictionary/equal_function.md",sourceDirName:"chap-5/f-d-dictionary",slug:"/chap-5/f-d-dictionary/equal_function",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/equal_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-5/f-d-dictionary/equal_function.md",tags:[],version:"current",frontMatter:{title:"equal"},sidebar:"tutorialSidebar",previous:{title:"eql",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/eql_function"},next:{title:"equalp",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/equalp_function"}},h={},j=[{value:"Expanded Reference: equal",id:"expanded-reference-equal",level:2}];function x(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"equal",children:"equal"}),"\n","\n","\n",(0,s.jsx)(t,{}),"\n",(0,s.jsx)(r.h2,{id:"expanded-reference-equal",children:"Expanded Reference: equal"}),"\n",(0,s.jsx)(r.admonition,{type:"tip",children:(0,s.jsx)(r.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:"(equal )\n"})})]})}function o(e={}){const{wrapper:r}={...(0,l.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>d,a:()=>t});var s=n(67294);const l={},i=s.createContext(l);function t(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);