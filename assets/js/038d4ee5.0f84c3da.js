"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[20623],{86355:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>E,contentTitle:()=>v,default:()=>A,frontMatter:()=>g,metadata:()=>w,toc:()=>R});var t=r(85893),s=r(11151);function a(e){return(0,t.jsx)(t.Fragment,{})}function i(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a()}function c(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components};return(0,t.jsxs)(n.p,{children:["Various aspects of the ",(0,t.jsx)(n.em,{children:"Lisp reader"})," can be controlled dynamically. See Section 2.1.1 (Readtables) and Section 2.1.2 (Variables that affect the Lisp Reader)."]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}function d(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"readtable case"})," of the ",(0,t.jsx)(n.em,{children:"current readtable"})," affects the ",(0,t.jsx)(n.em,{children:"Lisp reader"})," in the following ways: ",":upcase"]}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.em,{children:"readtable case"})," is ",":upcase",", unescaped constituent ",(0,t.jsx)(n.em,{children:"characters"})," are converted to ",(0,t.jsx)(n.em,{children:"uppercase"}),", as specified in Section 2.2 (Reader Algorithm)."]}),"\n",(0,t.jsx)(n.p,{children:":downcase"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.em,{children:"readtable case"})," is ",":downcase",", unescaped constituent ",(0,t.jsx)(n.em,{children:"characters"})," are converted to ",(0,t.jsx)(n.em,{children:"lowercase"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":preserve"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.em,{children:"readtable case"})," is ",":preserve",", the case of all ",(0,t.jsx)(n.em,{children:"characters"})," remains unchanged."]}),"\n",(0,t.jsx)(n.p,{children:":invert"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.em,{children:"readtable case"})," is ",":invert",", then if all of the unescaped letters in the extended token are of the same ",(0,t.jsx)(n.em,{children:"case"}),", those (unescaped) letters are converted to the opposite ",(0,t.jsx)(n.em,{children:"case"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function h(e){const n={code:"code",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'\n\n(defun test-readtable-case-reading () \n\n  (let ((\\*readtable\\* (copy-readtable nil))) \n\n    (format t "READTABLE-CASE Input Symbol-name~ \n\n~%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-~ \n\n~%") \n\n    (dolist (readtable-case \u2019(:upcase :downcase :preserve :invert)) \n\n      (setf (readtable-case \\*readtable\\*) readtable-case) \n\n      (dolist (input \u2019("ZEBRA" "Zebra" "zebra")) \n\n\t(format t "~&:~A~16T~A~24T~A" \n\n\t\t(string-upcase readtable-case) \n\n\t\tinput \n\n\t\t(symbol-name (read-from-string input))))))) \n\n\n\n\n\n\n\nThe output from (test-readtable-case-reading) should be as follows: \n\nREADTABLE-CASE Input Symbol-name \n\n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013- \n\n:UPCASE ZEBRA ZEBRA \n\n:UPCASE Zebra ZEBRA \n\n:UPCASE zebra ZEBRA \n\n:DOWNCASE ZEBRA zebra \n\n:DOWNCASE Zebra zebra \n\n:DOWNCASE zebra zebra \n\n:PRESERVE ZEBRA ZEBRA \n\n:PRESERVE Zebra Zebra \n\n:PRESERVE zebra zebra \n\n:INVERT ZEBRA zebra \n\n:INVERT Zebra Zebra \n\n:INVERT zebra ZEBRA \n\n\n'})})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function f(e){return(0,t.jsx)(t.Fragment,{})}function m(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(f,{...e})}):f()}function u(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Eof-error-p"})," in input function calls controls what happens if input is from a file (or any other input source that has a definite end) and the end of the file is reached. If ",(0,t.jsx)(n.em,{children:"eof-error-p"})," is ",(0,t.jsx)(n.em,{children:"true"})," (the default), an error of ",(0,t.jsx)(n.em,{children:"type"})," ",(0,t.jsx)(n.strong,{children:"end-of-file"})," is signaled at end of file. If it is ",(0,t.jsx)(n.em,{children:"false"}),", then no error is signaled, and instead the function returns ",(0,t.jsx)(n.em,{children:"eof-value"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Functions such as ",(0,t.jsx)(n.strong,{children:"read"})," that read the representation of an ",(0,t.jsx)(n.em,{children:"object"})," rather than a single character always signals an error, regardless of ",(0,t.jsx)(n.em,{children:"eof-error-p"}),", if the file ends in the middle of an object representation. For example, if a file does not contain enough right parentheses to balance the left parentheses in it, ",(0,t.jsx)(n.strong,{children:"read"})," signals an error. If a file ends in a ",(0,t.jsx)(n.em,{children:"symbol"})," or a ",(0,t.jsx)(n.em,{children:"number"})," immediately followed by end-of-file, ",(0,t.jsx)(n.strong,{children:"read"})," reads the ",(0,t.jsx)(n.em,{children:"symbol"})," or ",(0,t.jsx)(n.em,{children:"number"})," successfully and when called again will act according to ",(0,t.jsx)(n.em,{children:"eof-error-p"}),". Similarly, the ",(0,t.jsx)(n.em,{children:"function"})," ",(0,t.jsx)(n.strong,{children:"read-line"})," successfully reads the last line of a file even if that line is terminated by end-of-file rather than the newline character. Ignorable text, such as lines containing only ",(0,t.jsx)(n.em,{children:"whitespace"}),(0,t.jsx)("sub",{children:"2"})," or comments, are not considered to begin an ",(0,t.jsx)(n.em,{children:"object"}),"; if ",(0,t.jsx)(n.strong,{children:"read"})," begins to read an ",(0,t.jsx)(n.em,{children:"expression"})," but sees only such ignorable text, it does not consider the file to end in the middle of an ",(0,t.jsx)(n.em,{children:"object"}),". Thus an ",(0,t.jsx)(n.em,{children:"eof-error-p"})," argument controls what happens when the file ends between ",(0,t.jsx)(n.em,{children:"objects"}),"."]})]})}function x(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function j(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.em,{children:"recursive-p"})," is supplied and not ",(0,t.jsx)(n.strong,{children:"nil"}),", it specifies that this function call is not an outermost call to ",(0,t.jsx)(n.strong,{children:"read"})," but an embedded call, typically from a ",(0,t.jsx)(n.em,{children:"reader macro function"}),". It is important to distinguish such recursive calls for three reasons."]}),"\n",(0,t.jsxs)(n.p,{children:["1. An outermost call establishes the context within which the #",(0,t.jsx)(n.em,{children:"n"}),"= and #",(0,t.jsx)(n.em,{children:"n"}),"# syntax is scoped. Consider, for example, the expression"]}),"\n",(0,t.jsx)(n.p,{children:"(cons \u2019#3=(p q r) \u2019(x y . #3#))"}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.em,{children:"single-quote reader macro"})," were defined in this way:"]}),"\n",(0,t.jsx)(n.p,{children:"(set-macro-character #\\\u2019 ;incorrect"}),"\n",(0,t.jsx)(n.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,t.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,t.jsx)(n.p,{children:"(list \u2019quote (read stream))))"}),"\n",(0,t.jsxs)(n.p,{children:["then each call to the ",(0,t.jsx)(n.em,{children:"single-quote reader macro function"})," would establish independent contexts for the scope of ",(0,t.jsx)(n.strong,{children:"read"})," information, including the scope of identifications between markers like \u201c#3=\u201d and \u201c#3#\u201d. However, for this expression, the scope was clearly intended to be determined by the outer set of parentheses, so such a definition would be incorrect. The correct way to define the ",(0,t.jsx)(n.em,{children:"single-quote reader macro"})," uses ",(0,t.jsx)(n.em,{children:"recursive-p"}),":"]}),"\n",(0,t.jsx)(n.p,{children:"(set-macro-character #\\\u2019 ;correct"}),"\n",(0,t.jsx)(n.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,t.jsx)(n.p,{children:"(declare (ignore char))"}),"\n",(0,t.jsx)(n.p,{children:"(list \u2019quote (read stream t nil t))))"}),"\n",(0,t.jsxs)(n.p,{children:["2. A recursive call does not alter whether the reading process is to preserve ",(0,t.jsx)(n.em,{children:"whitespace"}),(0,t.jsx)("sub",{children:"2"})," or not (as determined by whether the outermost call was to ",(0,t.jsx)(n.strong,{children:"read"})," or ",(0,t.jsx)(n.strong,{children:"read-preserving-whitespace"}),"). Suppose again that ",(0,t.jsx)(n.em,{children:"single-quote"})," were to be defined as shown above in the incorrect definition. Then a call to ",(0,t.jsx)(n.strong,{children:"read-preserving-whitespace"})," that read the expression \u2019foo",(0,t.jsx)(n.em,{children:"hSpacei"})," would fail to preserve the space character following the symbol foo because the ",(0,t.jsx)(n.em,{children:"single-quote reader macro function"})," calls ",(0,t.jsx)(n.strong,{children:"read"}),", not ",(0,t.jsx)(n.strong,{children:"read-preserving-whitespace"}),", to read the following expression (in this case foo). The correct definition, which passes the value ",(0,t.jsx)(n.em,{children:"true"})," for ",(0,t.jsx)(n.em,{children:"recursive-p"})," to ",(0,t.jsx)(n.strong,{children:"read"}),", allows the outermost call to determine whether ",(0,t.jsx)(n.em,{children:"whitespace"}),(0,t.jsx)("sub",{children:"2"})," is preserved."]}),"\n",(0,t.jsxs)(n.p,{children:["3. When end-of-file is encountered and the ",(0,t.jsx)(n.em,{children:"eof-error-p"})," argument is not ",(0,t.jsx)(n.strong,{children:"nil"}),", the kind of error that is signaled may depend on the value of ",(0,t.jsx)(n.em,{children:"recursive-p"}),". If ",(0,t.jsx)(n.em,{children:"recursive-p"})," is ",(0,t.jsx)(n.em,{children:"true"}),", then the end-of-file is deemed to have occurred within the middle of a printed representation; if ",(0,t.jsx)(n.em,{children:"recursive-p"})," is ",(0,t.jsx)(n.em,{children:"false"}),", then the end-of-file may be deemed to have occurred between ",(0,t.jsx)(n.em,{children:"objects"})," rather than within the middle of one."]})]})}function b(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}const g={title:"23.1 Reader Concepts"},v="23.1 Reader Concepts",w={id:"chap-23/cd-b-reader-concepts",title:"23.1 Reader Concepts",description:"23.1.1 Dynamic Control of the Lisp Reader",source:"@site/docs/chap-23/cd-b-reader-concepts.md",sourceDirName:"chap-23",slug:"/chap-23/cd-b-reader-concepts",permalink:"/cl-language-reference/docs/chap-23/cd-b-reader-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-23/cd-b-reader-concepts.md",tags:[],version:"current",frontMatter:{title:"23.1 Reader Concepts"},sidebar:"tutorialSidebar",previous:{title:"23. Reader",permalink:"/cl-language-reference/docs/category/23-reader"},next:{title:"23.2 Reader Dictionary",permalink:"/cl-language-reference/docs/category/232-reader-dictionary"}},E={},R=[{value:"23.1.1 Dynamic Control of the Lisp Reader",id:"2311-dynamic-control-of-the-lisp-reader",level:2},{value:"23.1.2 Effect of Readtable Case on the Lisp Reader",id:"2312-effect-of-readtable-case-on-the-lisp-reader",level:2},{value:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader",id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",level:3},{value:"23.1.3 Argument Conventions of Some Reader Functions",id:"2313-argument-conventions-of-some-reader-functions",level:2},{value:"23.1.3.1 The EOF",id:"23131-the-eof",level:3},{value:"23.1.3.2 The RECURSIVE",id:"23132-the-recursive",level:3}];function y(e){const n={h1:"h1",h2:"h2",h3:"h3",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"231-reader-concepts",children:"23.1 Reader Concepts"}),"\n","\n",(0,t.jsx)(i,{}),"\n",(0,t.jsx)(n.h2,{id:"2311-dynamic-control-of-the-lisp-reader",children:"23.1.1 Dynamic Control of the Lisp Reader"}),"\n","\n",(0,t.jsx)(o,{}),"\n",(0,t.jsx)(n.h2,{id:"2312-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2 Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,t.jsx)(l,{}),"\n",(0,t.jsx)(n.h3,{id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,t.jsx)(p,{}),"\n",(0,t.jsx)(n.h2,{id:"2313-argument-conventions-of-some-reader-functions",children:"23.1.3 Argument Conventions of Some Reader Functions"}),"\n","\n",(0,t.jsx)(m,{}),"\n",(0,t.jsx)(n.h3,{id:"23131-the-eof",children:"23.1.3.1 The EOF"}),"\n","\n",(0,t.jsx)(x,{}),"\n",(0,t.jsx)(n.h3,{id:"23132-the-recursive",children:"23.1.3.2 The RECURSIVE"}),"\n","\n","\n",(0,t.jsx)(b,{})]})}function A(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(y,{...e})}):y(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>c,a:()=>i});var t=r(67294);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);