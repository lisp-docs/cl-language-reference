"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[69635],{10865:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>r});var a=i(85893),n=i(11151);const o={},s="Reinitialization of Class Metaobjects",c={id:"meta-object-protocol/reinitialization-of-class-metaobjects",title:"Reinitialization of Class Metaobjects",description:"Reinitialization of Class Metaobjects",source:"@site/docs/meta-object-protocol/reinitialization-of-class-metaobjects.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/reinitialization-of-class-metaobjects",permalink:"/cl-language-reference/meta-object-protocol/reinitialization-of-class-metaobjects",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/reinitialization-of-class-metaobjects.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Readers for Slot Definition Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/readers-for-slot-definition-metaobjects"},next:{title:"remove-dependent-funcallable-standard-class",permalink:"/cl-language-reference/meta-object-protocol/remove-dependent-funcallable-standard-class"}},l={},r=[{value:"Reinitialization of Class Metaobjects",id:"reinitialization-of-class-metaobjects-1",level:4}];function d(e){const t={a:"a",h1:"h1",h4:"h4",p:"p",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"reinitialization-of-class-metaobjects",children:"Reinitialization of Class Metaobjects"}),"\n",(0,a.jsx)(t.h4,{id:"reinitialization-of-class-metaobjects-1",children:"Reinitialization of Class Metaobjects"}),"\n",(0,a.jsxs)(t.p,{children:["Some class metaobject classes allow their instances to be reinitialized. This is done by calling ",(0,a.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". The initialization arguments have the same interpretation as in class initialization."]}),"\n",(0,a.jsxs)(t.p,{children:["If the class metaobject was finalized before the call to ",(0,a.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," will be called again once all the initialization arguments have been processed and associated with the class metaobject. In addition, once finalization is complete, any dependents of the class metaobject will be updated by calling ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/update-dependent",children:"update-dependent"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>c,a:()=>s});var a=i(67294);const n={},o=a.createContext(n);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);