"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[20623],{86355:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>R,contentTitle:()=>v,default:()=>S,frontMatter:()=>w,metadata:()=>E,toc:()=>A});var t=n(85893),s=n(11151);function i(e){return(0,t.jsx)(t.Fragment,{})}function c(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(i,{...e})}):i()}function a(e){const r={em:"em",p:"p",...(0,s.a)(),...e.components};return(0,t.jsxs)(r.p,{children:["Various aspects of the ",(0,t.jsx)(r.em,{children:"Lisp reader"})," can be controlled dynamically. See Section 2.1.1 (Readtables) and Section 2.1.2 (Variables that affect the Lisp Reader)."]})}function d(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function l(e){const r={em:"em",p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(n,{styled:!0,term:"readtable case",children:(0,t.jsx)("i",{children:"readtable case"})})," of the ",(0,t.jsx)(n,{styled:!0,term:"current readtable",children:(0,t.jsx)("i",{children:"current readtable"})})," affects the ",(0,t.jsx)(r.em,{children:"Lisp reader"})," in the following ways: ",":upcase"]}),"\n",(0,t.jsxs)(r.p,{children:["When the ",(0,t.jsx)(n,{styled:!0,term:"readtable case",children:(0,t.jsx)("i",{children:"readtable case"})})," is ",":upcase",", unescaped constituent ",(0,t.jsx)(n,{styled:!0,term:"character",children:(0,t.jsx)("i",{children:"characters"})})," are converted to ",(0,t.jsx)(n,{styled:!0,term:"uppercase",children:(0,t.jsx)("i",{children:"uppercase"})}),", as specified in Section 2.2 (Reader Algorithm)."]}),"\n",(0,t.jsx)(r.p,{children:":downcase"}),"\n",(0,t.jsxs)(r.p,{children:["When the ",(0,t.jsx)(n,{styled:!0,term:"readtable case",children:(0,t.jsx)("i",{children:"readtable case"})})," is ",":downcase",", unescaped constituent ",(0,t.jsx)(n,{styled:!0,term:"character",children:(0,t.jsx)("i",{children:"characters"})})," are converted to ",(0,t.jsx)(n,{styled:!0,term:"lowercase",children:(0,t.jsx)("i",{children:"lowercase"})}),"."]}),"\n",(0,t.jsx)(r.p,{children:":preserve"}),"\n",(0,t.jsxs)(r.p,{children:["When the ",(0,t.jsx)(n,{styled:!0,term:"readtable case",children:(0,t.jsx)("i",{children:"readtable case"})})," is ",":preserve",", the case of all ",(0,t.jsx)(n,{styled:!0,term:"character",children:(0,t.jsx)("i",{children:"characters"})})," remains unchanged."]}),"\n",(0,t.jsx)(r.p,{children:":invert"}),"\n",(0,t.jsxs)(r.p,{children:["When the ",(0,t.jsx)(n,{styled:!0,term:"readtable case",children:(0,t.jsx)("i",{children:"readtable case"})})," is ",":invert",", then if all of the unescaped letters in the extended token are of the same ",(0,t.jsx)(n,{styled:!0,term:"case",children:(0,t.jsx)("i",{children:"case"})}),", those (unescaped) letters are converted to the opposite ",(0,t.jsx)(n,{styled:!0,term:"case",children:(0,t.jsx)("i",{children:"case"})}),"."]})]})}function o(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}function h(e){const r={code:"code",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-lisp",children:'(defun test-readtable-case-reading () \n  (let ((\\*readtable\\* (copy-readtable nil))) \n    (format t "READTABLE-CASE Input Symbol-name~ \n~%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-~ \n~%") \n    (dolist (readtable-case \u2019(:upcase :downcase :preserve :invert)) \n      (setf (readtable-case \\*readtable\\*) readtable-case) \n      (dolist (input \u2019("ZEBRA" "Zebra" "zebra")) \n\t(format t "~&:~A~16T~A~24T~A" \n\t\t(string-upcase readtable-case) \n\t\tinput \n\t\t(symbol-name (read-from-string input))))))) \n\nThe output from (test-readtable-case-reading) should be as follows: \nREADTABLE-CASE Input Symbol-name \n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013- \n:UPCASE ZEBRA ZEBRA \n:UPCASE Zebra ZEBRA \n:UPCASE zebra ZEBRA \n:DOWNCASE ZEBRA zebra \n:DOWNCASE Zebra zebra \n:DOWNCASE zebra zebra \n:PRESERVE ZEBRA ZEBRA \n:PRESERVE Zebra Zebra \n:PRESERVE zebra zebra \n:INVERT ZEBRA zebra \n:INVERT Zebra Zebra \n:INVERT zebra ZEBRA \n'})})}function p(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function x(e){return(0,t.jsx)(t.Fragment,{})}function m(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(x,{...e})}):x()}function j(e){const r={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:i}=r;return n||u("DictionaryLink",!0),i||u("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.em,{children:"Eof-error-p"})," in input function calls controls what happens if input is from a file (or any other input source that has a definite end) and the end of the file is reached. If ",(0,t.jsx)(r.em,{children:"eof-error-p"})," is ",(0,t.jsx)(i,{styled:!0,term:"true",children:(0,t.jsx)("i",{children:"true"})})," (the default), an error of ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})})," ",(0,t.jsx)(n,{styled:!0,term:"end-of-file",children:(0,t.jsx)("b",{children:"end-of-file"})})," is signaled at end of file. If it is ",(0,t.jsx)(i,{styled:!0,term:"false",children:(0,t.jsx)("i",{children:"false"})}),", then no error is signaled, and instead the function returns ",(0,t.jsx)(r.em,{children:"eof-value"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["Functions such as ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," that read the representation of an ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"object"})})," rather than a single character always signals an error, regardless of ",(0,t.jsx)(r.em,{children:"eof-error-p"}),", if the file ends in the middle of an object representation. For example, if a file does not contain enough right parentheses to balance the left parentheses in it, ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," signals an error. If a file ends in a ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," or a ",(0,t.jsx)(i,{styled:!0,term:"number",children:(0,t.jsx)("i",{children:"number"})})," immediately followed by end-of-file, ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," reads the ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," or ",(0,t.jsx)(i,{styled:!0,term:"number",children:(0,t.jsx)("i",{children:"number"})})," successfully and when called again will act according to ",(0,t.jsx)(r.em,{children:"eof-error-p"}),". Similarly, the ",(0,t.jsx)(i,{styled:!0,term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(n,{styled:!0,term:"read-line",children:(0,t.jsx)("b",{children:"read-line"})})," successfully reads the last line of a file even if that line is terminated by end-of-file rather than the newline character. Ignorable text, such as lines containing only ",(0,t.jsx)(i,{styled:!0,term:"whitespace",children:(0,t.jsx)("i",{children:"whitespace"})}),(0,t.jsx)("sub",{children:"2"})," or comments, are not considered to begin an ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"object"})}),"; if ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," begins to read an ",(0,t.jsx)(i,{styled:!0,term:"expression",children:(0,t.jsx)("i",{children:"expression"})})," but sees only such ignorable text, it does not consider the file to end in the middle of an ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"object"})}),". Thus an ",(0,t.jsx)(r.em,{children:"eof-error-p"})," argument controls what happens when the file ends between ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"objects"})}),"."]})]})}function f(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}function u(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function b(e){const r={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:i}=r;return n||g("DictionaryLink",!0),i||g("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["If ",(0,t.jsx)(r.em,{children:"recursive-p"})," is supplied and not ",(0,t.jsx)(n,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),", it specifies that this function call is not an outermost call to ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," but an embedded call, typically from a ",(0,t.jsx)(i,{styled:!0,term:"reader macro function",children:(0,t.jsx)("i",{children:"reader macro function"})}),". It is important to distinguish such recursive calls for three reasons."]}),"\n",(0,t.jsxs)(r.p,{children:["1. An outermost call establishes the context within which the #",(0,t.jsx)(r.em,{children:"n"}),"= and #",(0,t.jsx)(r.em,{children:"n"}),"# syntax is scoped. Consider, for example, the expression"]}),"\n",(0,t.jsx)(r.p,{children:"(cons \u2019#3=(p q r) \u2019(x y . #3#))"}),"\n",(0,t.jsxs)(r.p,{children:["If the ",(0,t.jsx)(r.em,{children:"single-quote reader macro"})," were defined in this way:"]}),"\n",(0,t.jsx)(r.p,{children:"(set-macro-character #\\\u2019 ;incorrect"}),"\n",(0,t.jsx)(r.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,t.jsx)(r.p,{children:"(declare (ignore char))"}),"\n",(0,t.jsx)(r.p,{children:"(list \u2019quote (read stream))))"}),"\n",(0,t.jsxs)(r.p,{children:["then each call to the ",(0,t.jsx)(r.em,{children:"single-quote reader macro function"})," would establish independent contexts for the scope of ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," information, including the scope of identifications between markers like \u201c#3=\u201d and \u201c#3#\u201d. However, for this expression, the scope was clearly intended to be determined by the outer set of parentheses, so such a definition would be incorrect. The correct way to define the ",(0,t.jsx)(r.em,{children:"single-quote reader macro"})," uses ",(0,t.jsx)(r.em,{children:"recursive-p"}),":"]}),"\n",(0,t.jsx)(r.p,{children:"(set-macro-character #\\\u2019 ;correct"}),"\n",(0,t.jsx)(r.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,t.jsx)(r.p,{children:"(declare (ignore char))"}),"\n",(0,t.jsx)(r.p,{children:"(list \u2019quote (read stream t nil t))))"}),"\n",(0,t.jsxs)(r.p,{children:["2. A recursive call does not alter whether the reading process is to preserve ",(0,t.jsx)(i,{styled:!0,term:"whitespace",children:(0,t.jsx)("i",{children:"whitespace"})}),(0,t.jsx)("sub",{children:"2"})," or not (as determined by whether the outermost call was to ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})})," or ",(0,t.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,t.jsx)("b",{children:"read-preserving-whitespace"})}),"). Suppose again that ",(0,t.jsx)(i,{styled:!0,term:"single-quote",children:(0,t.jsx)("i",{children:"single-quote"})})," were to be defined as shown above in the incorrect definition. Then a call to ",(0,t.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,t.jsx)("b",{children:"read-preserving-whitespace"})})," that read the expression \u2019foo*\u27e8Space\u27e9* would fail to preserve the space character following the symbol foo because the ",(0,t.jsx)(r.em,{children:"single-quote reader macro function"})," calls ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})}),", not ",(0,t.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,t.jsx)("b",{children:"read-preserving-whitespace"})}),", to read the following expression (in this case foo). The correct definition, which passes the value ",(0,t.jsx)(i,{styled:!0,term:"true",children:(0,t.jsx)("i",{children:"true"})})," for ",(0,t.jsx)(r.em,{children:"recursive-p"})," to ",(0,t.jsx)(n,{styled:!0,term:"read",children:(0,t.jsx)("b",{children:"read"})}),", allows the outermost call to determine whether ",(0,t.jsx)(i,{styled:!0,term:"whitespace",children:(0,t.jsx)("i",{children:"whitespace"})}),(0,t.jsx)("sub",{children:"2"})," is preserved."]}),"\n",(0,t.jsxs)(r.p,{children:["3. When end-of-file is encountered and the ",(0,t.jsx)(r.em,{children:"eof-error-p"})," argument is not ",(0,t.jsx)(n,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),", the kind of error that is signaled may depend on the value of ",(0,t.jsx)(r.em,{children:"recursive-p"}),". If ",(0,t.jsx)(r.em,{children:"recursive-p"})," is ",(0,t.jsx)(i,{styled:!0,term:"true",children:(0,t.jsx)("i",{children:"true"})}),", then the end-of-file is deemed to have occurred within the middle of a printed representation; if ",(0,t.jsx)(r.em,{children:"recursive-p"})," is ",(0,t.jsx)(i,{styled:!0,term:"false",children:(0,t.jsx)("i",{children:"false"})}),", then the end-of-file may be deemed to have occurred between ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"objects"})})," rather than within the middle of one."]})]})}function y(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(b,{...e})}):b(e)}function g(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const w={title:"23.1 Reader Concepts"},v="23.1 Reader Concepts",E={id:"chap-23/cd-b-reader-concepts",title:"23.1 Reader Concepts",description:"23.1.1 Dynamic Control of the Lisp Reader",source:"@site/docs/chap-23/cd-b-reader-concepts.md",sourceDirName:"chap-23",slug:"/chap-23/cd-b-reader-concepts",permalink:"/cl-language-reference/chap-23/cd-b-reader-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-23/cd-b-reader-concepts.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"23.1 Reader Concepts"},sidebar:"tutorialSidebar",previous:{title:"23. Reader",permalink:"/cl-language-reference/category/23-reader"},next:{title:"23.2 Reader Dictionary",permalink:"/cl-language-reference/category/232-reader-dictionary"}},R={},A=[{value:"23.1.1 Dynamic Control of the Lisp Reader",id:"2311-dynamic-control-of-the-lisp-reader",level:2},{value:"23.1.2 Effect of Readtable Case on the Lisp Reader",id:"2312-effect-of-readtable-case-on-the-lisp-reader",level:2},{value:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader",id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",level:3},{value:"23.1.3 Argument Conventions of Some Reader Functions",id:"2313-argument-conventions-of-some-reader-functions",level:2},{value:"23.1.3.1 The EOF",id:"23131-the-eof",level:3},{value:"23.1.3.2 The RECURSIVE",id:"23132-the-recursive",level:3}];function C(e){const r={h1:"h1",h2:"h2",h3:"h3",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"231-reader-concepts",children:"23.1 Reader Concepts"}),"\n","\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(r.h2,{id:"2311-dynamic-control-of-the-lisp-reader",children:"23.1.1 Dynamic Control of the Lisp Reader"}),"\n","\n",(0,t.jsx)(d,{}),"\n",(0,t.jsx)(r.h2,{id:"2312-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2 Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,t.jsx)(o,{}),"\n",(0,t.jsx)(r.h3,{id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,t.jsx)(p,{}),"\n",(0,t.jsx)(r.h2,{id:"2313-argument-conventions-of-some-reader-functions",children:"23.1.3 Argument Conventions of Some Reader Functions"}),"\n","\n",(0,t.jsx)(m,{}),"\n",(0,t.jsx)(r.h3,{id:"23131-the-eof",children:"23.1.3.1 The EOF"}),"\n","\n",(0,t.jsx)(f,{}),"\n",(0,t.jsx)(r.h3,{id:"23132-the-recursive",children:"23.1.3.2 The RECURSIVE"}),"\n","\n","\n",(0,t.jsx)(y,{})]})}function S(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(C,{...e})}):C(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>a,a:()=>c});var t=n(67294);const s={},i=t.createContext(s);function c(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);