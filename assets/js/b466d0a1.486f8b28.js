"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[44344],{33004:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>Y,contentTitle:()=>V,default:()=>ne,frontMatter:()=>Q,metadata:()=>X,toc:()=>$});var s=i(85893),r=i(11151);function t(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Common Lisp constructs are described not only in terms of their behavior in situations during which they are intended to be used (see the \u201cDescription\u201d part of each ",(0,s.jsx)(n.em,{children:"operator"})," specification), but in all other situations (see the \u201cExceptional Situations\u201d part of each ",(0,s.jsx)(n.em,{children:"operator"})," specification)."]}),"\n",(0,s.jsxs)(n.p,{children:["A situation is the evaluation of an expression in a specific context. A ",(0,s.jsx)(n.em,{children:"condition"})," is an ",(0,s.jsx)(n.em,{children:"object"})," that represents a specific situation that has been detected. ",(0,s.jsx)(n.em,{children:"Conditions"})," are ",(0,s.jsx)(n.em,{children:"generalized instances"})," of the ",(0,s.jsx)(n.em,{children:"class"})," ",(0,s.jsx)(n.strong,{children:"condition"}),". A hierarchy of ",(0,s.jsx)(n.em,{children:"condition"})," classes is defined in Common Lisp. A ",(0,s.jsx)(n.em,{children:"condition"})," has ",(0,s.jsx)(n.em,{children:"slots"})," that contain data relevant to the situation that the ",(0,s.jsx)(n.em,{children:"condition"})," represents."]}),"\n",(0,s.jsxs)(n.p,{children:["An error is a situation in which normal program execution cannot continue correctly without some form of intervention (either interactively by the user or under program control). Not all errors are detected. When an error goes undetected, the effects can be ",(0,s.jsx)(n.em,{children:"implementation-dependent"}),", ",(0,s.jsx)(n.em,{children:"implementation-defined"}),", unspecified, or undefined. See Section 1.4 (Definitions). All detected errors can be represented by ",(0,s.jsx)(n.em,{children:"conditions"}),", but not all ",(0,s.jsx)(n.em,{children:"conditions"})," represent errors."]}),"\n",(0,s.jsxs)(n.p,{children:["Signaling is the process by which a ",(0,s.jsx)(n.em,{children:"condition"})," can alter the flow of control in a program by raising the ",(0,s.jsx)(n.em,{children:"condition"})," which can then be ",(0,s.jsx)(n.em,{children:"handled"}),". The functions ",(0,s.jsx)(n.strong,{children:"error"}),", ",(0,s.jsx)(n.strong,{children:"cerror"}),", ",(0,s.jsx)(n.strong,{children:"signal"}),", and ",(0,s.jsx)(n.strong,{children:"warn"})," are used to signal ",(0,s.jsx)(n.em,{children:"conditions"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The process of signaling involves the selection and invocation of a ",(0,s.jsx)(n.em,{children:"handler"})," from a set of ",(0,s.jsx)(n.em,{children:"active handlers"}),". A ",(0,s.jsx)(n.em,{children:"handler"})," is a ",(0,s.jsx)(n.em,{children:"function"})," of one argument (the ",(0,s.jsx)(n.em,{children:"condition"}),") that is invoked to handle a ",(0,s.jsx)(n.em,{children:"condition"}),". Each ",(0,s.jsx)(n.em,{children:"handler"})," is associated with a ",(0,s.jsx)(n.em,{children:"condition type"}),", and a ",(0,s.jsx)(n.em,{children:"handler"})," will be invoked only on a ",(0,s.jsx)(n.em,{children:"condition"})," of the ",(0,s.jsx)(n.em,{children:"handler"})," \u2019s associated ",(0,s.jsx)(n.em,{children:"type"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Active handlers"})," are ",(0,s.jsx)(n.em,{children:"established"})," dynamically (see ",(0,s.jsx)(n.strong,{children:"handler-bind"})," or ",(0,s.jsx)(n.strong,{children:"handler-case"}),"). ",(0,s.jsx)(n.em,{children:"Handlers"})," are invoked in a ",(0,s.jsx)(n.em,{children:"dynamic environment"})," equivalent to that of the signaler, except that the set of ",(0,s.jsx)(n.em,{children:"active handlers"})," is bound in such a way as to include only those that were ",(0,s.jsx)(n.em,{children:"active"})," at the time the ",(0,s.jsx)(n.em,{children:"handler"})," being invoked was ",(0,s.jsx)(n.em,{children:"established"}),". Signaling a ",(0,s.jsx)(n.em,{children:"condition"})," has no side-effect on the ",(0,s.jsx)(n.em,{children:"condition"}),", and there is no dynamic state contained in a ",(0,s.jsx)(n.em,{children:"condition"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"handler"})," is invoked, it can address the ",(0,s.jsx)(n.em,{children:"situation"})," in one of three ways:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decline"})}),"\n",(0,s.jsxs)(n.p,{children:["It can decline to ",(0,s.jsx)(n.em,{children:"handle"})," the ",(0,s.jsx)(n.em,{children:"condition"}),". It does this by simply returning rather than transferring control. When this happens, any values returned by the handler are ignored and the next most recently established handler is invoked. If there is no such handler and the signaling function is ",(0,s.jsx)(n.strong,{children:"error"})," or ",(0,s.jsx)(n.strong,{children:"cerror"}),", the debugger is entered in the ",(0,s.jsx)(n.em,{children:"dynamic environment"})," of the signaler. If there is no such handler and the signaling function is either ",(0,s.jsx)(n.strong,{children:"signal"})," or ",(0,s.jsx)(n.strong,{children:"warn"}),", the signaling function simply returns ",(0,s.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Handle"})}),"\n",(0,s.jsxs)(n.p,{children:["It can ",(0,s.jsx)(n.em,{children:"handle"})," the ",(0,s.jsx)(n.em,{children:"condition"})," by performing a non-local transfer of control. This can be done either primitively by using ",(0,s.jsx)(n.strong,{children:"go"}),", ",(0,s.jsx)(n.strong,{children:"return"}),", ",(0,s.jsx)(n.strong,{children:"throw"})," or more abstractly by using a function such as ",(0,s.jsx)(n.strong,{children:"abort"})," or ",(0,s.jsx)(n.strong,{children:"invoke-restart"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Defer"})}),"\n",(0,s.jsxs)(n.p,{children:["It can put off a decision about whether to ",(0,s.jsx)(n.em,{children:"handle"})," or ",(0,s.jsx)(n.em,{children:"decline"}),", by any of a number of actions, but most commonly by signaling another condition, resignaling the same condition, or forcing entry into the debugger."]})]})}function o(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}function c(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Figure 9\u20131 lists the ",(0,s.jsx)(n.em,{children:"standardized condition types"}),". Additional ",(0,s.jsx)(n.em,{children:"condition types"})," can be defined by using ",(0,s.jsx)(n.strong,{children:"define-condition"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"arithmetic-error floating-point-overflow simple-type-error cell-error floating-point-underflow simple-warning condition package-error storage-condition control-error parse-error stream-error division-by-zero print-not-readable style-warning end-of-file program-error type-error error reader-error unbound-slot file-error serious-condition unbound-variable floating-point-inexact simple-condition undefined-function floating-point-invalid-operation simple-error warning"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20131. Standardized Condition Types"})}),"\n",(0,s.jsxs)(n.p,{children:["All ",(0,s.jsx)(n.em,{children:"condition"})," types are ",(0,s.jsx)(n.em,{children:"subtypes"})," of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"condition"}),". That is,"]}),"\n",(0,s.jsxs)(n.p,{children:["(typep ",(0,s.jsx)(n.em,{children:"c"})," \u2019condition) ",(0,s.jsx)(n.em,{children:"\u2192 true"})]}),"\n",(0,s.jsxs)(n.p,{children:["if and only if ",(0,s.jsx)(n.em,{children:"c"})," is a ",(0,s.jsx)(n.em,{children:"condition"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Implementations"})," must define all specified ",(0,s.jsx)(n.em,{children:"subtype"})," relationships. Except where noted, all ",(0,s.jsx)(n.em,{children:"subtype"})," relationships indicated in this document are not mutually exclusive. A ",(0,s.jsx)(n.em,{children:"condition"})," inherits the structure of its ",(0,s.jsx)(n.em,{children:"supertypes"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The metaclass of the ",(0,s.jsx)(n.em,{children:"class"})," ",(0,s.jsx)(n.strong,{children:"condition"})," is not specified. ",(0,s.jsx)(n.em,{children:"Names"})," of ",(0,s.jsx)(n.em,{children:"condition types"})," may be used to specify ",(0,s.jsx)(n.em,{children:"supertype"})," relationships in ",(0,s.jsx)(n.strong,{children:"define-condition"}),", but the consequences are not specified if an attempt is made to use a ",(0,s.jsx)(n.em,{children:"condition type"})," as a ",(0,s.jsx)(n.em,{children:"superclass"})," in a ",(0,s.jsx)(n.strong,{children:"defclass"})," ",(0,s.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 9\u20132 shows ",(0,s.jsx)(n.em,{children:"operators"})," that define ",(0,s.jsx)(n.em,{children:"condition types"})," and creating ",(0,s.jsx)(n.em,{children:"conditions"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"define-condition make-condition"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20132. Operators that define and create conditions."})}),"\n",(0,s.jsxs)(n.p,{children:["Figure 9\u20133 shows ",(0,s.jsx)(n.em,{children:"operators"})," that ",(0,s.jsx)(n.em,{children:"read"})," the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.em,{children:"condition slots"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"arithmetic-error-operands simple-condition-format-arguments arithmetic-error-operation simple-condition-format-control cell-error-name stream-error-stream"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"file-error-pathname type-error-datum"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"package-error-package type-error-expected-type"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(n.strong,{children:"print-not-readable-object unbound-slot-instance"})}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20133. Operators that read condition slots."})})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function a(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"serious condition"})," is a ",(0,s.jsx)(n.em,{children:"condition"})," serious enough to require interactive intervention if not handled. ",(0,s.jsx)(n.em,{children:"Serious conditions"})," are typically signaled with ",(0,s.jsx)(n.strong,{children:"error"})," or ",(0,s.jsx)(n.strong,{children:"cerror"}),"; non-serious ",(0,s.jsx)(n.em,{children:"conditions"})," are typically signaled with ",(0,s.jsx)(n.strong,{children:"signal"})," or ",(0,s.jsx)(n.strong,{children:"warn"}),"."]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}function h(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["The function ",(0,s.jsx)(n.strong,{children:"make-condition"})," can be used to construct a ",(0,s.jsx)(n.em,{children:"condition object"})," explicitly. Functions such as ",(0,s.jsx)(n.strong,{children:"error"}),", ",(0,s.jsx)(n.strong,{children:"cerror"}),", ",(0,s.jsx)(n.strong,{children:"signal"}),", and ",(0,s.jsx)(n.strong,{children:"warn"})," operate on ",(0,s.jsx)(n.em,{children:"conditions"})," and might create ",(0,s.jsx)(n.em,{children:"condition objects"})," implicitly. Macros such as ",(0,s.jsx)(n.strong,{children:"ccase"}),", ",(0,s.jsx)(n.strong,{children:"ctypecase"}),", ",(0,s.jsx)(n.strong,{children:"ecase"}),", ",(0,s.jsx)(n.strong,{children:"etypecase"}),", ",(0,s.jsx)(n.strong,{children:"check-type"}),", and ",(0,s.jsx)(n.strong,{children:"assert"})," might also implicitly create (and ",(0,s.jsx)(n.em,{children:"signal"}),") ",(0,s.jsx)(n.em,{children:"conditions"}),"."]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}function x(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A number of the functions in the condition system take arguments which are identified as ",(0,s.jsx)(n.em,{children:"condition designators"}),". By convention, those arguments are notated as"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"datum"})," &rest ",(0,s.jsx)(n.em,{children:"arguments"})]}),"\n",(0,s.jsxs)(n.p,{children:["Taken together, the ",(0,s.jsx)(n.em,{children:"datum"})," and the ",(0,s.jsx)(n.em,{children:"arguments"})," are \u201c",(0,s.jsx)(n.em,{children:"designators"})," for a ",(0,s.jsx)(n.em,{children:"condition"})," of default type ",(0,s.jsx)(n.em,{children:"default-type"}),".\u201d How the denoted ",(0,s.jsx)(n.em,{children:"condition"})," is computed depends on the type of the ",(0,s.jsx)(n.em,{children:"datum"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If the ",(0,s.jsx)(n.em,{children:"datum"})," is a ",(0,s.jsx)(n.em,{children:"symbol"})," naming a ",(0,s.jsx)(n.em,{children:"condition type . . ."})]}),"\n",(0,s.jsxs)(n.p,{children:["The denoted ",(0,s.jsx)(n.em,{children:"condition"})," is the result of"]}),"\n",(0,s.jsxs)(n.p,{children:["(apply #\u2019make-condition ",(0,s.jsx)(n.em,{children:"datum arguments"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If the ",(0,s.jsx)(n.em,{children:"datum"})," is a ",(0,s.jsx)(n.em,{children:"format control . . ."})]}),"\n",(0,s.jsxs)(n.p,{children:["The denoted ",(0,s.jsx)(n.em,{children:"condition"})," is the result of"]}),"\n",(0,s.jsxs)(n.p,{children:["(make-condition ",(0,s.jsx)(n.em,{children:"defaulted-type"})]}),"\n",(0,s.jsxs)(n.p,{children:[":format-control"," ",(0,s.jsx)(n.em,{children:"datum"})]}),"\n",(0,s.jsxs)(n.p,{children:[":format-arguments"," ",(0,s.jsx)(n.em,{children:"arguments"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["where the ",(0,s.jsx)(n.em,{children:"defaulted-type"})," is a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"default-type"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," If the ",(0,s.jsx)(n.em,{children:"datum"})," is a ",(0,s.jsx)(n.em,{children:"condition . . ."})]}),"\n",(0,s.jsxs)(n.p,{children:["The denoted ",(0,s.jsx)(n.em,{children:"condition"})," is the ",(0,s.jsx)(n.em,{children:"datum"})," itself. In this case, unless otherwise specified by the description of the ",(0,s.jsx)(n.em,{children:"operator"})," in question, the ",(0,s.jsx)(n.em,{children:"arguments"})," must be ",(0,s.jsx)(n.em,{children:"null"}),"; that is, the consequences are undefined if any ",(0,s.jsx)(n.em,{children:"arguments"})," were supplied."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.em,{children:"default-type"})," gets used only in the case where the ",(0,s.jsx)(n.em,{children:"datum string"})," is supplied. In the other situations, the resulting condition is not necessarily of ",(0,s.jsx)(n.em,{children:"type default-type"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Here are some illustrations of how different ",(0,s.jsx)(n.em,{children:"condition designators"})," can denote equivalent ",(0,s.jsx)(n.em,{children:"condition objects"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["(let ((c (make-condition \u2019arithmetic-error ",":operator"," \u2019/ ",":operands"," \u2019(7 0))))"]}),"\n",(0,s.jsx)(n.p,{children:"(error c))"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2261"})," (error \u2019arithmetic-error ",":operator"," \u2019/ ",":operands"," \u2019(7 0))"]}),"\n",(0,s.jsx)(n.p,{children:'(error "Bad luck.")'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2261"})," (error \u2019simple-error ",":format-control",' "Bad luck." ',":format-arguments"," \u2019())"]})]})}function j(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}function p(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If the ",":report"," argument to ",(0,s.jsx)(n.strong,{children:"define-condition"})," is used, a print function is defined that is called whenever the defined ",(0,s.jsx)(n.em,{children:"condition"})," is printed while the ",(0,s.jsx)(n.em,{children:"value"})," of ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," is ",(0,s.jsx)(n.em,{children:"false"}),". This function is called the ",(0,s.jsx)(n.em,{children:"condition reporter"}),"; the text which it outputs is called a ",(0,s.jsx)(n.em,{children:"report message"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.em,{children:"condition"})," is printed and ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," is ",(0,s.jsx)(n.em,{children:"false"}),", the ",(0,s.jsx)(n.em,{children:"condition reporter"})," for the ",(0,s.jsx)(n.em,{children:"condition"})," is invoked. ",(0,s.jsx)(n.em,{children:"Conditions"})," are printed automatically by functions such as ",(0,s.jsx)(n.strong,{children:"invoke-debugger"}),", ",(0,s.jsx)(n.strong,{children:"break"}),", and ",(0,s.jsx)(n.strong,{children:"warn"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.strong,{children:"*print-escape*"})," is ",(0,s.jsx)(n.em,{children:"true"}),", the ",(0,s.jsx)(n.em,{children:"object"})," should print in an abbreviated fashion according to the style of the implementation (",(0,s.jsx)(n.em,{children:"e.g."}),", by ",(0,s.jsx)(n.strong,{children:"print-unreadable-object"}),"). It is not required that a ",(0,s.jsx)(n.em,{children:"condition"})," can be recreated by reading its printed representation."]}),"\n",(0,s.jsxs)(n.p,{children:["No ",(0,s.jsx)(n.em,{children:"function"})," is provided for directly ",(0,s.jsx)(n.em,{children:"accessing"})," or invoking ",(0,s.jsx)(n.em,{children:"condition reporters"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function g(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In order to ensure a properly aesthetic result when presenting ",(0,s.jsx)(n.em,{children:"report messages"})," to the user, certain stylistic conventions are recommended."]}),"\n",(0,s.jsxs)(n.p,{children:["There are stylistic recommendations for the content of the messages output by ",(0,s.jsx)(n.em,{children:"condition reporters"}),", but there are no formal requirements on those ",(0,s.jsx)(n.em,{children:"programs"}),". If a ",(0,s.jsx)(n.em,{children:"program"})," violates the recommendations for some message, the display of that message might be less aesthetic than if the guideline had been observed, but the ",(0,s.jsx)(n.em,{children:"program"})," is still considered a ",(0,s.jsx)(n.em,{children:"conforming program"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The requirements on a ",(0,s.jsx)(n.em,{children:"program"})," or ",(0,s.jsx)(n.em,{children:"implementation"})," which invokes a ",(0,s.jsx)(n.em,{children:"condition reporter"})," are somewhat stronger. A ",(0,s.jsx)(n.em,{children:"conforming program"})," must be permitted to assume that if these style guidelines are followed, proper aesthetics will be maintained. Where appropriate, any specific requirements on such routines are explicitly mentioned below."]})]})}function f(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}function b(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["It is recommended that a ",(0,s.jsx)(n.em,{children:"report message"})," be a complete sentences, in the proper case and correctly punctuated. In English, for example, this means the first letter should be uppercase, and there should be a trailing period."]}),"\n",(0,s.jsx)(n.p,{children:'(error "This is a message") ; Not recommended'}),"\n",(0,s.jsx)(n.p,{children:'(error "this is a message.") ; Not recommended'}),"\n",(0,s.jsx)(n.p,{children:'(error "This is a message.") ; Recommended instead'})]})}function y(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}function v(e){const n={del:"del",em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["It is recommended that a ",(0,s.jsx)(n.em,{children:"report message"})," not begin with any introductory text, such as \u201cError: \u201d or \u201cWarning: \u201d or even just ",(0,s.jsx)(n.em,{children:"freshline"})," or ",(0,s.jsx)(n.em,{children:"newline"}),". Such text is added, if appropriate to the context, by the routine invoking the ",(0,s.jsx)(n.em,{children:"condition reporter"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:["It is recommended that a ",(0,s.jsx)(n.em,{children:"report message"})," not be followed by a trailing ",(0,s.jsx)(n.em,{children:"freshline"})," or ",(0,s.jsx)(n.em,{children:"newline"}),". Such text is added, if appropriate to the context, by the routine invoking the ",(0,s.jsx)(n.em,{children:"condition reporter"})," ."]}),"\n",(0,s.jsx)(n.p,{children:'(error "This is a message.~%") ; Not recommended'}),"\n",(0,s.jsx)(n.p,{children:'(error "~&This is a message.") ; Not recommended'}),"\n",(0,s.jsxs)(n.p,{children:['(error "',(0,s.jsx)(n.del,{children:"&This is a message."}),'%") ; Not recommended']}),"\n",(0,s.jsx)(n.p,{children:'(error "This is a message.") ; Recommended instead'})]})}function w(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(v,{...e})}):v(e)}function k(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Especially if it is long, it is permissible and appropriate for a ",(0,s.jsx)(n.em,{children:"report message"})," to contain one or more embedded ",(0,s.jsx)(n.em,{children:"newlines"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If the calling routine conventionally inserts some additional prefix (such as \u201cError: \u201d or \u201c;; Error: \u201d) on the first line of the message, it must also assure that an appropriate prefix will"}),"\n",(0,s.jsxs)(n.p,{children:["be added to each subsequent line of the output, so that the left edge of the message output by the ",(0,s.jsx)(n.em,{children:"condition reporter"})," will still be properly aligned."]}),"\n",(0,s.jsx)(n.p,{children:"(defun test ()"}),"\n",(0,s.jsx)(n.p,{children:'(error "This is an error message.~%It has two lines."))'}),"\n",(0,s.jsx)(n.p,{children:";; Implementation A"}),"\n",(0,s.jsx)(n.p,{children:"(test)"}),"\n",(0,s.jsx)(n.p,{children:"This is an error message."}),"\n",(0,s.jsx)(n.p,{children:"It has two lines."}),"\n",(0,s.jsx)(n.p,{children:";; Implementation B"}),"\n",(0,s.jsx)(n.p,{children:"(test)"}),"\n",(0,s.jsx)(n.p,{children:";; Error: This is an error message."}),"\n",(0,s.jsx)(n.p,{children:";; It has two lines."}),"\n",(0,s.jsx)(n.p,{children:";; Implementation C"}),"\n",(0,s.jsx)(n.p,{children:"(test)"}),"\n",(0,s.jsx)(n.p,{children:"\xbb Error: This is an error message."}),"\n",(0,s.jsx)(n.p,{children:"It has two lines."})]})}function C(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}function T(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["Because the indentation of a ",(0,s.jsx)(n.em,{children:"report message"})," might be shifted to the right or left by an arbitrary amount, special care should be taken with the semi-standard ",(0,s.jsx)(n.em,{children:"character hTabi"})," (in those ",(0,s.jsx)(n.em,{children:"implementations"})," that support such a ",(0,s.jsx)(n.em,{children:"character"})," ). Unless the ",(0,s.jsx)(n.em,{children:"implementation"})," specifically defines its behavior in this context, its use should be avoided."]})}function I(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(T,{...e})}):T(e)}function F(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["The name of the containing function should generally not be mentioned in ",(0,s.jsx)(n.em,{children:"report messages"}),". It is assumed that the ",(0,s.jsx)(n.em,{children:"debugger"})," will make this information accessible in situations where it is necessary and appropriate."]})}function R(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(F,{...e})}):F(e)}function A(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The operation of the condition system depends on the ordering of active ",(0,s.jsx)(n.em,{children:"applicable handlers"})," from most recent to least recent."]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.em,{children:"handler"})," is associated with a ",(0,s.jsx)(n.em,{children:"type specifier"})," that must designate a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"condition"}),". A ",(0,s.jsx)(n.em,{children:"handler"})," is said to be ",(0,s.jsx)(n.em,{children:"applicable"})," to a ",(0,s.jsx)(n.em,{children:"condition"})," if that ",(0,s.jsx)(n.em,{children:"condition"})," is of the ",(0,s.jsx)(n.em,{children:"type"})," designated by the associated ",(0,s.jsx)(n.em,{children:"type specifier"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Active handlers"})," are ",(0,s.jsx)(n.em,{children:"established"})," by using ",(0,s.jsx)(n.strong,{children:"handler-bind"})," (or an abstraction based on ",(0,s.jsx)(n.strong,{children:"handler-bind"}),", such as ",(0,s.jsx)(n.strong,{children:"handler-case"})," or ",(0,s.jsx)(n.strong,{children:"ignore-errors"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Active handlers"})," can be ",(0,s.jsx)(n.em,{children:"established"})," within the dynamic scope of other ",(0,s.jsx)(n.em,{children:"active handlers"}),". At any point during program execution, there is a set of ",(0,s.jsx)(n.em,{children:"active handlers"}),". When a ",(0,s.jsx)(n.em,{children:"condition"})," is signaled, the ",(0,s.jsx)(n.em,{children:"most"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"recent"})," active ",(0,s.jsx)(n.em,{children:"applicable handler"})," for that ",(0,s.jsx)(n.em,{children:"condition"})," is selected from this set. Given a ",(0,s.jsx)(n.em,{children:"condition"}),", the order of recentness of active ",(0,s.jsx)(n.em,{children:"applicable handlers"})," is defined by the following two rules:"]}),"\n",(0,s.jsxs)(n.p,{children:["1. Each handler in a set of active handlers ",(0,s.jsx)(n.em,{children:"H"}),(0,s.jsx)("sub",{children:"1"})," is more recent than every handler in a set ",(0,s.jsx)(n.em,{children:"H"}),(0,s.jsx)("sub",{children:"2"})," if the handlers in ",(0,s.jsx)(n.em,{children:"H"}),(0,s.jsx)("sub",{children:"2"})," were active when the handlers in ",(0,s.jsx)(n.em,{children:"H"}),(0,s.jsx)("sub",{children:"1"})," were established."]}),"\n",(0,s.jsxs)(n.p,{children:["2. Let ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"1"})," and ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"2"})," be two applicable active handlers established by the same ",(0,s.jsx)(n.em,{children:"form"}),". Then ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"1"})," is more recent than ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"2"})," if ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"1"})," was defined to the left of ",(0,s.jsx)(n.em,{children:"h"}),(0,s.jsx)("sub",{children:"2"})," in the ",(0,s.jsx)(n.em,{children:"form"})," that established them."]}),"\n",(0,s.jsxs)(n.p,{children:["Once a handler in a handler binding ",(0,s.jsx)(n.em,{children:"form"})," (such as ",(0,s.jsx)(n.strong,{children:"handler-bind"})," or ",(0,s.jsx)(n.strong,{children:"handler-case"}),") has been selected, all handlers in that ",(0,s.jsx)(n.em,{children:"form"})," become inactive for the remainder of the signaling process. While the selected ",(0,s.jsx)(n.em,{children:"handler"})," runs, no other ",(0,s.jsx)(n.em,{children:"handler"})," established by that ",(0,s.jsx)(n.em,{children:"form"})," is active. That is, if the ",(0,s.jsx)(n.em,{children:"handler"})," declines, no other handler established by that ",(0,s.jsx)(n.em,{children:"form"})," will be considered for possible invocation."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 9\u20134 shows ",(0,s.jsx)(n.em,{children:"operators"})," relating to the ",(0,s.jsx)(n.em,{children:"handling"})," of ",(0,s.jsx)(n.em,{children:"conditions"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"handler-bind handler-case ignore-errors"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20134. Operators relating to handling conditions."})})]})}function S(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(A,{...e})}):A(e)}function E(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.em,{children:"condition"})," is signaled, the most recent applicable ",(0,s.jsx)(n.em,{children:"active handler"})," is invoked. Sometimes a handler will decline by simply returning without a transfer of control. In such cases, the next most recent applicable active handler is invoked."]}),"\n",(0,s.jsxs)(n.p,{children:["If there are no applicable handlers for a ",(0,s.jsx)(n.em,{children:"condition"})," that has been signaled, or if all applicable handlers decline, the ",(0,s.jsx)(n.em,{children:"condition"})," is unhandled."]}),"\n",(0,s.jsxs)(n.p,{children:["The functions ",(0,s.jsx)(n.strong,{children:"cerror"})," and ",(0,s.jsx)(n.strong,{children:"error"})," invoke the interactive ",(0,s.jsx)(n.em,{children:"condition"})," handler (the debugger) rather than return if the ",(0,s.jsx)(n.em,{children:"condition"})," being signaled, regardless of its ",(0,s.jsx)(n.em,{children:"type"}),", is unhandled. In contrast, ",(0,s.jsx)(n.strong,{children:"signal"})," returns ",(0,s.jsx)(n.strong,{children:"nil"})," if the ",(0,s.jsx)(n.em,{children:"condition"})," being signaled, regardless of its ",(0,s.jsx)(n.em,{children:"type"}),", is unhandled."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"variable"})," ",(0,s.jsx)(n.strong,{children:"*break-on-signals*"})," can be used to cause the debugger to be entered before the signaling process begins."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 9\u20135 shows ",(0,s.jsx)(n.em,{children:"defined names"})," relating to the ",(0,s.jsx)(n.em,{children:"signaling"})," of ",(0,s.jsx)(n.em,{children:"conditions"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"*break-on-signals* error warn"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(n.strong,{children:"cerror signal"})}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20135. Defined names relating to signaling conditions."})})]})}function N(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(E,{...e})}):E(e)}function q(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["During the ",(0,s.jsx)(n.em,{children:"dynamic extent"})," of the ",(0,s.jsx)(n.em,{children:"signaling"})," process for a particular ",(0,s.jsx)(n.em,{children:"condition object"}),", ",(0,s.jsx)(n.strong,{children:"signaling"})," the same ",(0,s.jsx)(n.em,{children:"condition object"})," again is permitted if and only if the ",(0,s.jsx)(n.em,{children:"situation"})," represented in both cases are the same."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, a ",(0,s.jsx)(n.em,{children:"handler"})," might legitimately ",(0,s.jsx)(n.em,{children:"signal"})," the ",(0,s.jsx)(n.em,{children:"condition object"})," that is its ",(0,s.jsx)(n.em,{children:"argument"})," in order to allow outer ",(0,s.jsx)(n.em,{children:"handlers"})," first opportunity to ",(0,s.jsx)(n.em,{children:"handle"})," the condition. (Such a ",(0,s.jsx)(n.em,{children:"handlers"})," is sometimes called a \u201cdefault handler.\u201d) This action is permitted because the ",(0,s.jsx)(n.em,{children:"situation"})," which the second ",(0,s.jsx)(n.em,{children:"signaling"})," process is addressing is really the same ",(0,s.jsx)(n.em,{children:"situation"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["On the other hand, in an ",(0,s.jsx)(n.em,{children:"implementation"})," that implemented asynchronous keyboard events by interrupting the user process with a call to ",(0,s.jsx)(n.strong,{children:"signal"}),", it would not be permissible for two distinct asynchronous keyboard events to ",(0,s.jsx)(n.em,{children:"signal identical condition objects"})," at the same time for different situations."]})]})}function D(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}function H(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The interactive condition handler returns only through non-local transfer of control to specially defined ",(0,s.jsx)(n.em,{children:"restarts"})," that can be set up either by the system or by user code. Transferring control to a restart is called \u201cinvoking\u201d the restart. Like handlers, active ",(0,s.jsx)(n.em,{children:"restarts"})," are ",(0,s.jsx)(n.em,{children:"established"})," dynamically, and only active ",(0,s.jsx)(n.em,{children:"restarts"})," can be invoked. An active ",(0,s.jsx)(n.em,{children:"restart"})," can be invoked by the user from the debugger or by a program by using ",(0,s.jsx)(n.strong,{children:"invoke-restart"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"restart"})," contains a ",(0,s.jsx)(n.em,{children:"function"})," to be ",(0,s.jsx)(n.em,{children:"called"})," when the ",(0,s.jsx)(n.em,{children:"restart"})," is invoked, an optional name that can be used to find or invoke the ",(0,s.jsx)(n.em,{children:"restart"}),", and an optional set of interaction information for the debugger to use to enable the user to manually invoke a ",(0,s.jsx)(n.em,{children:"restart"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The name of a ",(0,s.jsx)(n.em,{children:"restart"})," is used by ",(0,s.jsx)(n.strong,{children:"invoke-restart"}),". ",(0,s.jsx)(n.em,{children:"Restarts"})," that can be invoked only within the debugger do not need names."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Restarts"})," can be established by using ",(0,s.jsx)(n.strong,{children:"restart-bind"}),", ",(0,s.jsx)(n.strong,{children:"restart-case"}),", and ",(0,s.jsx)(n.strong,{children:"with-simple-restart"}),". A ",(0,s.jsx)(n.em,{children:"restart"})," function can itself invoke any other ",(0,s.jsx)(n.em,{children:"restart"})," that was active at the time of establishment of the ",(0,s.jsx)(n.em,{children:"restart"})," of which the ",(0,s.jsx)(n.em,{children:"function"})," is part."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"restarts established"})," by a ",(0,s.jsx)(n.strong,{children:"restart-bind"})," ",(0,s.jsx)(n.em,{children:"form"}),", a ",(0,s.jsx)(n.strong,{children:"restart-case"})," ",(0,s.jsx)(n.em,{children:"form"}),", or a ",(0,s.jsx)(n.strong,{children:"with-simple-restart"})," ",(0,s.jsx)(n.em,{children:"form"})," have ",(0,s.jsx)(n.em,{children:"dynamic extent"})," which extends for the duration of that ",(0,s.jsx)(n.em,{children:"form"}),"\u2019s execution."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Restarts"})," of the same name can be ordered from least recent to most recent according to the following two rules:"]}),"\n",(0,s.jsxs)(n.p,{children:["1. Each ",(0,s.jsx)(n.em,{children:"restart"})," in a set of active restarts ",(0,s.jsx)(n.em,{children:"R"}),(0,s.jsx)("sub",{children:"1"})," is more recent than every ",(0,s.jsx)(n.em,{children:"restart"})," in a set ",(0,s.jsx)(n.em,{children:"R"}),(0,s.jsx)("sub",{children:"2"})," if the ",(0,s.jsx)(n.em,{children:"restarts"})," in ",(0,s.jsx)(n.em,{children:"R"}),(0,s.jsx)("sub",{children:"2"})," were active when the ",(0,s.jsx)(n.em,{children:"restarts"})," in ",(0,s.jsx)(n.em,{children:"R"}),(0,s.jsx)("sub",{children:"1"})," were established."]}),"\n",(0,s.jsxs)(n.p,{children:["2. Let ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"1"})," and ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"2"})," be two active ",(0,s.jsx)(n.em,{children:"restarts"})," with the same name established by the same ",(0,s.jsx)(n.em,{children:"form"}),". Then ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"1"})," is more recent than ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"2"})," if ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"1"})," was defined to the left of ",(0,s.jsx)(n.em,{children:"r"}),(0,s.jsx)("sub",{children:"2"})," in the ",(0,s.jsx)(n.em,{children:"form"})," that established them."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"restart"})," is invoked but does not transfer control, the values resulting from the ",(0,s.jsx)(n.em,{children:"restart"})," function are returned by the function that invoked the restart, either ",(0,s.jsx)(n.strong,{children:"invoke-restart"})," or ",(0,s.jsx)(n.strong,{children:"invoke-restart-interactively"}),"."]})]})}function W(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(H,{...e})}):H(e)}function z(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["For interactive handling, two pieces of information are needed from a ",(0,s.jsx)(n.em,{children:"restart"}),": a report function and an interactive function."]}),"\n",(0,s.jsxs)(n.p,{children:["The report function is used by a program such as the debugger to present a description of the action the ",(0,s.jsx)(n.em,{children:"restart"})," will take. The report function is specified and established by the ",":report-function"," keyword to ",(0,s.jsx)(n.strong,{children:"restart-bind"})," or the ",":report"," keyword to ",(0,s.jsx)(n.strong,{children:"restart-case"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The interactive function, which can be specified using the ",":interactive-function"," keyword to ",(0,s.jsx)(n.strong,{children:"restart-bind"})," or ",":interactive"," keyword to ",(0,s.jsx)(n.strong,{children:"restart-case"}),", is used when the ",(0,s.jsx)(n.em,{children:"restart"})," is invoked interactively, such as from the debugger, to produce a suitable list of arguments."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"invoke-restart"})," invokes the most recently ",(0,s.jsx)(n.em,{children:"established restart"})," whose name is the same as the first argument to ",(0,s.jsx)(n.strong,{children:"invoke-restart"}),". If a ",(0,s.jsx)(n.em,{children:"restart"})," is invoked interactively by the debugger and does not transfer control but rather returns values, the precise action of the debugger on those values is ",(0,s.jsx)(n.em,{children:"implementation-defined"}),"."]})]})}function L(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(z,{...e})}):z(e)}function M(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(n.em,{children:"restarts"})," have functional interfaces, such as ",(0,s.jsx)(n.strong,{children:"abort"}),", ",(0,s.jsx)(n.strong,{children:"continue"}),", ",(0,s.jsx)(n.strong,{children:"muffle-warning"}),", ",(0,s.jsx)(n.strong,{children:"store-value"}),", and ",(0,s.jsx)(n.strong,{children:"use-value"}),". They are ordinary functions that use ",(0,s.jsx)(n.strong,{children:"find-restart"})," and ",(0,s.jsx)(n.strong,{children:"invoke-restart"})," internally, that have the same name as the ",(0,s.jsx)(n.em,{children:"restarts"})," they manipulate, and that are provided simply for notational convenience."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 9\u20136 shows ",(0,s.jsx)(n.em,{children:"defined names"})," relating to ",(0,s.jsx)(n.em,{children:"restarts"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"abort invoke-restart-interactively store-value compute-restarts muffle-warning use-value"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"continue restart-bind with-simple-restart find-restart restart-case"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(n.strong,{children:"invoke-restart restart-name"})}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20136. Defined names relating to restarts."})})]})}function O(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(M,{...e})}):M(e)}function P(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.em,{children:"restart"})," has an associated test, which is a function of one argument (a ",(0,s.jsx)(n.em,{children:"condition"})," or ",(0,s.jsx)(n.strong,{children:"nil"}),") which returns ",(0,s.jsx)(n.em,{children:"true"})," if the ",(0,s.jsx)(n.em,{children:"restart"})," should be visible in the current ",(0,s.jsx)(n.em,{children:"situation"}),". This test is created by the ",":test-function"," option to ",(0,s.jsx)(n.strong,{children:"restart-bind"})," or the ",":test"," option to ",(0,s.jsx)(n.strong,{children:"restart-case"}),"."]})}function B(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}function U(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"restart"})," can be \u201cassociated with\u201d a ",(0,s.jsx)(n.em,{children:"condition"})," explicitly by ",(0,s.jsx)(n.strong,{children:"with-condition-restarts"}),", or implicitly by ",(0,s.jsx)(n.strong,{children:"restart-case"}),". Such an assocation has ",(0,s.jsx)(n.em,{children:"dynamic extent"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A single ",(0,s.jsx)(n.em,{children:"restart"})," may be associated with several ",(0,s.jsx)(n.em,{children:"conditions"})," at the same time. A single ",(0,s.jsx)(n.em,{children:"condition"})," may have several associated ",(0,s.jsx)(n.em,{children:"restarts"})," at the same time."]}),"\n",(0,s.jsxs)(n.p,{children:["Active restarts associated with a particular ",(0,s.jsx)(n.em,{children:"condition"})," can be detected by ",(0,s.jsx)(n.em,{children:"calling"})," a ",(0,s.jsx)(n.em,{children:"function"})," such as ",(0,s.jsx)(n.strong,{children:"find-restart"}),", supplying that ",(0,s.jsx)(n.em,{children:"condition"})," as the ",(0,s.jsx)(n.em,{children:"condition argument"}),". Active restarts can also be detected without regard to any associated ",(0,s.jsx)(n.em,{children:"condition"})," by calling such a function without a ",(0,s.jsx)(n.em,{children:"condition argument"}),", or by supplying a value of ",(0,s.jsx)(n.strong,{children:"nil"})," for such an ",(0,s.jsx)(n.em,{children:"argument"}),"."]})]})}function _(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(U,{...e})}):U(e)}function G(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Conditional signaling of ",(0,s.jsx)(n.em,{children:"conditions"})," based on such things as key match, form evaluation, and ",(0,s.jsx)(n.em,{children:"type"})," are handled by assertion ",(0,s.jsx)(n.em,{children:"operators"}),". Figure 9\u20137 shows ",(0,s.jsx)(n.em,{children:"operators"})," relating to assertions."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"assert check-type ecase"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(n.strong,{children:"ccase ctypecase etypecase"})}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 9\u20137. Operators relating to assertions."})})]})}function Z(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(G,{...e})}):G(e)}function J(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["For a background reference to the abstract concepts detailed in this section, see ",(0,s.jsx)(n.em,{children:"Exceptional Situations in Lisp"}),". The details of that paper are not binding on this document, but may be helpful in establishing a conceptual basis for understanding this material."]})}function K(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(J,{...e})}):J(e)}const Q={title:"9.1 Condition System Concepts"},V="9.1 Condition System Concepts",X={id:"chap-9/j-b-condition-system-concepts",title:"9.1 Condition System Concepts",description:"9.1.1 Condition Types",source:"@site/docs/chap-9/j-b-condition-system-concepts.md",sourceDirName:"chap-9",slug:"/chap-9/j-b-condition-system-concepts",permalink:"/cl-language-reference/docs/chap-9/j-b-condition-system-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-9/j-b-condition-system-concepts.md",tags:[],version:"current",frontMatter:{title:"9.1 Condition System Concepts"},sidebar:"tutorialSidebar",previous:{title:"9. Conditions",permalink:"/cl-language-reference/docs/category/9-conditions"},next:{title:"9.2 Conditions Dictionary",permalink:"/cl-language-reference/docs/category/92-conditions-dictionary"}},Y={},$=[{value:"9.1.1 Condition Types",id:"911-condition-types",level:2},{value:"9.1.1.1 Serious Conditions",id:"9111-serious-conditions",level:3},{value:"9.1.2 Creating Conditions",id:"912-creating-conditions",level:2},{value:"9.1.2.1 Condition Designators",id:"9121-condition-designators",level:3},{value:"9.1.3 Printing Conditions",id:"913-printing-conditions",level:2},{value:"9.1.3.1 Recommended Style in Condition Reporting",id:"9131-recommended-style-in-condition-reporting",level:3},{value:"9.1.3.1.1 Capitalization and Punctuation in Condition Reports",id:"91311-capitalization-and-punctuation-in-condition-reports",level:4},{value:"9.1.3.1.2 Leading and Trailing Newlines in Condition Reports",id:"91312-leading-and-trailing-newlines-in-condition-reports",level:4},{value:"9.1.3.1.3 Embedded Newlines in Condition Reports",id:"91313-embedded-newlines-in-condition-reports",level:4},{value:"9.1.3.1.4 Note about Tabs in Condition Reports",id:"91314-note-about-tabs-in-condition-reports",level:4},{value:"9.1.3.1.5 Mentioning Containing Function in Condition Reports",id:"91315-mentioning-containing-function-in-condition-reports",level:4},{value:"9.1.4 Signaling and Handling Conditions",id:"914-signaling-and-handling-conditions",level:2},{value:"9.1.4.1 Signaling",id:"9141-signaling",level:3},{value:"9.1.4.1.1 Resignaling a Condition",id:"91411-resignaling-a-condition",level:4},{value:"9.1.4.2 Restarts",id:"9142-restarts",level:3},{value:"9.1.4.2.1 Interactive Use of Restarts",id:"91421-interactive-use-of-restarts",level:4},{value:"9.1.4.2.2 Interfaces to Restarts",id:"91422-interfaces-to-restarts",level:4},{value:"9.1.4.2.3 Restart Tests",id:"91423-restart-tests",level:4},{value:"9.1.4.2.4 Associating a Restart with a Condition",id:"91424-associating-a-restart-with-a-condition",level:4},{value:"9.1.5 Assertions",id:"915-assertions",level:2},{value:"9.1.6 Notes about the Condition System",id:"916-notes-about-the-condition-system",level:2}];function ee(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"91-condition-system-concepts",children:"9.1 Condition System Concepts"}),"\n","\n",(0,s.jsx)(o,{}),"\n",(0,s.jsx)(n.h2,{id:"911-condition-types",children:"9.1.1 Condition Types"}),"\n","\n",(0,s.jsx)(d,{}),"\n",(0,s.jsx)(n.h3,{id:"9111-serious-conditions",children:"9.1.1.1 Serious Conditions"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h2,{id:"912-creating-conditions",children:"9.1.2 Creating Conditions"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(n.h3,{id:"9121-condition-designators",children:"9.1.2.1 Condition Designators"}),"\n","\n",(0,s.jsx)(j,{}),"\n",(0,s.jsx)(n.h2,{id:"913-printing-conditions",children:"9.1.3 Printing Conditions"}),"\n","\n",(0,s.jsx)(u,{}),"\n",(0,s.jsx)(n.h3,{id:"9131-recommended-style-in-condition-reporting",children:"9.1.3.1 Recommended Style in Condition Reporting"}),"\n","\n",(0,s.jsx)(f,{}),"\n",(0,s.jsx)(n.h4,{id:"91311-capitalization-and-punctuation-in-condition-reports",children:"9.1.3.1.1 Capitalization and Punctuation in Condition Reports"}),"\n","\n",(0,s.jsx)(y,{}),"\n",(0,s.jsx)(n.h4,{id:"91312-leading-and-trailing-newlines-in-condition-reports",children:"9.1.3.1.2 Leading and Trailing Newlines in Condition Reports"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(n.h4,{id:"91313-embedded-newlines-in-condition-reports",children:"9.1.3.1.3 Embedded Newlines in Condition Reports"}),"\n","\n",(0,s.jsx)(C,{}),"\n",(0,s.jsx)(n.h4,{id:"91314-note-about-tabs-in-condition-reports",children:"9.1.3.1.4 Note about Tabs in Condition Reports"}),"\n","\n",(0,s.jsx)(I,{}),"\n",(0,s.jsx)(n.h4,{id:"91315-mentioning-containing-function-in-condition-reports",children:"9.1.3.1.5 Mentioning Containing Function in Condition Reports"}),"\n","\n",(0,s.jsx)(R,{}),"\n",(0,s.jsx)(n.h2,{id:"914-signaling-and-handling-conditions",children:"9.1.4 Signaling and Handling Conditions"}),"\n","\n",(0,s.jsx)(S,{}),"\n",(0,s.jsx)(n.h3,{id:"9141-signaling",children:"9.1.4.1 Signaling"}),"\n","\n",(0,s.jsx)(N,{}),"\n",(0,s.jsx)(n.h4,{id:"91411-resignaling-a-condition",children:"9.1.4.1.1 Resignaling a Condition"}),"\n","\n",(0,s.jsx)(D,{}),"\n",(0,s.jsx)(n.h3,{id:"9142-restarts",children:"9.1.4.2 Restarts"}),"\n","\n",(0,s.jsx)(W,{}),"\n",(0,s.jsx)(n.h4,{id:"91421-interactive-use-of-restarts",children:"9.1.4.2.1 Interactive Use of Restarts"}),"\n","\n",(0,s.jsx)(L,{}),"\n",(0,s.jsx)(n.h4,{id:"91422-interfaces-to-restarts",children:"9.1.4.2.2 Interfaces to Restarts"}),"\n","\n",(0,s.jsx)(O,{}),"\n",(0,s.jsx)(n.h4,{id:"91423-restart-tests",children:"9.1.4.2.3 Restart Tests"}),"\n","\n",(0,s.jsx)(B,{}),"\n",(0,s.jsx)(n.h4,{id:"91424-associating-a-restart-with-a-condition",children:"9.1.4.2.4 Associating a Restart with a Condition"}),"\n","\n",(0,s.jsx)(_,{}),"\n",(0,s.jsx)(n.h2,{id:"915-assertions",children:"9.1.5 Assertions"}),"\n","\n",(0,s.jsx)(Z,{}),"\n",(0,s.jsx)(n.h2,{id:"916-notes-about-the-condition-system",children:"9.1.6 Notes about the Condition System"}),"\n","\n","\n",(0,s.jsx)(K,{})]})}function ne(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ee,{...e})}):ee(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>o});var s=i(67294);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);