"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[84829],{39936:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=n(85893),o=n(11151);const i={},c="compute-applicable-methods-using-classes",a={id:"meta-object-protocol/compute-applicable-methods-using-classes",title:"compute-applicable-methods-using-classes",description:"Generic Function COMPUTE-APPLICABLE-METHODS-USING-CLASSES",source:"@site/docs/meta-object-protocol/compute-applicable-methods-using-classes.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/compute-applicable-methods-using-classes",permalink:"/cl-language-reference/meta-object-protocol/compute-applicable-methods-using-classes",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/compute-applicable-methods-using-classes.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"compute-applicable-methods-using-classes-standard-generic-function",permalink:"/cl-language-reference/meta-object-protocol/compute-applicable-methods-using-classes-standard-generic-function"},next:{title:"compute-applicable-methods",permalink:"/cl-language-reference/meta-object-protocol/compute-applicable-methods"}},r={},l=[{value:"<strong>compute-applicable-methods-using-classes</strong> (<em>generic-function</em> standard-generic-function) <em>arguments</em>",id:"compute-applicable-methods-using-classes-generic-function-standard-generic-function-arguments",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",hr:"hr",p:"p",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"compute-applicable-methods-using-classes",children:"compute-applicable-methods-using-classes"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"Generic Function"})," ",(0,s.jsx)(t.strong,{children:"COMPUTE-APPLICABLE-METHODS-USING-CLASSES"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"compute-applicable-methods-using-classes"})," ",(0,s.jsx)(t.em,{children:"generic-function"})," ",(0,s.jsx)(t.em,{children:"classes"})," => ",(0,s.jsx)(t.em,{children:"methods"}),", ",(0,s.jsx)(t.em,{children:"ok"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Arguments and values:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"generic-function"})," -- A generic function metaobject."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"classes"})," -- A list of class metaobjects."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"methods"})," -- A (possibly empty) list of method metaobjects."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"ok"})," -- A generalized boolean."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Description:"})}),"\n",(0,s.jsx)(t.p,{children:"This generic function is called to attempt to determine the method applicability of a generic function given only the classes of the required arguments."}),"\n",(0,s.jsx)(t.p,{children:"If it is possible to completely determine the ordered list of applicable methods based only on the supplied classes, this generic function returns that list as its first value and true as its second value. The returned list of method metaobjects is sorted by precedence order, the most specific method coming first. If no methods are applicable to arguments with the specified classes, the empty list and true are returned."}),"\n",(0,s.jsx)(t.p,{children:"If it is not possible to completely determine the ordered list of applicable methods based only on the supplied classes, this generic function returns an unspecified first value and false as its second value."}),"\n",(0,s.jsxs)(t.p,{children:["When a generic function is invoked, the discriminating function must determine the ordered list of methods applicable to the arguments. Depending on the generic function and the arguments, this is done in one of three ways: using a memoized value; calling ",(0,s.jsx)(t.strong,{children:"compute-applicable-methods-using-classes"})," or calling",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"}),". (Refer to the description of ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"})," for the details of this process.)"]}),"\n",(0,s.jsxs)(t.p,{children:["The following consistency relationship between ",(0,s.jsx)(t.strong,{children:"compute-applicable-methods-using-classes"})," and ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"})," must be maintained: for any given generic function and set of arguments, if ",(0,s.jsx)(t.strong,{children:"compute-applicable-methods-using-classes"})," returns a second value of true, the first value must be equal to the value that would be returned by a corresponding call to ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"}),". The results are undefined if a portable method on either of these generic functions causes this consistency to be violated."]}),"\n",(0,s.jsx)(t.p,{children:"The list returned by this generic function will not be mutated by the implementation. The results are undefined if a portable program mutates the list returned by this generic function."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Methods:"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"compute-applicable-methods-using-classes-generic-function-standard-generic-function-arguments",children:(0,s.jsxs)(t.a,{href:"/meta-object-protocol/compute-applicable-methods-using-classes-standard-generic-function",children:[(0,s.jsx)(t.strong,{children:"compute-applicable-methods-using-classes"})," (",(0,s.jsx)(t.em,{children:"generic-function"})," standard-generic-function) ",(0,s.jsx)(t.em,{children:"arguments"})]})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Remarks:"})}),"\n",(0,s.jsx)(t.p,{children:"This generic function exists to allow user extensions which alter method lookup rules, but which base the new rules only on the classes of the required arguments, to take advantage of the class-based method lookup memoization found in many implementations. (There is of course no requirement for an implementation to provide this optimization.)"}),"\n",(0,s.jsxs)(t.p,{children:["Such an extension can be implemented by two methods, one on this generic function and one on ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-applicable-methods",children:"compute-applicable-methods"}),". Whenever the user extension is in effect, the first method will return a second value of true. This should allow the implementation to absorb these cases into its own memoization scheme."]}),"\n",(0,s.jsxs)(t.p,{children:["To get appropriate performance, other kinds of extensions may require methods on ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/compute-discriminating-function",children:"compute-discriminating-function"})," which implement their own memoization scheme."]})]})}function p(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>c});var s=n(67294);const o={},i=s.createContext(o);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);