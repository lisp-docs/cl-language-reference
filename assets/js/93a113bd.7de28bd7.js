"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[7098],{60560:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var n=o(85893),s=o(11151);const i={},r="Restrictions on portable programs",a={id:"meta-object-protocol/restrictions-on-portable-programs",title:"Restrictions on portable programs",description:"Restrictions on portable programs",source:"@site/docs/meta-object-protocol/restrictions-on-portable-programs.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/restrictions-on-portable-programs",permalink:"/cl-language-reference/meta-object-protocol/restrictions-on-portable-programs",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/restrictions-on-portable-programs.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Restrictions on implementations",permalink:"/cl-language-reference/meta-object-protocol/restrictions-on-implementations"},next:{title:"set-funcallable-instance-function",permalink:"/cl-language-reference/meta-object-protocol/set-funcallable-instance-function"}},c={},l=[{value:"Restrictions on portable programs",id:"restrictions-on-portable-programs-1",level:4}];function d(e){const t={a:"a",code:"code",h1:"h1",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"restrictions-on-portable-programs",children:"Restrictions on portable programs"}),"\n",(0,n.jsx)(t.h4,{id:"restrictions-on-portable-programs-1",children:"Restrictions on portable programs"}),"\n",(0,n.jsx)(t.p,{children:"Portable programs are allowed to define subclasses of specified classes, and are permitted to define methods on specified generic functions, with the following restrictions. The results are undefined if any of these restrictions is violated."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Portable programs must not redefine any specified classes, generic functions, methods or method combinations. Any method defined by a portable program on a specified generic function must have at least one specializer that is neither a specified class nor an ",(0,n.jsx)(t.code,{children:"eql"})," specializer whose associated value is an instance of a specified class."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Portable programs may define methods that extend specified methods unless the description of the specified method explicitly prohibits this. Unless there is a specific statement to the contrary, these extending methods must return whatever value was returned by the call to ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_call_n.htm#call-next-method",children:"call-next-method"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Portable programs may define methods that override specified methods only when the description of the specified method explicitly allows this. Typically, when a method is allowed to be overridden, a small number of related methods will need to be overridden as well."}),"\n",(0,n.jsxs)(t.p,{children:["An example of this is the specified methods on the generic functions ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/add-dependent",children:"add-dependent"}),", ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/remove-dependent",children:"remove-dependent"}),", and ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/map-dependents",children:"map-dependents"}),". Overriding a specified method on one of these generic functions requires that the corresponding method on the other two generic functions be overridden as well."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Portable methods on specified generic functions specialized to portable metaobject classes must be defined before any instances of those classes (or any subclasses) are created, either directly or indirectly by a call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". Methods can be defined after instances are created by ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_alloca.htm#allocate-instance",children:"allocate-instance"})," however. Portable metaobject classes cannot be redefined."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Implementation note:"})}),"\n",(0,n.jsx)(t.p,{children:"The purpose of this last restriction is to permit implementations to provide performance optimizations by analyzing, at the time the first instance of a metaobject class is initialized, what portable methods will be applicable to it. This can make it possible to optimize calls to those specified generic functions which would have no applicable portable methods."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Note:"})}),"\n",(0,n.jsx)(t.p,{children:"The specification technology used in this document needs further development. The concepts of object-oriented protocols and subclass specialization are intuitively familiar to programmers of object-oriented systems; the protocols presented here fit quite naturally into this framework. Nonetheless, in preparing this document, we have found it difficult to give specification-quality descriptions of the protocols in a way that makes it clear what extensions users can and cannot write. Object-oriented protocol specification is inherently about specifying leeway, and this seems difficult using current technology."}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>a,a:()=>r});var n=o(67294);const s={},i=n.createContext(s);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);