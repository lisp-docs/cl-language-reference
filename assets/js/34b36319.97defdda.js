"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[79052],{75059:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>h,contentTitle:()=>t,default:()=>p,frontMatter:()=>c,metadata:()=>d,toc:()=>a});var r=o(85893),l=o(11151);function s(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,l.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"boole"})," ",(0,r.jsx)(n.em,{children:"Function"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"boole"})," ",(0,r.jsx)(n.em,{children:"op integer-1 integer-2 \u2192 result-integer"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Op"}),"\u2014a ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifier"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"integer-1"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"boole"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"integer-2"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result-integer"}),"\u2014an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"boole"})," performs bit-wise logical operations on ",(0,r.jsx)(n.em,{children:"integer-1"})," and ",(0,r.jsx)(n.em,{children:"integer-2"}),", which are treated as if they were binary and in two\u2019s complement representation."]}),"\n",(0,r.jsxs)(n.p,{children:["The operation to be performed and the return value are determined by ",(0,r.jsx)(n.em,{children:"op"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"boole"})," returns the values specified for any ",(0,r.jsx)(n.em,{children:"op"})," in Figure 12\u201317."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Op Result"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-1"})," ",(0,r.jsx)(n.em,{children:"integer-1"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-2"})," ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-andc1"})," and complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," with ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-andc2"})," and ",(0,r.jsx)(n.em,{children:"integer-1"})," with complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-and"})," and "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-c1"})," complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-c2"})," complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-clr"})," always 0 (all zero bits) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-eqv"})," equivalence (exclusive nor) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-ior"})," inclusive or "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-nand"})," not-and "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-nor"})," not-or "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-orc1"})," or complement of ",(0,r.jsx)(n.em,{children:"integer-1"})," with ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-orc2"})," or ",(0,r.jsx)(n.em,{children:"integer-1"})," with complement of ",(0,r.jsx)(n.em,{children:"integer-2"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-set"})," always -1 (all one bits) "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"boole-xor"})," exclusive or"]}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 12\u201317. Bit-Wise Logical Operations"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:' \n(boole boole-ior 1 16) \u2192 17 \n(boole boole-and -2 5) \u2192 4 \n(boole boole-eqv 17 15) \u2192 -31 \n;;; These examples illustrate the result of applying BOOLE and each \n;;; of the possible values of OP to each possible combination of bits. \n(progn \n(format t "&#126;&amp;Results of (BOOLE <op> #b0011 #b0101) ...&#126; \n&#126;%\u2013-Op\u2013\u2013\u2013-Decimal\u2013\u2013-Binary\u2013\u2013Bits\u2013-&#126;%") \n(dolist (symbol \u2019(boole-1 boole-2 boole-and boole-andc1 \nboole-andc2 boole-c1 boole-c2 boole-clr \nboole-eqv boole-ior boole-nand boole-nor \n\n \n \n**boole** \nboole-orc1 boole-orc2 boole-set boole-xor)) \n(let ((result (boole (symbol-value symbol) #b0011 #b0101))) \n(format t "&#126;&amp; &#126;A&#126;13T&#126;3,\u2019 D&#126;23T&#126;:\\*&#126;5,\u2019 B&#126;31T ...&#126;4,\u20190B&#126;%" \nsymbol result (logand result #b1111))))) \n\u25b7 Results of (BOOLE <op> #b0011 #b0101) ... \n\u25b7 \u2013-Op\u2013\u2013\u2013-Decimal\u2013\u2013-Binary\u2013\u2013Bits\u2013- \n\u25b7 BOOLE-1 3 11 ...0011 \n\u25b7 BOOLE-2 5 101 ...0101 \n\u25b7 BOOLE-AND 1 1 ...0001 \n\u25b7 BOOLE-ANDC1 4 100 ...0100 \n\u25b7 BOOLE-ANDC2 2 10 ...0010 \n\u25b7 BOOLE-C1 -4 -100 ...1100 \n\u25b7 BOOLE-C2 -6 -110 ...1010 \n\u25b7 BOOLE-CLR 0 0 ...0000 \n\u25b7 BOOLE-EQV -7 -111 ...1001 \n\u25b7 BOOLE-IOR 7 111 ...0111 \n\u25b7 BOOLE-NAND -2 -10 ...1110 \n\u25b7 BOOLE-NOR -8 -1000 ...1000 \n\u25b7 BOOLE-ORC1 -3 -11 ...1101 \n\u25b7 BOOLE-ORC2 -5 -101 ...1011 \n\u25b7 BOOLE-SET -1 -1 ...1111 \n\u25b7 BOOLE-XOR 6 110 ...0110 \n\u2192 NIL \n\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["Should signal ",(0,r.jsx)(n.strong,{children:"type-error"})," if its first argument is not a ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifier"})," or if any subsequent argument is not an ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"logand"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsx)(n.p,{children:"In general,"}),"\n",(0,r.jsxs)(n.p,{children:["(boole boole-and x y) ",(0,r.jsx)(n.em,{children:"\u2261"})," (logand x y)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Programmers"})," who would prefer to use numeric indices rather than ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifiers"})," can get an equivalent effect by a technique such as the following:"]}),"\n",(0,r.jsx)(n.p,{children:";; The order of the values in this \u2018table\u2019 are such that"}),"\n",(0,r.jsx)(n.p,{children:";; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n"}),"\n",(0,r.jsx)(n.p,{children:"(defconstant boole-n-vector"}),"\n",(0,r.jsx)(n.p,{children:"(vector boole-clr boole-and boole-andc1 boole-2"}),"\n",(0,r.jsx)(n.p,{children:"boole-andc2 boole-1 boole-xor boole-ior"}),"\n",(0,r.jsx)(n.p,{children:"boole-nor boole-eqv boole-c1 boole-orc1"}),"\n",(0,r.jsx)(n.p,{children:"boole-c2 boole-orc2 boole-nand boole-set))"}),"\n",(0,r.jsx)(n.p,{children:"\u2192 BOOLE-N-VECTOR"}),"\n",(0,r.jsx)(n.p,{children:"(proclaim \u2019(inline boole-n))"}),"\n",(0,r.jsx)(n.p,{children:"\u2192 implementation-dependent"}),"\n",(0,r.jsx)(n.p,{children:"(defun boole-n (n integer &rest more-integers)"}),"\n",(0,r.jsx)(n.p,{children:"(apply #\u2019boole (elt boole-n-vector n) integer more-integers))"}),"\n",(0,r.jsx)(n.p,{children:"\u2192 BOOLE-N"}),"\n",(0,r.jsx)(n.p,{children:"(boole-n #b0111 5 3) \u2192 7"}),"\n",(0,r.jsx)(n.p,{children:"(boole-n #b0001 5 3) \u2192 1"}),"\n",(0,r.jsx)(n.p,{children:"(boole-n #b1101 5 3) \u2192 -3"}),"\n",(0,r.jsx)(n.p,{children:"(loop for n from #b0000 to #b1111 collect (boole-n n 5 3))"}),"\n",(0,r.jsx)(n.p,{children:"\u2192 (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)("sup",{children:"boole-1, boole-2, boole-and, boole-andc1, boole"})," andc2, boole-c1, boole-c2, boole-clr, boole-eqv, boole-ior, boole-nand, boole-nor, boole-orc1, boole-orc2, boole-set, boole-xor"]})," ",(0,r.jsx)("i",{children:"Constant Variable"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Constant Value:"})}),"\n",(0,r.jsxs)(n.p,{children:["The identity and nature of the ",(0,r.jsx)(n.em,{children:"values"})," of each of these ",(0,r.jsx)(n.em,{children:"variables"})," is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),", except that it must be ",(0,r.jsx)(n.em,{children:"distinct"})," from each of the ",(0,r.jsx)(n.em,{children:"values"})," of the others, and it must be a valid first ",(0,r.jsx)(n.em,{children:"argument"})," to the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"boole"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["Each of these ",(0,r.jsx)(n.em,{children:"constants"})," has a ",(0,r.jsx)(n.em,{children:"value"})," which is one of the sixteen possible ",(0,r.jsx)(n.em,{children:"bit-wise logical operation specifiers"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"\n(boole boole-ior 1 16) \u2192 17 \n(boole boole-and -2 5) \u2192 4 \n(boole boole-eqv 17 15) \u2192 -31 \n\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"boole"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"logand, logandc1, logandc2, logeqv, logior, lognand,"})," ",(0,r.jsx)(n.em,{children:". . ."})]})]})}function i(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}const c={},t="boole",d={id:"chap-12/bc-c-dictionary/boole",title:"boole",description:"Expanded Reference: boole",source:"@site/docs/chap-12/bc-c-dictionary/boole.md",sourceDirName:"chap-12/bc-c-dictionary",slug:"/chap-12/bc-c-dictionary/boole",permalink:"/cl-language-reference/docs/chap-12/bc-c-dictionary/boole",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-12/bc-c-dictionary/boole.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"bit",permalink:"/cl-language-reference/docs/chap-12/bc-c-dictionary/bit"},next:{title:"byte, byte-size, byte-position",permalink:"/cl-language-reference/docs/chap-12/bc-c-dictionary/byte"}},h={},a=[{value:"Expanded Reference: boole",id:"expanded-reference-boole",level:2}];function x(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"boole",children:"boole"}),"\n","\n","\n",(0,r.jsx)(i,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-boole",children:"Expanded Reference: boole"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(boole )\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>c,a:()=>i});var r=o(67294);const l={},s=r.createContext(l);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);