"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[12277],{43786:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>r});var a=s(85893),i=s(11151);const c={},o="Class finalization protocol",n={id:"meta-object-protocol/class-finalization-protocol",title:"Class finalization protocol",description:"Class finalization protocol",source:"@site/docs/meta-object-protocol/class-finalization-protocol.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/class-finalization-protocol",permalink:"/cl-language-reference/meta-object-protocol/class-finalization-protocol",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/class-finalization-protocol.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"EQL-SPECIALIZER",permalink:"/cl-language-reference/meta-object-protocol/class-eql-specializer"},next:{title:"class-finalized-p-built-in-class",permalink:"/cl-language-reference/meta-object-protocol/class-finalized-p-built-in-class"}},l={},r=[{value:"Class finalization protocol",id:"class-finalization-protocol-1",level:3}];function f(e){const t={a:"a",em:"em",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"class-finalization-protocol",children:"Class finalization protocol"}),"\n",(0,a.jsx)(t.h3,{id:"class-finalization-protocol-1",children:"Class finalization protocol"}),"\n",(0,a.jsxs)(t.p,{children:["Class ",(0,a.jsx)(t.em,{children:"finalization"})," is the process of computing the information a class inherits from its superclasses and preparing to actually allocate instances of the class. The class finalization process includes computing the class precedence list of the class, the full set of slots accessible in instances of the class and the full set of default initialization arguments for the class. These values are associated with the class metaobject and can be accessed by calling the appropriate reader. In addition, the class finalization process makes decisions about how instances of the class will be implemented."]}),"\n",(0,a.jsxs)(t.p,{children:["To support forward-referenced superclasses, and to account for the fact that not all classes are actually instantiated, class finalization is not done as part of the initialization of the class metaobject. Instead, finalization is done as a separate protocol, invoked by calling the generic function ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"}),". The exact point at which ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," is called depends on the class of the class metaobject; for ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," it is called sometime after all the superclasses of the class are defined, but no later than when the first instance of the class is allocated (by ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/allocate-instance",children:"allocate-instance"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["The first step of class finalization is computing the class precedence list. Doing this first allows subsequent steps to access the class precedence list. This step is performed by calling the generic function ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/compute-class-precedence-list",children:"compute-class-precedence-list"}),". The value returned from this call is associated with the class metaobject and can be accessed by calling the ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/class-precedence-list",children:"class-precedence-list"})," generic function."]}),"\n",(0,a.jsxs)(t.p,{children:["The second step is computing the full set of slots that will be accessible in instances of the class. This step is performed by calling the generic function ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"}),". The result of this call is a list of effective slot definition metaobjects. This value is associated with the class metaobject and can be accessed by calling the ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/class-slots",children:"class-slots"})," generic function."]}),"\n",(0,a.jsxs)(t.p,{children:["The behavior of ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/compute-slots",children:"compute-slots"})," is itself layered, consisting of calls to ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/effective-slot-definition-class",children:"effective-slot-definition-class"})," and ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-slot-definition",children:"compute-effective-slot-definition"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The final step of class finalization is computing the full set of initialization arguments for the class. This is done by calling the generic function ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/compute-default-initargs",children:"compute-default-initargs"}),". The value returned by this generic function is associated with the class metaobject and can be accessed by calling ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/class-default-initargs",children:"class-default-initargs"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If the class was previously finalized, ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," may call ",(0,a.jsx)(t.a,{href:"/chap-7/h-h-dictionary/make-instances-obsolete_standard-generic-function",children:"make-instances-obsolete"}),". The circumstances under which this happens are describe in ",(0,a.jsx)(t.a,{href:"http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node300.md#SECTION0032110000000000000000",children:"the section of the CLOS specification called ``Redefining Classes.''"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Forward-referenced classes, which provide a temporary definition for a class which has been referenced but not yet defined, can never be finalized. An error is signalled if ",(0,a.jsx)(t.a,{href:"/meta-object-protocol/finalize-inheritance",children:"finalize-inheritance"})," is called on a forward-referenced class."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(f,{...e})}):f(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>n,a:()=>o});var a=s(67294);const i={},c=a.createContext(i);function o(e){const t=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(c.Provider,{value:t},e.children)}}}]);