"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[63047],{11027:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>p,contentTitle:()=>h,default:()=>j,frontMatter:()=>a,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"chap-4/e-e-dictionary/subtypep_function","title":"subtypep","description":"Expanded Reference: subtypep","source":"@site/docs/chap-4/e-e-dictionary/subtypep_function.md","sourceDirName":"chap-4/e-e-dictionary","slug":"/chap-4/e-e-dictionary/subtypep_function","permalink":"/cl-language-reference/chap-4/e-e-dictionary/subtypep_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-4/e-e-dictionary/subtypep_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"subtypep"},"sidebar":"tutorialSidebar","previous":{"title":"structure-object","permalink":"/cl-language-reference/chap-4/e-e-dictionary/structure-object_class"},"next":{"title":"t","permalink":"/cl-language-reference/chap-4/e-e-dictionary/t_system-class"}}');var s=t(74848),i=t(28453);function l(e){const r={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:n}=r;return t||d("DictionaryLink",!0),n||d("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"subtypep"})," ",(0,s.jsx)(n,{term:"function",children:(0,s.jsx)("i",{children:"Function"})})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," ",(0,s.jsx)(r.em,{children:"type-1 type-2"})," &optional ",(0,s.jsx)(r.em,{children:"environment \u2192 subtype-p, valid-p"})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"type-1"}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," ."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"type-2"}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," ."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})}),"\u2014an ",(0,s.jsx)(n,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})}),". The default is ",(0,s.jsx)(t,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})}),", denoting the ",(0,s.jsx)(n,{styled:!0,term:"null lexical environment",children:(0,s.jsx)("i",{children:"null lexical environment"})})," and the current ",(0,s.jsx)(n,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"subtype-p"}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"valid-p"}),"\u2014a ",(0,s.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(r.p,{children:["If ",(0,s.jsx)(r.em,{children:"type-1"})," is a ",(0,s.jsx)(n,{styled:!0,term:"recognizable subtype",children:(0,s.jsx)("i",{children:"recognizable subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"}),", the first ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," is ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})}),". Otherwise, the first ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," is ",(0,s.jsx)(n,{term:"false",children:(0,s.jsx)("i",{children:"false"})}),", indicating that either ",(0,s.jsx)(r.em,{children:"type-1"})," is not a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"}),", or else ",(0,s.jsx)(r.em,{children:"type-1"})," is a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"})," but is not a ",(0,s.jsx)(n,{styled:!0,term:"recognizable subtype",children:(0,s.jsx)("i",{children:"recognizable subtype"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["A second ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," is also returned indicating the \u2018certainty\u2019 of the first ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),". If this value is ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})}),", then the first value is an accurate indication of the ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," relationship. (The second ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," is always ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," when the first ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," is ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})}),".)"]}),"\n",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})}),"\n",(0,s.jsxs)(r.p,{children:["Figure 4\u20139 summarizes the possible combinations of ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," that might result."]}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsx)(r.strong,{children:"Value 1 Value 2 Meaning"}),"|"]}),"\n",(0,s.jsx)(r.p,{children:"| :- |"}),"\n",(0,s.jsxs)(r.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(r.em,{children:"true true type-1"})," is definitely a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"}),". "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(r.em,{children:"false true type-1"})," is definitely not a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"}),". ",(0,s.jsx)(r.em,{children:"false false"})," ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," could not determine the relationship, so ",(0,s.jsx)(r.em,{children:"type-1"})," might or might not be a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of ",(0,s.jsx)(r.em,{children:"type-2"}),"."]}),"|"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Figure 4\u20139. Result possibilities for subtypep"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," is permitted to return the ",(0,s.jsx)(r.em,{children:"values false"})," and ",(0,s.jsx)(n,{term:"false",children:(0,s.jsx)("i",{children:"false"})})," only when at least one argument involves one of these ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})}),": ",(0,s.jsx)(t,{term:"and",children:(0,s.jsx)("b",{children:"and"})}),", ",(0,s.jsx)(t,{term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),", the list form of ",(0,s.jsx)(t,{term:"function",children:(0,s.jsx)("b",{children:"function"})}),", ",(0,s.jsx)(t,{term:"member",children:(0,s.jsx)("b",{children:"member"})}),", ",(0,s.jsx)(t,{term:"not",children:(0,s.jsx)("b",{children:"not"})}),", ",(0,s.jsx)(t,{term:"or",children:(0,s.jsx)("b",{children:"or"})}),", ",(0,s.jsx)(r.strong,{children:"satisfies"}),", or ",(0,s.jsx)(t,{term:"values",children:(0,s.jsx)("b",{children:"values"})}),". (A ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," \u2018involves\u2019 such a ",(0,s.jsx)(n,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," if, after being ",(0,s.jsx)(r.em,{children:"type expanded"}),", it contains that ",(0,s.jsx)(n,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," in a position that would call for its meaning as a ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," to be used.) One consequence of this is that if neither ",(0,s.jsx)(r.em,{children:"type-1"})," nor ",(0,s.jsx)(r.em,{children:"type-2"})," involves any of these ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})}),", then ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," is obliged to determine the relationship accurately. In particular, ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," returns the ",(0,s.jsx)(r.em,{children:"values true"})," and ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," if the arguments are ",(0,s.jsx)(t,{term:"equal",children:(0,s.jsx)("b",{children:"equal"})})," and do not involve any of these ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," never returns a second value of ",(0,s.jsx)(t,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})})," when both ",(0,s.jsx)(r.em,{children:"type-1"})," and ",(0,s.jsx)(r.em,{children:"type-2"})," involve only the names in Figure 4\u20132, or names of ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"types"})})," defined by ",(0,s.jsx)(t,{term:"defstruct",children:(0,s.jsx)("b",{children:"defstruct"})}),", ",(0,s.jsx)(t,{term:"define-condition",children:(0,s.jsx)("b",{children:"define-condition"})}),", or ",(0,s.jsx)(t,{term:"defclass",children:(0,s.jsx)("b",{children:"defclass"})}),", or ",(0,s.jsx)(n,{styled:!0,term:"derived type",children:(0,s.jsx)("i",{children:"derived types"})})," that expand into only those names. While ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})})," listed in Figure 4\u20132 and names of ",(0,s.jsx)(t,{term:"defclass",children:(0,s.jsx)("b",{children:"defclass"})})," and ",(0,s.jsx)(t,{term:"defstruct",children:(0,s.jsx)("b",{children:"defstruct"})})," can in some cases be implemented as ",(0,s.jsx)(n,{styled:!0,term:"derived type",children:(0,s.jsx)("i",{children:"derived types"})}),", ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," regards them as primitive."]}),"\n",(0,s.jsxs)(r.p,{children:["The relationships between ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"types"})})," reflected by ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," are those specific to the particular implementation. For example, if an implementation supports only a single type of floating-point numbers, in that implementation (subtypep \u2019float \u2019long-float) returns the ",(0,s.jsx)(r.em,{children:"values true"})," and ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," (since the two ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"types"})})," are identical)."]}),"\n",(0,s.jsxs)(r.p,{children:["For all ",(0,s.jsx)(r.em,{children:"T1"})," and ",(0,s.jsx)(r.em,{children:"T2"})," other than *, (array ",(0,s.jsx)(r.em,{children:"T1"}),") and (array ",(0,s.jsx)(r.em,{children:"T2"}),") are two different ",(0,s.jsx)(r.em,{children:"type spec ifiers"})," that always refer to the same sets of things if and only if they refer to ",(0,s.jsx)(n,{term:"array",children:(0,s.jsx)("i",{children:"arrays"})})," of exactly the same specialized representation, ",(0,s.jsx)(r.em,{children:"i.e."}),", if (upgraded-array-element-type \u2019",(0,s.jsx)(r.em,{children:"T1"}),") and (upgraded-array-element-type \u2019",(0,s.jsx)(r.em,{children:"T2"}),") return two different ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})})," that always refer to the same sets of ",(0,s.jsx)(n,{term:"object",children:(0,s.jsx)("i",{children:"objects"})}),". This is another way of saying that \u2018(array ",(0,s.jsx)(r.em,{children:"type-specifier"}),") and \u2018(array ,(upgraded-array-element-type \u2019",(0,s.jsx)(r.em,{children:"type-specifier"}),")) refer to the same set of specialized ",(0,s.jsx)(n,{term:"array",children:(0,s.jsx)("i",{children:"array"})})," representations. For all ",(0,s.jsx)(r.em,{children:"T1"})," and ",(0,s.jsx)(r.em,{children:"T2"})," other than *, the intersection of (array ",(0,s.jsx)(r.em,{children:"T1"}),") and (array ",(0,s.jsx)(r.em,{children:"T2"}),") is the empty set if and only if they refer to ",(0,s.jsx)(n,{term:"array",children:(0,s.jsx)("i",{children:"arrays"})})," of different, distinct specialized representations."]}),"\n",(0,s.jsx)(r.p,{children:"Therefore,"}),"\n",(0,s.jsx)(r.p,{children:"(subtypep \u2019(array T1) \u2019(array T2)) \u2192 true"}),"\n",(0,s.jsx)(r.p,{children:"if and only if"}),"\n",(0,s.jsx)(r.p,{children:"(upgraded-array-element-type \u2019T1) and"}),"\n",(0,s.jsx)(r.p,{children:"(upgraded-array-element-type \u2019T2)"}),"\n",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})}),"\n",(0,s.jsxs)(r.p,{children:["return two different ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})})," that always refer to the same sets of ",(0,s.jsx)(n,{term:"object",children:(0,s.jsx)("i",{children:"objects"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["For all type-specifiers ",(0,s.jsx)(r.em,{children:"T1"})," and ",(0,s.jsx)(r.em,{children:"T2"})," other than *,"]}),"\n",(0,s.jsxs)(r.p,{children:["(subtypep \u2019(complex T1) \u2019(complex T2)) \u2192 true, ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})]}),"\n",(0,s.jsx)(r.p,{children:"if:"}),"\n",(0,s.jsxs)(r.p,{children:["1. T1 is a ",(0,s.jsx)(n,{term:"subtype",children:(0,s.jsx)("i",{children:"subtype"})})," of T2, or"]}),"\n",(0,s.jsxs)(r.p,{children:["2. (upgraded-complex-part-type \u2019",(0,s.jsx)(r.em,{children:"T1"}),") and (upgraded-complex-part-type \u2019",(0,s.jsx)(r.em,{children:"T2"}),") return two different ",(0,s.jsx)(n,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifiers"})})," that always refer to the same sets of ",(0,s.jsx)(n,{term:"object",children:(0,s.jsx)("i",{children:"objects"})}),"; in this case, (complex ",(0,s.jsx)(r.em,{children:"T1"}),") and (complex ",(0,s.jsx)(r.em,{children:"T2"}),") both refer to the same specialized representation."]}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(n,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," are ",(0,s.jsx)(n,{term:"false",children:(0,s.jsx)("i",{children:"false"})})," and ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," otherwise."]}),"\n",(0,s.jsx)(r.p,{children:"The form"}),"\n",(0,s.jsx)(r.p,{children:"(subtypep \u2019(complex single-float) \u2019(complex float))"}),"\n",(0,s.jsxs)(r.p,{children:["must return ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," in all implementations, but"]}),"\n",(0,s.jsx)(r.p,{children:"(subtypep \u2019(array single-float) \u2019(array float))"}),"\n",(0,s.jsxs)(r.p,{children:["returns ",(0,s.jsx)(n,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," only in implementations that do not have a specialized ",(0,s.jsx)(n,{term:"array",children:(0,s.jsx)("i",{children:"array"})})," representation for ",(0,s.jsx)(n,{styled:!0,term:"single float",children:(0,s.jsx)("i",{children:"single floats"})})," distinct from that for other ",(0,s.jsx)(n,{term:"float",children:(0,s.jsx)("i",{children:"floats"})}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:"(subtypep \u2019compiled-function \u2019function) \u2192 true, *true* \n(subtypep \u2019null \u2019list) \u2192 true, *true* \n(subtypep \u2019null \u2019symbol) \u2192 true, *true* \n(subtypep \u2019integer \u2019string) \u2192 false, *true* \n(subtypep \u2019(satisfies dummy) nil) \u2192 false, *implementation-dependent* \n(subtypep \u2019(integer 1 3) \u2019(integer 1 4)) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019nil) \u2192 true, *true* \n(subtypep \u2019nil \u2019(integer (0) (0))) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019(member)) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019(member) \u2019nil) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019nil \u2019(member)) \u2192 true, *true* ;or *false*, *false* \nLet <aet-x> and <aet-y> be two distinct *type specifiers* that do not always refer to the same sets of *objects* in a given implementation, but for which **make-array**, will return an *object* of the same *array type*. \nThus, in each case, \n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-x>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-y>))) \n\u2192 true, *true*  \n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-y>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-x>))) \n\u2192 true, *true* \nIf (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of *objects*, these names should always refer to the same sets of *objects*. That implies that the following set of tests are also true: \n(subtypep \u2019(array <aet-x>) \u2019(array <aet-y>)) \u2192 true, *true* \n(subtypep \u2019(array <aet-y>) \u2019(array <aet-x>)) \u2192 true, *true* \n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(r.p,{children:"Section 4.2 (Types)"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(r.p,{children:["The small differences between the ",(0,s.jsx)(t,{term:"subtypep",children:(0,s.jsx)("b",{children:"subtypep"})})," specification for the ",(0,s.jsx)(t,{term:"array",children:(0,s.jsx)("b",{children:"array"})})," and ",(0,s.jsx)(t,{term:"complex",children:(0,s.jsx)("b",{children:"complex"})})," types are necessary because there is no creation function for ",(0,s.jsx)(r.em,{children:"complexes"})," which allows the specification of the resultant part type independently of the actual types of the parts. Thus in the case of the ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(t,{term:"complex",children:(0,s.jsx)("b",{children:"complex"})}),", the actual type of the parts is referred to, although a ",(0,s.jsx)(n,{term:"number",children:(0,s.jsx)("i",{children:"number"})})," can be a member of more than one ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})}),". For example, 17 is of ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," (mod 18) as well as ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," (mod 256) and ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(t,{term:"integer",children:(0,s.jsx)("b",{children:"integer"})}),"; and 2.3f5 is of ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(t,{term:"single-float",children:(0,s.jsx)("b",{children:"single-float"})})," as well as ",(0,s.jsx)(n,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(t,{term:"float",children:(0,s.jsx)("b",{children:"float"})}),"."]})]})}function c(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function d(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const a={title:"subtypep"},h="subtypep",p={},o=[{value:"Expanded Reference: subtypep",id:"expanded-reference-subtypep",level:2}];function x(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"subtypep",children:"subtypep"})}),"\n","\n",(0,s.jsx)(c,{}),"\n",(0,s.jsx)(r.h2,{id:"expanded-reference-subtypep",children:"Expanded Reference: subtypep"}),"\n",(0,s.jsx)(r.admonition,{type:"tip",children:(0,s.jsx)(r.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:"(subtypep )\n"})})]})}function j(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>l,x:()=>c});var n=t(96540);const s={},i=n.createContext(s);function l(e){const r=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);