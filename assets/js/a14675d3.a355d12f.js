"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[97490],{93915:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>H,contentTitle:()=>_,default:()=>Z,frontMatter:()=>q,metadata:()=>B,toc:()=>G});var i=s(85893),r=s(11151);function t(e){return(0,i.jsx)(i.Fragment,{})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t()}function c(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," establishes a mapping from names to ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),". At any given time, one ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is current. The ",(0,i.jsx)(n.em,{children:"current package"})," is the one that is the ",(0,i.jsx)(s,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("b",{children:"*package*"})}),". When using the ",(0,i.jsx)(n.em,{children:"Lisp reader"})," , it is possible to refer to ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," in ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," other than the current one through the use of ",(0,i.jsx)(n.em,{children:"package prefixes"})," in the printed representation of the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Figure 11\u20131 lists some ",(0,i.jsx)(n.em,{children:"defined names"})," that are applicable to ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})}),". Where an ",(0,i.jsx)(s,{styled:!0,term:"operator",children:(0,i.jsx)("i",{children:"operator"})})," takes an argument that is either a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," or a ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})})," of ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),", an argument of ",(0,i.jsx)(s,{styled:!0,term:"nil",children:(0,i.jsx)("b",{children:"nil"})})," is treated as an empty ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})})," of ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),". Any ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," argument may be either a ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"string"})}),", a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),", or a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". If a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is supplied, its name will be used as the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," name."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsx)(n.strong,{children:"*modules* import provide *package* in-package rename-package defpackage intern require do-all-symbols list-all-packages shadow do-external-symbols make-package shadowing-import do-symbols package-name unexport export package-nicknames unintern find-all-symbols package-shadowing-symbols unuse-package find-package package-use-list use-package find-symbol package-used-by-list"}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 11\u20131. Some Defined Names related to Packages"})})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function a(e){const n={p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," has a ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," (a ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"string"})}),") and perhaps some ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nicknames"})})," (also ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"strings"})}),"). These are assigned when the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is created and can be changed later."]}),"\n",(0,i.jsxs)(n.p,{children:["There is a single namespace for ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})}),". The ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(s,{styled:!0,term:"find-package",children:(0,i.jsx)("b",{children:"find-package"})})," translates a package ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," or ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nickname"})})," into the associated ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". The ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(s,{styled:!0,term:"package-name",children:(0,i.jsx)("b",{children:"package-name"})})," returns the ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," of a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". The ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(s,{styled:!0,term:"package-nicknames",children:(0,i.jsx)("b",{children:"package-nicknames"})})," returns a ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})})," of all ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nicknames"})})," for a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". ",(0,i.jsx)(s,{styled:!0,term:"rename-package",children:(0,i.jsx)("b",{children:"rename-package"})})]}),"\n",(0,i.jsxs)(n.p,{children:["removes a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"\u2019s current ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," and ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nicknames"})})," and replaces them with new ones specified by the caller."]})]})}function o(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}function h(e){return(0,i.jsx)(i.Fragment,{})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h()}function x(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The mappings in a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," are divided into two classes, external and internal. The ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," targeted by these different mappings are called ",(0,i.jsx)(n.em,{children:"external symbols"})," and ",(0,i.jsx)(n.em,{children:"internal symbols"})," of the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". Within a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", a name refers to one ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," or to none; if it does refer to a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),", then it is either external or internal in that ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", but not both. ",(0,i.jsx)(n.em,{children:"External symbols"})," are part of the package\u2019s public interface to other ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})}),". ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"Symbols"})})," become ",(0,i.jsx)(n.em,{children:"external symbols"})," of a given ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," if they have been ",(0,i.jsx)(s,{styled:!0,term:"exported",children:(0,i.jsx)("i",{children:"exported"})})," from that ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," has the same ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," no matter what ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," it is ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," in, but it might be an ",(0,i.jsx)(n.em,{children:"external symbol"})," of some ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," and an ",(0,i.jsx)(n.em,{children:"internal symbol"})," of others."]})]})}function j(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}function p(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"Packages"})})," can be built up in layers. From one point of view, a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is a single collection of mappings from ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"strings"})})," into ",(0,i.jsx)(n.em,{children:"internal symbols"})," and ",(0,i.jsx)(n.em,{children:"external symbols"}),". However, some of these mappings might be established within the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," itself, while other mappings are inherited from other ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," via ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),". A ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is said to be ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," in a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," if the mapping is in the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," itself and is not inherited from somewhere else."]}),"\n",(0,i.jsxs)(n.p,{children:["There is no way to inherit the ",(0,i.jsx)(n.em,{children:"internal symbols"})," of another ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"; to refer to an ",(0,i.jsx)(n.em,{children:"internal symbol"})," using the ",(0,i.jsx)(n.em,{children:"Lisp reader"})," , a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," containing the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," must be made to be the ",(0,i.jsx)(n.em,{children:"current package"}),", a ",(0,i.jsx)(n.em,{children:"package prefix"})," must be used, or the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," must be ",(0,i.jsx)(n.em,{children:"imported"})," into the ",(0,i.jsx)(n.em,{children:"current package"}),"."]})]})}function y(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}function g(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," becomes ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," if that is its ",(0,i.jsx)(n.em,{children:"home package"})," when it is created, or if it is ",(0,i.jsx)(n.em,{children:"imported"})," into that ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", or by inheritance via ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", it can be referred to when using the ",(0,i.jsx)(n.em,{children:"Lisp reader"})," without a ",(0,i.jsx)(n.em,{children:"package prefix"})," when that ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is the ",(0,i.jsx)(n.em,{children:"current package"}),", regardless of whether it is ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," or inherited."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"Symbols"})})," from one ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," can be made ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in another ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," in two ways."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 Any individual ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," can be added to a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," by use of ",(0,i.jsx)(s,{styled:!0,term:"import",children:(0,i.jsx)("b",{children:"import"})}),". After the call to ",(0,i.jsx)(s,{styled:!0,term:"import",children:(0,i.jsx)("b",{children:"import"})})," the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," in the importing ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". The status of the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," in the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," it came from (if any) is unchanged, and the ",(0,i.jsx)(n.em,{children:"home package"})," for this ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is unchanged. Once ",(0,i.jsx)(n.em,{children:"imported"}),", a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," in the importing ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," and can be removed only by calling ",(0,i.jsx)(s,{styled:!0,term:"unintern",children:(0,i.jsx)("b",{children:"unintern"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(n.em,{children:"shadowed"})," ",(0,i.jsx)("sub",{children:"3"})," by another ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," in some ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," if the first ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," would be ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," by inheritance if not for the presence of the second ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),". See ",(0,i.jsx)(s,{styled:!0,term:"shadowing-import",children:(0,i.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 The second mechanism for making ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," from one ",(0,i.jsx)(n.em,{children:"package accessible"})," in another is provided by ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),". All of the ",(0,i.jsx)(n.em,{children:"external symbols"})," of the used ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," are inherited"]}),"\n",(0,i.jsxs)(n.p,{children:["by the using ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". The ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(s,{styled:!0,term:"unuse-package",children:(0,i.jsx)("b",{children:"unuse-package"})})," undoes the effects of a previous ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),"."]})]})}function b(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}function k(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is to be located in a given ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," the following occurs:"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 The ",(0,i.jsx)(n.em,{children:"external symbols"})," and ",(0,i.jsx)(n.em,{children:"internal symbols"})," of the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," are searched for the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 The ",(0,i.jsx)(n.em,{children:"external symbols"})," of the used ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," are searched in some unspecified order. The order does not matter; see the rules for handling name conflicts listed below."]})]})}function f(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(k,{...e})}):k(e)}function u(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Within one ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", any particular name can refer to at most one ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),". A name conflict is said to occur when there would be more than one candidate ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),". Any time a name conflict is about to occur, a ",(0,i.jsx)(n.em,{children:"correctable error"})," is signaled."]}),"\n",(0,i.jsx)(n.p,{children:"The following rules apply to name conflicts:"}),"\n",(0,i.jsx)(n.p,{children:"\u2013 Name conflicts are detected when they become possible, that is, when the package structure is altered. Name conflicts are not checked during every name lookup."}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 If the ",(0,i.jsx)(n.em,{children:"same symbol"})," is ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," to a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," through more than one path, there is no name conflict. A ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," cannot conflict with itself. Name conflicts occur only between ",(0,i.jsx)(n.em,{children:"distinct symbols"})," with the same name (under ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("b",{children:"string="})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 Every ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," has a list of shadowing ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),". A shadowing ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," takes precedence over any other ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," of the same name that would otherwise be ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". A name conflict involving a shadowing symbol is always resolved in favor of the shadowing ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),", without signaling an error (except for one exception involving ",(0,i.jsx)(s,{styled:!0,term:"import",children:(0,i.jsx)("b",{children:"import"})}),"). See ",(0,i.jsx)(s,{styled:!0,term:"shadow",children:(0,i.jsx)("b",{children:"shadow"})})," and ",(0,i.jsx)(s,{styled:!0,term:"shadowing-import",children:(0,i.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 The functions ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),", ",(0,i.jsx)(s,{styled:!0,term:"import",children:(0,i.jsx)("b",{children:"import"})}),", and ",(0,i.jsx)(s,{styled:!0,term:"export",children:(0,i.jsx)("b",{children:"export"})})," check for name conflicts."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 ",(0,i.jsx)(s,{styled:!0,term:"shadow",children:(0,i.jsx)("b",{children:"shadow"})})," and ",(0,i.jsx)(s,{styled:!0,term:"shadowing-import",children:(0,i.jsx)("b",{children:"shadowing-import"})})," never signal a name-conflict error."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 ",(0,i.jsx)(s,{styled:!0,term:"unuse-package",children:(0,i.jsx)("b",{children:"unuse-package"})})," and ",(0,i.jsx)(s,{styled:!0,term:"unexport",children:(0,i.jsx)("b",{children:"unexport"})})," do not need to do any name-conflict checking. ",(0,i.jsx)(s,{styled:!0,term:"unintern",children:(0,i.jsx)("b",{children:"unintern"})})," does name-conflict checking only when a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," being ",(0,i.jsx)(s,{styled:!0,term:"uninterned",children:(0,i.jsx)("i",{children:"uninterned"})})," is a ",(0,i.jsx)(n.em,{children:"shadowing symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 Giving a shadowing symbol to ",(0,i.jsx)(s,{styled:!0,term:"unintern",children:(0,i.jsx)("b",{children:"unintern"})})," can uncover a name conflict that had previously been resolved by the shadowing."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 Package functions signal name-conflict errors of ",(0,i.jsx)(s,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})})," ",(0,i.jsx)(s,{styled:!0,term:"package-error",children:(0,i.jsx)("b",{children:"package-error"})})," before making any change to the package structure. When multiple changes are to be made, it is permissible for the implementation to process each change separately. For example, when ",(0,i.jsx)(s,{styled:!0,term:"export",children:(0,i.jsx)("b",{children:"export"})})," is"]}),"\n",(0,i.jsxs)(n.p,{children:["given a ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})})," of ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),", aborting from a name conflict caused by the second ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," in the ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})})," might still export the first ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," in the ",(0,i.jsx)(s,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"list"})}),". However, a name-conflict error caused by ",(0,i.jsx)(s,{styled:!0,term:"export",children:(0,i.jsx)("b",{children:"export"})})," of a single ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," will be signaled before that ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,i.jsx)(s,{styled:!0,term:"accessibility",children:(0,i.jsx)("i",{children:"accessibility"})})," in any ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is changed."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 Continuing from a name-conflict error must offer the user a chance to resolve the name conflict in favor of either of the candidates. The ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," structure should be altered to reflect the resolution of the name conflict, via ",(0,i.jsx)(s,{styled:!0,term:"shadowing-import",children:(0,i.jsx)("b",{children:"shadowing-import"})}),", ",(0,i.jsx)(s,{styled:!0,term:"unintern",children:(0,i.jsx)("b",{children:"unintern"})}),", or ",(0,i.jsx)(s,{styled:!0,term:"unexport",children:(0,i.jsx)("b",{children:"unexport"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})})," between a ",(0,i.jsx)(n.em,{children:"symbol present"})," in the using ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," and an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the used ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is resolved in favor of the first ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," by making it a shadowing ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),", or in favor of the second ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," by uninterning the first ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," from the using ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,i.jsx)(s,{styled:!0,term:"export",children:(0,i.jsx)("b",{children:"export"})})," or ",(0,i.jsx)(s,{styled:!0,term:"unintern",children:(0,i.jsx)("b",{children:"unintern"})})," due to a ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"\u2019s inheriting two ",(0,i.jsx)(n.em,{children:"distinct symbols"})," with the ",(0,i.jsx)(n.em,{children:"same name"})," (under ",(0,i.jsx)(s,{styled:!0,term:"string",children:(0,i.jsx)("b",{children:"string="})}),") from two other ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," can be resolved in favor of either ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," by importing it into the using ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," and making it a ",(0,i.jsx)(n.em,{children:"shadowing symbol"}),", just as with ",(0,i.jsx)(s,{styled:!0,term:"use-package",children:(0,i.jsx)("b",{children:"use-package"})}),"."]})]})}function w(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}function v(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This section describes the ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," that are available in every ",(0,i.jsx)(n.em,{children:"conforming implementation"}),". A summary of the ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"names"})})," and ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nicknames"})})," of those ",(0,i.jsx)(n.em,{children:"standardized packages"})," is given in Figure 11\u20132."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsx)(n.strong,{children:"Name Nicknames"}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsx)("p",{children:"COMMON-LISP CL "}),(0,i.jsx)("p",{children:"COMMON-LISP-USER CL-USER "}),(0,i.jsxs)("p",{children:["KEYWORD ",(0,i.jsx)(n.em,{children:"none"})]}),"|"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 11\u20132. Standardized Package Names"})})]})}function C(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}function O(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," contains the primitives of the Common Lisp system as defined by this specification. Its ",(0,i.jsx)(n.em,{children:"external symbols"})," include all of the ",(0,i.jsx)(n.em,{children:"defined names"})," (except for ",(0,i.jsx)(n.em,{children:"defined names"})," in the KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),") that are present in the Common Lisp system, such as ",(0,i.jsx)(s,{styled:!0,term:"car",children:(0,i.jsx)("b",{children:"car"})}),", ",(0,i.jsx)(s,{styled:!0,term:"cdr",children:(0,i.jsx)("b",{children:"cdr"})}),", ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("b",{children:"*package*"})}),", etc. The COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," has the ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nickname"})})," CL."]}),"\n",(0,i.jsxs)(n.p,{children:["The COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," has as ",(0,i.jsx)(n.em,{children:"external symbols"})," those symbols enumerated in the figures in Section 1.9 (Symbols in the COMMON-LISP Package), and no others. These ",(0,i.jsx)(n.em,{children:"external symbols"})," are ",(0,i.jsx)(s,{styled:!0,term:"present",children:(0,i.jsx)("i",{children:"present"})})," in the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," but their ",(0,i.jsx)(n.em,{children:"home package"})," need not be the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, the symbol HELP cannot be an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," because it is not mentioned in Section 1.9 (Symbols in the COMMON-LISP Package). In contrast, the ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"variable"})," must be an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," even though it has no definition because it is listed in that section (to support its use as a valid second ",(0,i.jsx)(s,{styled:!0,term:"argument",children:(0,i.jsx)("i",{children:"argument"})})," to the ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(n.strong,{children:"documentation"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["The COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," can have additional ",(0,i.jsx)(n.em,{children:"internal symbols"}),"."]})]})}function M(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(O,{...e})}):O(e)}function L(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In a ",(0,i.jsx)(n.em,{children:"conforming implementation"}),", an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," can have a ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})}),", ",(0,i.jsx)(s,{styled:!0,term:"macro",children:(0,i.jsx)("i",{children:"macro"})}),", or ",(0,i.jsx)(n.em,{children:"special operator"})," definition, a ",(0,i.jsx)(n.em,{children:"global variable"})," definition (or other status as a ",(0,i.jsx)(n.em,{children:"dynamic variable"})," due to a ",(0,i.jsx)(s,{styled:!0,term:"special",children:(0,i.jsx)("b",{children:"special"})})," ",(0,i.jsx)(s,{styled:!0,term:"proclamation",children:(0,i.jsx)("i",{children:"proclamation"})}),"), or a ",(0,i.jsx)(s,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})})," definition only if explicitly permitted in this standard. For example, ",(0,i.jsx)(s,{styled:!0,term:"fboundp",children:(0,i.jsx)("b",{children:"fboundp"})})," ",(0,i.jsx)(n.em,{children:"yields false"})," for any ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," that is not the ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," of a ",(0,i.jsx)(n.em,{children:"standardized function"}),", ",(0,i.jsx)(n.em,{children:"macro"})," or ",(0,i.jsx)(n.em,{children:"special operator"})," , and ",(0,i.jsx)(s,{styled:!0,term:"boundp",children:(0,i.jsx)("b",{children:"boundp"})})," returns ",(0,i.jsx)(s,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})})," for any ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," that is not the ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," of a ",(0,i.jsx)(n.em,{children:"standardized global variable"}),". It also follows that ",(0,i.jsx)(n.em,{children:"conforming programs"})," can use ",(0,i.jsx)(n.em,{children:"external symbols"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," as the ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"names"})})," of local ",(0,i.jsx)(n.em,{children:"lexical variables"})," with confidence that those ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"names"})})," have not been ",(0,i.jsx)(n.em,{children:"proclaimed"})," ",(0,i.jsx)(s,{styled:!0,term:"special",children:(0,i.jsx)("b",{children:"special"})})," by the ",(0,i.jsx)(s,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," unless those ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," are ",(0,i.jsx)(s,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"names"})})," of ",(0,i.jsx)(n.em,{children:"standardized global variables"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"conforming implementation"})," must not place any ",(0,i.jsx)(s,{styled:!0,term:"property",children:(0,i.jsx)("i",{children:"property"})})," on an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," using a ",(0,i.jsx)(n.em,{children:"property indicator"})," that is either an ",(0,i.jsx)(n.em,{children:"external symbol"})," of any ",(0,i.jsx)(n.em,{children:"standardized package"})," or a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," that is otherwise ",(0,i.jsx)(s,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in the COMMON-LISP-USER ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]})]})}function S(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(L,{...e})}):L(e)}function P(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Except where explicitly allowed, the consequences are undefined if any of the following actions are performed on an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["1. ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"Binding"})})," or altering its value (lexically or dynamically). (Some exceptions are noted below.) 2. Defining, undefining, or ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})})," it as a ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})}),". (Some exceptions are noted below.)"]}),"\n",(0,i.jsxs)(n.p,{children:["3. Defining, undefining, or ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})})," it as a ",(0,i.jsx)(s,{styled:!0,term:"macro",children:(0,i.jsx)("i",{children:"macro"})})," or ",(0,i.jsx)(n.em,{children:"compiler macro"}),". (Some exceptions are noted below.)"]}),"\n",(0,i.jsxs)(n.p,{children:["4. Defining it as a ",(0,i.jsx)(n.em,{children:"type specifier"})," (via ",(0,i.jsx)(s,{styled:!0,term:"defstruct",children:(0,i.jsx)("b",{children:"defstruct"})}),", ",(0,i.jsx)(s,{styled:!0,term:"defclass",children:(0,i.jsx)("b",{children:"defclass"})}),", ",(0,i.jsx)(s,{styled:!0,term:"deftype",children:(0,i.jsx)("b",{children:"deftype"})}),", ",(0,i.jsx)(s,{styled:!0,term:"define-condition",children:(0,i.jsx)("b",{children:"define-condition"})}),"). 5. Defining it as a structure (via ",(0,i.jsx)(s,{styled:!0,term:"defstruct",children:(0,i.jsx)("b",{children:"defstruct"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["6. Defining it as a ",(0,i.jsx)(s,{styled:!0,term:"declaration",children:(0,i.jsx)("i",{children:"declaration"})})," with a ",(0,i.jsx)(s,{styled:!0,term:"declaration",children:(0,i.jsx)("b",{children:"declaration"})})," ",(0,i.jsx)(s,{styled:!0,term:"proclamation",children:(0,i.jsx)("i",{children:"proclamation"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["7. Defining it as a ",(0,i.jsx)(n.em,{children:"symbol macro"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["8. Altering its ",(0,i.jsx)(n.em,{children:"home package"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["9. Tracing it (via ",(0,i.jsx)(s,{styled:!0,term:"trace",children:(0,i.jsx)("b",{children:"trace"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["10. Declaring or proclaiming it ",(0,i.jsx)(s,{styled:!0,term:"special",children:(0,i.jsx)("b",{children:"special"})})," (via ",(0,i.jsx)(s,{styled:!0,term:"declare",children:(0,i.jsx)("b",{children:"declare"})}),", ",(0,i.jsx)(s,{styled:!0,term:"declaim",children:(0,i.jsx)("b",{children:"declaim"})}),", or ",(0,i.jsx)(s,{styled:!0,term:"proclaim",children:(0,i.jsx)("b",{children:"proclaim"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["11. Declaring or proclaiming its ",(0,i.jsx)(s,{styled:!0,term:"type",children:(0,i.jsx)("b",{children:"type"})})," or ",(0,i.jsx)(s,{styled:!0,term:"ftype",children:(0,i.jsx)("b",{children:"ftype"})})," (via ",(0,i.jsx)(s,{styled:!0,term:"declare",children:(0,i.jsx)("b",{children:"declare"})}),", ",(0,i.jsx)(s,{styled:!0,term:"declaim",children:(0,i.jsx)("b",{children:"declaim"})}),", or ",(0,i.jsx)(s,{styled:!0,term:"proclaim",children:(0,i.jsx)("b",{children:"proclaim"})}),"). (Some exceptions are noted below.)"]}),"\n",(0,i.jsxs)(n.p,{children:["12. Removing it from the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["13. Defining a ",(0,i.jsx)(n.em,{children:"setf expander"})," for it (via ",(0,i.jsx)(s,{styled:!0,term:"defsetf",children:(0,i.jsx)("b",{children:"defsetf"})})," or ",(0,i.jsx)(n.strong,{children:"define-setf-method"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["14. Defining, undefining, or binding its ",(0,i.jsx)(n.em,{children:"setf function name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["15. Defining it as a ",(0,i.jsx)(n.em,{children:"method combination"})," type (via ",(0,i.jsx)(s,{styled:!0,term:"define-method-combination",children:(0,i.jsx)("b",{children:"define-method-combination"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["16. Using it as the class-name argument to ",(0,i.jsx)(s,{styled:!0,term:"setf",children:(0,i.jsx)("b",{children:"setf"})})," of ",(0,i.jsx)(s,{styled:!0,term:"find-class",children:(0,i.jsx)("b",{children:"find-class"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["17. Binding it as a ",(0,i.jsx)(n.em,{children:"catch tag"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["18. Binding it as a ",(0,i.jsx)(n.em,{children:"restart name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["19. Defining a ",(0,i.jsx)(s,{styled:!0,term:"method",children:(0,i.jsx)("i",{children:"method"})})," for a ",(0,i.jsx)(n.em,{children:"standardized generic function"})," which is ",(0,i.jsx)(s,{styled:!0,term:"applicable",children:(0,i.jsx)("i",{children:"applicable"})})," when all of the ",(0,i.jsx)(s,{styled:!0,term:"argument",children:(0,i.jsx)("i",{children:"arguments"})})," are ",(0,i.jsx)(n.em,{children:"direct instances"})," of ",(0,i.jsx)(n.em,{children:"standardized classes"}),"."]})]})}function E(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(P,{...e})}):P(e)}function I(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["If an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is not globally defined as a ",(0,i.jsx)(n.em,{children:"standardized dynamic variable"})," or ",(0,i.jsx)(n.em,{children:"constant variable"}),", it is allowed to lexically ",(0,i.jsx)(s,{styled:!0,term:"bind",children:(0,i.jsx)("i",{children:"bind"})})," it and to declare the ",(0,i.jsx)(s,{styled:!0,term:"type",children:(0,i.jsx)("b",{children:"type"})})," of that ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})}),", and it is allowed to locally ",(0,i.jsx)(s,{styled:!0,term:"establish",children:(0,i.jsx)("i",{children:"establish"})})," it as a ",(0,i.jsx)(n.em,{children:"symbol macro"})," (",(0,i.jsx)(n.em,{children:"e.g."}),", with ",(0,i.jsx)(s,{styled:!0,term:"symbol-macrolet",children:(0,i.jsx)("b",{children:"symbol-macrolet"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Unless explicitly specified otherwise, if an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is globally defined as a ",(0,i.jsx)(n.em,{children:"standardized dynamic variable"}),", it is permitted to ",(0,i.jsx)(s,{styled:!0,term:"bind",children:(0,i.jsx)("i",{children:"bind"})})," or ",(0,i.jsx)(s,{styled:!0,term:"assign",children:(0,i.jsx)("i",{children:"assign"})})," that ",(0,i.jsx)(n.em,{children:"dynamic variable"})," provided that the \u201cValue Type\u201d constraints on the ",(0,i.jsx)(n.em,{children:"dynamic variable"})," are maintained, and that the new ",(0,i.jsx)(s,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of the ",(0,i.jsx)(s,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," is consistent with the stated purpose of the ",(0,i.jsx)(s,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is not defined as a ",(0,i.jsx)(n.em,{children:"standardized function"}),", ",(0,i.jsx)(n.em,{children:"macro"}),", or ",(0,i.jsx)(n.em,{children:"special operator"})," , it is allowed to lexically ",(0,i.jsx)(s,{styled:!0,term:"bind",children:(0,i.jsx)("i",{children:"bind"})})," it as a ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," (",(0,i.jsx)(n.em,{children:"e.g."}),", with ",(0,i.jsx)(s,{styled:!0,term:"flet",children:(0,i.jsx)("b",{children:"flet"})}),"), to declare the ",(0,i.jsx)(s,{styled:!0,term:"ftype",children:(0,i.jsx)("b",{children:"ftype"})})," of that ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})}),", and (in ",(0,i.jsx)(s,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementations"})})," which provide the ability to do so) to ",(0,i.jsx)(s,{styled:!0,term:"trace",children:(0,i.jsx)("b",{children:"trace"})})," that ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is not defined as a ",(0,i.jsx)(n.em,{children:"standardized function"}),", ",(0,i.jsx)(n.em,{children:"macro"}),", or ",(0,i.jsx)(n.em,{children:"special operator"})," , it is allowed to lexically ",(0,i.jsx)(s,{styled:!0,term:"bind",children:(0,i.jsx)("i",{children:"bind"})})," it as a ",(0,i.jsx)(s,{styled:!0,term:"macro",children:(0,i.jsx)("i",{children:"macro"})})," (",(0,i.jsx)(n.em,{children:"e.g."}),", with ",(0,i.jsx)(s,{styled:!0,term:"macrolet",children:(0,i.jsx)("b",{children:"macrolet"})}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["If an ",(0,i.jsx)(n.em,{children:"external symbol"})," of the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is not defined as a ",(0,i.jsx)(n.em,{children:"standardized function"}),", ",(0,i.jsx)(n.em,{children:"macro"}),", or ",(0,i.jsx)(n.em,{children:"special operator"})," , it is allowed to lexically ",(0,i.jsx)(s,{styled:!0,term:"bind",children:(0,i.jsx)("i",{children:"bind"})})," its ",(0,i.jsx)(n.em,{children:"setf function name"})," as a ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})}),", and to declare the ",(0,i.jsx)(s,{styled:!0,term:"ftype",children:(0,i.jsx)("b",{children:"ftype"})})," of that ",(0,i.jsx)(s,{styled:!0,term:"binding",children:(0,i.jsx)("i",{children:"binding"})}),"."]})]})}function N(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(I,{...e})}):I(e)}function T(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(n.p,{children:["The COMMON-LISP-USER ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is the ",(0,i.jsx)(n.em,{children:"current package"})," when a Common Lisp system starts up. This ",(0,i.jsx)(n.em,{children:"package uses"})," the COMMON-LISP ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),". The COMMON-LISP-USER ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," has the ",(0,i.jsx)(s,{styled:!0,term:"nickname",children:(0,i.jsx)("i",{children:"nickname"})})," CL-USER. The COMMON-LISP-USER ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," can have additional ",(0,i.jsx)(n.em,{children:"symbols interned"})," within it; it can ",(0,i.jsx)(s,{styled:!0,term:"use",children:(0,i.jsx)("i",{children:"use"})})," other ",(0,i.jsx)(n.em,{children:"implementation-defined packages"}),"."]})}function D(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(T,{...e})}):T(e)}function F(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," contains ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),", called ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("i",{children:"keywords"})}),(0,i.jsx)("sub",{children:"1"}),", that are typically used as special markers in ",(0,i.jsx)(s,{styled:!0,term:"program",children:(0,i.jsx)("i",{children:"programs"})})," and their associated data ",(0,i.jsx)(s,{styled:!0,term:"expression",children:(0,i.jsx)("i",{children:"expressions"})}),(0,i.jsx)("sub",{children:"1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Symbol tokens"})," that start with a ",(0,i.jsx)(n.em,{children:"package marker"})," are parsed by the ",(0,i.jsx)(n.em,{children:"Lisp reader"})," as ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," in the KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"; see Section 2.3.4 (Symbols as Tokens). This makes it notationally convenient to use ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("i",{children:"keywords"})})," when communicating between programs in different ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})}),". For example, the mechanism for passing ",(0,i.jsx)(n.em,{children:"keyword parameters"})," in a ",(0,i.jsx)(s,{styled:!0,term:"call",children:(0,i.jsx)("i",{children:"call"})})," uses ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("i",{children:"keywords"})}),(0,i.jsx)("sub",{children:"1"})," to name the corresponding ",(0,i.jsx)(s,{styled:!0,term:"argument",children:(0,i.jsx)("i",{children:"arguments"})}),"; see Section 3.4.1 (Ordinary Lambda Lists)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"Symbols"})})," in the KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," are, by definition, of ",(0,i.jsx)(s,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})})," ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("b",{children:"keyword"})}),"."]})]})}function A(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(F,{...e})}):F(e)}function R(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(n.p,{children:["The KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," is treated differently than other ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})})," in that special actions are taken when a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(s,{styled:!0,term:"interned",children:(0,i.jsx)("i",{children:"interned"})})," in it. In particular, when a ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(s,{styled:!0,term:"interned",children:(0,i.jsx)("i",{children:"interned"})})," in the KEYWORD ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", it is automatically made to be an ",(0,i.jsx)(n.em,{children:"external symbol"})," and is automatically made to be a ",(0,i.jsx)(n.em,{children:"constant variable"})," with itself as a ",(0,i.jsx)(s,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})}),"."]})}function W(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(R,{...e})}):R(e)}function z(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["It is generally best to confine the use of ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("i",{children:"keywords"})})," to situations in which there are a finitely enumerable set of names to be selected between. For example, if there were two states of a light switch, they might be called ",":on"," and ",":off","."]}),"\n",(0,i.jsxs)(n.p,{children:["In situations where the set of names is not finitely enumerable (",(0,i.jsx)(n.em,{children:"i.e."}),", where name conflicts might arise) it is frequently best to use ",(0,i.jsx)(s,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," in some ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," other than KEYWORD so that conflicts will be naturally avoided. For example, it is generally not wise for a ",(0,i.jsx)(s,{styled:!0,term:"program",children:(0,i.jsx)("i",{children:"program"})})," to use a ",(0,i.jsx)(s,{styled:!0,term:"keyword",children:(0,i.jsx)("i",{children:"keyword"})})," ",(0,i.jsx)("sub",{children:"1"})," as a ",(0,i.jsx)(n.em,{children:"property indicator"})," , since if there were ever another ",(0,i.jsx)(s,{styled:!0,term:"program",children:(0,i.jsx)("i",{children:"program"})})," that did the same thing, each would clobber the other\u2019s data."]})]})}function K(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(z,{...e})}):z(e)}function Y(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Other, ",(0,i.jsx)(n.em,{children:"implementation-defined packages"})," might be present in the initial Common Lisp environment."]}),"\n",(0,i.jsxs)(n.p,{children:["It is recommended, but not required, that the documentation for a ",(0,i.jsx)(n.em,{children:"conforming implementation"})," contain a full list of all ",(0,i.jsx)(s,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})})," names initially present in that ",(0,i.jsx)(s,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," but not specified in this specification. (See also the ",(0,i.jsx)(s,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"function"})})," ",(0,i.jsx)(s,{styled:!0,term:"list-all-packages",children:(0,i.jsx)("b",{children:"list-all-packages"})}),".)"]})]})}function U(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(Y,{...e})}):Y(e)}const q={title:"11.1 Package Concepts"},_="11.1 Package Concepts",B={id:"chap-11/bb-b-package-concepts",title:"11.1 Package Concepts",description:"11.1.1 Introduction to Packages",source:"@site/docs/chap-11/bb-b-package-concepts.md",sourceDirName:"chap-11",slug:"/chap-11/bb-b-package-concepts",permalink:"/cl-language-reference/chap-11/bb-b-package-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-11/bb-b-package-concepts.md",tags:[],version:"current",frontMatter:{title:"11.1 Package Concepts"},sidebar:"tutorialSidebar",previous:{title:"11. Packages",permalink:"/cl-language-reference/category/11-packages"},next:{title:"11.2 Packages Dictionary",permalink:"/cl-language-reference/category/112-packages-dictionary"}},H={},G=[{value:"11.1.1 Introduction to Packages",id:"1111-introduction-to-packages",level:2},{value:"11.1.1.1 Package Names and Nicknames",id:"11111-package-names-and-nicknames",level:3},{value:"11.1.1.2 Symbols in a Package",id:"11112-symbols-in-a-package",level:3},{value:"11.1.1.2.1 Internal and External Symbols",id:"111121-internal-and-external-symbols",level:4},{value:"11.1.1.2.2 Package Inheritance",id:"111122-package-inheritance",level:4},{value:"11.1.1.2.3 Accessibility of Symbols in a Package",id:"111123-accessibility-of-symbols-in-a-package",level:4},{value:"11.1.1.2.4 Locating a Symbol in a Package",id:"111124-locating-a-symbol-in-a-package",level:4},{value:"11.1.1.2.5 Prevention of Name Conflicts in Packages",id:"111125-prevention-of-name-conflicts-in-packages",level:4},{value:"11.1.2 Standardized Packages",id:"1112-standardized-packages",level:2},{value:"11.1.2.1 The COMMON",id:"11121-the-common",level:3},{value:"11.1.2.1.1 Constraints on the COMMON",id:"111211-constraints-on-the-common",level:4},{value:"11.1.2.1.2 Constraints on the COMMON",id:"111212-constraints-on-the-common",level:4},{value:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON",id:"1112121-some-exceptions-to-constraints-on-the-common",level:5},{value:"11.1.2.2 The COMMON",id:"11122-the-common",level:3},{value:"11.1.2.3 The KEYWORD Package",id:"11123-the-keyword-package",level:3},{value:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package",id:"111231-interning-a-symbol-in-the-keyword-package",level:4},{value:"11.1.2.3.2 Notes about The KEYWORD Package",id:"111232-notes-about-the-keyword-package",level:4},{value:"11.1.2.4 Implementation",id:"11124-implementation",level:3}];function V(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"111-package-concepts",children:"11.1 Package Concepts"}),"\n","\n",(0,i.jsx)(l,{}),"\n",(0,i.jsx)(n.h2,{id:"1111-introduction-to-packages",children:"11.1.1 Introduction to Packages"}),"\n","\n",(0,i.jsx)(d,{}),"\n",(0,i.jsx)(n.h3,{id:"11111-package-names-and-nicknames",children:"11.1.1.1 Package Names and Nicknames"}),"\n","\n",(0,i.jsx)(o,{}),"\n",(0,i.jsx)(n.h3,{id:"11112-symbols-in-a-package",children:"11.1.1.2 Symbols in a Package"}),"\n","\n",(0,i.jsx)(m,{}),"\n",(0,i.jsx)(n.h4,{id:"111121-internal-and-external-symbols",children:"11.1.1.2.1 Internal and External Symbols"}),"\n","\n",(0,i.jsx)(j,{}),"\n",(0,i.jsx)(n.h4,{id:"111122-package-inheritance",children:"11.1.1.2.2 Package Inheritance"}),"\n","\n",(0,i.jsx)(y,{}),"\n",(0,i.jsx)(n.h4,{id:"111123-accessibility-of-symbols-in-a-package",children:"11.1.1.2.3 Accessibility of Symbols in a Package"}),"\n","\n",(0,i.jsx)(b,{}),"\n",(0,i.jsx)(n.h4,{id:"111124-locating-a-symbol-in-a-package",children:"11.1.1.2.4 Locating a Symbol in a Package"}),"\n","\n",(0,i.jsx)(f,{}),"\n",(0,i.jsx)(n.h4,{id:"111125-prevention-of-name-conflicts-in-packages",children:"11.1.1.2.5 Prevention of Name Conflicts in Packages"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(n.h2,{id:"1112-standardized-packages",children:"11.1.2 Standardized Packages"}),"\n","\n",(0,i.jsx)(C,{}),"\n",(0,i.jsx)(n.h3,{id:"11121-the-common",children:"11.1.2.1 The COMMON"}),"\n","\n",(0,i.jsx)(M,{}),"\n",(0,i.jsx)(n.h4,{id:"111211-constraints-on-the-common",children:"11.1.2.1.1 Constraints on the COMMON"}),"\n","\n",(0,i.jsx)(S,{}),"\n",(0,i.jsx)(n.h4,{id:"111212-constraints-on-the-common",children:"11.1.2.1.2 Constraints on the COMMON"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(n.h5,{id:"1112121-some-exceptions-to-constraints-on-the-common",children:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON"}),"\n","\n",(0,i.jsx)(N,{}),"\n",(0,i.jsx)(n.h3,{id:"11122-the-common",children:"11.1.2.2 The COMMON"}),"\n","\n",(0,i.jsx)(D,{}),"\n",(0,i.jsx)(n.h3,{id:"11123-the-keyword-package",children:"11.1.2.3 The KEYWORD Package"}),"\n","\n",(0,i.jsx)(A,{}),"\n",(0,i.jsx)(n.h4,{id:"111231-interning-a-symbol-in-the-keyword-package",children:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package"}),"\n","\n",(0,i.jsx)(W,{}),"\n",(0,i.jsx)(n.h4,{id:"111232-notes-about-the-keyword-package",children:"11.1.2.3.2 Notes about The KEYWORD Package"}),"\n","\n",(0,i.jsx)(K,{}),"\n",(0,i.jsx)(n.h3,{id:"11124-implementation",children:"11.1.2.4 Implementation"}),"\n","\n","\n",(0,i.jsx)(U,{})]})}function Z(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(V,{...e})}):V(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>l});var i=s(67294);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);