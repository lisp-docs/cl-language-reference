"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[17340],{28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var r=i(96540);const s={},t=r.createContext(s);function c(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(t.Provider,{value:n},e.children)}},35432:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>re,contentTitle:()=>ie,default:()=>ce,frontMatter:()=>ne,metadata:()=>r,toc:()=>se});const r=JSON.parse('{"id":"chap-11/bb-b-package-concepts","title":"11.1 Package Concepts","description":"11.1.1 Introduction to Packages","source":"@site/docs/chap-11/bb-b-package-concepts.md","sourceDirName":"chap-11","slug":"/chap-11/bb-b-package-concepts","permalink":"/cl-language-reference/chap-11/bb-b-package-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-11/bb-b-package-concepts.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"11.1 Package Concepts"},"sidebar":"tutorialSidebar","previous":{"title":"unbound-variable","permalink":"/cl-language-reference/chap-10/ba-c-dictionary/unbound-variable_condition-type"},"next":{"title":"11.2 Packages Dictionary","permalink":"/cl-language-reference/category/112-packages-dictionary"}}');var s=i(74848),t=i(28453);function c(e){return(0,s.jsx)(s.Fragment,{})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c()}function a(e){const n={em:"em",p:"p",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||o("DictionaryLink",!0),r||o("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," establishes a mapping from names to ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),". At any given time, one ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is current. The ",(0,s.jsx)(r,{styled:!0,term:"current package",children:(0,s.jsx)("i",{children:"current package"})})," is the one that is the ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," of ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("b",{children:"*package*"})}),". When using the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," , it is possible to refer to ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," in ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," other than the current one through the use of ",(0,s.jsx)(n.em,{children:"package prefixes"})," in the printed representation of the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 11\u20131 lists some ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," that are applicable to ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})}),". Where an ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," takes an argument that is either a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," or a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),", an argument of ",(0,s.jsx)(i,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})})," is treated as an empty ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),". Any ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," argument may be either a ",(0,s.jsx)(r,{term:"string",children:(0,s.jsx)("i",{children:"string"})}),", a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", or a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". If a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is supplied, its name will be used as the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," name."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"*modules* import provide *package* in-package rename-package defpackage intern require do-all-symbols list-all-packages shadow do-external-symbols make-package shadowing-import do-symbols package-name unexport export package-nicknames unintern find-all-symbols package-shadowing-symbols unuse-package find-package package-use-list use-package find-symbol package-used-by-list"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 11\u20131. Some Defined Names related to Packages"})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}function o(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function h(e){const n={p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||x("DictionaryLink",!0),r||x("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," has a ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," (a ",(0,s.jsx)(r,{term:"string",children:(0,s.jsx)("i",{children:"string"})}),") and perhaps some ",(0,s.jsx)(r,{term:"nickname",children:(0,s.jsx)("i",{children:"nicknames"})})," (also ",(0,s.jsx)(r,{term:"string",children:(0,s.jsx)("i",{children:"strings"})}),"). These are assigned when the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is created and can be changed later."]}),"\n",(0,s.jsxs)(n.p,{children:["There is a single namespace for ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})}),". The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"find-package",children:(0,s.jsx)("b",{children:"find-package"})})," translates a package ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," or ",(0,s.jsx)(r,{term:"nickname",children:(0,s.jsx)("i",{children:"nickname"})})," into the associated ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"package-name",children:(0,s.jsx)("b",{children:"package-name"})})," returns the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"package-nicknames",children:(0,s.jsx)("b",{children:"package-nicknames"})})," returns a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of all ",(0,s.jsx)(r,{term:"nickname",children:(0,s.jsx)("i",{children:"nicknames"})})," for a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". ",(0,s.jsx)(i,{term:"rename-package",children:(0,s.jsx)("b",{children:"rename-package"})})]}),"\n",(0,s.jsxs)(n.p,{children:["removes a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"\u2019s current ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," and ",(0,s.jsx)(r,{term:"nickname",children:(0,s.jsx)("i",{children:"nicknames"})})," and replaces them with new ones specified by the caller."]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}function x(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function j(e){return(0,s.jsx)(s.Fragment,{})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j()}function g(e){const n={p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The mappings in a ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," are divided into two classes, external and internal. The ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," targeted by these different mappings are called ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," and ",(0,s.jsx)(i,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbols"})})," of the ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". Within a ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", a name refers to one ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," or to none; if it does refer to a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", then it is either external or internal in that ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", but not both. ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"External symbols"})})," are part of the package\u2019s public interface to other ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"packages"})}),". ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"Symbols"})})," become ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," of a given ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," if they have been ",(0,s.jsx)(i,{term:"exported",children:(0,s.jsx)("i",{children:"exported"})})," from that ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," has the same ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," no matter what ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," it is ",(0,s.jsx)(i,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," in, but it might be an ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of some ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," and an ",(0,s.jsx)(i,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbol"})})," of others."]})]})}function b(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}function y(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||k("DictionaryLink",!0),r||k("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"Packages"})})," can be built up in layers. From one point of view, a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is a single collection of mappings from ",(0,s.jsx)(r,{term:"string",children:(0,s.jsx)("i",{children:"strings"})})," into ",(0,s.jsx)(r,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbols"})})," and ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})}),". However, some of these mappings might be established within the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," itself, while other mappings are inherited from other ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," via ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),". A ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is said to be ",(0,s.jsx)(r,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," in a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," if the mapping is in the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," itself and is not inherited from somewhere else."]}),"\n",(0,s.jsxs)(n.p,{children:["There is no way to inherit the ",(0,s.jsx)(r,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbols"})})," of another ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"; to refer to an ",(0,s.jsx)(r,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbol"})})," using the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," , a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," containing the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," must be made to be the ",(0,s.jsx)(r,{styled:!0,term:"current package",children:(0,s.jsx)("i",{children:"current package"})}),", a ",(0,s.jsx)(r,{styled:!0,term:"package prefix",children:(0,s.jsx)("i",{children:"package prefix"})})," must be used, or the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," must be ",(0,s.jsx)(n.em,{children:"imported"})," into the ",(0,s.jsx)(r,{styled:!0,term:"current package",children:(0,s.jsx)("i",{children:"current package"})}),"."]})]})}function f(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function k(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function u(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||v("DictionaryLink",!0),r||v("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," becomes ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," in a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," if that is its ",(0,s.jsx)(r,{styled:!0,term:"home package",children:(0,s.jsx)("i",{children:"home package"})})," when it is created, or if it is ",(0,s.jsx)(n.em,{children:"imported"})," into that ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", or by inheritance via ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," in a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", it can be referred to when using the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," without a ",(0,s.jsx)(r,{styled:!0,term:"package prefix",children:(0,s.jsx)("i",{children:"package prefix"})})," when that ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is the ",(0,s.jsx)(r,{styled:!0,term:"current package",children:(0,s.jsx)("i",{children:"current package"})}),", regardless of whether it is ",(0,s.jsx)(r,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," or inherited."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"Symbols"})})," from one ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," can be made ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," in another ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," in two ways."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 Any individual ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," can be added to a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," by use of ",(0,s.jsx)(i,{term:"import",children:(0,s.jsx)("b",{children:"import"})}),". After the call to ",(0,s.jsx)(i,{term:"import",children:(0,s.jsx)("b",{children:"import"})})," the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(r,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," in the importing ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". The status of the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," in the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," it came from (if any) is unchanged, and the ",(0,s.jsx)(r,{styled:!0,term:"home package",children:(0,s.jsx)("i",{children:"home package"})})," for this ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is unchanged. Once ",(0,s.jsx)(n.em,{children:"imported"}),", a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(r,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," in the importing ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," and can be removed only by calling ",(0,s.jsx)(i,{term:"unintern",children:(0,s.jsx)("b",{children:"unintern"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(n.em,{children:"shadowed"})," ",(0,s.jsx)("sub",{children:"3"})," by another ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," in some ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," if the first ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," would be ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," by inheritance if not for the presence of the second ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),". See ",(0,s.jsx)(i,{term:"shadowing-import",children:(0,s.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 The second mechanism for making ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," from one ",(0,s.jsx)(n.em,{children:"package accessible"})," in another is provided by ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),". All of the ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," of the used ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," are inherited"]}),"\n",(0,s.jsxs)(n.p,{children:["by the using ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"unuse-package",children:(0,s.jsx)("b",{children:"unuse-package"})})," undoes the effects of a previous ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),"."]})]})}function w(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}function v(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function O(e){const n={p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is to be located in a given ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," the following occurs:"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 The ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," and ",(0,s.jsx)(i,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbols"})})," of the ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," are searched for the ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 The ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," of the used ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," are searched in some unspecified order. The order does not matter; see the rules for handling name conflicts listed below."]})]})}function M(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}function T(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||P("DictionaryLink",!0),r||P("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Within one ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", any particular name can refer to at most one ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),". A name conflict is said to occur when there would be more than one candidate ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),". Any time a name conflict is about to occur, a ",(0,s.jsx)(n.em,{children:"correctable error"})," is signaled."]}),"\n",(0,s.jsx)(n.p,{children:"The following rules apply to name conflicts:"}),"\n",(0,s.jsx)(n.p,{children:"\u2013 Name conflicts are detected when they become possible, that is, when the package structure is altered. Name conflicts are not checked during every name lookup."}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 If the ",(0,s.jsx)(n.em,{children:"same symbol"})," is ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," to a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," through more than one path, there is no name conflict. A ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," cannot conflict with itself. Name conflicts occur only between ",(0,s.jsx)(n.em,{children:"distinct symbols"})," with the same name (under ",(0,s.jsx)(i,{term:"string",children:(0,s.jsx)("b",{children:"string="})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 Every ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," has a list of shadowing ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),". A shadowing ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," takes precedence over any other ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," of the same name that would otherwise be ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," in the ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". A name conflict involving a shadowing symbol is always resolved in favor of the shadowing ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", without signaling an error (except for one exception involving ",(0,s.jsx)(i,{term:"import",children:(0,s.jsx)("b",{children:"import"})}),"). See ",(0,s.jsx)(i,{term:"shadow",children:(0,s.jsx)("b",{children:"shadow"})})," and ",(0,s.jsx)(i,{term:"shadowing-import",children:(0,s.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 The functions ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),", ",(0,s.jsx)(i,{term:"import",children:(0,s.jsx)("b",{children:"import"})}),", and ",(0,s.jsx)(i,{term:"export",children:(0,s.jsx)("b",{children:"export"})})," check for name conflicts."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 ",(0,s.jsx)(i,{term:"shadow",children:(0,s.jsx)("b",{children:"shadow"})})," and ",(0,s.jsx)(i,{term:"shadowing-import",children:(0,s.jsx)("b",{children:"shadowing-import"})})," never signal a name-conflict error."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 ",(0,s.jsx)(i,{term:"unuse-package",children:(0,s.jsx)("b",{children:"unuse-package"})})," and ",(0,s.jsx)(i,{term:"unexport",children:(0,s.jsx)("b",{children:"unexport"})})," do not need to do any name-conflict checking. ",(0,s.jsx)(i,{term:"unintern",children:(0,s.jsx)("b",{children:"unintern"})})," does name-conflict checking only when a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," being ",(0,s.jsx)(r,{term:"uninterned",children:(0,s.jsx)("i",{children:"uninterned"})})," is a ",(0,s.jsx)(r,{styled:!0,term:"shadowing symbol",children:(0,s.jsx)("i",{children:"shadowing symbol"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 Giving a shadowing symbol to ",(0,s.jsx)(i,{term:"unintern",children:(0,s.jsx)("b",{children:"unintern"})})," can uncover a name conflict that had previously been resolved by the shadowing."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 Package functions signal name-conflict errors of ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{term:"package-error",children:(0,s.jsx)("b",{children:"package-error"})})," before making any change to the package structure. When multiple changes are to be made, it is permissible for the implementation to process each change separately. For example, when ",(0,s.jsx)(i,{term:"export",children:(0,s.jsx)("b",{children:"export"})})," is"]}),"\n",(0,s.jsxs)(n.p,{children:["given a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),", aborting from a name conflict caused by the second ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," in the ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," might still export the first ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," in the ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})}),". However, a name-conflict error caused by ",(0,s.jsx)(i,{term:"export",children:(0,s.jsx)("b",{children:"export"})})," of a single ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," will be signaled before that ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,s.jsx)(r,{term:"accessibility",children:(0,s.jsx)("i",{children:"accessibility"})})," in any ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is changed."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 Continuing from a name-conflict error must offer the user a chance to resolve the name conflict in favor of either of the candidates. The ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," structure should be altered to reflect the resolution of the name conflict, via ",(0,s.jsx)(i,{term:"shadowing-import",children:(0,s.jsx)("b",{children:"shadowing-import"})}),", ",(0,s.jsx)(i,{term:"unintern",children:(0,s.jsx)("b",{children:"unintern"})}),", or ",(0,s.jsx)(i,{term:"unexport",children:(0,s.jsx)("b",{children:"unexport"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})})," between a ",(0,s.jsx)(n.em,{children:"symbol present"})," in the using ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," and an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the used ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is resolved in favor of the first ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," by making it a shadowing ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", or in favor of the second ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," by uninterning the first ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," from the using ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,s.jsx)(i,{term:"export",children:(0,s.jsx)("b",{children:"export"})})," or ",(0,s.jsx)(i,{term:"unintern",children:(0,s.jsx)("b",{children:"unintern"})})," due to a ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"\u2019s inheriting two ",(0,s.jsx)(n.em,{children:"distinct symbols"})," with the ",(0,s.jsx)(n.em,{children:"same name"})," (under ",(0,s.jsx)(i,{term:"string",children:(0,s.jsx)("b",{children:"string="})}),") from two other ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," can be resolved in favor of either ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," by importing it into the using ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," and making it a ",(0,s.jsx)(r,{styled:!0,term:"shadowing symbol",children:(0,s.jsx)("i",{children:"shadowing symbol"})}),", just as with ",(0,s.jsx)(i,{term:"use-package",children:(0,s.jsx)("b",{children:"use-package"})}),"."]})]})}function S(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(T,{...e})}):T(e)}function P(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function L(e){const n={em:"em",p:"p",strong:"strong",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This section describes the ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," that are available in every ",(0,s.jsx)(i,{styled:!0,term:"conforming implementation",children:(0,s.jsx)("i",{children:"conforming implementation"})}),". A summary of the ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"names"})})," and ",(0,s.jsx)(i,{term:"nickname",children:(0,s.jsx)("i",{children:"nicknames"})})," of those ",(0,s.jsx)(n.em,{children:"standardized packages"})," is given in Figure 11\u20132."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"Name Nicknames"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)("p",{children:"COMMON-LISP CL "}),(0,s.jsx)("p",{children:"COMMON-LISP-USER CL-USER "}),(0,s.jsxs)("p",{children:["KEYWORD ",(0,s.jsx)(n.em,{children:"none"})]}),"|"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 11\u20132. Standardized Package Names"})})]})}function C(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(L,{...e})}):L(e)}function E(e){const n={p:"p",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||N("DictionaryLink",!0),r||N("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," contains the primitives of the Common Lisp system as defined by this specification. Its ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," include all of the ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," (except for ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," in the KEYWORD ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),") that are present in the Common Lisp system, such as ",(0,s.jsx)(i,{term:"car",children:(0,s.jsx)("b",{children:"car"})}),", ",(0,s.jsx)(i,{term:"cdr",children:(0,s.jsx)("b",{children:"cdr"})}),", ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("b",{children:"*package*"})}),", etc. The COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," has the ",(0,s.jsx)(r,{term:"nickname",children:(0,s.jsx)("i",{children:"nickname"})})," CL."]}),"\n",(0,s.jsxs)(n.p,{children:["The COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," has as ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," those symbols enumerated in the figures in Section 1.9 (Symbols in the COMMON-LISP Package), and no others. These ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," are ",(0,s.jsx)(r,{term:"present",children:(0,s.jsx)("i",{children:"present"})})," in the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," but their ",(0,s.jsx)(r,{styled:!0,term:"home package",children:(0,s.jsx)("i",{children:"home package"})})," need not be the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the symbol HELP cannot be an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," because it is not mentioned in Section 1.9 (Symbols in the COMMON-LISP Package). In contrast, the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"variable"})," must be an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," even though it has no definition because it is listed in that section (to support its use as a valid second ",(0,s.jsx)(r,{term:"argument",children:(0,s.jsx)("i",{children:"argument"})})," to the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(n.strong,{children:"documentation"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["The COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," can have additional ",(0,s.jsx)(r,{styled:!0,term:"internal symbol",children:(0,s.jsx)("i",{children:"internal symbols"})}),"."]})]})}function R(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(E,{...e})}):E(e)}function N(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function I(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||G("DictionaryLink",!0),r||G("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In a ",(0,s.jsx)(r,{styled:!0,term:"conforming implementation",children:(0,s.jsx)("i",{children:"conforming implementation"})}),", an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," can have a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),", ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),", or ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," definition, a ",(0,s.jsx)(r,{styled:!0,term:"global variable",children:(0,s.jsx)("i",{children:"global variable"})})," definition (or other status as a ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," due to a ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})})," ",(0,s.jsx)(r,{term:"proclamation",children:(0,s.jsx)("i",{children:"proclamation"})}),"), or a ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," definition only if explicitly permitted in this standard. For example, ",(0,s.jsx)(i,{term:"fboundp",children:(0,s.jsx)("b",{children:"fboundp"})})," ",(0,s.jsx)(n.em,{children:"yields false"})," for any ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," that is not the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(n.em,{children:"standardized function"}),", ",(0,s.jsx)(r,{styled:!0,term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," or ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," , and ",(0,s.jsx)(i,{term:"boundp",children:(0,s.jsx)("b",{children:"boundp"})})," returns ",(0,s.jsx)(r,{term:"false",children:(0,s.jsx)("i",{children:"false"})})," for any ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," that is not the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(n.em,{children:"standardized global variable"}),". It also follows that ",(0,s.jsx)(r,{styled:!0,term:"conforming program",children:(0,s.jsx)("i",{children:"conforming programs"})})," can use ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbols"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," as the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"names"})})," of local ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variables"})})," with confidence that those ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"names"})})," have not been ",(0,s.jsx)(n.em,{children:"proclaimed"})," ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})})," by the ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})})," unless those ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," are ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"names"})})," of ",(0,s.jsx)(n.em,{children:"standardized global variables"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"conforming implementation",children:(0,s.jsx)("i",{children:"conforming implementation"})})," must not place any ",(0,s.jsx)(r,{term:"property",children:(0,s.jsx)("i",{children:"property"})})," on an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," using a ",(0,s.jsx)(r,{styled:!0,term:"property indicator",children:(0,s.jsx)("i",{children:"property indicator"})})," that is either an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of any ",(0,s.jsx)(n.em,{children:"standardized package"})," or a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," that is otherwise ",(0,s.jsx)(r,{term:"accessible",children:(0,s.jsx)("i",{children:"accessible"})})," in the COMMON-LISP-USER ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"."]})]})}function D(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(I,{...e})}):I(e)}function G(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function F(e){const n={em:"em",p:"p",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||W("DictionaryLink",!0),r||W("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Except where explicitly allowed, the consequences are undefined if any of the following actions are performed on an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["1. ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"Binding"})})," or altering its value (lexically or dynamically). (Some exceptions are noted below.) 2. Defining, undefining, or ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," it as a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),". (Some exceptions are noted below.)"]}),"\n",(0,s.jsxs)(n.p,{children:["3. Defining, undefining, or ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," it as a ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," or ",(0,s.jsx)(r,{styled:!0,term:"compiler macro",children:(0,s.jsx)("i",{children:"compiler macro"})}),". (Some exceptions are noted below.)"]}),"\n",(0,s.jsxs)(n.p,{children:["4. Defining it as a ",(0,s.jsx)(r,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," (via ",(0,s.jsx)(i,{term:"defstruct",children:(0,s.jsx)("b",{children:"defstruct"})}),", ",(0,s.jsx)(i,{term:"defclass",children:(0,s.jsx)("b",{children:"defclass"})}),", ",(0,s.jsx)(i,{term:"deftype",children:(0,s.jsx)("b",{children:"deftype"})}),", ",(0,s.jsx)(i,{term:"define-condition",children:(0,s.jsx)("b",{children:"define-condition"})}),"). 5. Defining it as a structure (via ",(0,s.jsx)(i,{term:"defstruct",children:(0,s.jsx)("b",{children:"defstruct"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["6. Defining it as a ",(0,s.jsx)(r,{term:"declaration",children:(0,s.jsx)("i",{children:"declaration"})})," with a ",(0,s.jsx)(i,{term:"declaration",children:(0,s.jsx)("b",{children:"declaration"})})," ",(0,s.jsx)(r,{term:"proclamation",children:(0,s.jsx)("i",{children:"proclamation"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["7. Defining it as a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["8. Altering its ",(0,s.jsx)(r,{styled:!0,term:"home package",children:(0,s.jsx)("i",{children:"home package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["9. Tracing it (via ",(0,s.jsx)(i,{term:"trace",children:(0,s.jsx)("b",{children:"trace"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["10. Declaring or proclaiming it ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})})," (via ",(0,s.jsx)(i,{term:"declare",children:(0,s.jsx)("b",{children:"declare"})}),", ",(0,s.jsx)(i,{term:"declaim",children:(0,s.jsx)("b",{children:"declaim"})}),", or ",(0,s.jsx)(i,{term:"proclaim",children:(0,s.jsx)("b",{children:"proclaim"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["11. Declaring or proclaiming its ",(0,s.jsx)(i,{term:"type",children:(0,s.jsx)("b",{children:"type"})})," or ",(0,s.jsx)(i,{term:"ftype",children:(0,s.jsx)("b",{children:"ftype"})})," (via ",(0,s.jsx)(i,{term:"declare",children:(0,s.jsx)("b",{children:"declare"})}),", ",(0,s.jsx)(i,{term:"declaim",children:(0,s.jsx)("b",{children:"declaim"})}),", or ",(0,s.jsx)(i,{term:"proclaim",children:(0,s.jsx)("b",{children:"proclaim"})}),"). (Some exceptions are noted below.)"]}),"\n",(0,s.jsxs)(n.p,{children:["12. Removing it from the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["13. Defining a ",(0,s.jsx)(r,{styled:!0,term:"setf expander",children:(0,s.jsx)("i",{children:"setf expander"})})," for it (via ",(0,s.jsx)(i,{term:"defsetf",children:(0,s.jsx)("b",{children:"defsetf"})})," or ",(0,s.jsx)(n.strong,{children:"define-setf-method"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["14. Defining, undefining, or binding its ",(0,s.jsx)(r,{styled:!0,term:"setf function name",children:(0,s.jsx)("i",{children:"setf function name"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["15. Defining it as a ",(0,s.jsx)(r,{styled:!0,term:"method combination",children:(0,s.jsx)("i",{children:"method combination"})})," type (via ",(0,s.jsx)(i,{term:"define-method-combination",children:(0,s.jsx)("b",{children:"define-method-combination"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["16. Using it as the class-name argument to ",(0,s.jsx)(i,{term:"setf",children:(0,s.jsx)("b",{children:"setf"})})," of ",(0,s.jsx)(i,{term:"find-class",children:(0,s.jsx)("b",{children:"find-class"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["17. Binding it as a ",(0,s.jsx)(r,{styled:!0,term:"catch tag",children:(0,s.jsx)("i",{children:"catch tag"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["18. Binding it as a ",(0,s.jsx)(n.em,{children:"restart name"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["19. Defining a ",(0,s.jsx)(r,{term:"method",children:(0,s.jsx)("i",{children:"method"})})," for a ",(0,s.jsx)(n.em,{children:"standardized generic function"})," which is ",(0,s.jsx)(r,{term:"applicable",children:(0,s.jsx)("i",{children:"applicable"})})," when all of the ",(0,s.jsx)(r,{term:"argument",children:(0,s.jsx)("i",{children:"arguments"})})," are ",(0,s.jsx)(r,{styled:!0,term:"direct instance",children:(0,s.jsx)("i",{children:"direct instances"})})," of ",(0,s.jsx)(n.em,{children:"standardized classes"}),"."]})]})}function A(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(F,{...e})}):F(e)}function W(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function z(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||Y("DictionaryLink",!0),r||Y("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is not globally defined as a ",(0,s.jsx)(n.em,{children:"standardized dynamic variable"})," or ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variable"})}),", it is allowed to lexically ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"bind"})})," it and to declare the ",(0,s.jsx)(i,{term:"type",children:(0,s.jsx)("b",{children:"type"})})," of that ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),", and it is allowed to locally ",(0,s.jsx)(r,{term:"establish",children:(0,s.jsx)("i",{children:"establish"})})," it as a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})})," (",(0,s.jsx)(n.em,{children:"e.g."}),", with ",(0,s.jsx)(i,{term:"symbol-macrolet",children:(0,s.jsx)("b",{children:"symbol-macrolet"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Unless explicitly specified otherwise, if an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is globally defined as a ",(0,s.jsx)(n.em,{children:"standardized dynamic variable"}),", it is permitted to ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"bind"})})," or ",(0,s.jsx)(r,{term:"assign",children:(0,s.jsx)("i",{children:"assign"})})," that ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," provided that the \u201cValue Type\u201d constraints on the ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," are maintained, and that the new ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," of the ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," is consistent with the stated purpose of the ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is not defined as a ",(0,s.jsx)(n.em,{children:"standardized function"}),", ",(0,s.jsx)(r,{styled:!0,term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),", or ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"bind"})})," it as a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," (",(0,s.jsx)(n.em,{children:"e.g."}),", with ",(0,s.jsx)(i,{term:"flet",children:(0,s.jsx)("b",{children:"flet"})}),"), to declare the ",(0,s.jsx)(i,{term:"ftype",children:(0,s.jsx)("b",{children:"ftype"})})," of that ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),", and (in ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementations"})})," which provide the ability to do so) to ",(0,s.jsx)(i,{term:"trace",children:(0,s.jsx)("b",{children:"trace"})})," that ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is not defined as a ",(0,s.jsx)(n.em,{children:"standardized function"}),", ",(0,s.jsx)(r,{styled:!0,term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),", or ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"bind"})})," it as a ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," (",(0,s.jsx)(n.em,{children:"e.g."}),", with ",(0,s.jsx)(i,{term:"macrolet",children:(0,s.jsx)("b",{children:"macrolet"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(r,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is not defined as a ",(0,s.jsx)(n.em,{children:"standardized function"}),", ",(0,s.jsx)(r,{styled:!0,term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),", or ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"bind"})})," its ",(0,s.jsx)(r,{styled:!0,term:"setf function name",children:(0,s.jsx)("i",{children:"setf function name"})})," as a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),", and to declare the ",(0,s.jsx)(i,{term:"ftype",children:(0,s.jsx)("b",{children:"ftype"})})," of that ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),"."]})]})}function K(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(z,{...e})}):z(e)}function Y(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function U(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(n.p,{children:["The COMMON-LISP-USER ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is the ",(0,s.jsx)(i,{styled:!0,term:"current package",children:(0,s.jsx)("i",{children:"current package"})})," when a Common Lisp system starts up. This ",(0,s.jsx)(n.em,{children:"package uses"})," the COMMON-LISP ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),". The COMMON-LISP-USER ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," has the ",(0,s.jsx)(i,{term:"nickname",children:(0,s.jsx)("i",{children:"nickname"})})," CL-USER. The COMMON-LISP-USER ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," can have additional ",(0,s.jsx)(n.em,{children:"symbols interned"})," within it; it can ",(0,s.jsx)(i,{term:"use",children:(0,s.jsx)("i",{children:"use"})})," other ",(0,s.jsx)(n.em,{children:"implementation-defined packages"}),"."]})}function _(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(U,{...e})}):U(e)}function q(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||H("DictionaryLink",!0),r||H("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The KEYWORD ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," contains ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),", called ",(0,s.jsx)(r,{term:"keyword",children:(0,s.jsx)("i",{children:"keywords"})}),(0,s.jsx)("sub",{children:"1"}),", that are typically used as special markers in ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"programs"})})," and their associated data ",(0,s.jsx)(r,{term:"expression",children:(0,s.jsx)("i",{children:"expressions"})}),(0,s.jsx)("sub",{children:"1"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Symbol tokens"})," that start with a ",(0,s.jsx)(r,{styled:!0,term:"package marker",children:(0,s.jsx)("i",{children:"package marker"})})," are parsed by the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," as ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," in the KEYWORD ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),"; see Section 2.3.4 (Symbols as Tokens). This makes it notationally convenient to use ",(0,s.jsx)(r,{term:"keyword",children:(0,s.jsx)("i",{children:"keywords"})})," when communicating between programs in different ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"packages"})}),". For example, the mechanism for passing ",(0,s.jsx)(r,{styled:!0,term:"keyword parameter",children:(0,s.jsx)("i",{children:"keyword parameters"})})," in a ",(0,s.jsx)(r,{term:"call",children:(0,s.jsx)("i",{children:"call"})})," uses ",(0,s.jsx)(r,{term:"keyword",children:(0,s.jsx)("i",{children:"keywords"})}),(0,s.jsx)("sub",{children:"1"})," to name the corresponding ",(0,s.jsx)(r,{term:"argument",children:(0,s.jsx)("i",{children:"arguments"})}),"; see Section 3.4.1 (Ordinary Lambda Lists)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"Symbols"})})," in the KEYWORD ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," are, by definition, of ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{term:"keyword",children:(0,s.jsx)("b",{children:"keyword"})}),"."]})]})}function B(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}function H(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function J(e){const n={p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(n.p,{children:["The KEYWORD ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," is treated differently than other ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"packages"})})," in that special actions are taken when a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(i,{term:"interned",children:(0,s.jsx)("i",{children:"interned"})})," in it. In particular, when a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is ",(0,s.jsx)(i,{term:"interned",children:(0,s.jsx)("i",{children:"interned"})})," in the KEYWORD ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})}),", it is automatically made to be an ",(0,s.jsx)(i,{styled:!0,term:"external symbol",children:(0,s.jsx)("i",{children:"external symbol"})})," and is automatically made to be a ",(0,s.jsx)(i,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variable"})})," with itself as a ",(0,s.jsx)(i,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),"."]})}function V(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(J,{...e})}):J(e)}function Q(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["It is generally best to confine the use of ",(0,s.jsx)(i,{term:"keyword",children:(0,s.jsx)("i",{children:"keywords"})})," to situations in which there are a finitely enumerable set of names to be selected between. For example, if there were two states of a light switch, they might be called ",":on"," and ",":off","."]}),"\n",(0,s.jsxs)(n.p,{children:["In situations where the set of names is not finitely enumerable (",(0,s.jsx)(n.em,{children:"i.e."}),", where name conflicts might arise) it is frequently best to use ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," in some ",(0,s.jsx)(i,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," other than KEYWORD so that conflicts will be naturally avoided. For example, it is generally not wise for a ",(0,s.jsx)(i,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," to use a ",(0,s.jsx)(i,{term:"keyword",children:(0,s.jsx)("i",{children:"keyword"})})," ",(0,s.jsx)("sub",{children:"1"})," as a ",(0,s.jsx)(i,{styled:!0,term:"property indicator",children:(0,s.jsx)("i",{children:"property indicator"})})," , since if there were ever another ",(0,s.jsx)(i,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," that did the same thing, each would clobber the other\u2019s data."]})]})}function X(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Q,{...e})}):Q(e)}function Z(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||ee("DictionaryLink",!0),r||ee("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Other, ",(0,s.jsx)(n.em,{children:"implementation-defined packages"})," might be present in the initial Common Lisp environment."]}),"\n",(0,s.jsxs)(n.p,{children:["It is recommended, but not required, that the documentation for a ",(0,s.jsx)(r,{styled:!0,term:"conforming implementation",children:(0,s.jsx)("i",{children:"conforming implementation"})})," contain a full list of all ",(0,s.jsx)(r,{term:"package",children:(0,s.jsx)("i",{children:"package"})})," names initially present in that ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})})," but not specified in this specification. (See also the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"list-all-packages",children:(0,s.jsx)("b",{children:"list-all-packages"})}),".)"]})]})}function $(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Z,{...e})}):Z(e)}function ee(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const ne={title:"11.1 Package Concepts"},ie="11.1 Package Concepts",re={},se=[{value:"11.1.1 Introduction to Packages",id:"1111-introduction-to-packages",level:2},{value:"11.1.1.1 Package Names and Nicknames",id:"11111-package-names-and-nicknames",level:3},{value:"11.1.1.2 Symbols in a Package",id:"11112-symbols-in-a-package",level:3},{value:"11.1.1.2.1 Internal and External Symbols",id:"111121-internal-and-external-symbols",level:4},{value:"11.1.1.2.2 Package Inheritance",id:"111122-package-inheritance",level:4},{value:"11.1.1.2.3 Accessibility of Symbols in a Package",id:"111123-accessibility-of-symbols-in-a-package",level:4},{value:"11.1.1.2.4 Locating a Symbol in a Package",id:"111124-locating-a-symbol-in-a-package",level:4},{value:"11.1.1.2.5 Prevention of Name Conflicts in Packages",id:"111125-prevention-of-name-conflicts-in-packages",level:4},{value:"11.1.2 Standardized Packages",id:"1112-standardized-packages",level:2},{value:"11.1.2.1 The COMMON",id:"11121-the-common",level:3},{value:"11.1.2.1.1 Constraints on the COMMON",id:"111211-constraints-on-the-common",level:4},{value:"11.1.2.1.2 Constraints on the COMMON",id:"111212-constraints-on-the-common",level:4},{value:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON",id:"1112121-some-exceptions-to-constraints-on-the-common",level:5},{value:"11.1.2.2 The COMMON",id:"11122-the-common",level:3},{value:"11.1.2.3 The KEYWORD Package",id:"11123-the-keyword-package",level:3},{value:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package",id:"111231-interning-a-symbol-in-the-keyword-package",level:4},{value:"11.1.2.3.2 Notes about The KEYWORD Package",id:"111232-notes-about-the-keyword-package",level:4},{value:"11.1.2.4 Implementation",id:"11124-implementation",level:3}];function te(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"111-package-concepts",children:"11.1 Package Concepts"})}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h2,{id:"1111-introduction-to-packages",children:"11.1.1 Introduction to Packages"}),"\n","\n",(0,s.jsx)(d,{}),"\n",(0,s.jsx)(n.h3,{id:"11111-package-names-and-nicknames",children:"11.1.1.1 Package Names and Nicknames"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(n.h3,{id:"11112-symbols-in-a-package",children:"11.1.1.2 Symbols in a Package"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(n.h4,{id:"111121-internal-and-external-symbols",children:"11.1.1.2.1 Internal and External Symbols"}),"\n","\n",(0,s.jsx)(b,{}),"\n",(0,s.jsx)(n.h4,{id:"111122-package-inheritance",children:"11.1.1.2.2 Package Inheritance"}),"\n","\n",(0,s.jsx)(f,{}),"\n",(0,s.jsx)(n.h4,{id:"111123-accessibility-of-symbols-in-a-package",children:"11.1.1.2.3 Accessibility of Symbols in a Package"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(n.h4,{id:"111124-locating-a-symbol-in-a-package",children:"11.1.1.2.4 Locating a Symbol in a Package"}),"\n","\n",(0,s.jsx)(M,{}),"\n",(0,s.jsx)(n.h4,{id:"111125-prevention-of-name-conflicts-in-packages",children:"11.1.1.2.5 Prevention of Name Conflicts in Packages"}),"\n","\n",(0,s.jsx)(S,{}),"\n",(0,s.jsx)(n.h2,{id:"1112-standardized-packages",children:"11.1.2 Standardized Packages"}),"\n","\n",(0,s.jsx)(C,{}),"\n",(0,s.jsx)(n.h3,{id:"11121-the-common",children:"11.1.2.1 The COMMON"}),"\n","\n",(0,s.jsx)(R,{}),"\n",(0,s.jsx)(n.h4,{id:"111211-constraints-on-the-common",children:"11.1.2.1.1 Constraints on the COMMON"}),"\n","\n",(0,s.jsx)(D,{}),"\n",(0,s.jsx)(n.h4,{id:"111212-constraints-on-the-common",children:"11.1.2.1.2 Constraints on the COMMON"}),"\n","\n",(0,s.jsx)(A,{}),"\n",(0,s.jsx)(n.h5,{id:"1112121-some-exceptions-to-constraints-on-the-common",children:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON"}),"\n","\n",(0,s.jsx)(K,{}),"\n",(0,s.jsx)(n.h3,{id:"11122-the-common",children:"11.1.2.2 The COMMON"}),"\n","\n",(0,s.jsx)(_,{}),"\n",(0,s.jsx)(n.h3,{id:"11123-the-keyword-package",children:"11.1.2.3 The KEYWORD Package"}),"\n","\n",(0,s.jsx)(B,{}),"\n",(0,s.jsx)(n.h4,{id:"111231-interning-a-symbol-in-the-keyword-package",children:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package"}),"\n","\n",(0,s.jsx)(V,{}),"\n",(0,s.jsx)(n.h4,{id:"111232-notes-about-the-keyword-package",children:"11.1.2.3.2 Notes about The KEYWORD Package"}),"\n","\n",(0,s.jsx)(X,{}),"\n",(0,s.jsx)(n.h3,{id:"11124-implementation",children:"11.1.2.4 Implementation"}),"\n","\n",(0,s.jsx)($,{})]})}function ce(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(te,{...e})}):te(e)}}}]);