"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[2882],{41292:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>d,metadata:()=>a,toc:()=>p});var r=s(85893),n=s(11151);function i(e){const t={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,n.a)(),...e.components},{ClLinks:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"subtypep"})," ",(0,r.jsx)(s,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"Function"})})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," ",(0,r.jsx)(t.em,{children:"type-1 type-2"})," &optional ",(0,r.jsx)(t.em,{children:"environment \u2192 subtype-p, valid-p"})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"type-1"}),"\u2014a ",(0,r.jsx)(t.em,{children:"type specifier"})," ."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"type-2"}),"\u2014a ",(0,r.jsx)(t.em,{children:"type specifier"})," ."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(s,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),"\u2014an ",(0,r.jsx)(t.em,{children:"environment object"}),". The default is ",(0,r.jsx)(s,{styled:!0,term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", denoting the ",(0,r.jsx)(t.em,{children:"null lexical environment"})," and the current ",(0,r.jsx)(t.em,{children:"global environment"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"subtype-p"}),"\u2014a ",(0,r.jsx)(t.em,{children:"generalized boolean"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"valid-p"}),"\u2014a ",(0,r.jsx)(t.em,{children:"generalized boolean"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(t.p,{children:["If ",(0,r.jsx)(t.em,{children:"type-1"})," is a ",(0,r.jsx)(t.em,{children:"recognizable subtype"})," of ",(0,r.jsx)(t.em,{children:"type-2"}),", the first ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})})," is ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})}),". Otherwise, the first ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})})," is ",(0,r.jsx)(s,{styled:!0,term:"false",children:(0,r.jsx)("i",{children:"false"})}),", indicating that either ",(0,r.jsx)(t.em,{children:"type-1"})," is not a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of ",(0,r.jsx)(t.em,{children:"type-2"}),", or else ",(0,r.jsx)(t.em,{children:"type-1"})," is a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of ",(0,r.jsx)(t.em,{children:"type-2"})," but is not a ",(0,r.jsx)(t.em,{children:"recognizable subtype"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["A second ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})})," is also returned indicating the \u2018certainty\u2019 of the first ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})}),". If this value is ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})}),", then the first value is an accurate indication of the ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," relationship. (The second ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})})," is always ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," when the first ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"value"})})," is ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})}),".)"]}),"\n",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})}),"\n",(0,r.jsxs)(t.p,{children:["Figure 4\u20139 summarizes the possible combinations of ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"values"})})," that might result."]}),"\n",(0,r.jsxs)(t.p,{children:["|",(0,r.jsx)(t.strong,{children:"Value 1 Value 2 Meaning"}),"|"]}),"\n",(0,r.jsx)(t.p,{children:"| :- |"}),"\n",(0,r.jsxs)(t.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(t.em,{children:"true true type-1"})," is definitely a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of ",(0,r.jsx)(t.em,{children:"type-2"}),". "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(t.em,{children:"false true type-1"})," is definitely not a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of ",(0,r.jsx)(t.em,{children:"type-2"}),". ",(0,r.jsx)(t.em,{children:"false false"})," ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," could not determine the relationship, so ",(0,r.jsx)(t.em,{children:"type-1"})," might or might not be a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of ",(0,r.jsx)(t.em,{children:"type-2"}),"."]}),"|"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Figure 4\u20139. Result possibilities for subtypep"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," is permitted to return the ",(0,r.jsx)(t.em,{children:"values false"})," and ",(0,r.jsx)(s,{styled:!0,term:"false",children:(0,r.jsx)("i",{children:"false"})})," only when at least one argument involves one of these ",(0,r.jsx)(t.em,{children:"type specifiers"}),": ",(0,r.jsx)(s,{styled:!0,term:"and",children:(0,r.jsx)("b",{children:"and"})}),", ",(0,r.jsx)(s,{styled:!0,term:"eql",children:(0,r.jsx)("b",{children:"eql"})}),", the list form of ",(0,r.jsx)(s,{styled:!0,term:"function",children:(0,r.jsx)("b",{children:"function"})}),", ",(0,r.jsx)(s,{styled:!0,term:"member",children:(0,r.jsx)("b",{children:"member"})}),", ",(0,r.jsx)(s,{styled:!0,term:"not",children:(0,r.jsx)("b",{children:"not"})}),", ",(0,r.jsx)(s,{styled:!0,term:"or",children:(0,r.jsx)("b",{children:"or"})}),", ",(0,r.jsx)(t.strong,{children:"satisfies"}),", or ",(0,r.jsx)(s,{styled:!0,term:"values",children:(0,r.jsx)("b",{children:"values"})}),". (A ",(0,r.jsx)(t.em,{children:"type specifier"})," \u2018involves\u2019 such a ",(0,r.jsx)(s,{styled:!0,term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," if, after being ",(0,r.jsx)(t.em,{children:"type expanded"}),", it contains that ",(0,r.jsx)(s,{styled:!0,term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," in a position that would call for its meaning as a ",(0,r.jsx)(t.em,{children:"type specifier"})," to be used.) One consequence of this is that if neither ",(0,r.jsx)(t.em,{children:"type-1"})," nor ",(0,r.jsx)(t.em,{children:"type-2"})," involves any of these ",(0,r.jsx)(t.em,{children:"type specifiers"}),", then ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," is obliged to determine the relationship accurately. In particular, ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," returns the ",(0,r.jsx)(t.em,{children:"values true"})," and ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," if the arguments are ",(0,r.jsx)(s,{styled:!0,term:"equal",children:(0,r.jsx)("b",{children:"equal"})})," and do not involve any of these ",(0,r.jsx)(t.em,{children:"type specifiers"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," never returns a second value of ",(0,r.jsx)(s,{styled:!0,term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," when both ",(0,r.jsx)(t.em,{children:"type-1"})," and ",(0,r.jsx)(t.em,{children:"type-2"})," involve only the names in Figure 4\u20132, or names of ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"types"})})," defined by ",(0,r.jsx)(s,{styled:!0,term:"defstruct",children:(0,r.jsx)("b",{children:"defstruct"})}),", ",(0,r.jsx)(s,{styled:!0,term:"define-condition",children:(0,r.jsx)("b",{children:"define-condition"})}),", or ",(0,r.jsx)(s,{styled:!0,term:"defclass",children:(0,r.jsx)("b",{children:"defclass"})}),", or ",(0,r.jsx)(t.em,{children:"derived types"})," that expand into only those names. While ",(0,r.jsx)(t.em,{children:"type specifiers"})," listed in Figure 4\u20132 and names of ",(0,r.jsx)(s,{styled:!0,term:"defclass",children:(0,r.jsx)("b",{children:"defclass"})})," and ",(0,r.jsx)(s,{styled:!0,term:"defstruct",children:(0,r.jsx)("b",{children:"defstruct"})})," can in some cases be implemented as ",(0,r.jsx)(t.em,{children:"derived types"}),", ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," regards them as primitive."]}),"\n",(0,r.jsxs)(t.p,{children:["The relationships between ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"types"})})," reflected by ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," are those specific to the particular implementation. For example, if an implementation supports only a single type of floating-point numbers, in that implementation (subtypep \u2019float \u2019long-float) returns the ",(0,r.jsx)(t.em,{children:"values true"})," and ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," (since the two ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"types"})})," are identical)."]}),"\n",(0,r.jsxs)(t.p,{children:["For all ",(0,r.jsx)(t.em,{children:"T1"})," and ",(0,r.jsx)(t.em,{children:"T2"})," other than *, (array ",(0,r.jsx)(t.em,{children:"T1"}),") and (array ",(0,r.jsx)(t.em,{children:"T2"}),") are two different ",(0,r.jsx)(t.em,{children:"type spec ifiers"})," that always refer to the same sets of things if and only if they refer to ",(0,r.jsx)(s,{styled:!0,term:"array",children:(0,r.jsx)("i",{children:"arrays"})})," of exactly the same specialized representation, ",(0,r.jsx)(t.em,{children:"i.e."}),", if (upgraded-array-element-type \u2019",(0,r.jsx)(t.em,{children:"T1"}),") and (upgraded-array-element-type \u2019",(0,r.jsx)(t.em,{children:"T2"}),") return two different ",(0,r.jsx)(t.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,r.jsx)(s,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})}),". This is another way of saying that \u2018(array ",(0,r.jsx)(t.em,{children:"type-specifier"}),") and \u2018(array ,(upgraded-array-element-type \u2019",(0,r.jsx)(t.em,{children:"type-specifier"}),")) refer to the same set of specialized ",(0,r.jsx)(s,{styled:!0,term:"array",children:(0,r.jsx)("i",{children:"array"})})," representations. For all ",(0,r.jsx)(t.em,{children:"T1"})," and ",(0,r.jsx)(t.em,{children:"T2"})," other than *, the intersection of (array ",(0,r.jsx)(t.em,{children:"T1"}),") and (array ",(0,r.jsx)(t.em,{children:"T2"}),") is the empty set if and only if they refer to ",(0,r.jsx)(s,{styled:!0,term:"array",children:(0,r.jsx)("i",{children:"arrays"})})," of different, distinct specialized representations."]}),"\n",(0,r.jsx)(t.p,{children:"Therefore,"}),"\n",(0,r.jsx)(t.p,{children:"(subtypep \u2019(array T1) \u2019(array T2)) \u2192 true"}),"\n",(0,r.jsx)(t.p,{children:"if and only if"}),"\n",(0,r.jsx)(t.p,{children:"(upgraded-array-element-type \u2019T1) and"}),"\n",(0,r.jsx)(t.p,{children:"(upgraded-array-element-type \u2019T2)"}),"\n",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})}),"\n",(0,r.jsxs)(t.p,{children:["return two different ",(0,r.jsx)(t.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,r.jsx)(s,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["For all type-specifiers ",(0,r.jsx)(t.em,{children:"T1"})," and ",(0,r.jsx)(t.em,{children:"T2"})," other than *,"]}),"\n",(0,r.jsxs)(t.p,{children:["(subtypep \u2019(complex T1) \u2019(complex T2)) \u2192 true, ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})]}),"\n",(0,r.jsx)(t.p,{children:"if:"}),"\n",(0,r.jsxs)(t.p,{children:["1. T1 is a ",(0,r.jsx)(s,{styled:!0,term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})})," of T2, or"]}),"\n",(0,r.jsxs)(t.p,{children:["2. (upgraded-complex-part-type \u2019",(0,r.jsx)(t.em,{children:"T1"}),") and (upgraded-complex-part-type \u2019",(0,r.jsx)(t.em,{children:"T2"}),") return two different ",(0,r.jsx)(t.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,r.jsx)(s,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})}),"; in this case, (complex ",(0,r.jsx)(t.em,{children:"T1"}),") and (complex ",(0,r.jsx)(t.em,{children:"T2"}),") both refer to the same specialized representation."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"value",children:(0,r.jsx)("i",{children:"values"})})," are ",(0,r.jsx)(s,{styled:!0,term:"false",children:(0,r.jsx)("i",{children:"false"})})," and ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," otherwise."]}),"\n",(0,r.jsx)(t.p,{children:"The form"}),"\n",(0,r.jsx)(t.p,{children:"(subtypep \u2019(complex single-float) \u2019(complex float))"}),"\n",(0,r.jsxs)(t.p,{children:["must return ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," in all implementations, but"]}),"\n",(0,r.jsx)(t.p,{children:"(subtypep \u2019(array single-float) \u2019(array float))"}),"\n",(0,r.jsxs)(t.p,{children:["returns ",(0,r.jsx)(s,{styled:!0,term:"true",children:(0,r.jsx)("i",{children:"true"})})," only in implementations that do not have a specialized ",(0,r.jsx)(s,{styled:!0,term:"array",children:(0,r.jsx)("i",{children:"array"})})," representation for ",(0,r.jsx)(t.em,{children:"single floats"})," distinct from that for other ",(0,r.jsx)(s,{styled:!0,term:"float",children:(0,r.jsx)("i",{children:"floats"})}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lisp",children:"\n(subtypep \u2019compiled-function \u2019function) \u2192 true, *true* \n(subtypep \u2019null \u2019list) \u2192 true, *true* \n(subtypep \u2019null \u2019symbol) \u2192 true, *true* \n(subtypep \u2019integer \u2019string) \u2192 false, *true* \n(subtypep \u2019(satisfies dummy) nil) \u2192 false, *implementation-dependent* \n(subtypep \u2019(integer 1 3) \u2019(integer 1 4)) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019nil) \u2192 true, *true* \n(subtypep \u2019nil \u2019(integer (0) (0))) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019(member)) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019(member) \u2019nil) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019nil \u2019(member)) \u2192 true, *true* ;or *false*, *false* \nLet <aet-x> and <aet-y> be two distinct *type specifiers* that do not always refer to the same sets of *objects* in a given implementation, but for which **make-array**, will return an *object* of the same *array type*. \nThus, in each case, \n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-x>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-y>))) \n\u2192 true, *true*  \n\n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-y>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-x>))) \n\u2192 true, *true* \nIf (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of *objects*, these names should always refer to the same sets of *objects*. That implies that the following set of tests are also true: \n(subtypep \u2019(array <aet-x>) \u2019(array <aet-y>)) \u2192 true, *true* \n(subtypep \u2019(array <aet-y>) \u2019(array <aet-x>)) \u2192 true, *true* \n\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"See Also:"})}),"\n",(0,r.jsx)(t.p,{children:"Section 4.2 (Types)"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(t.p,{children:["The small differences between the ",(0,r.jsx)(s,{styled:!0,term:"subtypep",children:(0,r.jsx)("b",{children:"subtypep"})})," specification for the ",(0,r.jsx)(s,{styled:!0,term:"array",children:(0,r.jsx)("b",{children:"array"})})," and ",(0,r.jsx)(s,{styled:!0,term:"complex",children:(0,r.jsx)("b",{children:"complex"})})," types are necessary because there is no creation function for ",(0,r.jsx)(t.em,{children:"complexes"})," which allows the specification of the resultant part type independently of the actual types of the parts. Thus in the case of the ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(s,{styled:!0,term:"complex",children:(0,r.jsx)("b",{children:"complex"})}),", the actual type of the parts is referred to, although a ",(0,r.jsx)(s,{styled:!0,term:"number",children:(0,r.jsx)("i",{children:"number"})})," can be a member of more than one ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})}),". For example, 17 is of ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," (mod 18) as well as ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," (mod 256) and ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(s,{styled:!0,term:"integer",children:(0,r.jsx)("b",{children:"integer"})}),"; and 2.3f5 is of ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(s,{styled:!0,term:"single-float",children:(0,r.jsx)("b",{children:"single-float"})})," as well as ",(0,r.jsx)(s,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(s,{styled:!0,term:"float",children:(0,r.jsx)("b",{children:"float"})}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}const d={title:"subtypep"},c="subtypep",a={id:"chap-4/e-e-dictionary/subtypep_function",title:"subtypep",description:"Expanded Reference: subtypep",source:"@site/docs/chap-4/e-e-dictionary/subtypep_function.md",sourceDirName:"chap-4/e-e-dictionary",slug:"/chap-4/e-e-dictionary/subtypep_function",permalink:"/cl-language-reference/chap-4/e-e-dictionary/subtypep_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-4/e-e-dictionary/subtypep_function.md",tags:[],version:"current",frontMatter:{title:"subtypep"},sidebar:"tutorialSidebar",previous:{title:"structure-object",permalink:"/cl-language-reference/chap-4/e-e-dictionary/structure-object_class"},next:{title:"t",permalink:"/cl-language-reference/chap-4/e-e-dictionary/t_system-class"}},h={},p=[{value:"Expanded Reference: subtypep",id:"expanded-reference-subtypep",level:2}];function o(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"subtypep",children:"subtypep"}),"\n","\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(t.h2,{id:"expanded-reference-subtypep",children:"Expanded Reference: subtypep"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsx)(t.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lisp",children:"(subtypep )\n"})})]})}function x(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>d,a:()=>l});var r=s(67294);const n={},i=r.createContext(n);function l(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);