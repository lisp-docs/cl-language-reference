"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[13693],{19372:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>o,default:()=>j,frontMatter:()=>a,metadata:()=>t,toc:()=>x});const t=JSON.parse('{"id":"chap-14/be-c-dictionary/tree-equal_function","title":"tree-equal","description":"Expanded Reference: tree-equal","source":"@site/docs/chap-14/be-c-dictionary/tree-equal_function.md","sourceDirName":"chap-14/be-c-dictionary","slug":"/chap-14/be-c-dictionary/tree-equal_function","permalink":"/cl-language-reference/chap-14/be-c-dictionary/tree-equal_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-14/be-c-dictionary/tree-equal_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"tree-equal"},"sidebar":"tutorialSidebar","previous":{"title":"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not","permalink":"/cl-language-reference/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function"},"next":{"title":"union, nunion","permalink":"/cl-language-reference/chap-14/be-c-dictionary/union_nunion_function"}}');var s=n(74848),i=n(28453);function l(e){const r={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||d("DictionaryLink",!0),t||d("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"tree-equal"})," ",(0,s.jsx)(t,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"Function"})})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," ",(0,s.jsx)(r.em,{children:"tree-1 tree-2"})," &key ",(0,s.jsx)(r.em,{children:"test test-not \u2192 generalized-boolean"})]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"tree-1"}),"\u2014a ",(0,s.jsx)(t,{styled:!0,term:"tree",children:(0,s.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"tree-2"}),"\u2014a ",(0,s.jsx)(t,{styled:!0,term:"tree",children:(0,s.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"test"}),"\u2014a ",(0,s.jsx)(t,{styled:!0,term:"designator",children:(0,s.jsx)("i",{children:"designator"})})," for a ",(0,s.jsx)(t,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"function"})})," of two ",(0,s.jsx)(t,{styled:!0,term:"argument",children:(0,s.jsx)("i",{children:"arguments"})})," that returns a ",(0,s.jsx)(t,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),". ",(0,s.jsxs)(r.em,{children:["test-not",(0,s.jsx)(t,{styled:!0,term:"t",children:(0,s.jsx)("i",{children:"\u2014a "})}),"designator"]})," for a ",(0,s.jsx)(t,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"function"})})," of two ",(0,s.jsx)(t,{styled:!0,term:"argument",children:(0,s.jsx)("i",{children:"arguments"})})," that returns a ",(0,s.jsx)(t,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),". ",(0,s.jsx)(r.em,{children:"generalized-boolean"}),"\u2014a ",(0,s.jsx)(t,{styled:!0,term:"generalized boolean",children:(0,s.jsx)("i",{children:"generalized boolean"})}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," tests whether two trees are of the same shape and have the same leaves. ",(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," returns ",(0,s.jsx)(t,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})})," if ",(0,s.jsx)(r.em,{children:"tree-1"})," and ",(0,s.jsx)(r.em,{children:"tree-2"})," are both ",(0,s.jsx)(t,{styled:!0,term:"atom",children:(0,s.jsx)("i",{children:"atoms"})})," and ",(0,s.jsx)(t,{styled:!0,term:"satisfy the test",children:(0,s.jsx)("i",{children:"satisfy the test"})}),", or if they are both ",(0,s.jsx)(r.em,{children:"conses"})," and the ",(0,s.jsx)(t,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"car"})})," of ",(0,s.jsx)(r.em,{children:"tree-1"})," is ",(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," to the ",(0,s.jsx)(t,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"car"})})," of ",(0,s.jsx)(r.em,{children:"tree-2"})," and the ",(0,s.jsx)(t,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of ",(0,s.jsx)(r.em,{children:"tree-1"})," is ",(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," to the ",(0,s.jsx)(t,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of ",(0,s.jsx)(r.em,{children:"tree-2"}),". Otherwise, ",(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," returns ",(0,s.jsx)(t,{styled:!0,term:"false",children:(0,s.jsx)("i",{children:"false"})}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"tree-equal",children:(0,s.jsx)("b",{children:"tree-equal"})})," recursively compares ",(0,s.jsx)(r.em,{children:"conses"})," but not any other ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," that have components."]}),"\n",(0,s.jsxs)(r.p,{children:["The first argument to the ",":test"," or ",":test-not"," function is ",(0,s.jsx)(r.em,{children:"tree-1"})," or a ",(0,s.jsx)(t,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"car"})})," or ",(0,s.jsx)(t,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of ",(0,s.jsx)(r.em,{children:"tree-1"}),"; the second argument is ",(0,s.jsx)(r.em,{children:"tree-2"})," or a ",(0,s.jsx)(t,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"car"})})," or ",(0,s.jsx)(t,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of ",(0,s.jsx)(r.em,{children:"tree-2"}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:"(setq tree1 \u2019(1 (1 2)) \n      tree2 \u2019(1 (1 2))) \u2192 (1 (1 2)) \n(tree-equal tree1 tree2) \u2192 true \n(eql tree1 tree2) \u2192 false \n(setq tree1 \u2019(\u2019a (\u2019b \u2019c)) \n      tree2 \u2019(\u2019a (\u2019b \u2019c))) \u2192 (\u2019a (\u2019b \u2019c)) \n\u2192 ((QUOTE A) ((QUOTE B) (QUOTE C))) \n(tree-equal tree1 tree2 :test \u2019eq) \u2192 true \n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Exceptional Situations:"})}),"\n",(0,s.jsxs)(r.p,{children:["The consequences are undefined if both ",(0,s.jsx)(r.em,{children:"tree-1"})," and ",(0,s.jsx)(r.em,{children:"tree-2"})," are circular."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(n,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),", Section 3.6 (Traversal Rules and Side Effects)"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(r.p,{children:["The ",":test-not"," parameter is deprecated."]})]})}function c(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function d(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const a={title:"tree-equal"},o="tree-equal",h={},x=[{value:"Expanded Reference: tree-equal",id:"expanded-reference-tree-equal",level:2}];function u(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"tree-equal",children:"tree-equal"})}),"\n","\n",(0,s.jsx)(c,{}),"\n",(0,s.jsx)(r.h2,{id:"expanded-reference-tree-equal",children:"Expanded Reference: tree-equal"}),"\n",(0,s.jsx)(r.admonition,{type:"tip",children:(0,s.jsx)(r.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:"(tree-equal )\n"})})]})}function j(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>c});var t=n(96540);const s={},i=t.createContext(s);function l(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);