"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[87025],{88783:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>x,frontMatter:()=>c,metadata:()=>l,toc:()=>h});var t=s(85893),r=s(11151);function i(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," ",(0,t.jsx)(n.em,{children:"Macro"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,t.jsx)(n.p,{children:"The \u201cshort form\u201d:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," ",(0,t.jsx)(n.em,{children:"access-fn update-fn"})," [",(0,t.jsx)(n.em,{children:"documentation"}),"]"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"! access-fn"})}),"\n",(0,t.jsx)(n.p,{children:"The \u201clong form\u201d:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," ",(0,t.jsx)(n.em,{children:"access-fn lambda-list"})," (",(0,t.jsx)(n.em,{children:"{store-variable}"}),"*) [[ ",(0,t.jsx)(n.em,{children:"{declaration}"}),"* ",(0,t.jsx)(n.em,{children:"| documentation"})," ]] ",(0,t.jsx)(n.em,{children:"{form}"}),"* ",(0,t.jsx)(n.em,{children:"! access-fn"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"access-fn"}),"\u2014a ",(0,t.jsx)(n.em,{children:"symbol"})," which names a ",(0,t.jsx)(n.em,{children:"function"})," or a ",(0,t.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"update-fn"}),"\u2014a ",(0,t.jsx)(n.em,{children:"symbol"})," naming a ",(0,t.jsx)(n.em,{children:"function"})," or ",(0,t.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"lambda-list"}),"\u2014a ",(0,t.jsx)(n.em,{children:"defsetf lambda list"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"store-variable"}),"\u2014a ",(0,t.jsx)(n.em,{children:"symbol"})," (a ",(0,t.jsx)(n.em,{children:"variable name"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,t.jsx)(n.strong,{children:"declare"})," ",(0,t.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"documentation"}),"\u2014a ",(0,t.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"form"}),"\u2014a ",(0,t.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Data and Control"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"defsetf"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," defines how to ",(0,t.jsx)(n.strong,{children:"setf"})," a ",(0,t.jsx)(n.em,{children:"place"})," of the form (",(0,t.jsx)(n.em,{children:"access-fn"})," ...) for relatively simple cases. (See ",(0,t.jsx)(n.strong,{children:"define-setf-expander"})," for more general access to this facility.) It must be the case that the ",(0,t.jsx)(n.em,{children:"function"})," or ",(0,t.jsx)(n.em,{children:"macro"})," named by ",(0,t.jsx)(n.em,{children:"access-fn"})," evaluates all of its arguments."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," may take one of two forms, called the \u201cshort form\u201d and the \u201clong form,\u201d which are distinguished by the ",(0,t.jsx)(n.em,{children:"type"})," of the second ",(0,t.jsx)(n.em,{children:"argument"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When the short form is used, ",(0,t.jsx)(n.em,{children:"update-fn"})," must name a ",(0,t.jsx)(n.em,{children:"function"})," (or ",(0,t.jsx)(n.em,{children:"macro"}),") that takes one more argument than ",(0,t.jsx)(n.em,{children:"access-fn"})," takes. When ",(0,t.jsx)(n.strong,{children:"setf"})," is given a ",(0,t.jsx)(n.em,{children:"place"})," that is a call on ",(0,t.jsx)(n.em,{children:"access-fn"}),", it expands into a call on ",(0,t.jsx)(n.em,{children:"update-fn"})," that is given all the arguments to ",(0,t.jsx)(n.em,{children:"access-fn"})," and also, as its last argument, the new value (which must be returned by ",(0,t.jsx)(n.em,{children:"update-fn"})," as its value)."]}),"\n",(0,t.jsxs)(n.p,{children:["The long form ",(0,t.jsx)(n.strong,{children:"defsetf"})," resembles ",(0,t.jsx)(n.strong,{children:"defmacro"}),". The ",(0,t.jsx)(n.em,{children:"lambda-list"})," describes the arguments of ",(0,t.jsx)(n.em,{children:"access-fn"}),". The ",(0,t.jsx)(n.em,{children:"store-variables"})," describe the value or values to be stored into the ",(0,t.jsx)(n.em,{children:"place"}),". The ",(0,t.jsx)(n.em,{children:"body"})," must compute the expansion of a ",(0,t.jsx)(n.strong,{children:"setf"})," of a call on ",(0,t.jsx)(n.em,{children:"access-fn"}),". The expansion function is defined in the same ",(0,t.jsx)(n.em,{children:"lexical environment"})," in which the ",(0,t.jsx)(n.strong,{children:"defsetf"})," ",(0,t.jsx)(n.em,{children:"form"})," appears."]}),"\n",(0,t.jsxs)(n.p,{children:["During the evaluation of the ",(0,t.jsx)(n.em,{children:"forms"}),", the variables in the ",(0,t.jsx)(n.em,{children:"lambda-list"})," and the ",(0,t.jsx)(n.em,{children:"store-variables"})," are bound to names of temporary variables, generated as if by ",(0,t.jsx)(n.strong,{children:"gensym"})," or ",(0,t.jsx)(n.strong,{children:"gentemp"}),", that will be bound by the expansion of ",(0,t.jsx)(n.strong,{children:"setf"})," to the values of those ",(0,t.jsx)(n.em,{children:"subforms"}),". This binding permits the ",(0,t.jsx)(n.em,{children:"forms"})," to be written without regard for order-of-evaluation issues. ",(0,t.jsx)(n.strong,{children:"defsetf"})," arranges for the temporary variables to be optimized out of the final result in cases where that is possible."]}),"\n",(0,t.jsxs)(n.p,{children:["The body code in ",(0,t.jsx)(n.strong,{children:"defsetf"})," is implicitly enclosed in a ",(0,t.jsx)(n.em,{children:"block"})," whose name is ",(0,t.jsx)(n.em,{children:"access-fn"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"defsetf"})," ensures that ",(0,t.jsx)(n.em,{children:"subforms"})," of the ",(0,t.jsx)(n.em,{children:"place"})," are evaluated exactly once."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Documentation"})," is attached to ",(0,t.jsx)(n.em,{children:"access-fn"})," as a ",(0,t.jsx)(n.em,{children:"documentation string"})," of kind ",(0,t.jsx)(n.strong,{children:"setf"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a ",(0,t.jsx)(n.strong,{children:"defsetf"})," ",(0,t.jsx)(n.em,{children:"form"})," appears as a ",(0,t.jsx)(n.em,{children:"top level form"}),", the ",(0,t.jsx)(n.em,{children:"compiler"})," must make the ",(0,t.jsx)(n.em,{children:"setf expander"})," available so that it may be used to expand calls to ",(0,t.jsx)(n.strong,{children:"setf"})," later on in the ",(0,t.jsx)(n.em,{children:"file"}),". Users must ensure that the ",(0,t.jsx)(n.em,{children:"forms"}),", if any, can be evaluated at compile time if the ",(0,t.jsx)(n.em,{children:"access-fn"})," is used in a ",(0,t.jsx)(n.em,{children:"place"})," later in the same ",(0,t.jsx)(n.em,{children:"file"}),". The ",(0,t.jsx)(n.em,{children:"compiler"})," must make these ",(0,t.jsx)(n.em,{children:"setf expanders"})," available to compile-time calls to ",(0,t.jsx)(n.strong,{children:"get-setf-expansion"})," when its ",(0,t.jsx)(n.em,{children:"environment"})," argument is a value received as the ",(0,t.jsx)(n.em,{children:"environment parameter"})," of a ",(0,t.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"\nThe e\u21b5ect of \n(defsetf symbol-value set) \nis built into the Common Lisp system. This causes the form (setf (symbol-value foo) fu) to expand into (set foo fu). \nNote that \n(defsetf car rplaca) \nwould be incorrect because **rplaca** does not return its last argument. \n\n\n\n**defsetf** \n(defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) *!* MIDDLEGUY \n(defun set-middleguy (x v) \n  (unless (null x) \n    (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v)) \n  v) *!* SET-MIDDLEGUY \n(defsetf middleguy set-middleguy) *!* MIDDLEGUY \n(setq a (list \u2019a \u2019b \u2019c \u2019d) \n      b (list \u2019x) \n      c (list 1 2 3 (list 4 5 6) 7 8 9)) *!* (1 2 3 (4 5 6) 7 8 9) \n(setf (middleguy a) 3) *!* 3 \n(setf (middleguy b) 7) *!* 7 \n(setf (middleguy (middleguy c)) \u2019middleguy-symbol) *!* MIDDLEGUY-SYMBOL \na *!* (A 3 C D) \nb *!* (7) \nc *!* (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9) \nAn example of the use of the long form of **defsetf**: \n(defsetf subseq (sequence start &optional end) (new-sequence) \n  \u2018(progn (replace ,sequence ,new-sequence \n\t\t   :start1 ,start :end1 ,end) \n\t  ,new-sequence)) *!* SUBSEQ \n(defvar \\*xy\\* (make-array \u2019(10 10))) \n(defun xy (&key ((x x) 0) ((y y) 0)) (aref \\*xy\\* x y)) *!* XY \n(defun set-xy (new-value &key ((x x) 0) ((y y) 0)) \n  (setf (aref \\*xy\\* x y) new-value)) *!* SET-XY \n(defsetf xy (&key ((x x) 0) ((y y) 0)) (store) \n  \u2018(set-xy ,store \u2019x ,x \u2019y ,y)) *!* XY \n(get-setf-expansion \u2019(xy a b)) \n*!* (#:t0 #:t1), \n(a b), \n(#:store), \n((lambda (&key ((x #:x)) ((y #:y))) \n   (set-xy #:store \u2019x #:x \u2019y #:y)) \n #:t0 #:t1), \n(xy #:t0 #:t1) \n(xy \u2019x 1) *!* NIL \n(setf (xy \u2019x 1) 1) *!* 1 \n(xy \u2019x 1) *!* 1 \n(let ((a \u2019x) (b \u2019y)) \n  (setf (xy a 1 b 2) 3) \n  (setf (xy b 5 a 9) 14)) \n*!* 14 \n(xy \u2019y 0 \u2019x 1) *!* 1 \n(xy \u2019x 1 \u2019y 2) *!* 3 \nData and Control \n\n\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"documentation"}),", ",(0,t.jsx)(n.strong,{children:"setf"}),", ",(0,t.jsx)(n.strong,{children:"define-setf-expander"}),", ",(0,t.jsx)(n.strong,{children:"get-setf-expansion"}),", Section 5.1 (Generalized Reference), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"forms"})," must include provision for returning the correct value (the value or values of ",(0,t.jsx)(n.em,{children:"store-variable"}),"). This is handled by ",(0,t.jsx)(n.em,{children:"forms"})," rather than by ",(0,t.jsx)(n.strong,{children:"defsetf"})," because in many cases this value can be returned at no extra cost, by calling a function that simultaneously stores into the ",(0,t.jsx)(n.em,{children:"place"})," and returns the correct value."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"setf"})," of a call on ",(0,t.jsx)(n.em,{children:"access-fn"})," also evaluates all of ",(0,t.jsx)(n.em,{children:"access-fn"}),"\u2019s arguments; it cannot treat any of them specially. This means that ",(0,t.jsx)(n.strong,{children:"defsetf"})," cannot be used to describe how to store into a ",(0,t.jsx)(n.em,{children:"generalized reference"})," to a byte, such as (ldb field reference). ",(0,t.jsx)(n.strong,{children:"define-setf-expander"})," is used to handle situations that do not fit the restrictions imposed by ",(0,t.jsx)(n.strong,{children:"defsetf"})," and gives the user additional control."]})]})}function a(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}const c={title:"defsetf"},d="defsetf",l={id:"chap-5/f-d-dictionary/defsetf_macro",title:"defsetf",description:"Expanded Reference: defsetf",source:"@site/docs/chap-5/f-d-dictionary/defsetf_macro.md",sourceDirName:"chap-5/f-d-dictionary",slug:"/chap-5/f-d-dictionary/defsetf_macro",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/defsetf_macro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-5/f-d-dictionary/defsetf_macro.md",tags:[],version:"current",frontMatter:{title:"defsetf"},sidebar:"tutorialSidebar",previous:{title:"defparameter, defvar",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/defparameter_defvar_macro"},next:{title:"defun",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/defun_macro"}},o={},h=[{value:"Expanded Reference: defsetf",id:"expanded-reference-defsetf",level:2}];function f(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"defsetf",children:"defsetf"}),"\n","\n","\n",(0,t.jsx)(a,{}),"\n",(0,t.jsx)(n.h2,{id:"expanded-reference-defsetf",children:"Expanded Reference: defsetf"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(defsetf )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>a});var t=s(67294);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);