"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[39748],{53061:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>x,frontMatter:()=>c,metadata:()=>l,toc:()=>h});var s=n(85893),r=n(11151);function i(e){const t={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," ",(0,s.jsx)(t.em,{children:"Macro"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Syntax:"})}),"\n",(0,s.jsx)(t.p,{children:"The \u201cshort form\u201d:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," ",(0,s.jsx)(t.em,{children:"access-fn update-fn"})," [",(0,s.jsx)(t.em,{children:"documentation"}),"]"]}),"\n",(0,s.jsx)(t.p,{children:"\u2192  access-fn"}),"\n",(0,s.jsx)(t.p,{children:"The \u201clong form\u201d:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," ",(0,s.jsx)(t.em,{children:"access-fn lambda-list"})," (",(0,s.jsx)(t.em,{children:"{store-variable}"}),"*) [[ ",(0,s.jsx)(t.em,{children:"{declaration}"}),"* ",(0,s.jsx)(t.em,{children:"| documentation"})," ]] ",(0,s.jsx)(t.em,{children:"{form}"}),"* \u2192  access-fn"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"access-fn"}),"\u2014a ",(0,s.jsx)(t.em,{children:"symbol"})," which names a ",(0,s.jsx)(t.em,{children:"function"})," or a ",(0,s.jsx)(t.em,{children:"macro"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"update-fn"}),"\u2014a ",(0,s.jsx)(t.em,{children:"symbol"})," naming a ",(0,s.jsx)(t.em,{children:"function"})," or ",(0,s.jsx)(t.em,{children:"macro"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"lambda-list"}),"\u2014a ",(0,s.jsx)(t.em,{children:"defsetf lambda list"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"store-variable"}),"\u2014a ",(0,s.jsx)(t.em,{children:"symbol"})," (a ",(0,s.jsx)(t.em,{children:"variable name"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"declaration"}),"\u2014a ",(0,s.jsx)(t.strong,{children:"declare"})," ",(0,s.jsx)(t.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"documentation"}),"\u2014a ",(0,s.jsx)(t.em,{children:"string"}),"; not evaluated."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"form"}),"\u2014a ",(0,s.jsx)(t.em,{children:"form"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Data and Control"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"defsetf"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," defines how to ",(0,s.jsx)(t.strong,{children:"setf"})," a ",(0,s.jsx)(t.em,{children:"place"})," of the form (",(0,s.jsx)(t.em,{children:"access-fn"})," ...) for relatively simple cases. (See ",(0,s.jsx)(t.strong,{children:"define-setf-expander"})," for more general access to this facility.) It must be the case that the ",(0,s.jsx)(t.em,{children:"function"})," or ",(0,s.jsx)(t.em,{children:"macro"})," named by ",(0,s.jsx)(t.em,{children:"access-fn"})," evaluates all of its arguments."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," may take one of two forms, called the \u201cshort form\u201d and the \u201clong form,\u201d which are distinguished by the ",(0,s.jsx)(t.em,{children:"type"})," of the second ",(0,s.jsx)(t.em,{children:"argument"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["When the short form is used, ",(0,s.jsx)(t.em,{children:"update-fn"})," must name a ",(0,s.jsx)(t.em,{children:"function"})," (or ",(0,s.jsx)(t.em,{children:"macro"}),") that takes one more argument than ",(0,s.jsx)(t.em,{children:"access-fn"})," takes. When ",(0,s.jsx)(t.strong,{children:"setf"})," is given a ",(0,s.jsx)(t.em,{children:"place"})," that is a call on ",(0,s.jsx)(t.em,{children:"access-fn"}),", it expands into a call on ",(0,s.jsx)(t.em,{children:"update-fn"})," that is given all the arguments to ",(0,s.jsx)(t.em,{children:"access-fn"})," and also, as its last argument, the new value (which must be returned by ",(0,s.jsx)(t.em,{children:"update-fn"})," as its value)."]}),"\n",(0,s.jsxs)(t.p,{children:["The long form ",(0,s.jsx)(t.strong,{children:"defsetf"})," resembles ",(0,s.jsx)(t.strong,{children:"defmacro"}),". The ",(0,s.jsx)(t.em,{children:"lambda-list"})," describes the arguments of ",(0,s.jsx)(t.em,{children:"access-fn"}),". The ",(0,s.jsx)(t.em,{children:"store-variables"})," describe the value or values to be stored into the ",(0,s.jsx)(t.em,{children:"place"}),". The ",(0,s.jsx)(t.em,{children:"body"})," must compute the expansion of a ",(0,s.jsx)(t.strong,{children:"setf"})," of a call on ",(0,s.jsx)(t.em,{children:"access-fn"}),". The expansion function is defined in the same ",(0,s.jsx)(t.em,{children:"lexical environment"})," in which the ",(0,s.jsx)(t.strong,{children:"defsetf"})," ",(0,s.jsx)(t.em,{children:"form"})," appears."]}),"\n",(0,s.jsxs)(t.p,{children:["During the evaluation of the ",(0,s.jsx)(t.em,{children:"forms"}),", the variables in the ",(0,s.jsx)(t.em,{children:"lambda-list"})," and the ",(0,s.jsx)(t.em,{children:"store-variables"})," are bound to names of temporary variables, generated as if by ",(0,s.jsx)(t.strong,{children:"gensym"})," or ",(0,s.jsx)(t.strong,{children:"gentemp"}),", that will be bound by the expansion of ",(0,s.jsx)(t.strong,{children:"setf"})," to the values of those ",(0,s.jsx)(t.em,{children:"subforms"}),". This binding permits the ",(0,s.jsx)(t.em,{children:"forms"})," to be written without regard for order-of-evaluation issues. ",(0,s.jsx)(t.strong,{children:"defsetf"})," arranges for the temporary variables to be optimized out of the final result in cases where that is possible."]}),"\n",(0,s.jsxs)(t.p,{children:["The body code in ",(0,s.jsx)(t.strong,{children:"defsetf"})," is implicitly enclosed in a ",(0,s.jsx)(t.em,{children:"block"})," whose name is ",(0,s.jsx)(t.em,{children:"access-fn"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"defsetf"})," ensures that ",(0,s.jsx)(t.em,{children:"subforms"})," of the ",(0,s.jsx)(t.em,{children:"place"})," are evaluated exactly once."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"Documentation"})," is attached to ",(0,s.jsx)(t.em,{children:"access-fn"})," as a ",(0,s.jsx)(t.em,{children:"documentation string"})," of kind ",(0,s.jsx)(t.strong,{children:"setf"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If a ",(0,s.jsx)(t.strong,{children:"defsetf"})," ",(0,s.jsx)(t.em,{children:"form"})," appears as a ",(0,s.jsx)(t.em,{children:"top level form"}),", the ",(0,s.jsx)(t.em,{children:"compiler"})," must make the ",(0,s.jsx)(t.em,{children:"setf expander"})," available so that it may be used to expand calls to ",(0,s.jsx)(t.strong,{children:"setf"})," later on in the ",(0,s.jsx)(t.em,{children:"file"}),". Users must ensure that the ",(0,s.jsx)(t.em,{children:"forms"}),", if any, can be evaluated at compile time if the ",(0,s.jsx)(t.em,{children:"access-fn"})," is used in a ",(0,s.jsx)(t.em,{children:"place"})," later in the same ",(0,s.jsx)(t.em,{children:"file"}),". The ",(0,s.jsx)(t.em,{children:"compiler"})," must make these ",(0,s.jsx)(t.em,{children:"setf expanders"})," available to compile-time calls to ",(0,s.jsx)(t.strong,{children:"get-setf-expansion"})," when its ",(0,s.jsx)(t.em,{children:"environment"})," argument is a value received as the ",(0,s.jsx)(t.em,{children:"environment parameter"})," of a ",(0,s.jsx)(t.em,{children:"macro"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lisp",children:"\nThe e\u21b5ect of \n(defsetf symbol-value set) \nis built into the Common Lisp system. This causes the form (setf (symbol-value foo) fu) to expand into (set foo fu). \nNote that \n(defsetf car rplaca) \nwould be incorrect because **rplaca** does not return its last argument. \n\n\n\n**defsetf** \n(defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) \u2192 MIDDLEGUY \n(defun set-middleguy (x v) \n  (unless (null x) \n    (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v)) \n  v) \u2192 SET-MIDDLEGUY \n(defsetf middleguy set-middleguy) \u2192 MIDDLEGUY \n(setq a (list \u2019a \u2019b \u2019c \u2019d) \n      b (list \u2019x) \n      c (list 1 2 3 (list 4 5 6) 7 8 9)) \u2192 (1 2 3 (4 5 6) 7 8 9) \n(setf (middleguy a) 3) \u2192 3 \n(setf (middleguy b) 7) \u2192 7 \n(setf (middleguy (middleguy c)) \u2019middleguy-symbol) \u2192 MIDDLEGUY-SYMBOL \na \u2192 (A 3 C D) \nb \u2192 (7) \nc \u2192 (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9) \nAn example of the use of the long form of **defsetf**: \n(defsetf subseq (sequence start &amp;optional end) (new-sequence) \n\t\t \u2018(progn (replace ,sequence ,new-sequence \n\t\t\t\t  :start1 ,start :end1 ,end) \n\t\t\t ,new-sequence)) \u2192 SUBSEQ \n\t\t\t (defvar \\*xy\\* (make-array \u2019(10 10))) \n\t\t\t (defun xy (&amp;key ((x x) 0) ((y y) 0)) (aref \\*xy\\* x y)) \u2192 XY \n\t\t\t\t    (defun set-xy (new-value &amp;key ((x x) 0) ((y y) 0)) \n\t\t\t\t\t\t   (setf (aref \\*xy\\* x y) new-value)) \u2192 SET-XY \n\t\t\t\t\t\t   (defsetf xy (&amp;key ((x x) 0) ((y y) 0)) (store) \n\t\t\t\t\t\t\t\t\u2018(set-xy ,store \u2019x ,x \u2019y ,y)) \u2192 XY \n\t\t\t\t\t\t\t\t (get-setf-expansion \u2019(xy a b)) \n\t\t\t\t\t\t\t\t \u2192 (#:t0 #:t1), \n\t\t\t\t\t\t\t\t (a b), \n\t\t\t\t\t\t\t\t (#:store), \n\t\t\t\t\t\t\t\t ((lambda (&amp;key ((x #:x)) ((y #:y))) \n\t\t\t\t\t\t\t\t\t   (set-xy #:store \u2019x #:x \u2019y #:y)) \n\t\t\t\t\t\t\t\t    #:t0 #:t1), \n\t\t\t\t\t\t\t\t  (xy #:t0 #:t1) \n\t\t\t\t\t\t\t\t  (xy \u2019x 1) \u2192 NIL \n\t\t\t\t\t\t\t\t  (setf (xy \u2019x 1) 1) \u2192 1 \n\t\t\t\t\t\t\t\t  (xy \u2019x 1) \u2192 1 \n\t\t\t\t\t\t\t\t  (let ((a \u2019x) (b \u2019y)) \n\t\t\t\t\t\t\t\t    (setf (xy a 1 b 2) 3) \n\t\t\t\t\t\t\t\t    (setf (xy b 5 a 9) 14)) \n\t\t\t\t\t\t\t\t  \u2192 14 \n\t\t\t\t\t\t\t\t  (xy \u2019y 0 \u2019x 1) \u2192 1 \n\t\t\t\t\t\t\t\t  (xy \u2019x 1 \u2019y 2) \u2192 3 \n\t\t\t\t\t\t\t\t  Data and Control \n\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t  \n\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"documentation"}),", ",(0,s.jsx)(t.strong,{children:"setf"}),", ",(0,s.jsx)(t.strong,{children:"define-setf-expander"}),", ",(0,s.jsx)(t.strong,{children:"get-setf-expansion"}),", Section 5.1 (Generalized Reference), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"forms"})," must include provision for returning the correct value (the value or values of ",(0,s.jsx)(t.em,{children:"store-variable"}),"). This is handled by ",(0,s.jsx)(t.em,{children:"forms"})," rather than by ",(0,s.jsx)(t.strong,{children:"defsetf"})," because in many cases this value can be returned at no extra cost, by calling a function that simultaneously stores into the ",(0,s.jsx)(t.em,{children:"place"})," and returns the correct value."]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"setf"})," of a call on ",(0,s.jsx)(t.em,{children:"access-fn"})," also evaluates all of ",(0,s.jsx)(t.em,{children:"access-fn"}),"\u2019s arguments; it cannot treat any of them specially. This means that ",(0,s.jsx)(t.strong,{children:"defsetf"})," cannot be used to describe how to store into a ",(0,s.jsx)(t.em,{children:"generalized reference"})," to a byte, such as (ldb field reference). ",(0,s.jsx)(t.strong,{children:"define-setf-expander"})," is used to handle situations that do not fit the restrictions imposed by ",(0,s.jsx)(t.strong,{children:"defsetf"})," and gives the user additional control."]})]})}function a(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}const c={},d="defsetf",l={id:"chap-5/f-d-dictionary/defsetf",title:"defsetf",description:"Expanded Reference: defsetf",source:"@site/docs/chap-5/f-d-dictionary/defsetf.md",sourceDirName:"chap-5/f-d-dictionary",slug:"/chap-5/f-d-dictionary/defsetf",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/defsetf",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-5/f-d-dictionary/defsetf.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"defparameter, defvar",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/defparameter"},next:{title:"destructuring-bind",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/destructuringbind"}},o={},h=[{value:"Expanded Reference: defsetf",id:"expanded-reference-defsetf",level:2}];function f(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"defsetf",children:"defsetf"}),"\n","\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(t.h2,{id:"expanded-reference-defsetf",children:"Expanded Reference: defsetf"}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lisp",children:"(defsetf )\n"})})]})}function x(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>a});var s=n(67294);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);