"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[72477],{58208:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>h});var i=t(85893),a=t(11151);function s(n){const e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"dynamic-extent"})," ",(0,i.jsx)(e.em,{children:"Declaration"})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(e.p,{children:["(dynamic-extent [[ ",(0,i.jsx)(e.em,{children:"{var}"}),"* | (",(0,i.jsx)(e.strong,{children:"function"})," ",(0,i.jsx)(e.em,{children:"fn"}),")* ]])"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Arguments:"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.em,{children:"var"}),"\u2014a ",(0,i.jsx)(e.em,{children:"variable name"}),"."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.em,{children:"fn"}),"\u2014a ",(0,i.jsx)(e.em,{children:"function name"}),"."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Valid Context:"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"declaration"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Binding Types Aected:"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.em,{children:"variable"}),", ",(0,i.jsx)(e.em,{children:"function"})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(e.p,{children:["In some containing ",(0,i.jsx)("i",{children:"form"}),", ",(0,i.jsx)("i",{children:"F"}),", this declaration asserts for each ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]})," (which need not be bound by ",(0,i.jsx)("i",{children:"F"}),"), and for each ",(0,i.jsxs)("i",{children:["value v",(0,i.jsx)("sub",{children:"ij"})]})," that ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]})," takes on, and for each ",(0,i.jsxs)("i",{children:["object x",(0,i.jsx)("sub",{children:"ijk"})]})," that is an ",(0,i.jsx)("i",{children:"otherwise inaccessible part"})," of ",(0,i.jsxs)("i",{children:["v",(0,i.jsx)("sub",{children:"ij"})]})," at any time when ",(0,i.jsxs)("i",{children:["v",(0,i.jsx)("sub",{children:"ij"})]})," becomes the value of ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]}),", that just after the execution of ",(0,i.jsx)("i",{children:"F"})," terminates, ",(0,i.jsxs)("i",{children:["x",(0,i.jsx)("sub",{children:"ijk"})]})," is either ",(0,i.jsx)("i",{children:"inaccessible"})," (if ",(0,i.jsx)("i",{children:"F"})," established a ",(0,i.jsx)("i",{children:"binding"})," for ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]}),") or still an ",(0,i.jsx)("i",{children:"otherwise inaccessible part"})," of the current value of ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]})," (if ",(0,i.jsx)("i",{children:"F"})," did not establish a ",(0,i.jsx)("i",{children:"binding"})," for ",(0,i.jsxs)("i",{children:["var",(0,i.jsx)("sub",{children:"i"})]}),"). The same relation holds for each ",(0,i.jsxs)("i",{children:["fn",(0,i.jsx)("sub",{children:"i"})]}),", except that the ",(0,i.jsx)("i",{children:"bindings"})," are in the ",(0,i.jsx)("i",{children:"function namespace"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"Evaluation and"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"dynamic-extent"})}),"\n",(0,i.jsxs)(e.p,{children:["The compiler is permitted to use this information in any way that is appropriate to the ",(0,i.jsx)(e.em,{children:"implementation"})," and that does not conflict with the semantics of Common Lisp."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"dynamic-extent"})," declarations can be ",(0,i.jsx)(e.em,{children:"free declarations"})," or ",(0,i.jsx)(e.em,{children:"bound declarations"}),"."]}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.em,{children:"vars"})," and ",(0,i.jsx)(e.em,{children:"fns"})," named in a ",(0,i.jsx)(e.strong,{children:"dynamic-extent"})," declaration must not refer to ",(0,i.jsx)(e.em,{children:"symbol macro"})," or ",(0,i.jsx)(e.em,{children:"macro"})," bindings."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lisp",children:' \n\n\n\nSince stack allocation of the initial value entails knowing at the *object*\u2019s creation time that the *object* can be *stack-allocated*, it is not generally useful to make a **dynamic-extent** *declaration* for *variables* which have no lexically apparent initial value. For example, it is probably useful to write: \n\n\n\n(defun f () \n\n\n\n(let ((x (list 1 2 3))) \n\n\n\n(declare (dynamic-extent x)) \n\n\n\n...)) \n\n\n\nThis would permit those compilers that wish to do so to *stack allocate* the list held by the local variable x. It is permissible, but in practice probably not as useful, to write: \n\n\n\n(defun g (x) (declare (dynamic-extent x)) ...) \n\n\n\n(defun f () (g (list 1 2 3))) \n\n\n\nMost compilers would probably not *stack allocate* the *argument* to g in f because it would be a modularity violation for the compiler to assume facts about g from within f. Only an implementation that was willing to be responsible for recompiling f if the definition of g changed incompatibly could legitimately *stack allocate* the *list* argument to g in f. \n\n\n\nHere is another example: \n\n\n\n(declaim (inline g)) \n\n\n\n(defun g (x) (declare (dynamic-extent x)) ...) \n\n\n\n(defun f () (g (list 1 2 3))) \n\n\n\n(defun f () \n\n\n\n(flet ((g (x) (declare (dynamic-extent x)) ...)) \n\n\n\n(g (list 1 2 3)))) \n\n\n\nIn the previous example, some compilers might determine that optimization was possible and others might not. \n\n\n\nA variant of this is the so-called \u201cstack allocated rest list\u201d that can be achieved (in implementations supporting the optimization) by: \n\n\n\n(defun f (&amp;rest x) \n\n\n\n(declare (dynamic-extent x)) \n\n\n\n\n\n\n\n \n\n\n\n \n\n\n\n**dynamic-extent** \n\n\n\n...) \n\n\n\nNote that although the initial value of x is not explicit, the f function is responsible for assembling the list x from the passed arguments, so the f function can be optimized by the compiler to construct a *stack-allocated* list instead of a heap-allocated list in implementations that support such. \n\n\n\nIn the following example, \n\n\n\n(let ((x (list \u2019a1 \u2019b1 \u2019c1)) \n\n\n\n(y (cons \u2019a2 (cons \u2019b2 (cons \u2019c2 nil))))) \n\n\n\n(declare (dynamic-extent x y)) \n\n\n\n...) \n\n\n\nThe *otherwise inaccessible parts* of x are three *conses*, and the *otherwise inaccessible parts* of y are three other *conses*. None of the symbols a1, b1, c1, a2, b2, c2, or **nil** is an *otherwise inaccessible part* of x or y because each is *interned* and hence *accessible* by the *package* (or *packages*) in which it is *interned*. However, if a freshly allocated *uninterned symbol* had been used, it would have been an *otherwise inaccessible part* of the *list* which contained it. \n\n\n\n;; In this example, the implementation is permitted to *stack allocate* \n\n\n\n;; the list that is bound to X. \n\n\n\n(let ((x (list 1 2 3))) \n\n\n\n(declare (dynamic-extent x)) \n\n\n\n(print x) \n\n\n\n:done) \n\n\n\n\u25b7 (1 2 3) \n\n\n\n*!* :DONE \n\n\n\n;; In this example, the list to be bound to L can be *stack-allocated*. \n\n\n\n(defun zap (x y z) \n\n\n\n(do ((l (list x y z) (cdr l))) \n\n\n\n((null l)) \n\n\n\n(declare (dynamic-extent l)) \n\n\n\n(prin1 (car l)))) *!* ZAP \n\n\n\n(zap 1 2 3) \n\n\n\n\u25b7 123 \n\n\n\n*!* NIL \n\n\n\n;; Some implementations might open-code LIST-ALL-PACKAGES in a way \n\n\n\n;; that permits using *stack allocation* of the list to be bound to L. \n\n\n\n(do ((l (list-all-packages) (cdr l))) \n\n\n\n((null l)) \n\n\n\n(declare (dynamic-extent l)) \n\n\n\n(let ((name (package-name (car l)))) \n\n\n\n(when (string-search "COMMON-LISP" name) (print name)))) \n\n\n\n\u25b7 "COMMON-LISP" \n\n\n\nEvaluation and \n\n\n\n \n\n\n\n \n\n\n\n\u25b7 "COMMON-LISP-USER" \n\n\n\n*!* NIL \n\n\n\n;; Some implementations might have the ability to *stack allocate* \n\n\n\n;; rest lists. A declaration such as the following should be a cue \n\n\n\n;; to such implementations that stack-allocation of the rest list \n\n\n\n;; would be desirable. \n\n\n\n(defun add (&amp;rest x) \n\n\n\n(declare (dynamic-extent x)) \n\n\n\n(apply #\u2019+ x)) *!* ADD \n\n\n\n(add 1 2 3) *!* 6 \n\n\n\n(defun zap (n m) \n\n\n\n;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N). \n\n\n\n;; It may be slow, but with a good compiler at least it \n\n\n\n;; doesn\u2019t waste much heap storage. :-\\} \n\n\n\n(let ((a (make-array n))) \n\n\n\n(declare (dynamic-extent a)) \n\n\n\n(dotimes (i n) \n\n\n\n(declare (dynamic-extent i)) \n\n\n\n(setf (aref a i) (random (+ i 1)))) \n\n\n\n(aref a m))) *!* ZAP \n\n\n\n(&lt; (zap 5 3) 3) *! true* \n\n\n\nThe following are in error, since the value of x is used outside of its *extent*: \n\n\n\n(length (list (let ((x (list 1 2 3))) ; Invalid \n\n\n\n(declare (dynamic-extent x)) \n\n\n\nx))) \n\n\n\n(progn (let ((x (list 1 2 3))) ; Invalid \n\n\n\n(declare (dynamic-extent x)) \n\n\n\nx) \n\n\n\nnil) \n\n\n\n\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"declare"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(e.p,{children:["The most common optimization is to ",(0,i.jsx)(e.em,{children:"stack allocate"})," the initial value of the ",(0,i.jsx)(e.em,{children:"objects"})," named by the ",(0,i.jsx)(e.em,{children:"vars"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"It is permissible for an implementation to simply ignore this declaration."}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"type"})})]})}function c(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(s,{...n})}):s(n)}const l={},r="dynamic-extent",o={id:"chap-3/d-i-dictionary/dynamicextent",title:"dynamic-extent",description:"Expanded Reference: dynamic-extent",source:"@site/docs/chap-3/d-i-dictionary/dynamicextent.md",sourceDirName:"chap-3/d-i-dictionary",slug:"/chap-3/d-i-dictionary/dynamicextent",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/dynamicextent",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-i-dictionary/dynamicextent.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"defmacro",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/defmacro"},next:{title:"eval",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/eval"}},d={},h=[{value:"Expanded Reference: dynamic-extent",id:"expanded-reference-dynamic-extent",level:2}];function x(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"dynamic-extent",children:"dynamic-extent"}),"\n","\n","\n",(0,i.jsx)(c,{}),"\n",(0,i.jsx)(e.h2,{id:"expanded-reference-dynamic-extent",children:"Expanded Reference: dynamic-extent"}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lisp",children:"(dynamic-extent )\n"})})]})}function m(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(x,{...n})}):x(n)}},11151:(n,e,t)=>{t.d(e,{Z:()=>l,a:()=>c});var i=t(67294);const a={},s=i.createContext(a);function c(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:c(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);