"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[2239],{7005:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>U,contentTitle:()=>z,default:()=>J,frontMatter:()=>V,metadata:()=>O,toc:()=>Z});var n=t(5893),a=t(1151);function s(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"Lisp reader"})," takes ",(0,n.jsx)(r.em,{children:"characters"})," from a ",(0,n.jsx)(r.em,{children:"stream"}),", interprets them as a printed representation of an ",(0,n.jsx)(r.em,{children:"object"}),", constructs that ",(0,n.jsx)(r.em,{children:"object"}),", and returns it."]}),"\n",(0,n.jsxs)(r.p,{children:["The syntax described by this chapter is called the ",(0,n.jsx)(r.em,{children:"standard syntax"}),". Operations are provided by Common Lisp so that various aspects of the syntax information represented by a ",(0,n.jsx)(r.em,{children:"readtable"})," can be modified under program control; see Chapter 23 (Reader). Except as explicitly stated otherwise, the syntax used throughout this document is ",(0,n.jsx)(r.em,{children:"standard syntax"})," ."]})]})}function i(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(s,{...e})}):s(e)}function c(e){const r={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["Syntax information for use by the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," is embodied in an ",(0,n.jsx)(r.em,{children:"object"})," called a ",(0,n.jsx)(r.em,{children:"readtable"}),". Among other things, the ",(0,n.jsx)(r.em,{children:"readtable"})," contains the association between ",(0,n.jsx)(r.em,{children:"characters"})," and ",(0,n.jsx)(r.em,{children:"syntax types"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Figure 2\u20131 lists some ",(0,n.jsx)(r.em,{children:"defined names"})," that are applicable to ",(0,n.jsx)(r.em,{children:"readtables"}),"."]}),"\n",(0,n.jsx)(r.table,{children:(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsxs)(r.th,{style:{textAlign:"left"},children:["<p>",(0,n.jsx)(r.strong,{children:"*readtable* readtable-case"})," </p><p>",(0,n.jsx)(r.strong,{children:"copy-readtable readtablep"})," </p><p>",(0,n.jsx)(r.strong,{children:"get-dispatch-macro-character set-dispatch-macro-character get-macro-character set-macro-character"})," </p><p>",(0,n.jsx)(r.strong,{children:"make-dispatch-macro-character set-syntax-from-char"}),"</p>"]})})})}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20131. Readtable defined names"})})]})}function h(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}function l(e){const r={em:"em",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(r.p,{children:["Several ",(0,n.jsx)(r.em,{children:"readtables"})," describing different syntaxes can exist, but at any given time only one, called the ",(0,n.jsx)(r.em,{children:"current readtable"}),", affects the way in which ",(0,n.jsx)(r.em,{children:"expressions"}),"<sub>2</sub> are parsed into ",(0,n.jsx)(r.em,{children:"objects"})," by the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," . The ",(0,n.jsx)(r.em,{children:"current readtable"})," in a given ",(0,n.jsx)(r.em,{children:"dynamic environment"})," is the ",(0,n.jsx)(r.em,{children:"value"})," of ",(0,n.jsx)(r.strong,{children:"*readtable*"})," in that ",(0,n.jsx)(r.em,{children:"environment"}),". To make a different ",(0,n.jsx)(r.em,{children:"readtable"})," become the ",(0,n.jsx)(r.em,{children:"current readtable"}),", ",(0,n.jsx)(r.strong,{children:"*readtable*"})," can be ",(0,n.jsx)(r.em,{children:"assigned"})," or ",(0,n.jsx)(r.em,{children:"bound"}),"."]})}function d(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}function o(e){const r={em:"em",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"standard readtable"})," conforms to ",(0,n.jsx)(r.em,{children:"standard syntax"})," . The consequences are undefined if an attempt is made to modify the ",(0,n.jsx)(r.em,{children:"standard readtable"}),". To achieve the effect of altering or extending ",(0,n.jsx)(r.em,{children:"standard syntax"})," , a copy of the ",(0,n.jsx)(r.em,{children:"standard readtable"})," can be created; see the ",(0,n.jsx)(r.em,{children:"function"})," ",(0,n.jsx)(r.strong,{children:"copy-readtable"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"readtable case"})," of the ",(0,n.jsx)(r.em,{children:"standard readtable"})," is ",":upcase","."]})]})}function p(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}function m(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"initial readtable"})," is the ",(0,n.jsx)(r.em,{children:"readtable"})," that is the ",(0,n.jsx)(r.em,{children:"current readtable"})," at the time when the ",(0,n.jsx)(r.em,{children:"Lisp image"})," starts. At that time, it conforms to ",(0,n.jsx)(r.em,{children:"standard syntax"})," . The ",(0,n.jsx)(r.em,{children:"initial readtable"})," is ",(0,n.jsx)(r.em,{children:"distinct"})," from the ",(0,n.jsx)(r.em,{children:"standard readtable"}),". It is permissible for a ",(0,n.jsx)(r.em,{children:"conforming program"})," to modify the ",(0,n.jsx)(r.em,{children:"initial readtable"}),"."]})}function x(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}function j(e){const r={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"Lisp reader"})," is influenced not only by the ",(0,n.jsx)(r.em,{children:"current readtable"}),", but also by various ",(0,n.jsx)(r.em,{children:"dynamic variables"}),". Figure 2\u20132 lists the ",(0,n.jsx)(r.em,{children:"variables"})," that influence the behavior of the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," ."]}),"\n",(0,n.jsx)(r.table,{children:(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.th,{style:{textAlign:"left"},children:(0,n.jsx)(r.strong,{children:"*package* *read-default-float-format* *readtable* *read-base* *read-suppress*"})})})})}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20132. Variables that influence the Lisp reader."})})]})}function u(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(j,{...e})}):j(e)}function b(e){const r={em:"em",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["All ",(0,n.jsx)(r.em,{children:"implementations"})," must support a ",(0,n.jsx)(r.em,{children:"character repertoire"})," called ",(0,n.jsx)(r.strong,{children:"standard-char"}),"; ",(0,n.jsx)(r.em,{children:"characters"})," that are members of that ",(0,n.jsx)(r.em,{children:"repertoire"})," are called ",(0,n.jsx)(r.em,{children:"standard characters"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.strong,{children:"standard-char"})," ",(0,n.jsx)(r.em,{children:"repertoire"})," consists of the ",(0,n.jsx)(r.em,{children:"non-graphic character newline"}),", the ",(0,n.jsx)(r.em,{children:"graphic character space"}),", and the following additional ninety-four ",(0,n.jsx)(r.em,{children:"graphic characters"})," or their equivalents:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.th,{style:{textAlign:"right"},children:(0,n.jsx)(r.strong,{children:"Graphic ID Glyph Description Graphic ID Glyph Description"})})})}),(0,n.jsx)(r.tbody,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.td,{style:{textAlign:"right"},children:"LA01 a small a LN01 n small n LA02 A capital A LN02 N capital N LB01 b small b LO01 o small o LB02 B capital B LO02 O capital O LC01 c small c LP01 p small p LC02 C capital C LP02 P capital P LD01 d small d LQ01 q small q LD02 D capital D LQ02 Q capital Q LE01 e small e LR01 r small r LE02 E capital E LR02 R capital R LF01 f small f LS01 s small s LF02 F capital F LS02 S capital S LG01 g small g LT01 t small t LG02 G capital G LT02 T capital T LH01 h small h LU01 u small u LH02 H capital H LU02 U capital U LI01 i small i LV01 v small v LI02 I capital I LV02 V capital V LJ01 j small j LW01 w small w LJ02 J capital J LW02 W capital W LK01 k small k LX01 x small x LK02 K capital K LX02 X capital X LL01 l small l LY01 y small y LL02 L capital L LY02 Y capital Y LM01 m small m LZ01 z small z LM02 M capital M LZ02 Z capital Z"})})})]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20133. Standard Character Subrepertoire (Part 1 of 3: Latin Characters)"})}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.th,{style:{textAlign:"right"},children:(0,n.jsx)(r.strong,{children:"Graphic ID Glyph Description Graphic ID Glyph Description"})})})}),(0,n.jsx)(r.tbody,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.td,{style:{textAlign:"right"},children:"ND01 1 digit 1 ND06 6 digit 6 ND02 2 digit 2 ND07 7 digit 7 ND03 3 digit 3 ND08 8 digit 8 ND04 4 digit 4 ND09 9 digit 9 ND05 5 digit 5 ND10 0 digit 0"})})})]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Figure 2\u20134. Standard Character Subrepertoire (Part 2 of 3: Numeric Characters)"})," Syntax ",(0,n.jsx)(r.strong,{children:"2\u20133"})]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.th,{style:{textAlign:"left"},children:(0,n.jsx)(r.strong,{children:"Graphic ID Glyph Description"})})})}),(0,n.jsx)(r.tbody,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.td,{style:{textAlign:"left"},children:'<p>SP02 ! exclamation mark </p><p>SC03 $ dollar sign </p><p>SP04 " quotation mark, or double quote SP05 \u2019 apostrophe, or [single] quote </p><p>SP06 ( left parenthesis, or open parenthesis SP07 ) right parenthesis, or close parenthesis SP08 , comma </p><p>SP09 low line, or underscore </p><p>SP10 - hyphen, or minus [sign] </p><p>SP11 . full stop, period, or dot </p><p>SP12 / solidus, or slash </p><p>SP13 : colon </p><p>SP14 ; semicolon </p><p>SP15 ? question mark </p><p>SA01 + plus [sign] </p><p>SA03 < less-than [sign] </p><p>SA04 = equals [sign] </p><p>SA05 > greater-than [sign] </p><p>SM01 # number sign, or sharp[sign] </p><p>SM02 % percent [sign] </p><p>SM03 & ampersand </p><p>SM04 * asterisk, or star </p><p>SM05 @ commercial at, or at-sign </p><p>SM06 [ left [square] bracket </p><p>SM07 \\ reverse solidus, or backslash </p><p>SM08 ] right [square] bracket </p><p>SM11 { left curly bracket, or left brace </p><p>SM13'})})})]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20135. Standard Character Subrepertoire (Part 3 of 3: Special Characters)"})}),"\n",(0,n.jsx)(r.p,{children:"The graphic IDs are not used within Common Lisp, but are provided for cross reference purposes with ISO 6937/2. Note that the first letter of the graphic ID categorizes the character as follows: L\u2014Latin, N\u2014Numeric, S\u2014Special."})]})}function g(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(b,{...e})}):b(e)}function f(e){const r={em:"em",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"Lisp reader"})," constructs an ",(0,n.jsx)(r.em,{children:"object"})," from the input text by interpreting each ",(0,n.jsx)(r.em,{children:"character"})," according to its ",(0,n.jsx)(r.em,{children:"syntax type"}),". The ",(0,n.jsx)(r.em,{children:"Lisp reader"})," cannot accept as input everything that the ",(0,n.jsx)(r.em,{children:"Lisp printer"})]}),"\n",(0,n.jsxs)(r.p,{children:["produces, and the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," has features that are not used by the ",(0,n.jsx)(r.em,{children:"Lisp printer"})," . The ",(0,n.jsx)(r.em,{children:"Lisp reader"})," can be used as a lexical analyzer for a more general user-written parser."]}),"\n",(0,n.jsxs)(r.p,{children:["When the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," is invoked, it reads a single character from the ",(0,n.jsx)(r.em,{children:"input stream"})," and dispatches according to the ",(0,n.jsx)(r.em,{children:"syntax type"})," of that ",(0,n.jsx)(r.em,{children:"character"})," . Every ",(0,n.jsx)(r.em,{children:"character"})," that can appear in the ",(0,n.jsx)(r.em,{children:"input stream"})," is of one of the ",(0,n.jsx)(r.em,{children:"syntax types"})," shown in Figure 2\u20136."]}),"\n",(0,n.jsx)(r.table,{children:(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsxs)(r.th,{style:{textAlign:"left"},children:["<p>",(0,n.jsx)(r.em,{children:"constituent macro character single escape"})," </p><p>",(0,n.jsx)(r.em,{children:"invalid multiple escape whitespace"}),"<sub>2</sub></p>"]})})})}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20136. Possible Character Syntax Types"})}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.em,{children:"syntax type"})," of a ",(0,n.jsx)(r.em,{children:"character"})," in a ",(0,n.jsx)(r.em,{children:"readtable"})," determines how that character is interpreted by the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," while that ",(0,n.jsx)(r.em,{children:"readtable"})," is the ",(0,n.jsx)(r.em,{children:"current readtable"}),". At any given time, every character has exactly one ",(0,n.jsx)(r.em,{children:"syntax type"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Figure 2\u20137 lists the ",(0,n.jsx)(r.em,{children:"syntax type"})," of each ",(0,n.jsx)(r.em,{children:"character"})," in ",(0,n.jsx)(r.em,{children:"standard syntax"})," ."]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.th,{style:{textAlign:"left"},children:(0,n.jsx)(r.strong,{children:"character syntax type character syntax type"})})})}),(0,n.jsx)(r.tbody,{children:(0,n.jsx)(r.tr,{children:(0,n.jsx)(r.td,{style:{textAlign:"left"},children:'Backspace <i>constituent</i> 0\u20139 <i>constituent</i> Tab <i>whitespace</i><sub>2</sub> : <i>constituent</i> Newline <i>whitespace</i><sub>2</sub> ; <i>terminating macro char</i> Linefeed <i>whitespace</i><sub>2</sub> < <i>constituent</i> Page <i>whitespace</i><sub>2</sub> = <i>constituent</i> Return <i>whitespace</i><sub>2</sub> > <i>constituent</i> Space <i>whitespace</i><sub>2</sub> ? <i>constituent</i>* ! <i>constituent</i>* @ <i>constituent</i> " <i>terminating macro char</i> A\u2013Z <i>constituent</i> # <i>non-terminating macro char</i> [ <i>constituent</i>* $ <i>constituent</i> \\ <i>single escape</i> % <i>constituent</i> ] <i>constituent</i>* & <i>constituent <sup>\u2227</sup> constituent</i> \u2019 <i>terminating macro char constituent</i> ( <i>terminating macro char</i> \u2018 <i>terminating macro char</i> ) <i>terminating macro char</i> a\u2013z <i>constituent</i> * <i>constituent</i> { <i>constituent</i>* + <i>constituent</i>'})})})]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20137. Character Syntax Types in Standard Syntax"})}),"\n",(0,n.jsxs)(r.p,{children:["The characters marked with an asterisk (*) are initially ",(0,n.jsx)(r.em,{children:"constituents"}),", but they are not used in any standard Common Lisp notations. These characters are explicitly reserved to the ",(0,n.jsx)(r.em,{children:"programmer"})," . ~ is not used in Common Lisp, and reserved to implementors. $ and % are ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"characters"}),", but are not used in the names of any standard Common Lisp ",(0,n.jsx)(r.em,{children:"defined names"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Whitespace"}),"<sub>2</sub> characters serve as separators but are otherwise ignored. ",(0,n.jsx)(r.em,{children:"Constituent"})," and ",(0,n.jsx)(r.em,{children:"escape characters"})," are accumulated to make a ",(0,n.jsx)(r.em,{children:"token"}),", which is then interpreted as a ",(0,n.jsx)(r.em,{children:"number"})," or ",(0,n.jsx)(r.em,{children:"symbol"}),". ",(0,n.jsx)(r.em,{children:"Macro characters"})," trigger the invocation of ",(0,n.jsx)(r.em,{children:"functions"})," (possibly user-supplied) that can perform arbitrary parsing actions. ",(0,n.jsx)(r.em,{children:"Macro characters"})," are divided into two kinds, ",(0,n.jsx)(r.em,{children:"terminating"})," and ",(0,n.jsx)(r.em,{children:"non"})]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"terminating"}),", depending on whether or not they terminate a ",(0,n.jsx)(r.em,{children:"token"}),". The following are descriptions of each kind of ",(0,n.jsx)(r.em,{children:"syntax type"}),"."]})]})}function y(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(f,{...e})}):f(e)}function v(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Constituent characters"})," are used in ",(0,n.jsx)(r.em,{children:"tokens"}),". A ",(0,n.jsx)(r.em,{children:"token"})," is a representation of a ",(0,n.jsx)(r.em,{children:"number"})," or a ",(0,n.jsx)(r.em,{children:"symbol"}),". Examples of ",(0,n.jsx)(r.em,{children:"constituent characters"})," are letters and digits."]}),"\n",(0,n.jsxs)(r.p,{children:["Letters in symbol names are sometimes converted to letters in the opposite ",(0,n.jsx)(r.em,{children:"case"})," when the name is read; see Section 23.1.2 (Effect of Readtable Case on the Lisp Reader). ",(0,n.jsx)(r.em,{children:"Case"})," conversion can be suppressed by the use of ",(0,n.jsx)(r.em,{children:"single escape"})," or ",(0,n.jsx)(r.em,{children:"multiple escape"})," characters."]})]})}function w(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(v,{...e})}):v(e)}function L(e){const r={em:"em",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["Every ",(0,n.jsx)(r.em,{children:"character"})," has one or more ",(0,n.jsx)(r.em,{children:"constituent traits"})," that define how the ",(0,n.jsx)(r.em,{children:"character"})," is to be interpreted by the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," when the ",(0,n.jsx)(r.em,{children:"character"})," is a ",(0,n.jsx)(r.em,{children:"constituent character"})," . These ",(0,n.jsx)(r.em,{children:"constituent traits"})," are ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>, digit, ",(0,n.jsx)(r.em,{children:"package marker"})," , plus sign, minus sign, dot, decimal point, ",(0,n.jsx)(r.em,{children:"ratio marker"})," , ",(0,n.jsx)(r.em,{children:"exponent marker"})," , and ",(0,n.jsx)(r.em,{children:"invalid"}),". Figure 2\u20138 shows the ",(0,n.jsx)(r.em,{children:"constituent traits"})," of the ",(0,n.jsx)(r.em,{children:"standard characters"})," and of certain ",(0,n.jsx)(r.em,{children:"semi-standard characters"}),"; no mechanism is provided for changing the ",(0,n.jsx)(r.em,{children:"constituent trait"})," of a ",(0,n.jsx)(r.em,{children:"character"})," . Any ",(0,n.jsx)(r.em,{children:"character"})," with the alphadigit ",(0,n.jsx)(r.em,{children:"constituent trait"})," in that figure is a digit if the ",(0,n.jsx)(r.em,{children:"current input base"})," is greater than that character\u2019s digit value, otherwise the ",(0,n.jsx)(r.em,{children:"character"})," is ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>. Any ",(0,n.jsx)(r.em,{children:"character"})," quoted by a ",(0,n.jsx)(r.em,{children:"single escape"})," is treated as an ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> constituent, regardless of its normal syntax."]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsx)(r.tr,{children:(0,n.jsxs)(r.th,{style:{textAlign:"left"},children:["<p>",(0,n.jsx)(r.strong,{children:"constituent traits constituent traits"})," </p><p>",(0,n.jsx)(r.strong,{children:"character character"}),"</p>"]})})}),(0,n.jsx)(r.tbody,{children:(0,n.jsx)(r.tr,{children:(0,n.jsxs)(r.td,{style:{textAlign:"left"},children:["<p>Backspace ",(0,n.jsx)(r.em,{children:"invalid"})," { ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> </p><p>Tab ",(0,n.jsx)(r.em,{children:"invalid"}),"* } ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> </p><p>Newline ",(0,n.jsx)(r.em,{children:"invalid"}),"* + ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>, plus sign Linefeed ",(0,n.jsx)(r.em,{children:"invalid"}),"* - ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>, minus sign Page ",(0,n.jsx)(r.em,{children:"invalid"}),"* . ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>, dot, decimal point Return ",(0,n.jsx)(r.em,{children:"invalid"}),"* / ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>, ",(0,n.jsx)(r.em,{children:"ratio marker"})," Space ",(0,n.jsx)(r.em,{children:"invalid"}),"* A, a alphadigit </p><p>! ",(0,n.jsx)(r.em,{children:"alphabetic"}),'<sub>2</sub> B, b alphadigit </p><p>" ',(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* C, c alphadigit </p><p># ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* D, d alphadigit, double-float ",(0,n.jsx)(r.em,{children:"exponent marker"})," $ ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> E, e alphadigit, float ",(0,n.jsx)(r.em,{children:"exponent marker"})," % ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> F, f alphadigit, single-float ",(0,n.jsx)(r.em,{children:"exponent marker"})," & ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> G, g alphadigit </p><p>\u2019 ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* H, h alphadigit </p><p>( ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* I, i alphadigit </p><p>) ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* J, j alphadigit </p><p>* ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> K, k alphadigit </p><p>, ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* L, l alphadigit, long-float ",(0,n.jsx)(r.em,{children:"exponent marker"})," 0-9 alphadigit M, m alphadigit </p><p>: ",(0,n.jsx)(r.em,{children:"package marker"})," N, n alphadigit </p><p>; ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* O, o alphadigit </p><p>< ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> P, p alphadigit </p><p>= ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> Q, q alphadigit </p><p>> ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> R, r alphadigit </p><p>? ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> S, s alphadigit, short-float ",(0,n.jsx)(r.em,{children:"exponent marker"})," @ ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> T, t alphadigit </p><p>[ ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> U, u alphadigit </p><p>\\ ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* V, v alphadigit </p><p>] ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> W, w alphadigit </p><p><i><sup>\u2227</sup> alphabetic</i><sub>2</sub> X, x alphadigit </p><p>",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> Y, y alphadigit </p><p>\u2018 ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub>* Z, z alphadigit </p><p>"]})})})]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Figure 2\u20138. Constituent Traits of Standard Characters and Semi-Standard Characters"})}),"\n",(0,n.jsxs)(r.p,{children:["The interpretations in this table apply only to ",(0,n.jsx)(r.em,{children:"characters"})," whose ",(0,n.jsx)(r.em,{children:"syntax type"})," is ",(0,n.jsx)(r.em,{children:"constituent"}),". Entries marked with an asterisk (*) are normally ",(0,n.jsx)(r.em,{children:"shadowed"})," <sub>2</sub> because the indicated ",(0,n.jsx)(r.em,{children:"characters"})," are of ",(0,n.jsx)(r.em,{children:"syntax type whitespace"}),"<sub>2</sub>, ",(0,n.jsx)(r.em,{children:"macro character"})," , ",(0,n.jsx)(r.em,{children:"single escape"}),", or ",(0,n.jsx)(r.em,{children:"multiple escape"}),"; these ",(0,n.jsx)(r.em,{children:"constituent traits"})," apply to them only if their ",(0,n.jsx)(r.em,{children:"syntax types"})," are changed to ",(0,n.jsx)(r.em,{children:"constituent"}),"."]})]})}function C(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(L,{...e})}):L(e)}function S(e){const r={em:"em",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Characters"})," with the ",(0,n.jsx)(r.em,{children:"constituent trait invalid"})," cannot ever appear in a ",(0,n.jsx)(r.em,{children:"token"})," except under the control of a ",(0,n.jsx)(r.em,{children:"single escape character"})," . If an ",(0,n.jsx)(r.em,{children:"invalid character"})," is encountered while an ",(0,n.jsx)(r.em,{children:"object"})," is being read, an error of ",(0,n.jsx)(r.em,{children:"type"})," ",(0,n.jsx)(r.strong,{children:"reader-error"})," is signaled. If an ",(0,n.jsx)(r.em,{children:"invalid character"})," is preceded by a ",(0,n.jsx)(r.em,{children:"single escape character"})," , it is treated as an ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"constituent"})," instead."]})}function k(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(S,{...e})}):S(e)}function T(e){const r={em:"em",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["When the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," encounters a ",(0,n.jsx)(r.em,{children:"macro character"})," on an ",(0,n.jsx)(r.em,{children:"input stream"}),", special parsing of subsequent ",(0,n.jsx)(r.em,{children:"characters"})," on the ",(0,n.jsx)(r.em,{children:"input stream"})," is performed."]}),"\n",(0,n.jsxs)(r.p,{children:["A ",(0,n.jsx)(r.em,{children:"macro character"})," has an associated ",(0,n.jsx)(r.em,{children:"function"})," called a ",(0,n.jsx)(r.em,{children:"reader macro function"})," that implements its specialized parsing behavior. An association of this kind can be established or modified under control of a ",(0,n.jsx)(r.em,{children:"conforming program"})," by using the ",(0,n.jsx)(r.em,{children:"functions"})," ",(0,n.jsx)(r.strong,{children:"set-macro-character"})," and ",(0,n.jsx)(r.strong,{children:"set-dispatch-macro-character"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Upon encountering a ",(0,n.jsx)(r.em,{children:"macro character"})," , the ",(0,n.jsx)(r.em,{children:"Lisp reader"})," calls its ",(0,n.jsx)(r.em,{children:"reader macro function"}),", which parses one specially formatted object from the ",(0,n.jsx)(r.em,{children:"input stream"}),". The ",(0,n.jsx)(r.em,{children:"function"})," either returns the parsed ",(0,n.jsx)(r.em,{children:"object"}),", or else it returns no ",(0,n.jsx)(r.em,{children:"values"})," to indicate that the characters scanned by the ",(0,n.jsx)(r.em,{children:"function"})," are being ignored (",(0,n.jsx)(r.em,{children:"e.g."}),", in the case of a comment). Examples of ",(0,n.jsx)(r.em,{children:"macro characters"})," are ",(0,n.jsx)(r.em,{children:"backquote"}),", ",(0,n.jsx)(r.em,{children:"single-quote"}),", ",(0,n.jsx)(r.em,{children:"left-parenthesis"}),", and ",(0,n.jsx)(r.em,{children:"right-parenthesis"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["A ",(0,n.jsx)(r.em,{children:"macro character"})," is either ",(0,n.jsx)(r.em,{children:"terminating"})," or ",(0,n.jsx)(r.em,{children:"non-terminating"}),". The difference between ",(0,n.jsx)(r.em,{children:"terminating"})," and ",(0,n.jsx)(r.em,{children:"non-terminating macro characters"})," lies in what happens when such characters occur in the middle of a ",(0,n.jsx)(r.em,{children:"token"}),". If a ",(0,n.jsx)(r.em,{children:"non-terminating macro character"})," occurs in the middle of a ",(0,n.jsx)(r.em,{children:"token"}),", the ",(0,n.jsx)(r.em,{children:"function"})," associated with the ",(0,n.jsx)(r.em,{children:"non-terminating macro character"})," is not called, and the ",(0,n.jsx)(r.em,{children:"non terminating macro character"})," does not terminate the ",(0,n.jsx)(r.em,{children:"token"}),"\u2019s name; it becomes part of the name as if the ",(0,n.jsx)(r.em,{children:"macro character"})," were really a constituent character. A ",(0,n.jsx)(r.em,{children:"terminating macro character"})," terminates any ",(0,n.jsx)(r.em,{children:"token"}),", and its associated ",(0,n.jsx)(r.em,{children:"reader macro function"})," is called no matter where the ",(0,n.jsx)(r.em,{children:"character"})," appears. The only ",(0,n.jsx)(r.em,{children:"non-terminating macro character"})," in ",(0,n.jsx)(r.em,{children:"standard syntax"})," is ",(0,n.jsx)(r.em,{children:"sharpsign"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["If a ",(0,n.jsx)(r.em,{children:"character"})," is a ",(0,n.jsx)(r.em,{children:"dispatching macro character C"}),"<sub>1</sub>, its ",(0,n.jsx)(r.em,{children:"reader macro function"})," is a ",(0,n.jsx)(r.em,{children:"function"})," supplied by the ",(0,n.jsx)(r.em,{children:"implementation"}),". This ",(0,n.jsx)(r.em,{children:"function"})," reads decimal ",(0,n.jsx)(r.em,{children:"digit characters"})," until a non-",(0,n.jsx)(r.em,{children:"digit C"}),"<sub>2</sub> is read. If any ",(0,n.jsx)(r.em,{children:"digits"})," were read, they are converted into a corresponding ",(0,n.jsx)(r.em,{children:"integer"})," infix parameter ",(0,n.jsx)(r.em,{children:"P"}),"; otherwise, the infix parameter ",(0,n.jsx)(r.em,{children:"P"})," is ",(0,n.jsx)(r.strong,{children:"nil"}),". The terminating non-",(0,n.jsx)(r.em,{children:"digit C"}),"<sub>2</sub> is a ",(0,n.jsx)(r.em,{children:"character"})," (sometimes called a \u201csub-character\u201d to emphasize its subordinate role in the dispatching) that is looked up in the dispatch table associated with the ",(0,n.jsx)(r.em,{children:"dispatching macro character C"}),"<sub>1</sub>. The ",(0,n.jsx)(r.em,{children:"reader macro function"})," associated with the sub-character ",(0,n.jsx)(r.em,{children:"C"}),"<sub>2</sub> is invoked with three arguments: the ",(0,n.jsx)(r.em,{children:"stream"}),", the sub-character ",(0,n.jsx)(r.em,{children:"C"}),"<sub>2</sub>, and the infix parameter ",(0,n.jsx)(r.em,{children:"P"}),". For more information about dispatch characters, see the ",(0,n.jsx)(r.em,{children:"function"})," ",(0,n.jsx)(r.strong,{children:"set-dispatch-macro-character"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["For information about the ",(0,n.jsx)(r.em,{children:"macro characters"})," that are available in ",(0,n.jsx)(r.em,{children:"standard syntax"})," , see Section 2.4 (Standard Macro Characters)."]})]})}function A(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(T,{...e})}):T(e)}function F(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["A pair of ",(0,n.jsx)(r.em,{children:"multiple escape characters"})," is used to indicate that an enclosed sequence of characters, including possible ",(0,n.jsx)(r.em,{children:"macro characters"})," and ",(0,n.jsx)(r.em,{children:"whitespace"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"characters"}),", are to be treated as ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"characters"})," with ",(0,n.jsx)(r.em,{children:"case"})," preserved. Any ",(0,n.jsx)(r.em,{children:"single escape"})," and ",(0,n.jsx)(r.em,{children:"multiple escape characters"})," that are to appear in the sequence must be preceded by a ",(0,n.jsx)(r.em,{children:"single escape character"})," ."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Vertical-bar"})," is a ",(0,n.jsx)(r.em,{children:"multiple escape character"})," in ",(0,n.jsx)(r.em,{children:"standard syntax"})," ."]})]})}function P(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(F,{...e})}):F(e)}function D(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.p,{children:";; The following examples assume the readtable case of *readtable*"}),"\n",(0,n.jsxs)(r.p,{children:[";; and *print-case* are both ",":upcase","."]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019ABC) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019|ABC|) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019a|B|c) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019|abc|) ",(0,n.jsx)(r.em,{children:"\u2192 false"})]})]})}function E(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(D,{...e})}):D(e)}function M(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["A ",(0,n.jsx)(r.em,{children:"single escape"})," is used to indicate that the next ",(0,n.jsx)(r.em,{children:"character"})," is to be treated as an ",(0,n.jsx)(r.em,{children:"alphabetic"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"character"})," with its ",(0,n.jsx)(r.em,{children:"case"})," preserved, no matter what the ",(0,n.jsx)(r.em,{children:"character"})," is or which ",(0,n.jsx)(r.em,{children:"constituent traits"})," it has."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Backslash"})," is a ",(0,n.jsx)(r.em,{children:"single escape character"})," in ",(0,n.jsx)(r.em,{children:"standard syntax"})," ."]})]})}function q(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(M,{...e})}):M(e)}function I(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.p,{children:";; The following examples assume the readtable case of *readtable*"}),"\n",(0,n.jsxs)(r.p,{children:[";; and *print-case* are both ",":upcase","."]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019\\A\\B\\C) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019a\\Bc) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019\\ABC) ",(0,n.jsx)(r.em,{children:"\u2192 true"})]}),"\n",(0,n.jsxs)(r.p,{children:["(eq \u2019abc \u2019\\abc) ",(0,n.jsx)(r.em,{children:"\u2192 false"})]})]})}function R(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(I,{...e})}):I(e)}function N(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Whitespace"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"characters"})," are used to separate ",(0,n.jsx)(r.em,{children:"tokens"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.em,{children:"Space"})," and ",(0,n.jsx)(r.em,{children:"newline"})," are ",(0,n.jsx)(r.em,{children:"whitespace"}),"<sub>2</sub> ",(0,n.jsx)(r.em,{children:"characters"})," in ",(0,n.jsx)(r.em,{children:"standard syntax"})," ."]})]})}function G(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(N,{...e})}):N(e)}function B(e){const r={em:"em",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["(length \u2019(this-that)) ",(0,n.jsx)(r.em,{children:"\u2192"})," 1"]}),"\n",(0,n.jsxs)(r.p,{children:["(length \u2019(this - that)) ",(0,n.jsx)(r.em,{children:"\u2192"})," 3"]}),"\n",(0,n.jsx)(r.p,{children:"(length \u2019(a"}),"\n",(0,n.jsxs)(r.p,{children:["b)) ",(0,n.jsx)(r.em,{children:"\u2192"})," 2"]}),"\n",(0,n.jsxs)(r.p,{children:["(+ 34) ",(0,n.jsx)(r.em,{children:"\u2192"})," 34"]}),"\n",(0,n.jsxs)(r.p,{children:["(+ 3 4) ",(0,n.jsx)(r.em,{children:"\u2192"})," 7"]})]})}function W(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(B,{...e})}):B(e)}const V={title:"2.1 Character Syntax"},z="2.1 Character Syntax",O={id:"chap-2/c-b-character-syntax",title:"2.1 Character Syntax",description:"2.1.1 Readtables",source:"@site/docs/chap-2/c-b-character-syntax.md",sourceDirName:"chap-2",slug:"/chap-2/c-b-character-syntax",permalink:"/cl-language-reference/docs/chap-2/c-b-character-syntax",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-2/c-b-character-syntax.md",tags:[],version:"current",frontMatter:{title:"2.1 Character Syntax"},sidebar:"tutorialSidebar",previous:{title:"2. Syntax",permalink:"/cl-language-reference/docs/category/2-syntax"},next:{title:"2.2 Reader Algorithm",permalink:"/cl-language-reference/docs/chap-2/c-c-reader-algorithm"}},U={},Z=[{value:"2.1.1 Readtables",id:"211-readtables",level:2},{value:"2.1.1.1 The Current Readtable",id:"2111-the-current-readtable",level:3},{value:"2.1.1.2 The Standard Readtable",id:"2112-the-standard-readtable",level:3},{value:"2.1.1.3 The Initial Readtable",id:"2113-the-initial-readtable",level:3},{value:"2.1.2 Variables that affect the Lisp Reader",id:"212-variables-that-affect-the-lisp-reader",level:2},{value:"2.1.3 Standard Characters",id:"213-standard-characters",level:2},{value:"2.1.4 Character Syntax Types",id:"214-character-syntax-types",level:2},{value:"2.1.4.1 Constituent Characters",id:"2141-constituent-characters",level:3},{value:"2.1.4.2 Constituent Traits",id:"2142-constituent-traits",level:3},{value:"2.1.4.3 Invalid Characters",id:"2143-invalid-characters",level:3},{value:"2.1.4.4 Macro Characters",id:"2144-macro-characters",level:3},{value:"2.1.4.5 Multiple Escape Characters",id:"2145-multiple-escape-characters",level:3},{value:"2.1.4.5.1 Examples of Multiple Escape Characters",id:"21451-examples-of-multiple-escape-characters",level:4},{value:"2.1.4.6 Single Escape Character",id:"2146-single-escape-character",level:3},{value:"2.1.4.6.1 Examples of Single Escape Characters",id:"21461-examples-of-single-escape-characters",level:4},{value:"2.1.4.7 Whitespace Characters",id:"2147-whitespace-characters",level:3},{value:"2.1.4.7.1 Examples of Whitespace Characters",id:"21471-examples-of-whitespace-characters",level:4}];function H(e){const r={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"21-character-syntax",children:"2.1 Character Syntax"}),"\n","\n",(0,n.jsx)(i,{}),"\n",(0,n.jsx)(r.h2,{id:"211-readtables",children:"2.1.1 Readtables"}),"\n","\n",(0,n.jsx)(h,{}),"\n",(0,n.jsx)(r.h3,{id:"2111-the-current-readtable",children:"2.1.1.1 The Current Readtable"}),"\n","\n",(0,n.jsx)(d,{}),"\n",(0,n.jsx)(r.h3,{id:"2112-the-standard-readtable",children:"2.1.1.2 The Standard Readtable"}),"\n","\n",(0,n.jsx)(p,{}),"\n",(0,n.jsx)(r.h3,{id:"2113-the-initial-readtable",children:"2.1.1.3 The Initial Readtable"}),"\n","\n",(0,n.jsx)(x,{}),"\n",(0,n.jsx)(r.h2,{id:"212-variables-that-affect-the-lisp-reader",children:"2.1.2 Variables that affect the Lisp Reader"}),"\n","\n",(0,n.jsx)(u,{}),"\n",(0,n.jsx)(r.h2,{id:"213-standard-characters",children:"2.1.3 Standard Characters"}),"\n","\n",(0,n.jsx)(g,{}),"\n",(0,n.jsx)(r.h2,{id:"214-character-syntax-types",children:"2.1.4 Character Syntax Types"}),"\n","\n",(0,n.jsx)(y,{}),"\n",(0,n.jsx)(r.h3,{id:"2141-constituent-characters",children:"2.1.4.1 Constituent Characters"}),"\n","\n",(0,n.jsx)(w,{}),"\n",(0,n.jsx)(r.h3,{id:"2142-constituent-traits",children:"2.1.4.2 Constituent Traits"}),"\n","\n",(0,n.jsx)(C,{}),"\n",(0,n.jsx)(r.h3,{id:"2143-invalid-characters",children:"2.1.4.3 Invalid Characters"}),"\n","\n",(0,n.jsx)(k,{}),"\n",(0,n.jsx)(r.h3,{id:"2144-macro-characters",children:"2.1.4.4 Macro Characters"}),"\n","\n",(0,n.jsx)(A,{}),"\n",(0,n.jsx)(r.h3,{id:"2145-multiple-escape-characters",children:"2.1.4.5 Multiple Escape Characters"}),"\n","\n",(0,n.jsx)(P,{}),"\n",(0,n.jsx)(r.h4,{id:"21451-examples-of-multiple-escape-characters",children:"2.1.4.5.1 Examples of Multiple Escape Characters"}),"\n","\n",(0,n.jsx)(E,{}),"\n",(0,n.jsx)(r.h3,{id:"2146-single-escape-character",children:"2.1.4.6 Single Escape Character"}),"\n","\n",(0,n.jsx)(q,{}),"\n",(0,n.jsx)(r.h4,{id:"21461-examples-of-single-escape-characters",children:"2.1.4.6.1 Examples of Single Escape Characters"}),"\n","\n",(0,n.jsx)(R,{}),"\n",(0,n.jsx)(r.h3,{id:"2147-whitespace-characters",children:"2.1.4.7 Whitespace Characters"}),"\n","\n",(0,n.jsx)(G,{}),"\n",(0,n.jsx)(r.h4,{id:"21471-examples-of-whitespace-characters",children:"2.1.4.7.1 Examples of Whitespace Characters"}),"\n","\n","\n",(0,n.jsx)(W,{})]})}function J(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(H,{...e})}):H(e)}},1151:(e,r,t)=>{t.d(r,{Z:()=>c,a:()=>i});var n=t(7294);const a={},s=n.createContext(a);function i(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);