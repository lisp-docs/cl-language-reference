"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[13083],{28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var s=n(96540);const t={},i=s.createContext(t);function l(e){const r=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:r},e.children)}},82252:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>o,default:()=>j,frontMatter:()=>c,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"chap-9/j-c-dictionary/assert_macro","title":"assert","description":"Expanded Reference: assert","source":"@site/docs/chap-9/j-c-dictionary/assert_macro.md","sourceDirName":"chap-9/j-c-dictionary","slug":"/chap-9/j-c-dictionary/assert_macro","permalink":"/cl-language-reference/chap-9/j-c-dictionary/assert_macro","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-9/j-c-dictionary/assert_macro.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"assert"},"sidebar":"tutorialSidebar","previous":{"title":"9.2 Conditions Dictionary","permalink":"/cl-language-reference/category/92-conditions-dictionary"},"next":{"title":"break-on-signals","permalink":"/cl-language-reference/chap-9/j-c-dictionary/break-on-signals_variable"}}');var t=n(74848),i=n(28453);function l(e){const r={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=r;return n||d("DictionaryLink",!0),s||d("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"assert"})," ",(0,t.jsx)(s,{styled:!0,term:"macro",children:(0,t.jsx)("i",{children:"Macro"})})]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Syntax:"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})})," ",(0,t.jsx)(r.em,{children:"test-form"})," [(",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"{place}"})}),"*) [",(0,t.jsx)(r.em,{children:"datum-form {argument-form}"}),"*]]"]}),"\n",(0,t.jsxs)(r.p,{children:["\u2192 ",(0,t.jsx)(n,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})})]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.em,{children:"test-form"}),"\u2014a ",(0,t.jsx)(s,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})}),"; always evaluated."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"place"})}),"\u2014a ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"place"})}),"; evaluated if an error is signaled."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.em,{children:"datum-form"}),"\u2014a ",(0,t.jsx)(s,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," that evaluates to a ",(0,t.jsx)(r.em,{children:"datum"}),". Evaluated each time an error is to be signaled, or not at all if no error is to be signaled."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.em,{children:"argument-form"}),"\u2014a ",(0,t.jsx)(s,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," that evaluates to an ",(0,t.jsx)(s,{styled:!0,term:"argument",children:(0,t.jsx)("i",{children:"argument"})}),". Evaluated each time an error is to be signaled, or not at all if no error is to be signaled."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.em,{children:"datum"}),", ",(0,t.jsx)(s,{styled:!0,term:"argument",children:(0,t.jsx)("i",{children:"arguments"})}),"\u2014",(0,t.jsx)(s,{styled:!0,term:"designator",children:(0,t.jsx)("i",{children:"designators"})})," for a ",(0,t.jsx)(s,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," of default type ",(0,t.jsx)(n,{styled:!0,term:"error",children:(0,t.jsx)("b",{children:"error"})}),". (These ",(0,t.jsx)(s,{styled:!0,term:"designator",children:(0,t.jsx)("i",{children:"designators"})})," are the result of evaluating ",(0,t.jsx)(r.em,{children:"datum-form"})," and each of the ",(0,t.jsx)(r.em,{children:"argument-forms"}),".)"]}),"\n",(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})})," assures that ",(0,t.jsx)(r.em,{children:"test-form"})," evaluates to ",(0,t.jsx)(s,{styled:!0,term:"true",children:(0,t.jsx)("i",{children:"true"})}),". If ",(0,t.jsx)(r.em,{children:"test-form"})," evaluates to ",(0,t.jsx)(s,{styled:!0,term:"false",children:(0,t.jsx)("i",{children:"false"})}),", ",(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})})," signals a ",(0,t.jsx)(r.em,{children:"correctable error"})," (denoted by ",(0,t.jsx)(r.em,{children:"datum"})," and ",(0,t.jsx)(s,{styled:!0,term:"argument",children:(0,t.jsx)("i",{children:"arguments"})}),"). Continuing from this error using the ",(0,t.jsx)(r.strong,{children:"continue"})," ",(0,t.jsx)(s,{styled:!0,term:"restart",children:(0,t.jsx)("i",{children:"restart"})})," makes it possible for the user to alter the values of the ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"places"})})," before ",(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})})," evaluates ",(0,t.jsx)(r.em,{children:"test-form"})," again. If the value of ",(0,t.jsx)(r.em,{children:"test-form"})," is ",(0,t.jsx)(s,{styled:!0,term:"non-nil",children:(0,t.jsx)("i",{children:"non-nil"})}),", ",(0,t.jsx)(n,{styled:!0,term:"assert",children:(0,t.jsx)("b",{children:"assert"})})," returns ",(0,t.jsx)(n,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"places"})})," are ",(0,t.jsx)(s,{styled:!0,term:"generalized reference",children:(0,t.jsx)("i",{children:"generalized references"})})," to data upon which ",(0,t.jsx)(r.em,{children:"test-form"})," depends, whose values can be changed by the user in attempting to correct the error. ",(0,t.jsx)(s,{styled:!0,term:"subform",children:(0,t.jsx)("i",{children:"Subforms"})})," of each ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"place"})})," are only evaluated if an error is signaled, and might be re-evaluated if the error is re-signaled (after continuing without actually fixing the problem). The order of evaluation of the ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"places"})})," is not specified; see Section 5.1.1.1 (Evaluation of Subforms to Places). If a ",(0,t.jsx)(r.em,{children:"place form"})," is supplied that produces more values than there are store variables, the extra values are ignored. If the supplied ",(0,t.jsx)(s,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," produces fewer values than there are store variables, the missing values are set to ",(0,t.jsx)(n,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-lisp",children:'(setq x (make-array \u2019(3 5) :initial-element 3)) \n\u2192 #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3)) \n(setq y (make-array \u2019(3 5) :initial-element 7)) \n\u2192 #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7)) \n(defun matrix-multiply (a b) \n  (let ((\\*print-array\\* nil)) \n    (assert (and (= (array-rank a) (array-rank b) 2) \n\t\t (= (array-dimension a 1) (array-dimension b 0))) \n\t    (a b) \n\t    "Cannot multiply ~S by ~S." a b) \n    (really-matrix-multiply a b))) \u2192 MATRIX-MULTIPLY \n(matrix-multiply x y) \n\u25b7 Correctable error in MATRIX-MULTIPLY: \n\u25b7 Cannot multiply #<ARRAY ...> by #<ARRAY ...>. \n\u25b7 Restart options: \n\u25b7 1: You will be prompted for one or more new values. \n\u25b7 2: Top level. \n\u25b7 Debug> :continue 1 \n\u25b7 Value for A: x \n\u25b7 Value for B: (make-array \u2019(5 3) :initial-element 6) \n\u2192 #2A((54 54 54 54 54) \n      (54 54 54 54 54) \n      (54 54 54 54 54) \n      (54 54 54 54 54) \n      (54 54 54 54 54)) \n(defun double-safely (x) (assert (numberp x) (x)) (+ x x)) \n(double-safely 4) \n\u2192 8 \n\n(double-safely t) \n\u25b7 Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL. \u25b7 Restart options: \n\u25b7 1: You will be prompted for one or more new values. \n\u25b7 2: Top level. \n\u25b7 Debug> :continue 1 \n\u25b7 Value for X: 7 \n\u2192 14 \n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Affected By:"})}),"\n",(0,t.jsx)(n,{styled:!0,term:"break-on-signals",children:(0,t.jsx)("b",{children:"*break-on-signals*"})}),"\n",(0,t.jsxs)(r.p,{children:["The set of active ",(0,t.jsx)(s,{styled:!0,term:"condition handler",children:(0,t.jsx)("i",{children:"condition handlers"})}),"."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(n,{styled:!0,term:"check-type",children:(0,t.jsx)("b",{children:"check-type"})}),", ",(0,t.jsx)(n,{styled:!0,term:"error",children:(0,t.jsx)("b",{children:"error"})}),", Section 5.1 (Generalized Reference)"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(r.p,{children:["The debugger need not include the ",(0,t.jsx)(r.em,{children:"test-form"})," in the error message, and the ",(0,t.jsx)(s,{styled:!0,term:"place",children:(0,t.jsx)("i",{children:"places"})})," should not be included in the message, but they should be made available for the user\u2019s perusal. If the user gives the \u201ccontinue\u201d command, the values of any of the references can be altered. The details of this depend on the implementation\u2019s style of user interface."]})]})}function a(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}function d(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const c={title:"assert"},o="assert",h={},m=[{value:"Expanded Reference: assert",id:"expanded-reference-assert",level:2}];function x(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"assert",children:"assert"})}),"\n","\n",(0,t.jsx)(a,{}),"\n",(0,t.jsx)(r.h2,{id:"expanded-reference-assert",children:"Expanded Reference: assert"}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsx)(r.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-lisp",children:"(assert )\n"})})]})}function j(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}}}]);