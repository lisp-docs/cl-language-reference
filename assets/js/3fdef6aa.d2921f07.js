"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[10346],{68960:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>U,contentTitle:()=>O,default:()=>H,frontMatter:()=>B,metadata:()=>G,toc:()=>V});var r=s(85893),t=s(11151);function i(e){return(0,r.jsx)(r.Fragment,{})}function a(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i()}function l(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"generalized reference"})," is the use of a ",(0,r.jsx)(n.em,{children:"form"}),", sometimes called a ",(0,r.jsx)(n.em,{children:"place"}),", as if it were a ",(0,r.jsx)(n.em,{children:"variable"})," that could be read and written. The ",(0,r.jsx)(n.em,{children:"value"})," of a ",(0,r.jsx)(n.em,{children:"place"})," is the ",(0,r.jsx)(n.em,{children:"object"})," to which the ",(0,r.jsx)(n.em,{children:"place form"})," evaluates. The ",(0,r.jsx)(n.em,{children:"value"})," of a ",(0,r.jsx)(n.em,{children:"place"})," can be changed by using ",(0,r.jsx)(n.strong,{children:"setf"}),". The concept of binding a ",(0,r.jsx)(n.em,{children:"place"})," is not defined"]}),"\n",(0,r.jsxs)(n.p,{children:["in Common Lisp, but an ",(0,r.jsx)(n.em,{children:"implementation"})," is permitted to extend the language by defining this concept."]}),"\n",(0,r.jsxs)(n.p,{children:["Figure 5\u20131 contains examples of the use of ",(0,r.jsx)(n.strong,{children:"setf"}),". Note that the values returned by evaluating the ",(0,r.jsx)(n.em,{children:"forms"})," in column two are not necessarily the same as those obtained by evaluating the ",(0,r.jsx)(n.em,{children:"forms"})," in column three. In general, the exact ",(0,r.jsx)(n.em,{children:"macro expansion"})," of a ",(0,r.jsx)(n.strong,{children:"setf"})," ",(0,r.jsx)(n.em,{children:"form"})," is not guaranteed and can even be ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"; all that is guaranteed is that the expansion is an update form that works for that particular ",(0,r.jsx)(n.em,{children:"implementation"}),", that the left-to-right evaluation of ",(0,r.jsx)(n.em,{children:"subforms"})," is preserved, and that the ultimate result of evaluating ",(0,r.jsx)(n.strong,{children:"setf"})," is the value or values being stored."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Access function Update Function Update using setf"}),"\n|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)("p",{children:"x (setq x datum) (setf x datum) "}),(0,r.jsx)("p",{children:"(car x) (rplaca x datum) (setf (car x) datum) (symbol-value x) (set x datum) (setf (symbol-value x) datum)"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 5\u20131. Examples of setf"})}),"\n",(0,r.jsxs)(n.p,{children:["Figure 5\u20132 shows ",(0,r.jsx)(n.em,{children:"operators"})," relating to ",(0,r.jsx)(n.em,{children:"places"})," and ",(0,r.jsx)(n.em,{children:"generalized reference"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"assert defsetf push"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"ccase get-setf-expansion remf"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"ctypecase getf rotatef decf incf setf"})," "]}),(0,r.jsx)("p",{children:(0,r.jsx)(n.strong,{children:"define-modify-macro pop shiftf define-setf-expander psetf"})}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 5\u20132. Operators relating to places and generalized reference."})}),"\n",(0,r.jsxs)(n.p,{children:["Some of the ",(0,r.jsx)(n.em,{children:"operators"})," above manipulate ",(0,r.jsx)(n.em,{children:"places"})," and some manipulate ",(0,r.jsx)(n.em,{children:"setf expanders"}),". A ",(0,r.jsx)(n.em,{children:"setf expansion"})," can be derived from any ",(0,r.jsx)(n.em,{children:"place"}),". New ",(0,r.jsx)(n.em,{children:"setf expanders"})," can be defined by using ",(0,r.jsx)(n.strong,{children:"defsetf"})," and ",(0,r.jsx)(n.strong,{children:"define-setf-expander"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"})]})}function c(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}function o(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The following rules apply to the ",(0,r.jsx)(n.em,{children:"evaluation"})," of ",(0,r.jsx)(n.em,{children:"subforms"})," in a ",(0,r.jsx)(n.em,{children:"place"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:["1. The evaluation ordering of ",(0,r.jsx)(n.em,{children:"subforms"})," within a ",(0,r.jsx)(n.em,{children:"place"})," is determined by the order specified by the second value returned by ",(0,r.jsx)(n.strong,{children:"get-setf-expansion"}),". For all ",(0,r.jsx)(n.em,{children:"places"})," defined by this specification (",(0,r.jsx)(n.em,{children:"e.g."}),", ",(0,r.jsx)(n.strong,{children:"getf"}),", ",(0,r.jsx)(n.strong,{children:"ldb"}),", ",(0,r.jsx)(n.em,{children:". . ."}),"), this order of evaluation is left-to-right. When a ",(0,r.jsx)(n.em,{children:"place"})," is derived from a macro expansion, this rule is applied after the macro is expanded to find the appropriate ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Places"})," defined by using ",(0,r.jsx)(n.strong,{children:"defmacro"})," or ",(0,r.jsx)(n.strong,{children:"define-setf-expander"})," use the evaluation order defined by those definitions. For example, consider the following:"]}),"\n",(0,r.jsx)(n.p,{children:"(defmacro wrong-order (x y) \u2018(getf ,y ,x))"}),"\n",(0,r.jsxs)(n.p,{children:["This following ",(0,r.jsx)(n.em,{children:"form"})," evaluates place2 first and then place1 because that is the order they are evaluated in the macro expansion:"]}),"\n",(0,r.jsx)(n.p,{children:"(push value (wrong-order place1 place2))"}),"\n",(0,r.jsxs)(n.p,{children:["2. For the ",(0,r.jsx)(n.em,{children:"macros"})," that manipulate ",(0,r.jsx)(n.em,{children:"places"})," (",(0,r.jsx)(n.strong,{children:"push"}),", ",(0,r.jsx)(n.strong,{children:"pushnew"}),", ",(0,r.jsx)(n.strong,{children:"remf"}),", ",(0,r.jsx)(n.strong,{children:"incf"}),", ",(0,r.jsx)(n.strong,{children:"decf"}),", ",(0,r.jsx)(n.strong,{children:"shiftf"}),", ",(0,r.jsx)(n.strong,{children:"rotatef"}),", ",(0,r.jsx)(n.strong,{children:"psetf"}),", ",(0,r.jsx)(n.strong,{children:"setf"}),", ",(0,r.jsx)(n.strong,{children:"pop"}),", and those defined by ",(0,r.jsx)(n.strong,{children:"define-modify-macro"}),") the ",(0,r.jsx)(n.em,{children:"subforms"})," of the macro call are evaluated exactly once in left-to-right order, with the ",(0,r.jsx)(n.em,{children:"subforms"})," of the ",(0,r.jsx)(n.em,{children:"places"})," evaluated in the order specified in (1)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"push"}),", ",(0,r.jsx)(n.strong,{children:"pushnew"}),", ",(0,r.jsx)(n.strong,{children:"remf"}),", ",(0,r.jsx)(n.strong,{children:"incf"}),", ",(0,r.jsx)(n.strong,{children:"decf"}),", ",(0,r.jsx)(n.strong,{children:"shiftf"}),", ",(0,r.jsx)(n.strong,{children:"rotatef"}),", ",(0,r.jsx)(n.strong,{children:"psetf"}),", ",(0,r.jsx)(n.strong,{children:"pop"})," evaluate all ",(0,r.jsx)(n.em,{children:"subforms"})," before modifying any of the ",(0,r.jsx)(n.em,{children:"place"})," locations. ",(0,r.jsx)(n.strong,{children:"setf"})," (in the case when ",(0,r.jsx)(n.strong,{children:"setf"})," has more than two arguments) performs its operation on each pair in sequence. For example, in"]}),"\n",(0,r.jsx)(n.p,{children:"(setf place1 value1 place2 value2 ...)"}),"\n",(0,r.jsxs)(n.p,{children:["the ",(0,r.jsx)(n.em,{children:"subforms"})," of place1 and value1 are evaluated, the location specified by place1 is modified to contain the value returned by value1, and then the rest of the ",(0,r.jsx)(n.strong,{children:"setf"})," form is processed in a like manner."]}),"\n",(0,r.jsxs)(n.p,{children:["3. For ",(0,r.jsx)(n.strong,{children:"check-type"}),", ",(0,r.jsx)(n.strong,{children:"ctypecase"}),", and ",(0,r.jsx)(n.strong,{children:"ccase"}),", ",(0,r.jsx)(n.em,{children:"subforms"})," of the ",(0,r.jsx)(n.em,{children:"place"})," are evaluated once as in (1), but might be evaluated again if the type check fails in the case of ",(0,r.jsx)(n.strong,{children:"check-type"})," or none of the cases hold in ",(0,r.jsx)(n.strong,{children:"ctypecase"})," and ",(0,r.jsx)(n.strong,{children:"ccase"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["4. For ",(0,r.jsx)(n.strong,{children:"assert"}),", the order of evaluation of the generalized references is not specified. Rules 2, 3 and 4 cover all ",(0,r.jsx)(n.em,{children:"standardized macros"})," that manipulate ",(0,r.jsx)(n.em,{children:"places"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}function h(e){const n={code:"code",pre:"pre",...(0,t.a)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:'\n\n(let ((ref2 (list \u2019()))) \n\n  (push (progn (princ "1") \u2019ref-1) \n\n\n\n\n\n\n\n\t(car (progn (princ "2") ref2)))) \n\n\u25b7 12 \n\n\u2192 (REF1) \n\n(let (x) \n\n  (push (setq x (list \u2019a)) \n\n\t(car (setq x (list \u2019b)))) \n\n  x) \n\n\u2192 (((A) . B)) \n\n**push** first evaluates (setq x (list \u2019a)) \u2192 (a), then evaluates (setq x (list \u2019b)) \u2192 (b), then modifies the *car* of this latest value to be ((a) . b). \n\n\n'})})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function x(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Sometimes it is possible to avoid evaluating ",(0,r.jsx)(n.em,{children:"subforms"})," of a ",(0,r.jsx)(n.em,{children:"place"})," multiple times or in the wrong order. A ",(0,r.jsx)(n.em,{children:"setf expansion"})," for a given access form can be expressed as an ordered collection of five ",(0,r.jsx)(n.em,{children:"objects"}),":"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"List of temporary variables"})}),"\n",(0,r.jsxs)(n.p,{children:["a list of symbols naming temporary variables to be bound sequentially, as if by ",(0,r.jsx)(n.strong,{children:"let*"}),", to ",(0,r.jsx)(n.em,{children:"values"})," resulting from value forms."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"List of value forms"})}),"\n",(0,r.jsxs)(n.p,{children:["a list of forms (typically, ",(0,r.jsx)(n.em,{children:"subforms"})," of the ",(0,r.jsx)(n.em,{children:"place"}),") which when evaluated yield the values to which the corresponding temporary variables should be bound."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"List of store variables"})}),"\n",(0,r.jsxs)(n.p,{children:["a list of symbols naming temporary store variables which are to hold the new values that will be assigned to the ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Storing form"})}),"\n",(0,r.jsxs)(n.p,{children:["a form which can reference both the temporary and the store variables, and which changes the ",(0,r.jsx)(n.em,{children:"value"})," of the ",(0,r.jsx)(n.em,{children:"place"})," and guarantees to return as its values the values of the store variables, which are the correct values for ",(0,r.jsx)(n.strong,{children:"setf"})," to return."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Accessing form"})}),"\n",(0,r.jsxs)(n.p,{children:["a ",(0,r.jsx)(n.em,{children:"form"})," which can reference the temporary variables, and which returns the ",(0,r.jsx)(n.em,{children:"value"})," of the ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The value returned by the accessing form is affected by execution of the storing form, but either of these forms might be evaluated any number of times."}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"}),"\n",(0,r.jsxs)(n.p,{children:["It is possible to do more than one ",(0,r.jsx)(n.strong,{children:"setf"})," in parallel via ",(0,r.jsx)(n.strong,{children:"psetf"}),", ",(0,r.jsx)(n.strong,{children:"shiftf"}),", and ",(0,r.jsx)(n.strong,{children:"rotatef"}),". Because of this, the ",(0,r.jsx)(n.em,{children:"setf expander"})," must produce new temporary and store variable names every time. For examples of how to do this, see ",(0,r.jsx)(n.strong,{children:"gensym"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For each ",(0,r.jsx)(n.em,{children:"standardized"})," accessor function ",(0,r.jsx)(n.em,{children:"F"}),", unless it is explicitly documented otherwise, it is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether the ability to use an ",(0,r.jsx)(n.em,{children:"F form"})," as a ",(0,r.jsx)(n.strong,{children:"setf"})," ",(0,r.jsx)(n.em,{children:"place"})," is implemented by a ",(0,r.jsx)(n.em,{children:"setf expander"})," or a ",(0,r.jsx)(n.em,{children:"setf function"}),". Also, it follows from this that it is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether the name (setf ",(0,r.jsx)(n.em,{children:"F"}),") is ",(0,r.jsx)(n.em,{children:"fbound"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}function f(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Examples of the contents of the constituents of ",(0,r.jsx)(n.em,{children:"setf expansions"})," follow."]}),"\n",(0,r.jsxs)(n.p,{children:["For a variable ",(0,r.jsx)(n.em,{children:"x"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",metastring:'title="Figure 5\u20133. Sample Setf Expansion of a Variable"',children:"<p>() ;list of temporary variables </p><p>() ;list of value forms </p><p>(g0001) ;list of store variables </p><p>(setq *x* g0001) ;storing form </p><p>*x* ;accessing form</p>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For (car ",(0,r.jsx)(n.em,{children:"exp"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",metastring:'title="Figure 5\u20134. Sample Setf Expansion of a CAR Form"',children:"<p>(g0002) ;list of temporary variables (*exp*) ;list of value forms </p><p>(g0003) ;list of store variables </p><p>(progn (rplaca g0002 g0003) g0003) ;storing form </p><p>(car g0002) ;accessing form</p>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For (subseq ",(0,r.jsx)(n.em,{children:"seq s e"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",metastring:'title="Figure 5\u20135. Sample Setf Expansion of a SUBSEQ Form"',children:"<p>(g0004 g0005 g0006) ;list of temporary variables </p><p>(*seq s e*) ;list of value forms </p><p>(g0007) ;list of store variables </p><p>(progn (replace g0004 g0007 :start1 g0005 :end1 g0006) g0007) </p><p>;storing form </p><p>(subseq g0004 g0005 g0006) ; accessing form</p>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In some cases, if a ",(0,r.jsx)(n.em,{children:"subform"})," of a ",(0,r.jsx)(n.em,{children:"place"})," is itself a ",(0,r.jsx)(n.em,{children:"place"}),", it is necessary to expand the ",(0,r.jsx)(n.em,{children:"subform"})," in order to compute some of the values in the expansion of the outer ",(0,r.jsx)(n.em,{children:"place"}),". For (ldb ",(0,r.jsx)(n.em,{children:"bs"})," (car ",(0,r.jsx)(n.em,{children:"exp"}),")):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",metastring:'title="Figure 5\u20136. Sample Setf Expansion of a LDB Form"',children:"<p>(g0001 g0002) ;list of temporary variables </p><p>(*bs exp*) ;list of value forms </p><p>(g0003) ;list of store variables </p><p>(progn (rplaca g0002 (dpb g0003 g0001 (car g0002))) g0003) </p><p>;storing form </p><p>(ldb g0001 (car g0002)) ; accessing form</p>\n"})})]})}function j(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}function u(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Several kinds of ",(0,r.jsx)(n.em,{children:"places"})," are defined by Common Lisp; this section enumerates them. This set can be extended by ",(0,r.jsx)(n.em,{children:"implementations"})," and by ",(0,r.jsx)(n.em,{children:"programmer code"}),"."]})}function g(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}function b(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["The name of a ",(0,r.jsx)(n.em,{children:"lexical variable"})," or ",(0,r.jsx)(n.em,{children:"dynamic variable"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"}),"."]})}function v(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}function y(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"function form"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"})," if it falls into one of the following categories:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A function call form whose first element is the name of any one of the functions in Figure 5\u20137."]}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"aref cdadr get"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"bit cdar gethash"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caaaar cddaar logical-pathname-translations caaadr cddadr macro-function"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caaar cddar ninth"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caadar cdddar nth"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caaddr cddddr readtable-case"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caadr cdddr rest"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caar cddr row-major-aref"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cadaar cdr sbit"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cadadr char schar"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cadar class-name second"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caddar compiler-macro-function seventh"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cadddr documentation sixth"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"caddr eighth slot-value"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cadr elt subseq"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"car fdefinition svref"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cdaaar fifth symbol-function"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cdaadr fill-pointer symbol-plist"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cdaar find-class symbol-value"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"cdadar first tenth"})," "]}),(0,r.jsx)("p",{children:(0,r.jsx)(n.strong,{children:"cdaddr fourth third"})}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 5\u20137. Functions that setf can be used with\u20141"})}),"\n",(0,r.jsxs)(n.p,{children:["In the case of ",(0,r.jsx)(n.strong,{children:"subseq"}),", the replacement value must be a ",(0,r.jsx)(n.em,{children:"sequence"})," whose elements might be contained by the sequence argument to ",(0,r.jsx)(n.strong,{children:"subseq"}),", but does not have to be a ",(0,r.jsx)(n.em,{children:"sequence"})," of the same ",(0,r.jsx)(n.em,{children:"type"})," as the ",(0,r.jsx)(n.em,{children:"sequence"})," of which the subsequence is specified. If the length of the replacement value does not equal the length of the subsequence to be replaced, then the shorter length determines the number of elements to be stored, as for ",(0,r.jsx)(n.strong,{children:"replace"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A function call form whose first element is the name of a selector function constructed by ",(0,r.jsx)(n.strong,{children:"defstruct"}),". The function name must refer to the global function definition, rather than a locally defined ",(0,r.jsx)(n.em,{children:"function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A function call form whose first element is the name of any one of the functions in Figure 5\u20138, provided that the supplied argument to that function is in turn a ",(0,r.jsx)(n.em,{children:"place"})," form; in this case the new ",(0,r.jsx)(n.em,{children:"place"})," has stored back into it the result of applying the supplied \u201cupdate\u201d function."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Function name Argument that is a"})," ",(0,r.jsx)(n.em,{children:"place"})," ",(0,r.jsx)(n.strong,{children:"Update function used"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"ldb"})," second ",(0,r.jsx)(n.strong,{children:"dpb"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"mask-field"})," second ",(0,r.jsx)(n.strong,{children:"deposit-field"})," "]}),(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"getf"})," first ",(0,r.jsx)(n.em,{children:"implementation-dependent"})]}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 5\u20138. Functions that setf can be used with\u20142"})}),"\n",(0,r.jsxs)(n.p,{children:["During the ",(0,r.jsx)(n.strong,{children:"setf"})," expansion of these ",(0,r.jsx)(n.em,{children:"forms"}),", it is necessary to call ",(0,r.jsx)(n.strong,{children:"get-setf-expansion"})," in order to figure out how the inner, nested generalized variable must be treated."]}),"\n",(0,r.jsxs)(n.p,{children:["The information from ",(0,r.jsx)(n.strong,{children:"get-setf-expansion"})," is used as follows."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ldb"})}),"\n",(0,r.jsx)(n.p,{children:"In a form such as:"}),"\n",(0,r.jsxs)(n.p,{children:["(setf (ldb ",(0,r.jsx)(n.em,{children:"byte-spec place-form"}),") ",(0,r.jsx)(n.em,{children:"value-form"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["the place referred to by the ",(0,r.jsx)(n.em,{children:"place-form"})," must always be both ",(0,r.jsx)(n.em,{children:"read"})," and ",(0,r.jsx)(n.em,{children:"written"}),"; note"]}),"\n",(0,r.jsxs)(n.p,{children:["that the update is to the generalized variable specified by ",(0,r.jsx)(n.em,{children:"place-form"}),", not to any"]}),"\n",(0,r.jsxs)(n.p,{children:["object of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"integer"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Thus this ",(0,r.jsx)(n.strong,{children:"setf"})," should generate code to do the following:"]}),"\n",(0,r.jsxs)(n.p,{children:["1. Evaluate ",(0,r.jsx)(n.em,{children:"byte-spec"})," (and bind it into a temporary variable)."]}),"\n",(0,r.jsxs)(n.p,{children:["2. Bind the temporary variables for ",(0,r.jsx)(n.em,{children:"place-form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["3. Evaluate ",(0,r.jsx)(n.em,{children:"value-form"})," (and bind its value or values into the store variable)."]}),"\n",(0,r.jsxs)(n.p,{children:["4. Do the ",(0,r.jsx)(n.em,{children:"read"})," from ",(0,r.jsx)(n.em,{children:"place-form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["5. Do the ",(0,r.jsx)(n.em,{children:"write"})," into ",(0,r.jsx)(n.em,{children:"place-form"})," with the given bits of the ",(0,r.jsx)(n.em,{children:"integer"})," fetched in"]}),"\n",(0,r.jsx)(n.p,{children:"step 4 replaced with the value from step 3."}),"\n",(0,r.jsxs)(n.p,{children:["If the evaluation of ",(0,r.jsx)(n.em,{children:"value-form"})," in step 3 alters what is found in ",(0,r.jsx)(n.em,{children:"place-form"}),", such as"]}),"\n",(0,r.jsxs)(n.p,{children:["setting different bits of ",(0,r.jsx)(n.em,{children:"integer"})," , then the change of the bits denoted by ",(0,r.jsx)(n.em,{children:"byte-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:["is to that altered ",(0,r.jsx)(n.em,{children:"integer"})," , because step 4 is done after the ",(0,r.jsx)(n.em,{children:"value-form"})," evaluation."]}),"\n",(0,r.jsxs)(n.p,{children:["Nevertheless, the evaluations required for ",(0,r.jsx)(n.em,{children:"binding"})," the temporary variables are"]}),"\n",(0,r.jsx)(n.p,{children:"done in steps 1 and 2, and thus the expected left-to-right evaluation order is seen."}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.p,{children:"(setq integer #x69) \u2192 #x69"}),"\n",(0,r.jsx)(n.p,{children:"(rotatef (ldb (byte 4 4) integer)"}),"\n",(0,r.jsx)(n.p,{children:"(ldb (byte 4 0) integer))"}),"\n",(0,r.jsx)(n.p,{children:"integer \u2192 #x96"}),"\n",(0,r.jsx)(n.p,{children:";;; This example is trying to swap two independent bit fields"}),"\n",(0,r.jsx)(n.p,{children:";;; in an integer. Note that the generalized variable of"}),"\n",(0,r.jsx)(n.p,{children:";;; interest here is just the (possibly local) program variable"}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"}),"\n",(0,r.jsx)(n.p,{children:";;; integer."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"mask-field"})}),"\n",(0,r.jsxs)(n.p,{children:["This case is the same as ",(0,r.jsx)(n.strong,{children:"ldb"})," in all essential aspects."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"getf"})}),"\n",(0,r.jsx)(n.p,{children:"In a form such as:"}),"\n",(0,r.jsxs)(n.p,{children:["(setf (getf ",(0,r.jsx)(n.em,{children:"place-form ind-form"}),") ",(0,r.jsx)(n.em,{children:"value-form"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["the place referred to by ",(0,r.jsx)(n.em,{children:"place-form"})," must always be both ",(0,r.jsx)(n.em,{children:"read"})," and ",(0,r.jsx)(n.em,{children:"written"}),"; note that"]}),"\n",(0,r.jsxs)(n.p,{children:["the update is to the generalized variable specified by ",(0,r.jsx)(n.em,{children:"place-form"}),", not necessarily to"]}),"\n",(0,r.jsxs)(n.p,{children:["the particular ",(0,r.jsx)(n.em,{children:"list"})," that is the property list in question."]}),"\n",(0,r.jsxs)(n.p,{children:["Thus this ",(0,r.jsx)(n.strong,{children:"setf"})," should generate code to do the following:"]}),"\n",(0,r.jsxs)(n.p,{children:["1. Bind the temporary variables for ",(0,r.jsx)(n.em,{children:"place-form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["2. Evaluate ",(0,r.jsx)(n.em,{children:"ind-form"})," (and bind it into a temporary variable)."]}),"\n",(0,r.jsxs)(n.p,{children:["3. Evaluate ",(0,r.jsx)(n.em,{children:"value-form"})," (and bind its value or values into the store variable)."]}),"\n",(0,r.jsxs)(n.p,{children:["4. Do the ",(0,r.jsx)(n.em,{children:"read"})," from ",(0,r.jsx)(n.em,{children:"place-form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["5. Do the ",(0,r.jsx)(n.em,{children:"write"})," into ",(0,r.jsx)(n.em,{children:"place-form"})," with a possibly-new property list obtained"]}),"\n",(0,r.jsx)(n.p,{children:"by combining the values from steps 2, 3, and 4. (Note that the phrase"}),"\n",(0,r.jsx)(n.p,{children:"\u201cpossibly-new property list\u201d can mean that the former property list is"}),"\n",(0,r.jsx)(n.p,{children:"somehow destructively re-used, or it can mean partial or full copying of"}),"\n",(0,r.jsx)(n.p,{children:"it. Since either copying or destructive re-use can occur, the treatment"}),"\n",(0,r.jsx)(n.p,{children:"of the resultant value for the possibly-new property list must proceed as"}),"\n",(0,r.jsx)(n.p,{children:"if it were a different copy needing to be stored back into the generalized"}),"\n",(0,r.jsx)(n.p,{children:"variable.)"}),"\n",(0,r.jsxs)(n.p,{children:["If the evaluation of ",(0,r.jsx)(n.em,{children:"value-form"})," in step 3 alters what is found in ",(0,r.jsx)(n.em,{children:"place-form"}),", such"]}),"\n",(0,r.jsx)(n.p,{children:"as setting a different named property in the list, then the change of the property"}),"\n",(0,r.jsxs)(n.p,{children:["denoted by ",(0,r.jsx)(n.em,{children:"ind-form"})," is to that altered list, because step 4 is done after the"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"value-form"})," evaluation. Nevertheless, the evaluations required for ",(0,r.jsx)(n.em,{children:"binding"})," the"]}),"\n",(0,r.jsx)(n.p,{children:"temporary variables are done in steps 1 and 2, and thus the expected left-to-right"}),"\n",(0,r.jsx)(n.p,{children:"evaluation order is seen."}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.p,{children:"(setq s (setq r (list (list \u2019a 1 \u2019b 2 \u2019c 3)))) \u2192 ((a 1 b 2 c 3))"}),"\n",(0,r.jsx)(n.p,{children:"(setf (getf (car r) \u2019b)"}),"\n",(0,r.jsx)(n.p,{children:"(progn (setq r nil) 6)) \u2192 6"}),"\n",(0,r.jsx)(n.p,{children:"r \u2192 NIL"}),"\n",(0,r.jsx)(n.p,{children:"s \u2192 ((A 1 B 6 C 3))"}),"\n",(0,r.jsx)(n.p,{children:";;; Note that the (setq r nil) does not affect the actions of"}),"\n",(0,r.jsx)(n.p,{children:";;; the SETF because the value of R had already been saved in"}),"\n",(0,r.jsx)(n.p,{children:";;; a temporary variable as part of the step 1. Only the CAR"}),"\n",(0,r.jsx)(n.p,{children:";;; of this value will be retrieved, and subsequently modified"}),"\n",(0,r.jsx)(n.p,{children:";;; after the value computation."})]})}function w(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}function F(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"values"})," ",(0,r.jsx)(n.em,{children:"form"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"}),", provided that each of its ",(0,r.jsx)(n.em,{children:"subforms"})," is also a ",(0,r.jsx)(n.em,{children:"place"})," form. A form such as"]}),"\n",(0,r.jsxs)(n.p,{children:["(setf (values ",(0,r.jsx)(n.em,{children:"place-1 . . . place-n"}),") ",(0,r.jsx)(n.em,{children:"values-form"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"does the following:"}),"\n",(0,r.jsxs)(n.p,{children:["1. The ",(0,r.jsx)(n.em,{children:"subforms"})," of each nested ",(0,r.jsx)(n.em,{children:"place"})," are evaluated in left-to-right order."]}),"\n",(0,r.jsxs)(n.p,{children:["2. The ",(0,r.jsx)(n.em,{children:"values-form"})," is evaluated, and the first store variable from each ",(0,r.jsx)(n.em,{children:"place"})," is bound to its return values as if by ",(0,r.jsx)(n.strong,{children:"multiple-value-bind"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["3. If the ",(0,r.jsx)(n.em,{children:"setf expansion"})," for any ",(0,r.jsx)(n.em,{children:"place"})," involves more than one store variable, then the additional store variables are bound to ",(0,r.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["4. The storing forms for each ",(0,r.jsx)(n.em,{children:"place"})," are evaluated in left-to-right order."]}),"\n",(0,r.jsxs)(n.p,{children:["The storing form in the ",(0,r.jsx)(n.em,{children:"setf expansion"})," of ",(0,r.jsx)(n.strong,{children:"values"})," returns as ",(0,r.jsx)(n.em,{children:"multiple values"}),(0,r.jsx)("sub",{children:"2"})," the values of the store variables in step 2. That is, the number of values returned is the same as the number of ",(0,r.jsx)(n.em,{children:"place"})," forms. This may be more or fewer values than are produced by the ",(0,r.jsx)(n.em,{children:"values-form"}),"."]})]})}function E(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(F,{...e})}):F(e)}function S(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"the"})," ",(0,r.jsx)(n.em,{children:"form"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"}),", in which case the declaration is transferred to the ",(0,r.jsx)(n.em,{children:"newvalue"})," form, and the resulting ",(0,r.jsx)(n.strong,{children:"setf"})," is analyzed. For example,"]}),"\n",(0,r.jsx)(n.p,{children:"(setf (the integer (cadr x)) (+ y 3))"}),"\n",(0,r.jsx)(n.p,{children:"is processed as if it were"}),"\n",(0,r.jsx)(n.p,{children:"(setf (cadr x) (the integer (+ y 3)))"}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"})]})}function P(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}function T(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The following situations involving ",(0,r.jsx)(n.strong,{children:"setf"})," of ",(0,r.jsx)(n.strong,{children:"apply"})," must be supported:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," (setf (apply #\u2019aref ",(0,r.jsx)(n.em,{children:"array {subscript}"}),"* ",(0,r.jsx)(n.em,{children:"more-subscripts"}),") ",(0,r.jsx)(n.em,{children:"new-element"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," (setf (apply #\u2019bit ",(0,r.jsx)(n.em,{children:"array {subscript}"}),"* ",(0,r.jsx)(n.em,{children:"more-subscripts"}),") ",(0,r.jsx)(n.em,{children:"new-element"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," (setf (apply #\u2019sbit ",(0,r.jsx)(n.em,{children:"array {subscript}"}),"* ",(0,r.jsx)(n.em,{children:"more-subscripts"}),") ",(0,r.jsx)(n.em,{children:"new-element"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["In all three cases, the ",(0,r.jsx)(n.em,{children:"element"})," of ",(0,r.jsx)(n.em,{children:"array"})," designated by the concatenation of ",(0,r.jsx)(n.em,{children:"subscripts"})," and ",(0,r.jsx)(n.em,{children:"more-subscripts"})," (",(0,r.jsx)(n.em,{children:"i.e."}),", the same ",(0,r.jsx)(n.em,{children:"element"})," which would be ",(0,r.jsx)(n.em,{children:"read"})," by the call to ",(0,r.jsx)(n.em,{children:"apply"})," if it were not part of a ",(0,r.jsx)(n.strong,{children:"setf"})," ",(0,r.jsx)(n.em,{children:"form"}),") is changed to have the ",(0,r.jsx)(n.em,{children:"value"})," given by ",(0,r.jsx)(n.em,{children:"new-element"}),". For these usages, the function name (",(0,r.jsx)(n.strong,{children:"aref"}),", ",(0,r.jsx)(n.strong,{children:"bit"}),", or ",(0,r.jsx)(n.strong,{children:"sbit"}),") must refer to the global function definition, rather than a locally defined ",(0,r.jsx)(n.em,{children:"function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["No other ",(0,r.jsx)(n.em,{children:"standardized function"})," is required to be supported, but an ",(0,r.jsx)(n.em,{children:"implementation"})," may define such support. An ",(0,r.jsx)(n.em,{children:"implementation"})," may also define support for ",(0,r.jsx)(n.em,{children:"implementation-defined operators"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If a user-defined ",(0,r.jsx)(n.em,{children:"function"})," is used in this context, the following equivalence is true, except that care is taken to preserve proper left-to-right evaluation of argument ",(0,r.jsx)(n.em,{children:"subforms"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:["(setf (apply #\u2019",(0,r.jsx)(n.em,{children:"name {arg}"}),"*) ",(0,r.jsx)(n.em,{children:"val"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2261"})," (apply #\u2019(setf ",(0,r.jsx)(n.em,{children:"name"}),") ",(0,r.jsx)(n.em,{children:"val {arg}"}),"*)"]})]})}function q(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(T,{...e})}):T(e)}function z(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["Any ",(0,r.jsx)(n.em,{children:"compound form"})," for which the ",(0,r.jsx)(n.em,{children:"operator"})," has a ",(0,r.jsx)(n.em,{children:"setf expander"})," defined can be used as a ",(0,r.jsx)(n.em,{children:"place"}),". The ",(0,r.jsx)(n.em,{children:"operator"})," must refer to the global function definition, rather than a locally defined ",(0,r.jsx)(n.em,{children:"function"})," or ",(0,r.jsx)(n.em,{children:"macro"}),"."]})}function A(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(z,{...e})}):z(e)}function C(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"macro form"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"}),", in which case Common Lisp expands the ",(0,r.jsx)(n.em,{children:"macro form"})," as if by ",(0,r.jsx)(n.strong,{children:"macroexpand-1"})," and then uses the ",(0,r.jsx)(n.em,{children:"macro expansion"})," in place of the original ",(0,r.jsx)(n.em,{children:"place"}),". Such ",(0,r.jsx)(n.em,{children:"macro expansion"})," is attempted only after exhausting all other possibilities other than expanding into a call to a function named (setf ",(0,r.jsx)(n.em,{children:"reader"}),")."]})}function k(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(C,{...e})}):C(e)}function N(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["A reference to a ",(0,r.jsx)(n.em,{children:"symbol"})," that has been ",(0,r.jsx)(n.em,{children:"established"})," as a ",(0,r.jsx)(n.em,{children:"symbol macro"})," can be used as a ",(0,r.jsx)(n.em,{children:"place"}),". In this case, ",(0,r.jsx)(n.strong,{children:"setf"})," expands the reference and then analyzes the resulting ",(0,r.jsx)(n.em,{children:"form"}),"."]})}function R(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(N,{...e})}):N(e)}function D(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["For any other ",(0,r.jsx)(n.em,{children:"compound form"})," for which the ",(0,r.jsx)(n.em,{children:"operator"})," is a ",(0,r.jsx)(n.em,{children:"symbol f"})," , the ",(0,r.jsx)(n.strong,{children:"setf"})," ",(0,r.jsx)(n.em,{children:"form"})," expands into a call to the ",(0,r.jsx)(n.em,{children:"function"})," named (setf ",(0,r.jsx)(n.em,{children:"f"})," ). The first ",(0,r.jsx)(n.em,{children:"argument"})," in the newly constructed ",(0,r.jsx)(n.em,{children:"function form"})," is ",(0,r.jsx)(n.em,{children:"newvalue"})," and the remaining ",(0,r.jsx)(n.em,{children:"arguments"})," are the remaining ",(0,r.jsx)(n.em,{children:"elements"})," of ",(0,r.jsx)(n.em,{children:"place"}),". This expansion occurs"]}),"\n",(0,r.jsxs)(n.p,{children:["regardless of whether ",(0,r.jsx)(n.em,{children:"f"})," or (setf ",(0,r.jsx)(n.em,{children:"f"})," ) is defined as a ",(0,r.jsx)(n.em,{children:"function"})," locally, globally, or not at all. For example,"]}),"\n",(0,r.jsxs)(n.p,{children:["(setf (",(0,r.jsx)(n.em,{children:"f arg1 arg2"})," ...) ",(0,r.jsx)(n.em,{children:"new-value"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"expands into a form with the same effect and value as"}),"\n",(0,r.jsxs)(n.p,{children:["(let ((#",":temp-1"," arg1) ;force correct order of evaluation"]}),"\n",(0,r.jsxs)(n.p,{children:["(#",":temp-2"," arg2)"]}),"\n",(0,r.jsx)(n.p,{children:"..."}),"\n",(0,r.jsxs)(n.p,{children:["(#",":temp-0"," ",(0,r.jsx)(n.em,{children:"new-value"}),"))"]}),"\n",(0,r.jsxs)(n.p,{children:["(funcall (function (setf ",(0,r.jsx)(n.em,{children:"f"})," )) #",":temp-0"," #",":temp-1"," #",":temp-2","...))"]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"function"})," named (setf ",(0,r.jsx)(n.em,{children:"f"})," ) must return its first argument as its only value in order to preserve the semantics of ",(0,r.jsx)(n.strong,{children:"setf"}),"."]})]})}function I(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(D,{...e})}):D(e)}function L(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["For each of the \u201cread-modify-write\u201d ",(0,r.jsx)(n.em,{children:"operators"})," in Figure 5\u20139, and for any additional ",(0,r.jsx)(n.em,{children:"macros"})," defined by the ",(0,r.jsx)(n.em,{children:"programmer"})," using ",(0,r.jsx)(n.strong,{children:"define-modify-macro"}),", an exception is made to the normal rule of left-to-right evaluation of arguments. Evaluation of ",(0,r.jsx)(n.em,{children:"argument forms"})," occurs in left-to-right order, with the exception that for the ",(0,r.jsx)(n.em,{children:"place argument"}),", the actual ",(0,r.jsx)(n.em,{children:"read"})," of the \u201cold value\u201d from that ",(0,r.jsx)(n.em,{children:"place"})," happens after all of the ",(0,r.jsx)(n.em,{children:"argument form evaluations"}),", and just before a \u201cnew value\u201d is computed and ",(0,r.jsx)(n.em,{children:"written"})," back into the ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Specifically, each of these ",(0,r.jsx)(n.em,{children:"operators"})," can be viewed as involving a ",(0,r.jsx)(n.em,{children:"form"})," with the following general syntax:"]}),"\n",(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.em,{children:"operator {preceding-form}"}),"* ",(0,r.jsx)(n.em,{children:"place {following-form}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:["The evaluation of each such ",(0,r.jsx)(n.em,{children:"form"})," proceeds like this:"]}),"\n",(0,r.jsxs)(n.p,{children:["1. ",(0,r.jsx)(n.em,{children:"Evaluate"})," each of the ",(0,r.jsx)(n.em,{children:"preceding-forms"}),", in left-to-right order."]}),"\n",(0,r.jsxs)(n.p,{children:["2. ",(0,r.jsx)(n.em,{children:"Evaluate"})," the ",(0,r.jsx)(n.em,{children:"subforms"})," of the ",(0,r.jsx)(n.em,{children:"place"}),", in the order specified by the second value of the ",(0,r.jsx)(n.em,{children:"setf expansion"})," for that ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["3. ",(0,r.jsx)(n.em,{children:"Evaluate"})," each of the ",(0,r.jsx)(n.em,{children:"following-forms"}),", in left-to-right order."]}),"\n",(0,r.jsxs)(n.p,{children:["4. ",(0,r.jsx)(n.em,{children:"Read"})," the old value from ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"5. Compute the new value."}),"\n",(0,r.jsxs)(n.p,{children:["6. Store the new value into ",(0,r.jsx)(n.em,{children:"place"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Data and Control"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[(0,r.jsx)(n.strong,{children:"decf pop pushnew"})," "]}),(0,r.jsx)("p",{children:(0,r.jsx)(n.strong,{children:"incf push remf"})}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 5\u20139. Read-Modify-Write Macros"})})]})}function M(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(L,{...e})}):L(e)}const B={title:"5.1 Generalized Reference"},O="5.1 Generalized Reference",G={id:"chap-5/f-b-generalized-reference",title:"5.1 Generalized Reference",description:"5.1.1 Overview of Places and Generalized Reference",source:"@site/docs/chap-5/f-b-generalized-reference.md",sourceDirName:"chap-5",slug:"/chap-5/f-b-generalized-reference",permalink:"/cl-language-reference/docs/chap-5/f-b-generalized-reference",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-5/f-b-generalized-reference.md",tags:[],version:"current",frontMatter:{title:"5.1 Generalized Reference"},sidebar:"tutorialSidebar",previous:{title:"5. Data and Control Flow",permalink:"/cl-language-reference/docs/category/5-data-and-control-flow"},next:{title:"5.2 Transfer of Control to an Exit Point",permalink:"/cl-language-reference/docs/chap-5/f-c-transfer-of-control-to-an-exit-point"}},U={},V=[{value:"5.1.1 Overview of Places and Generalized Reference",id:"511-overview-of-places-and-generalized-reference",level:2},{value:"5.1.1.1 Evaluation of Subforms to Places",id:"5111-evaluation-of-subforms-to-places",level:3},{value:"5.1.1.1.1 Examples of Evaluation of Subforms to Places",id:"51111-examples-of-evaluation-of-subforms-to-places",level:4},{value:"5.1.1.2 Setf Expansions",id:"5112-setf-expansions",level:3},{value:"5.1.1.2.1 Examples of Setf Expansions",id:"51121-examples-of-setf-expansions",level:4},{value:"5.1.2 Kinds of Places",id:"512-kinds-of-places",level:2},{value:"5.1.2.1 Variable Names as Places",id:"5121-variable-names-as-places",level:3},{value:"5.1.2.2 Function Call Forms as Places",id:"5122-function-call-forms-as-places",level:3},{value:"5.1.2.3 VALUES Forms as Places",id:"5123-values-forms-as-places",level:3},{value:"5.1.2.4 THE Forms as Places",id:"5124-the-forms-as-places",level:3},{value:"5.1.2.5 APPLY Forms as Places",id:"5125-apply-forms-as-places",level:3},{value:"5.1.2.6 Setf Expansions and Places",id:"5126-setf-expansions-and-places",level:3},{value:"5.1.2.7 Macro Forms as Places",id:"5127-macro-forms-as-places",level:3},{value:"5.1.2.8 Symbol Macros as Places",id:"5128-symbol-macros-as-places",level:3},{value:"5.1.2.9 Other Compound Forms as Places",id:"5129-other-compound-forms-as-places",level:3},{value:"5.1.3 Treatment of Other Macros Based on SETF",id:"513-treatment-of-other-macros-based-on-setf",level:2}];function _(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"51-generalized-reference",children:"5.1 Generalized Reference"}),"\n","\n",(0,r.jsx)(a,{}),"\n",(0,r.jsx)(n.h2,{id:"511-overview-of-places-and-generalized-reference",children:"5.1.1 Overview of Places and Generalized Reference"}),"\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h3,{id:"5111-evaluation-of-subforms-to-places",children:"5.1.1.1 Evaluation of Subforms to Places"}),"\n","\n",(0,r.jsx)(d,{}),"\n",(0,r.jsx)(n.h4,{id:"51111-examples-of-evaluation-of-subforms-to-places",children:"5.1.1.1.1 Examples of Evaluation of Subforms to Places"}),"\n","\n",(0,r.jsx)(p,{}),"\n",(0,r.jsx)(n.h3,{id:"5112-setf-expansions",children:"5.1.1.2 Setf Expansions"}),"\n","\n",(0,r.jsx)(m,{}),"\n",(0,r.jsx)(n.h4,{id:"51121-examples-of-setf-expansions",children:"5.1.1.2.1 Examples of Setf Expansions"}),"\n","\n",(0,r.jsx)(j,{}),"\n",(0,r.jsx)(n.h2,{id:"512-kinds-of-places",children:"5.1.2 Kinds of Places"}),"\n","\n",(0,r.jsx)(g,{}),"\n",(0,r.jsx)(n.h3,{id:"5121-variable-names-as-places",children:"5.1.2.1 Variable Names as Places"}),"\n","\n",(0,r.jsx)(v,{}),"\n",(0,r.jsx)(n.h3,{id:"5122-function-call-forms-as-places",children:"5.1.2.2 Function Call Forms as Places"}),"\n","\n",(0,r.jsx)(w,{}),"\n",(0,r.jsx)(n.h3,{id:"5123-values-forms-as-places",children:"5.1.2.3 VALUES Forms as Places"}),"\n","\n",(0,r.jsx)(E,{}),"\n",(0,r.jsx)(n.h3,{id:"5124-the-forms-as-places",children:"5.1.2.4 THE Forms as Places"}),"\n","\n",(0,r.jsx)(P,{}),"\n",(0,r.jsx)(n.h3,{id:"5125-apply-forms-as-places",children:"5.1.2.5 APPLY Forms as Places"}),"\n","\n",(0,r.jsx)(q,{}),"\n",(0,r.jsx)(n.h3,{id:"5126-setf-expansions-and-places",children:"5.1.2.6 Setf Expansions and Places"}),"\n","\n",(0,r.jsx)(A,{}),"\n",(0,r.jsx)(n.h3,{id:"5127-macro-forms-as-places",children:"5.1.2.7 Macro Forms as Places"}),"\n","\n",(0,r.jsx)(k,{}),"\n",(0,r.jsx)(n.h3,{id:"5128-symbol-macros-as-places",children:"5.1.2.8 Symbol Macros as Places"}),"\n","\n",(0,r.jsx)(R,{}),"\n",(0,r.jsx)(n.h3,{id:"5129-other-compound-forms-as-places",children:"5.1.2.9 Other Compound Forms as Places"}),"\n","\n",(0,r.jsx)(I,{}),"\n",(0,r.jsx)(n.h2,{id:"513-treatment-of-other-macros-based-on-setf",children:"5.1.3 Treatment of Other Macros Based on SETF"}),"\n","\n","\n",(0,r.jsx)(M,{})]})}function H(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>a});var r=s(67294);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);