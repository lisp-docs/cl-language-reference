"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[58912],{48280:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>U,contentTitle:()=>W,default:()=>A,frontMatter:()=>I,metadata:()=>E,toc:()=>_});var s=a(85893),i=a(11151);function r(e){return(0,s.jsx)(s.Fragment,{})}function t(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r()}function o(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The syntax of a ",(0,s.jsx)(n.em,{children:"logical pathname namestring"})," is as follows. (Note that unlike many notational descriptions in this document, this is a syntactic description of character sequences, not a structural description of ",(0,s.jsx)(n.em,{children:"objects"}),".)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"logical-pathname::"}),"=[",(0,s.jsx)(n.em,{children:"\u2193host host-marker"}),"]"]}),"\n",(0,s.jsxs)(n.p,{children:["[",(0,s.jsx)(n.em,{children:"\u2193relative-directory-marker"}),"] ",(0,s.jsx)(n.em,{children:"{\u2193directory directory-marker}"}),"*"]}),"\n",(0,s.jsxs)(n.p,{children:["[",(0,s.jsx)(n.em,{children:"\u2193name"}),"] [",(0,s.jsx)(n.em,{children:"type-marker \u2193type"})," [",(0,s.jsx)(n.em,{children:"version-marker \u2193version"}),"]]"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"host::"}),"=",(0,s.jsx)(n.em,{children:"\u2193word"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"directory::"}),"=",(0,s.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word | \u2193wild-inferiors-word"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"name::"}),"=",(0,s.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"type::"}),"=",(0,s.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"version::"}),"=",(0,s.jsx)(n.em,{children:"\u2193pos-int | newest-word | wildcard-version"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"host-marker"}),"\u2014a ",(0,s.jsx)(n.em,{children:"colon"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"relative-directory-marker"}),"\u2014a ",(0,s.jsx)(n.em,{children:"semicolon"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"directory-marker"}),"\u2014a ",(0,s.jsx)(n.em,{children:"semicolon"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"type-marker"}),"\u2014a ",(0,s.jsx)(n.em,{children:"dot"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"version-marker"}),"\u2014a ",(0,s.jsx)(n.em,{children:"dot"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"wild-inferiors-word"}),"\u2014The two character sequence \u201c**\u201d (two ",(0,s.jsx)(n.em,{children:"asterisks"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"newest-word"}),"\u2014The six character sequence \u201cnewest\u201d or the six character sequence \u201cNEWEST\u201d. ",(0,s.jsx)(n.em,{children:"wildcard-version"}),"\u2014an ",(0,s.jsx)(n.em,{children:"asterisk"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"wildcard-word"}),"\u2014one or more ",(0,s.jsx)(n.em,{children:"asterisks"}),", uppercase letters, digits, and hyphens, including at least one ",(0,s.jsx)(n.em,{children:"asterisk"}),", with no two ",(0,s.jsx)(n.em,{children:"asterisks"})," adjacent."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"word"}),"\u2014one or more uppercase letters, digits, and hyphens."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"pos-int"}),"\u2014a positive ",(0,s.jsx)(n.em,{children:"integer"})," ."]})]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function l(e){return(0,s.jsx)(s.Fragment,{})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l()}function m(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"host"})," must have been defined as a ",(0,s.jsx)(n.em,{children:"logical pathname"})," host; this can be done by using ",(0,s.jsx)(n.strong,{children:"setf"})," of ",(0,s.jsx)(n.strong,{children:"logical-pathname-translations"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"logical pathname"}),' host name "SYS" is reserved for the implementation. The existence and meaning of SYS: ',(0,s.jsx)(n.em,{children:"logical pathnames"})," is ",(0,s.jsx)(n.em,{children:"implementation-defined"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}function p(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["There is no syntax for a ",(0,s.jsx)(n.em,{children:"logical pathname"})," device since the device component of a ",(0,s.jsx)(n.em,{children:"logical pathname"})," is always ",":unspecific","; see Section 19.3.2.1 (Unspecific Components of a Logical Pathname)."]})}function x(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function j(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"relative-directory-marker"})," precedes the ",(0,s.jsx)(n.em,{children:"directories"}),", the directory component parsed is as ",(0,s.jsx)(n.em,{children:"relative"}),"; otherwise, the directory component is parsed as ",(0,s.jsx)(n.em,{children:"absolute"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"wild-inferiors-marker"})," is specified, it parses into ",":wild-inferiors","."]})]})}function g(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}function u(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"type"})," of a ",(0,s.jsx)(n.em,{children:"logical pathname"})," for a ",(0,s.jsx)(n.em,{children:"source file"}),' is "LISP". This should be translated into whatever type is appropriate in a physical pathname.']})}function f(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}function w(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(n.em,{children:"file systems"})," do not have ",(0,s.jsx)(n.em,{children:"versions"}),". ",(0,s.jsx)(n.em,{children:"Logical pathname"})," translation to such a ",(0,s.jsx)(n.em,{children:"file system"})," ignores the ",(0,s.jsx)(n.em,{children:"version"}),". This implies that a program cannot rely on being able to store more than one version of a file named by a ",(0,s.jsx)(n.em,{children:"logical pathname"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.em,{children:"wildcard-version"})," is specified, it parses into ",":wild","."]})]})}function v(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(w,{...e})}):w(e)}function y(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.em,{children:"asterisk"})," in a ",(0,s.jsx)(n.em,{children:"wildcard-word"})," matches a sequence of zero or more characters. The ",(0,s.jsx)(n.em,{children:"wildcard-word"})," \u201c*\u201d parses into ",":wild","; other ",(0,s.jsx)(n.em,{children:"wildcard-words"})," parse into ",(0,s.jsx)(n.em,{children:"strings"}),"."]})}function L(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function P(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["When parsing ",(0,s.jsx)(n.em,{children:"words"})," and ",(0,s.jsx)(n.em,{children:"wildcard-words"}),", lowercase letters are translated to uppercase."]})}function T(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}function b(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The consequences of using characters other than those specified here in a ",(0,s.jsx)(n.em,{children:"logical pathname namestring"})," are unspecified."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences of using any value not specified here as a ",(0,s.jsx)(n.em,{children:"logical pathname"})," component are unspecified."]})]})}function k(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}function N(e){return(0,s.jsx)(s.Fragment,{})}function S(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(N,{...e})}):N()}function C(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:["The device component of a ",(0,s.jsx)(n.em,{children:"logical pathname"})," is always ",":unspecific","; no other component of a ",(0,s.jsx)(n.em,{children:"logical pathname"})," can be ",":unspecific","."]})}function F(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}function q(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,s.jsxs)(n.p,{children:['The null string, "", is not a valid value for any component of a ',(0,s.jsx)(n.em,{children:"logical pathname"}),"."]})}function D(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}const I={title:"19.3 Logical Pathnames"},W="19.3 Logical Pathnames",E={id:"chap-19/bj-d-logical-pathnames",title:"19.3 Logical Pathnames",description:"19.3.1 Syntax of Logical Pathname Namestrings",source:"@site/docs/chap-19/bj-d-logical-pathnames.md",sourceDirName:"chap-19",slug:"/chap-19/bj-d-logical-pathnames",permalink:"/cl-language-reference/docs/chap-19/bj-d-logical-pathnames",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-19/bj-d-logical-pathnames.md",tags:[],version:"current",frontMatter:{title:"19.3 Logical Pathnames"},sidebar:"tutorialSidebar",previous:{title:"19.2 Pathnames",permalink:"/cl-language-reference/docs/chap-19/bj-c-pathnames"},next:{title:"19.4 Filenames Dictionary",permalink:"/cl-language-reference/docs/category/194-filenames-dictionary"}},U={},_=[{value:"19.3.1 Syntax of Logical Pathname Namestrings",id:"1931-syntax-of-logical-pathname-namestrings",level:2},{value:"19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings",id:"19311-additional-information-about-parsing-logical-pathname-namestrings",level:3},{value:"19.3.1.1.1 The Host part of a Logical Pathname Namestring",id:"193111-the-host-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.2 The Device part of a Logical Pathname Namestring",id:"193112-the-device-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.3 The Directory part of a Logical Pathname Namestring",id:"193113-the-directory-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.4 The Type part of a Logical Pathname Namestring",id:"193114-the-type-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.5 The Version part of a Logical Pathname Namestring",id:"193115-the-version-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring",id:"193116-wildcard-words-in-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring",id:"193117-lowercase-letters-in-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.8 Other Syntax in a Logical Pathname Namestring",id:"193118-other-syntax-in-a-logical-pathname-namestring",level:4},{value:"19.3.2 Logical Pathname Components",id:"1932-logical-pathname-components",level:2},{value:"19.3.2.1 Unspecific Components of a Logical Pathname",id:"19321-unspecific-components-of-a-logical-pathname",level:3},{value:"19.3.2.2 Null Strings as Components of a Logical Pathname",id:"19322-null-strings-as-components-of-a-logical-pathname",level:3}];function M(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"193-logical-pathnames",children:"19.3 Logical Pathnames"}),"\n","\n",(0,s.jsx)(t,{}),"\n",(0,s.jsx)(n.h2,{id:"1931-syntax-of-logical-pathname-namestrings",children:"19.3.1 Syntax of Logical Pathname Namestrings"}),"\n","\n",(0,s.jsx)(c,{}),"\n",(0,s.jsx)(n.h3,{id:"19311-additional-information-about-parsing-logical-pathname-namestrings",children:"19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(n.h4,{id:"193111-the-host-part-of-a-logical-pathname-namestring",children:"19.3.1.1.1 The Host part of a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(d,{}),"\n",(0,s.jsx)(n.h4,{id:"193112-the-device-part-of-a-logical-pathname-namestring",children:"19.3.1.1.2 The Device part of a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(x,{}),"\n",(0,s.jsx)(n.h4,{id:"193113-the-directory-part-of-a-logical-pathname-namestring",children:"19.3.1.1.3 The Directory part of a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(g,{}),"\n",(0,s.jsx)(n.h4,{id:"193114-the-type-part-of-a-logical-pathname-namestring",children:"19.3.1.1.4 The Type part of a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(f,{}),"\n",(0,s.jsx)(n.h4,{id:"193115-the-version-part-of-a-logical-pathname-namestring",children:"19.3.1.1.5 The Version part of a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(v,{}),"\n",(0,s.jsx)(n.h4,{id:"193116-wildcard-words-in-a-logical-pathname-namestring",children:"19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(L,{}),"\n",(0,s.jsx)(n.h4,{id:"193117-lowercase-letters-in-a-logical-pathname-namestring",children:"19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(T,{}),"\n",(0,s.jsx)(n.h4,{id:"193118-other-syntax-in-a-logical-pathname-namestring",children:"19.3.1.1.8 Other Syntax in a Logical Pathname Namestring"}),"\n","\n",(0,s.jsx)(k,{}),"\n",(0,s.jsx)(n.h2,{id:"1932-logical-pathname-components",children:"19.3.2 Logical Pathname Components"}),"\n","\n",(0,s.jsx)(S,{}),"\n",(0,s.jsx)(n.h3,{id:"19321-unspecific-components-of-a-logical-pathname",children:"19.3.2.1 Unspecific Components of a Logical Pathname"}),"\n","\n",(0,s.jsx)(F,{}),"\n",(0,s.jsx)(n.h3,{id:"19322-null-strings-as-components-of-a-logical-pathname",children:"19.3.2.2 Null Strings as Components of a Logical Pathname"}),"\n","\n","\n",(0,s.jsx)(D,{})]})}function A(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(M,{...e})}):M(e)}},11151:(e,n,a)=>{a.d(n,{Z:()=>o,a:()=>t});var s=a(67294);const i={},r=s.createContext(i);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);