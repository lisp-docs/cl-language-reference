"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[57919],{60908:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>d,toc:()=>h});var r=i(85893),t=i(11151);function a(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"load-time-value"})," ",(0,r.jsx)(n.em,{children:"Special Operator"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"load-time-value"})," ",(0,r.jsx)(n.em,{children:"form"})," &optional ",(0,r.jsx)(n.em,{children:"read-only-p \u2192 object"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"; evaluated as described below."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"read-only-p"}),"\u2014a ",(0,r.jsx)(n.em,{children:"boolean"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"object"}),"\u2014the ",(0,r.jsx)(n.em,{children:"primary value"})," resulting from evaluating ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"load-time-value"})," provides a mechanism for delaying evaluation of ",(0,r.jsx)(n.em,{children:"form"})," until the expression is in the run-time environment; see Section 3.2 (Compilation)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Read-only-p"})," designates whether the result can be considered a ",(0,r.jsx)(n.em,{children:"constant object"}),". If ",(0,r.jsx)(n.strong,{children:"t"}),", the result is a read-only quantity that can, if appropriate to the ",(0,r.jsx)(n.em,{children:"implementation"}),", be copied into read-only space and/or ",(0,r.jsx)(n.em,{children:"coalesced"})," with ",(0,r.jsx)(n.em,{children:"similar constant objects"})," from other ",(0,r.jsx)(n.em,{children:"programs"}),". If ",(0,r.jsx)(n.strong,{children:"nil"})," (the default), the result must be neither copied nor coalesced; it must be considered to be potentially modifiable data."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.strong,{children:"load-time-value"})," expression is processed by ",(0,r.jsx)(n.strong,{children:"compile-file"}),", the compiler performs its normal semantic processing (such as macro expansion and translation into machine code) on ",(0,r.jsx)(n.em,{children:"form"}),", but arranges for the execution of ",(0,r.jsx)(n.em,{children:"form"})," to occur at load time in a ",(0,r.jsx)(n.em,{children:"null lexical environment"}),", with the result of this ",(0,r.jsx)(n.em,{children:"evaluation"})," then being treated as a ",(0,r.jsx)(n.em,{children:"literal object"})," at run time. It is guaranteed that"]}),"\n",(0,r.jsxs)(n.p,{children:["the evaluation of ",(0,r.jsx)(n.em,{children:"form"})," will take place only once when the ",(0,r.jsx)(n.em,{children:"file"})," is ",(0,r.jsx)(n.em,{children:"loaded"}),", but the order of evaluation with respect to the evaluation of ",(0,r.jsx)(n.em,{children:"top level forms"})," in the file is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.strong,{children:"load-time-value"})," expression appears within a function compiled with ",(0,r.jsx)(n.strong,{children:"compile"}),", the ",(0,r.jsx)(n.em,{children:"form"})," is evaluated at compile time in a ",(0,r.jsx)(n.em,{children:"null lexical environment"}),". The result of this compile-time evaluation is treated as a ",(0,r.jsx)(n.em,{children:"literal object"})," in the compiled code."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"load-time-value"})}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.strong,{children:"load-time-value"})," expression is processed by ",(0,r.jsx)(n.strong,{children:"eval"}),", ",(0,r.jsx)(n.em,{children:"form"})," is evaluated in a ",(0,r.jsx)(n.em,{children:"null lexical environment"}),", and one value is returned. Implementations that implicitly compile (or partially compile) expressions processed by ",(0,r.jsx)(n.strong,{children:"eval"})," might evaluate ",(0,r.jsx)(n.em,{children:"form"})," only once, at the time this compilation is performed."]}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.em,{children:"same list"})," (load-time-value ",(0,r.jsx)(n.em,{children:"form"}),") is evaluated or compiled more than once, it is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,r.jsx)(n.em,{children:"form"})," is evaluated only once or is evaluated more than once. This can happen both when an expression being evaluated or compiled shares substructure, and when the ",(0,r.jsx)(n.em,{children:"same form"})," is processed by ",(0,r.jsx)(n.strong,{children:"eval"})," or ",(0,r.jsx)(n.strong,{children:"compile"})," multiple times. Since a ",(0,r.jsx)(n.strong,{children:"load-time-value"})," expression can be referenced in more than one place and can be evaluated multiple times by ",(0,r.jsx)(n.strong,{children:"eval"}),", it is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether each execution returns a fresh ",(0,r.jsx)(n.em,{children:"object"})," or returns the same ",(0,r.jsx)(n.em,{children:"object"})," as some other execution. Users must use caution when destructively modifying the resulting ",(0,r.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If two lists (load-time-value ",(0,r.jsx)(n.em,{children:"form"}),") that are the ",(0,r.jsx)(n.em,{children:"same"})," under ",(0,r.jsx)(n.strong,{children:"equal"})," but are not ",(0,r.jsx)(n.em,{children:"identical"})," are evaluated or compiled, their values always come from distinct evaluations of ",(0,r.jsx)(n.em,{children:"form"}),". Their ",(0,r.jsx)(n.em,{children:"values"})," may not be coalesced unless ",(0,r.jsx)(n.em,{children:"read-only-p"})," is ",(0,r.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.p,{children:";;; The function INCR1 always returns the same value, even in different images. ;;; The function INCR2 always returns the same value in a given image,"}),"\n",(0,r.jsx)(n.p,{children:";;; but the value it returns might vary from image to image."}),"\n",(0,r.jsx)(n.p,{children:"(defun incr1 (x) (+ x #.(random 17)))"}),"\n",(0,r.jsx)(n.p,{children:"(defun incr2 (x) (+ x (load-time-value (random 17))))"}),"\n",(0,r.jsx)(n.p,{children:";;; The function FOO1-REF references the nth element of the first of"}),"\n",(0,r.jsx)(n.p,{children:";;; the *FOO-ARRAYS* that is available at load time. It is permissible for"}),"\n",(0,r.jsx)(n.p,{children:";;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the"}),"\n",(0,r.jsx)(n.p,{children:";;; updated values."}),"\n",(0,r.jsx)(n.p,{children:"(defvar *foo-arrays* (list (make-array 7) (make-array 8)))"}),"\n",(0,r.jsx)(n.p,{children:"(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))"}),"\n",(0,r.jsx)(n.p,{children:"(defun set-foo1-ref (n val)"}),"\n",(0,r.jsx)(n.p,{children:"(setf (aref (load-time-value (first *my-arrays*) nil) n) val))"}),"\n",(0,r.jsx)(n.p,{children:";;; The function BAR1-REF references the nth element of the first of"}),"\n",(0,r.jsx)(n.p,{children:";;; the *BAR-ARRAYS* that is available at load time. The programmer has"}),"\n",(0,r.jsx)(n.p,{children:";;; promised that the array will be treated as read-only, so the system"}),"\n",(0,r.jsx)(n.p,{children:";;; can copy or coalesce the array."}),"\n",(0,r.jsx)(n.p,{children:"(defvar *bar-arrays* (list (make-array 7) (make-array 8)))"}),"\n",(0,r.jsx)(n.p,{children:"(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))"}),"\n",(0,r.jsx)(n.p,{children:";;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced"}),"\n",(0,r.jsx)(n.p,{children:";;; even though NIL was specified, because the object was already read-only"}),"\n",(0,r.jsx)(n.p,{children:";;; when it was written as a literal vector rather than created by a constructor. ;;; User programs must treat the vector v as read-only."}),"\n",(0,r.jsx)(n.p,{children:"(defun baz-ref (n)"}),"\n",(0,r.jsx)(n.p,{children:"(let ((v (load-time-value #(A B C) nil)))"}),"\n",(0,r.jsx)(n.p,{children:"(values (svref v n) v)))"}),"\n",(0,r.jsx)(n.p,{children:";;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced"}),"\n",(0,r.jsx)(n.p,{children:";;; even though NIL was specified in the outer situation because T was specified ;;; in the inner situation. User programs must treat the vector v as read-only. (defun baz-ref (n)"}),"\n",(0,r.jsx)(n.p,{children:"(let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))"}),"\n",(0,r.jsx)(n.p,{children:"(values (svref v n) v)))"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"compile-file"}),", ",(0,r.jsx)(n.strong,{children:"compile"}),", ",(0,r.jsx)(n.strong,{children:"eval"}),", Section 3.2.2.2 (Minimal Compilation), Section 3.2 (Compilation)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"load-time-value"})," must appear outside of quoted structure in a \u201cfor ",(0,r.jsx)(n.em,{children:"evaluation"}),"\u201d position. In situations which would appear to call for use of ",(0,r.jsx)(n.strong,{children:"load-time-value"})," within a quoted structure, the ",(0,r.jsx)(n.em,{children:"backquote reader macro"})," is probably called for; see Section 2.4.6 (Backquote)."]}),"\n",(0,r.jsxs)(n.p,{children:["Specifying ",(0,r.jsx)(n.strong,{children:"nil"})," for ",(0,r.jsx)(n.em,{children:"read-only-p"})," is not a way to force an object to become modifiable if it has already been made read-only. It is only a way to say that, for an object that is modifiable, this operation is not intended to make that object read-only."]})]})}function s(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}const l={},o="load-time-value",d={id:"chap-3/d-i-dictionary/loadtimevalue",title:"load-time-value",description:"Expanded Reference: load-time-value",source:"@site/docs/chap-3/d-i-dictionary/loadtimevalue.md",sourceDirName:"chap-3/d-i-dictionary",slug:"/chap-3/d-i-dictionary/loadtimevalue",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/loadtimevalue",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-i-dictionary/loadtimevalue.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"lambda",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/lambda"},next:{title:"macroexpand, macroexpand-1",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/macroexpandaamacroexpand1"}},c={},h=[{value:"Expanded Reference: load-time-value",id:"expanded-reference-load-time-value",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"load-time-value",children:"load-time-value"}),"\n","\n","\n",(0,r.jsx)(s,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-load-time-value",children:"Expanded Reference: load-time-value"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(load-time-value )\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>s});var r=i(67294);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);