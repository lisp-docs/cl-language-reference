"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[58912],{48280:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>U,contentTitle:()=>I,default:()=>A,frontMatter:()=>D,metadata:()=>W,toc:()=>_});var a=i(85893),r=i(11151);function s(e){return(0,a.jsx)(a.Fragment,{})}function t(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s()}function o(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The syntax of a ",(0,a.jsx)(n.em,{children:"logical pathname namestring"})," is as follows. (Note that unlike many notational descriptions in this document, this is a syntactic description of character sequences, not a structural description of ",(0,a.jsx)(i,{term:"object",children:(0,a.jsx)("i",{children:"objects"})}),".)"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"logical-pathname::"}),"=[",(0,a.jsx)(n.em,{children:"\u2193host host-marker"}),"]"]}),"\n",(0,a.jsxs)(n.p,{children:["[",(0,a.jsx)(n.em,{children:"\u2193relative-directory-marker"}),"] ",(0,a.jsx)(n.em,{children:"{\u2193directory directory-marker}"}),"*"]}),"\n",(0,a.jsxs)(n.p,{children:["[",(0,a.jsx)(i,{term:"name",children:(0,a.jsx)("i",{children:"\u2193name"})}),"] [",(0,a.jsx)(n.em,{children:"type-marker \u2193type"})," [",(0,a.jsx)(n.em,{children:"version-marker \u2193version"}),"]]"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"host::"}),"=",(0,a.jsx)(n.em,{children:"\u2193word"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"directory::"}),"=",(0,a.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word | \u2193wild-inferiors-word"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(i,{term:"name",children:(0,a.jsx)("i",{children:"name::"})}),"=",(0,a.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(i,{term:"type",children:(0,a.jsx)("i",{children:"type::"})}),"=",(0,a.jsx)(n.em,{children:"\u2193word | \u2193wildcard-word"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"version::"}),"=",(0,a.jsx)(n.em,{children:"\u2193pos-int | newest-word | wildcard-version"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"host-marker"}),"\u2014a ",(0,a.jsx)(i,{term:"colon",children:(0,a.jsx)("i",{children:"colon"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"relative-directory-marker"}),"\u2014a ",(0,a.jsx)(i,{term:"semicolon",children:(0,a.jsx)("i",{children:"semicolon"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"directory-marker"}),"\u2014a ",(0,a.jsx)(i,{term:"semicolon",children:(0,a.jsx)("i",{children:"semicolon"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"type-marker"}),"\u2014a ",(0,a.jsx)(i,{term:"dot",children:(0,a.jsx)("i",{children:"dot"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"version-marker"}),"\u2014a ",(0,a.jsx)(i,{term:"dot",children:(0,a.jsx)("i",{children:"dot"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"wild-inferiors-word"}),"\u2014The two character sequence \u201c**\u201d (two ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisks"})}),")."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"newest-word"}),"\u2014The six character sequence \u201cnewest\u201d or the six character sequence \u201cNEWEST\u201d. ",(0,a.jsx)(n.em,{children:"wildcard-version"}),"\u2014an ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisk"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"wildcard-word"}),"\u2014one or more ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisks"})}),", uppercase letters, digits, and hyphens, including at least one ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisk"})}),", with no two ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisks"})})," adjacent."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"word"}),"\u2014one or more uppercase letters, digits, and hyphens."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"pos-int"}),"\u2014a positive ",(0,a.jsx)(n.em,{children:"integer"})," ."]})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}function l(e){return(0,a.jsx)(a.Fragment,{})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l()}function d(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.em,{children:"host"})," must have been defined as a ",(0,a.jsx)(n.em,{children:"logical pathname"})," host; this can be done by using ",(0,a.jsx)(i,{term:"setf",children:(0,a.jsx)("b",{children:"setf"})})," of ",(0,a.jsx)(i,{term:"logical-pathname-translations",children:(0,a.jsx)("b",{children:"logical-pathname-translations"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.em,{children:"logical pathname"}),' host name "SYS" is reserved for the implementation. The existence and meaning of SYS: ',(0,a.jsx)(n.em,{children:"logical pathnames"})," is ",(0,a.jsx)(i,{term:"implementation-defined",children:(0,a.jsx)("i",{children:"implementation-defined"})}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function p(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(n.p,{children:["There is no syntax for a ",(0,a.jsx)(n.em,{children:"logical pathname"})," device since the device component of a ",(0,a.jsx)(n.em,{children:"logical pathname"})," is always ",":unspecific","; see Section 19.3.2.1 (Unspecific Components of a Logical Pathname)."]})}function x(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}function j(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["If a ",(0,a.jsx)(n.em,{children:"relative-directory-marker"})," precedes the ",(0,a.jsx)(n.em,{children:"directories"}),", the directory component parsed is as ",(0,a.jsx)(i,{term:"relative",children:(0,a.jsx)("i",{children:"relative"})}),"; otherwise, the directory component is parsed as ",(0,a.jsx)(i,{term:"absolute",children:(0,a.jsx)("i",{children:"absolute"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If a ",(0,a.jsx)(n.em,{children:"wild-inferiors-marker"})," is specified, it parses into ",":wild-inferiors","."]})]})}function g(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(j,{...e})}):j(e)}function u(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(i,{term:"type",children:(0,a.jsx)("i",{children:"type"})})," of a ",(0,a.jsx)(n.em,{children:"logical pathname"})," for a ",(0,a.jsx)(n.em,{children:"source file"}),' is "LISP". This should be translated into whatever type is appropriate in a physical pathname.']})}function f(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}function w(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Some ",(0,a.jsx)(n.em,{children:"file systems"})," do not have ",(0,a.jsx)(n.em,{children:"versions"}),". ",(0,a.jsx)(n.em,{children:"Logical pathname"})," translation to such a ",(0,a.jsx)(n.em,{children:"file system"})," ignores the ",(0,a.jsx)(n.em,{children:"version"}),". This implies that a program cannot rely on being able to store more than one version of a file named by a ",(0,a.jsx)(n.em,{children:"logical pathname"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If a ",(0,a.jsx)(n.em,{children:"wildcard-version"})," is specified, it parses into ",":wild","."]})]})}function v(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(w,{...e})}):w(e)}function y(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,a.jsxs)(n.p,{children:["Each ",(0,a.jsx)(i,{term:"asterisk",children:(0,a.jsx)("i",{children:"asterisk"})})," in a ",(0,a.jsx)(n.em,{children:"wildcard-word"})," matches a sequence of zero or more characters. The ",(0,a.jsx)(n.em,{children:"wildcard-word"})," \u201c*\u201d parses into ",":wild","; other ",(0,a.jsx)(n.em,{children:"wildcard-words"})," parse into ",(0,a.jsx)(i,{term:"string",children:(0,a.jsx)("i",{children:"strings"})}),"."]})}function L(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(y,{...e})}):y(e)}function k(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(n.p,{children:["When parsing ",(0,a.jsx)(n.em,{children:"words"})," and ",(0,a.jsx)(n.em,{children:"wildcard-words"}),", lowercase letters are translated to uppercase."]})}function b(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(k,{...e})}):k(e)}function P(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The consequences of using characters other than those specified here in a ",(0,a.jsx)(n.em,{children:"logical pathname namestring"})," are unspecified."]}),"\n",(0,a.jsxs)(n.p,{children:["The consequences of using any value not specified here as a ",(0,a.jsx)(n.em,{children:"logical pathname"})," component are unspecified."]})]})}function T(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(P,{...e})}):P(e)}function N(e){return(0,a.jsx)(a.Fragment,{})}function C(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(N,{...e})}):N()}function S(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(n.p,{children:["The device component of a ",(0,a.jsx)(n.em,{children:"logical pathname"})," is always ",":unspecific","; no other component of a ",(0,a.jsx)(n.em,{children:"logical pathname"})," can be ",":unspecific","."]})}function E(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(S,{...e})}):S(e)}function F(e){const n={em:"em",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(n.p,{children:['The null string, "", is not a valid value for any component of a ',(0,a.jsx)(n.em,{children:"logical pathname"}),"."]})}function q(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(F,{...e})}):F(e)}const D={title:"19.3 Logical Pathnames"},I="19.3 Logical Pathnames",W={id:"chap-19/bj-d-logical-pathnames",title:"19.3 Logical Pathnames",description:"19.3.1 Syntax of Logical Pathname Namestrings",source:"@site/docs/chap-19/bj-d-logical-pathnames.md",sourceDirName:"chap-19",slug:"/chap-19/bj-d-logical-pathnames",permalink:"/cl-language-reference/chap-19/bj-d-logical-pathnames",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-19/bj-d-logical-pathnames.md",tags:[],version:"current",frontMatter:{title:"19.3 Logical Pathnames"},sidebar:"tutorialSidebar",previous:{title:"19.2 Pathnames",permalink:"/cl-language-reference/chap-19/bj-c-pathnames"},next:{title:"19.4 Filenames Dictionary",permalink:"/cl-language-reference/category/194-filenames-dictionary"}},U={},_=[{value:"19.3.1 Syntax of Logical Pathname Namestrings",id:"1931-syntax-of-logical-pathname-namestrings",level:2},{value:"19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings",id:"19311-additional-information-about-parsing-logical-pathname-namestrings",level:3},{value:"19.3.1.1.1 The Host part of a Logical Pathname Namestring",id:"193111-the-host-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.2 The Device part of a Logical Pathname Namestring",id:"193112-the-device-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.3 The Directory part of a Logical Pathname Namestring",id:"193113-the-directory-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.4 The Type part of a Logical Pathname Namestring",id:"193114-the-type-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.5 The Version part of a Logical Pathname Namestring",id:"193115-the-version-part-of-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring",id:"193116-wildcard-words-in-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring",id:"193117-lowercase-letters-in-a-logical-pathname-namestring",level:4},{value:"19.3.1.1.8 Other Syntax in a Logical Pathname Namestring",id:"193118-other-syntax-in-a-logical-pathname-namestring",level:4},{value:"19.3.2 Logical Pathname Components",id:"1932-logical-pathname-components",level:2},{value:"19.3.2.1 Unspecific Components of a Logical Pathname",id:"19321-unspecific-components-of-a-logical-pathname",level:3},{value:"19.3.2.2 Null Strings as Components of a Logical Pathname",id:"19322-null-strings-as-components-of-a-logical-pathname",level:3}];function M(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"193-logical-pathnames",children:"19.3 Logical Pathnames"}),"\n","\n",(0,a.jsx)(t,{}),"\n",(0,a.jsx)(n.h2,{id:"1931-syntax-of-logical-pathname-namestrings",children:"19.3.1 Syntax of Logical Pathname Namestrings"}),"\n","\n",(0,a.jsx)(c,{}),"\n",(0,a.jsx)(n.h3,{id:"19311-additional-information-about-parsing-logical-pathname-namestrings",children:"19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings"}),"\n","\n",(0,a.jsx)(h,{}),"\n",(0,a.jsx)(n.h4,{id:"193111-the-host-part-of-a-logical-pathname-namestring",children:"19.3.1.1.1 The Host part of a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(m,{}),"\n",(0,a.jsx)(n.h4,{id:"193112-the-device-part-of-a-logical-pathname-namestring",children:"19.3.1.1.2 The Device part of a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(x,{}),"\n",(0,a.jsx)(n.h4,{id:"193113-the-directory-part-of-a-logical-pathname-namestring",children:"19.3.1.1.3 The Directory part of a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(g,{}),"\n",(0,a.jsx)(n.h4,{id:"193114-the-type-part-of-a-logical-pathname-namestring",children:"19.3.1.1.4 The Type part of a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(f,{}),"\n",(0,a.jsx)(n.h4,{id:"193115-the-version-part-of-a-logical-pathname-namestring",children:"19.3.1.1.5 The Version part of a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(v,{}),"\n",(0,a.jsx)(n.h4,{id:"193116-wildcard-words-in-a-logical-pathname-namestring",children:"19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(L,{}),"\n",(0,a.jsx)(n.h4,{id:"193117-lowercase-letters-in-a-logical-pathname-namestring",children:"19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(b,{}),"\n",(0,a.jsx)(n.h4,{id:"193118-other-syntax-in-a-logical-pathname-namestring",children:"19.3.1.1.8 Other Syntax in a Logical Pathname Namestring"}),"\n","\n",(0,a.jsx)(T,{}),"\n",(0,a.jsx)(n.h2,{id:"1932-logical-pathname-components",children:"19.3.2 Logical Pathname Components"}),"\n","\n",(0,a.jsx)(C,{}),"\n",(0,a.jsx)(n.h3,{id:"19321-unspecific-components-of-a-logical-pathname",children:"19.3.2.1 Unspecific Components of a Logical Pathname"}),"\n","\n",(0,a.jsx)(E,{}),"\n",(0,a.jsx)(n.h3,{id:"19322-null-strings-as-components-of-a-logical-pathname",children:"19.3.2.2 Null Strings as Components of a Logical Pathname"}),"\n","\n","\n",(0,a.jsx)(q,{})]})}function A(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(M,{...e})}):M(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>t});var a=i(67294);const r={},s=a.createContext(r);function t(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);