"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[90021],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},31206:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>Se,contentTitle:()=>Ge,default:()=>Ie,frontMatter:()=>Ee,metadata:()=>i,toc:()=>De});const i=JSON.parse('{"id":"chap-19/bj-c-pathnames","title":"19.2 Pathnames","description":"19.2.1 Pathname Components","source":"@site/docs/chap-19/bj-c-pathnames.md","sourceDirName":"chap-19","slug":"/chap-19/bj-c-pathnames","permalink":"/cl-language-reference/chap-19/bj-c-pathnames","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-19/bj-c-pathnames.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"19.2 Pathnames"},"sidebar":"tutorialSidebar","previous":{"title":"19.1 Overview of Filenames","permalink":"/cl-language-reference/chap-19/bj-b-overview-of-filenames"},"next":{"title":"19.3 Logical Pathnames","permalink":"/cl-language-reference/chap-19/bj-d-logical-pathnames"}}');var r=t(74848),s=t(28453);function o(e){return(0,r.jsx)(r.Fragment,{})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o()}function c(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," has six components: a host, a device, a directory, a name, a type, and a version."]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}function h(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The name of the file system on which the file resides, or the name of a ",(0,r.jsx)(t,{styled:!0,term:"logical host",children:(0,r.jsx)("i",{children:"logical host"})}),"."]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function d(e){const n={p:"p",...(0,s.R)(),...e.components};return(0,r.jsx)(n.p,{children:"Corresponds to the \u201cdevice\u201d or \u201cfile structure\u201d concept in many host file systems: the name of a logical or physical device containing files."})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function x(e){const n={p:"p",...(0,s.R)(),...e.components};return(0,r.jsx)(n.p,{children:"Corresponds to the \u201cdirectory\u201d concept in many host file systems: the name of a group of related files."})}function j(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}function u(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The \u201cname\u201d part of a group of ",(0,r.jsx)(t,{term:"file",children:(0,r.jsx)("i",{children:"files"})})," that can be thought of as conceptually related."]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}function y(e){const n={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||b("DictionaryLink",!0),i||b("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["Corresponds to the \u201cfiletype\u201d or \u201cextension\u201d concept in many host file systems. This says what kind of file this is. This component is always a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", ",":wild",", or ",":unspecific","."]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}function b(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function v(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||T("DictionaryLink",!0),i||T("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Corresponds to the \u201cversion number\u201d concept in many host file systems."}),"\n",(0,r.jsxs)(n.p,{children:["The version is either a positive ",(0,r.jsx)(n.em,{children:"integer"})," or a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," from the following list: ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", ",":wild",", ",":unspecific",", or ",":newest"," (refers to the largest version number that already exists in the file system when reading a file, or to a version number greater than any already existing in the file system when writing a new file). Implementations can define other special version ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),"."]})]})}function w(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(v,{...e})}):v(e)}function T(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function R(e){return(0,r.jsx)(r.Fragment,{})}function C(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(R,{...e})}):R()}function k(e){return(0,r.jsx)(r.Fragment,{})}function P(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(k,{...e})}):k()}function E(e){const n={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"Strings"})})," in ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component values never contain special ",(0,r.jsx)(t,{term:"character",children:(0,r.jsx)("i",{children:"characters"})})," that represent separation between ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," fields, such as ",(0,r.jsx)(t,{term:"slash",children:(0,r.jsx)("i",{children:"slash"})})," in Unix ",(0,r.jsx)(t,{term:"filename",children:(0,r.jsx)("i",{children:"filenames"})}),". Whether separator ",(0,r.jsx)(t,{term:"character",children:(0,r.jsx)("i",{children:"characters"})})," are permitted as part of a ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"string"})})," in a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component is ",(0,r.jsx)(t,{term:"implementation-defined",children:(0,r.jsx)("i",{children:"implementation-defined"})}),"; however, if the ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," does permit it, it must arrange to properly \u201cquote\u201d the character for the ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," when constructing a ",(0,r.jsx)(t,{term:"namestring",children:(0,r.jsx)("i",{children:"namestring"})}),". For example,"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:';; In a TOPS-20 implementation, which uses ^V to quote\n(NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))\n\u2192 #P"OZ:PS:^V<TEST^V>"\nNOT \u2192 #P"OZ:PS:<TEST>"\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Replaced ",(0,r.jsx)(n.code,{children:"\u2227"})," with ",(0,r.jsx)(n.code,{children:"^"})]})})]})}function G(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(E,{...e})}):E(e)}function S(e){const n={p:"p",strong:"strong",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{term:"namestring",children:(0,r.jsx)("i",{children:"Namestrings"})})," always use local file system ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})})," conventions, but Common Lisp ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"functions"})})," that manipulate ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," components allow the caller to select either of two conventions for representing ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})})," in component values by supplying a value for the ",":case"," keyword argument. Figure 19\u20132 lists the functions relating to ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathnames"})})," that permit a ",":case"," argument:"]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"make-pathname pathname-directory pathname-name pathname-device pathname-host pathname-type"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Figure 19\u20132. Pathname functions using a ",":CASE"," argument"]})})]})}function D(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}function L(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["For the functions in Figure 19\u20132, a value of ",":local"," for the ",":case"," argument (the default for these functions) indicates that the functions should receive and yield ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," in component values as if they were already represented according to the host ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})}),"\u2019s convention for ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," supports both ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"cases"})}),", ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," given or received as ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component values under this protocol are to be used exactly as written. If the file system only supports one ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),", the ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," will be translated to that ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),"."]})]})}function I(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(L,{...e})}):L(e)}function F(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["For the functions in Figure 19\u20132, a value of ",":common"," for the ",":case"," argument that these ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"functions"})})," should receive and yield ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," in component values according to the following conventions:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," All ",(0,r.jsx)(t,{term:"uppercase",children:(0,r.jsx)("i",{children:"uppercase"})})," means to use a file system\u2019s customary ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," All ",(0,r.jsx)(t,{term:"lowercase",children:(0,r.jsx)("i",{children:"lowercase"})})," means to use the opposite of the customary ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Mixed ",(0,r.jsx)(t,{term:"case",children:(0,r.jsx)("i",{children:"case"})})," represents itself."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that these conventions have been chosen in such a way that translation from ",":local"," to ",":common"," and back to ",":local"," is information-preserving."]})]})}function N(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(F,{...e})}):F(e)}function A(e){return(0,r.jsx)(r.Fragment,{})}function V(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(A,{...e})}):A()}function W(e){const n={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||U("DictionaryLink",!0),i||U("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["As a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component value, ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"represents that the component is \u201cunfilled\u201d; see Section 19.2.3 (Merging Pathnames)."]}),"\n",(0,r.jsxs)(n.p,{children:["The value of any ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component can be ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["When constructing a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),", ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," in the host component might mean a default host rather than an actual ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," in some ",(0,r.jsx)(i,{term:"implementation",children:(0,r.jsx)("i",{children:"implementations"})}),"."]})]})}function M(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(W,{...e})}):W(e)}function U(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function O(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["If ",":wild"," is the value of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, that component is considered to be a wildcard, which matches anything."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," must be prepared to encounter a value of ",":wild"," as the value of any ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, or as an ",(0,r.jsx)(t,{term:"element",children:(0,r.jsx)("i",{children:"element"})})," of a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," that is the value of the directory component."]}),"\n",(0,r.jsxs)(n.p,{children:["When constructing a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),", a ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," may use ",":wild"," as the value of any or all of the directory, name, type, or version component, but must not use ",":wild"," as the value of the host, or device component."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",":wild"," is used as the value of the directory component in the construction of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),", the effect is equivalent to specifying the list (",":absolute"," ",":wild-inferiors","), or the same as (",":absolute"," ",":wild",") in a ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," that does not support ",":wild-inferiors","."]})]})}function H(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(O,{...e})}):O(e)}function q(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["If ",":unspecific"," is the value of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, the component is considered to be \u201cabsent\u201d or to \u201chave no meaning\u201d in the ",(0,r.jsx)(t,{term:"filename",children:(0,r.jsx)("i",{children:"filename"})})," being represented by the ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Whether a value of ",":unspecific"," is permitted for any component on any given ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," accessible to the ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," is ",(0,r.jsx)(t,{term:"implementation-defined",children:(0,r.jsx)("i",{children:"implementation-defined"})}),". A ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," must never unconditionally use a ",":unspecific"," as the value of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component because such a value is not guaranteed to be permissible in all implementations. However, a ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," can, if it is careful, successfully manipulate user-supplied data which contains or refers to non-portable ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," components. And certainly a ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," should be prepared for the possibility that any components of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," could be ",":unspecific","."]}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.em,{children:"reading"}),(0,r.jsx)("sub",{children:"1"})," the value of any ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming programs"})})," should be prepared for the value to be ",":unspecific","."]}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.em,{children:"writing"}),(0,r.jsx)("sub",{children:"1"})," the value of any ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, the consequences are undefined if ",":unspecific"," is given for a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," in a ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," for which it does not make sense."]})]})}function Q(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(q,{...e})}):q(e)}function X(e){const n={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||Y("DictionaryLink",!0),i||Y("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," is converted to a ",(0,r.jsx)(i,{term:"namestring",children:(0,r.jsx)("i",{children:"namestring"})}),", the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," and ",":unspecific"," cause the field to be treated as if it were empty. That is, both ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," and ",":unspecific"," cause the component not to appear in the ",(0,r.jsx)(i,{term:"namestring",children:(0,r.jsx)("i",{children:"namestring"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["However, when merging a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," with a set of defaults, only a ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," value for a component will be replaced with the default for that component, while a value of ",":unspecific"," will be left alone as if the field were \u201cfilled\u201d; see the ",(0,r.jsx)(i,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(t,{term:"merge-pathnames",children:(0,r.jsx)("b",{children:"merge-pathnames"})})," and Section 19.2.3 (Merging Pathnames)."]})]})}function Z(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(X,{...e})}):X(e)}function Y(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function B(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||z("DictionaryLink",!0),i||z("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wildcard ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathnames"})})," can be used with ",(0,r.jsx)(t,{term:"directory",children:(0,r.jsx)("b",{children:"directory"})})," but not with ",(0,r.jsx)(t,{term:"open",children:(0,r.jsx)("b",{children:"open"})}),", and return true from ",(0,r.jsx)(t,{term:"wild-pathname-p",children:(0,r.jsx)("b",{children:"wild-pathname-p"})}),". When examining wildcard components of a wildcard ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),", conforming programs must be prepared to encounter any of the following additional values in any component or any element of a ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," that is the directory component:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," ",":wild",", which matches anything."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})})," containing ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," special wildcard ",(0,r.jsx)(i,{term:"character",children:(0,r.jsx)("i",{children:"characters"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Any ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),", representing an ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," wildcard pattern."]})]})}function _(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(B,{...e})}):B(e)}function z(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function J(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The space of possible ",(0,r.jsx)(t,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," that a ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," must be prepared to ",(0,r.jsx)(t,{term:"read",children:(0,r.jsx)("i",{children:"read"})})," ",(0,r.jsx)("sub",{children:"1"})," as the value of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component is substantially larger than the space of possible ",(0,r.jsx)(t,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," that a ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," is permitted to ",(0,r.jsx)(t,{term:"write",children:(0,r.jsx)("i",{children:"write"})}),(0,r.jsx)("sub",{children:"1"})," into such a component."]}),"\n",(0,r.jsx)(n.p,{children:"While the values discussed in the subsections of this section, in Section 19.2.2.2 (Special Pathname Component Values), and in Section 19.2.2.3 (Restrictions on Wildcard Pathnames) apply to values that might be seen when reading the component values, substantially more restrictive rules apply to constructing pathnames; see Section 19.2.2.5 (Restrictions on Constructing Pathnames)."}),"\n",(0,r.jsxs)(n.p,{children:["When examining ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," components, ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming programs"})})," should be aware of the following restrictions."]})]})}function K(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(J,{...e})}):J(e)}function $(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["It is ",(0,r.jsx)(t,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," what ",(0,r.jsx)(t,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," is used to represent the host."]})}function ee(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||ie("DictionaryLink",!0),i||ie("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The device might be a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", ",":wild",", ",":unspecific",", or ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",":wild"," might result from an attempt to ",(0,r.jsx)(i,{term:"read",children:(0,r.jsx)("i",{children:"read"})})," ",(0,r.jsx)("sub",{children:"1"})," the ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," component, even though portable programs are restricted from ",(0,r.jsx)(n.em,{children:"writing"}),(0,r.jsx)("sub",{children:"1"})," such a component value; see Section 19.2.2.3 (Restrictions on Wildcard Pathnames) and Section 19.2.2.5 (Restrictions on Constructing Pathnames)."]})]})}function te(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ne,{...e})}):ne(e)}function ie(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function re(e){const n={p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||oe("DictionaryLink",!0),i||oe("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The directory might be a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", ",":wild",", ",":unspecific",", or ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The directory can be a ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," and ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),". The ",(0,r.jsx)(i,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," of the ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," is one of the symbols ",":absolute"," or ",":relative",", meaning:"]}),"\n",(0,r.jsx)(n.p,{children:":absolute"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," whose ",(0,r.jsx)(i,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," is the symbol ",":absolute"," represents a directory path starting from the root direc tory. The list (",":absolute",") represents the root directory. The list (",":absolute",' "foo" "bar" "baz") represents the directory called "/foo/bar/baz" in Unix (except possibly for ',(0,r.jsx)(i,{term:"case",children:(0,r.jsx)("i",{children:"case"})}),")."]}),"\n",(0,r.jsx)(n.p,{children:":relative"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," whose ",(0,r.jsx)(i,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," is the symbol ",":relative"," represents a directory path starting from a default directory. The list (",":relative",") has the same meaning as ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," and hence is not used. The list (",":relative",' "foo" "bar") represents the directory named "bar" in the directory named "foo" in the default directory.']}),"\n",(0,r.jsxs)(n.p,{children:["Each remaining element of the ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," is a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})})," or a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})})," names a single level of directory structure. The ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," should contain only the directory names themselves\u2014no punctuation characters."]}),"\n",(0,r.jsxs)(n.p,{children:["In place of a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", at any point in the ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})}),", ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," can occur to indicate special file notations. Figure 19\u20133 lists the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," that have standard meanings. Implementations are permitted to add additional ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," of any ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," that is disjoint from ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("b",{children:"string"})})," if necessary to represent features of their file systems that cannot be represented with the standard ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," and ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Supplying any non-",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", including any of the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," listed below, to a file system for which it does not make sense signals an error of ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(t,{term:"file-error",children:(0,r.jsx)("b",{children:"file-error"})}),". For example, Unix does not support ",":wild-inferiors"," in most implementations."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Symbol Meaning"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsxs)("p",{children:[":wild"," Wildcard match of one level of directory structure ",":wild-inferiors"," Wildcard match of any number of directory levels ",":up"," Go upward in directory structure (semantic) "]}),(0,r.jsxs)("p",{children:[":back"," Go upward in directory structure (syntactic)"]}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 19\u20133. Special Markers In Directory Component"})}),"\n",(0,r.jsx)(n.p,{children:"The following notes apply to the previous figure:"}),"\n",(0,r.jsx)(n.p,{children:"Invalid Combinations"}),"\n",(0,r.jsxs)(n.p,{children:["Using ",":absolute"," or ",":wild-inferiors"," immediately followed by ",":up"," or ",":back"," signals an error of ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(t,{term:"file-error",children:(0,r.jsx)("b",{children:"file-error"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Syntactic vs Semantic"}),"\n",(0,r.jsxs)(n.p,{children:["\u201cSyntactic\u201d means that the action of ",":back"," depends only on the ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," and not on the contents of the file system."]}),"\n",(0,r.jsxs)(n.p,{children:["\u201cSemantic\u201d means that the action of ",":up"," depends on the contents of the file system; to resolve a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," containing ",":up"," to a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," whose directory component contains only ",":absolute"," and ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," requires probing the file system."]}),"\n",(0,r.jsxs)(n.p,{children:[":up"," differs from ",":back"," only in file systems that support multiple names for directories, perhaps via symbolic links. For example, suppose that there is a directory (",":absolute",' "X" "Y" "Z") linked to (',":absolute",' "A" "B" "C") and there also exist directories (',":absolute",' "A" "B" "Q") and (',":absolute",' "X" "Y" "Q"). Then (',":absolute",' "X" "Y" "Z" ',":up",' "Q") desig']}),"\n",(0,r.jsxs)(n.p,{children:["nates (",":absolute",' "A" "B" "Q") while (',":absolute",' "X" "Y" "Z" ',":back",' "Q") designates (',":absolute",' "X" "Y" "Q")']})]})}function se(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(re,{...e})}):re(e)}function oe(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ae(e){const n={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["In non-hierarchical ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file systems"})}),", the only valid ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," values for the directory component of a ",(0,r.jsx)(t,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," are (",":absolute"," ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),") and (",":absolute"," ",":wild","). ",":relative"," directories and the keywords ",":wild-inferiors",", ",":up",", and ",":back"," are not used in non-hierarchical ",(0,r.jsx)(t,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file systems"})}),"."]})}function ce(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ae,{...e})}):ae(e)}function le(e){const n={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||me("DictionaryLink",!0),i||me("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The name might be a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", ",":wild",", ",":unspecific",", or ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]})}function he(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(le,{...e})}):le(e)}function me(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function de(e){const n={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||xe("DictionaryLink",!0),i||xe("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The type might be a ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", ",":wild",", ",":unspecific",", or ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]})}function pe(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(de,{...e})}):de(e)}function xe(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function je(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||fe("DictionaryLink",!0),i||fe("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The version can be any ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," or any ",(0,r.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["The symbol ",":newest"," refers to the largest version number that already exists in the ",(0,r.jsx)(i,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," when reading, overwriting, appending, superseding, or directory listing an existing ",(0,r.jsx)(i,{term:"file",children:(0,r.jsx)("i",{children:"file"})}),". The symbol ",":newest"," refers to the smallest version number greater than any existing version number when creating a new file."]}),"\n",(0,r.jsxs)(n.p,{children:["The symbols ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", ",":unspecific",", and ",":wild"," have special meanings and restrictions; see Section 19.2.2.2 (Special Pathname Component Values) and Section 19.2.2.5 (Restrictions on Constructing Pathnames)."]}),"\n",(0,r.jsxs)(n.p,{children:["Other ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," and ",(0,r.jsx)(n.em,{children:"integers"})," have ",(0,r.jsx)(i,{term:"implementation-defined",children:(0,r.jsx)("i",{children:"implementation-defined"})})," meaning."]})]})}function ue(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(je,{...e})}):je(e)}function fe(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ye(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"It is suggested, but not required, that implementations do the following:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Use positive ",(0,r.jsx)(n.em,{children:"integers"})," starting at 1 as version numbers."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Recognize the symbol ",":oldest"," to designate the smallest existing version number. ",(0,r.jsx)(n.em,{children:"\u2022"})," Use ",(0,r.jsx)(t,{term:"keyword",children:(0,r.jsx)("i",{children:"keywords"})})," for other special versions."]})]})}function ge(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ye,{...e})}):ye(e)}function be(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||we("DictionaryLink",!0),i||we("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When constructing a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," from components, conforming programs must follow these rules:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Any component can be ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),". ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," in the host might mean a default host rather than an actual ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," in some implementations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The host, device, directory, name, and type can be ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})}),". There are ",(0,r.jsx)(n.em,{children:"implementation dependent"})," limits on the number and type of ",(0,r.jsx)(i,{term:"character",children:(0,r.jsx)("i",{children:"characters"})})," in these ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The directory can be a ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," and ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),". There are ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," limits on the ",(0,r.jsx)(i,{term:"list",children:(0,r.jsx)("i",{children:"list"})}),"\u2019s length and contents."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The version can be ",":newest","."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Any component can be taken from the corresponding component of another ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})}),". When the two ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathnames"})})," are for different file systems (in implementations that support multiple file systems), an appropriate translation occurs. If no meaningful translation is possible, an error is signaled. The definitions of \u201cappropriate\u201d and \u201cmeaningful\u201d are ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," An implementation might support other values for some components, but a portable program cannot use those values. A conforming program can use ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," values but this can make it non-portable; for example, it might work only with Unix file systems."]})]})}function ve(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(be,{...e})}):be(e)}function we(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Te(e){const n={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:i}=n;return t||Ce("DictionaryLink",!0),i||Ce("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Merging takes a ",(0,r.jsx)(i,{term:"pathname",children:(0,r.jsx)("i",{children:"pathname"})})," with unfilled components and supplies values for those components from a source of defaults."]}),"\n",(0,r.jsxs)(n.p,{children:["If a component\u2019s value is ",(0,r.jsx)(t,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", that component is considered to be unfilled. If a component\u2019s value is any ",(0,r.jsx)(n.em,{children:"non-nil object"}),", including ",":unspecific",", that component is considered to be filled."]}),"\n",(0,r.jsxs)(n.p,{children:["Except as explicitly specified otherwise, for functions that manipulate or inquire about ",(0,r.jsx)(i,{term:"file",children:(0,r.jsx)("i",{children:"files"})})," in the ",(0,r.jsx)(i,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})}),", the pathname argument to such a function is merged with ",(0,r.jsx)(t,{term:"default-pathname-defaults",children:(0,r.jsx)("b",{children:"*default-pathname-defaults*"})})," before accessing the ",(0,r.jsx)(i,{styled:!0,term:"file system",children:(0,r.jsx)("i",{children:"file system"})})," (as if by ",(0,r.jsx)(t,{term:"merge-pathnames",children:(0,r.jsx)("b",{children:"merge-pathnames"})}),")."]})]})}function Re(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Te,{...e})}):Te(e)}function Ce(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ke(e){const n={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:'Although the following examples are possible to execute only in *implementations* which permit :unspecific in the indicated position andwhich permit four-letter type components, they serve to illustrate the basic concept of *pathname* merging. \n(pathname-type \n (merge-pathnames (make-pathname :type "LISP") \n\t\t  (make-pathname :type "TEXT"))) \n\u2192 "LISP" \n(pathname-type \n (merge-pathnames (make-pathname :type nil) \n\t\t  (make-pathname :type "LISP"))) \n\u2192 "LISP" \n(pathname-type \n (merge-pathnames (make-pathname :type :unspecific) \n\t\t  (make-pathname :type "LISP"))) \n\u2192 :UNSPECIFIC \n\n\n'})})}function Pe(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ke,{...e})}):ke(e)}const Ee={title:"19.2 Pathnames"},Ge="19.2 Pathnames",Se={},De=[{value:"19.2.1 Pathname Components",id:"1921-pathname-components",level:2},{value:"19.2.1.1 The Pathname Host Component",id:"19211-the-pathname-host-component",level:3},{value:"19.2.1.2 The Pathname Device Component",id:"19212-the-pathname-device-component",level:3},{value:"19.2.1.3 The Pathname Directory Component",id:"19213-the-pathname-directory-component",level:3},{value:"19.2.1.4 The Pathname Name Component",id:"19214-the-pathname-name-component",level:3},{value:"19.2.1.5 The Pathname Type Component",id:"19215-the-pathname-type-component",level:3},{value:"19.2.1.6 The Pathname Version Component",id:"19216-the-pathname-version-component",level:3},{value:"19.2.2 Interpreting Pathname Component Values",id:"1922-interpreting-pathname-component-values",level:2},{value:"19.2.2.1 Strings in Component Values",id:"19221-strings-in-component-values",level:3},{value:"19.2.2.1.1 Special Characters in Pathname Components",id:"192211-special-characters-in-pathname-components",level:4},{value:"19.2.2.1.2 Case in Pathname Components",id:"192212-case-in-pathname-components",level:4},{value:"19.2.2.1.2.1 Local Case in Pathname Components",id:"1922121-local-case-in-pathname-components",level:5},{value:"19.2.2.1.2.2 Common Case in Pathname Components",id:"1922122-common-case-in-pathname-components",level:5},{value:"19.2.2.2 Special Pathname Component Values",id:"19222-special-pathname-component-values",level:3},{value:"19.2.2.2.1 NIL as a Component Value",id:"192221-nil-as-a-component-value",level:4},{value:"WILD as a Component Value",id:"wild-as-a-component-value",level:4},{value:"UNSPECIFIC as a Component Value",id:"unspecific-as-a-component-value",level:4},{value:"19.2.2.2.3.1 Relation between component values NIL and",id:"1922231-relation-between-component-values-nil-and",level:5},{value:"19.2.2.3 Restrictions on Wildcard Pathnames",id:"19223-restrictions-on-wildcard-pathnames",level:3},{value:"19.2.2.4 Restrictions on Examining Pathname Components",id:"19224-restrictions-on-examining-pathname-components",level:3},{value:"19.2.2.4.1 Restrictions on Examining a Pathname Host Component",id:"192241-restrictions-on-examining-a-pathname-host-component",level:4},{value:"19.2.2.4.2 Restrictions on Examining a Pathname Device Component",id:"192242-restrictions-on-examining-a-pathname-device-component",level:4},{value:"19.2.2.4.3 Restrictions on Examining a Pathname Directory Component",id:"192243-restrictions-on-examining-a-pathname-directory-component",level:4},{value:"19.2.2.4.3.1 Directory Components in Non",id:"1922431-directory-components-in-non",level:5},{value:"19.2.2.4.4 Restrictions on Examining a Pathname Name Component",id:"192244-restrictions-on-examining-a-pathname-name-component",level:4},{value:"19.2.2.4.5 Restrictions on Examining a Pathname Type Component",id:"192245-restrictions-on-examining-a-pathname-type-component",level:4},{value:"19.2.2.4.6 Restrictions on Examining a Pathname Version Component",id:"192246-restrictions-on-examining-a-pathname-version-component",level:4},{value:"19.2.2.4.7 Notes about the Pathname Version Component",id:"192247-notes-about-the-pathname-version-component",level:4},{value:"19.2.2.5 Restrictions on Constructing Pathnames",id:"19225-restrictions-on-constructing-pathnames",level:3},{value:"19.2.3 Merging Pathnames",id:"1923-merging-pathnames",level:2},{value:"19.2.3.1 Examples of Merging Pathnames",id:"19231-examples-of-merging-pathnames",level:3}];function Le(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"192-pathnames",children:"19.2 Pathnames"})}),"\n","\n",(0,r.jsx)(a,{}),"\n",(0,r.jsx)(n.h2,{id:"1921-pathname-components",children:"19.2.1 Pathname Components"}),"\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(n.h3,{id:"19211-the-pathname-host-component",children:"19.2.1.1 The Pathname Host Component"}),"\n","\n",(0,r.jsx)(m,{}),"\n",(0,r.jsx)(n.h3,{id:"19212-the-pathname-device-component",children:"19.2.1.2 The Pathname Device Component"}),"\n","\n",(0,r.jsx)(p,{}),"\n",(0,r.jsx)(n.h3,{id:"19213-the-pathname-directory-component",children:"19.2.1.3 The Pathname Directory Component"}),"\n","\n",(0,r.jsx)(j,{}),"\n",(0,r.jsx)(n.h3,{id:"19214-the-pathname-name-component",children:"19.2.1.4 The Pathname Name Component"}),"\n","\n",(0,r.jsx)(f,{}),"\n",(0,r.jsx)(n.h3,{id:"19215-the-pathname-type-component",children:"19.2.1.5 The Pathname Type Component"}),"\n","\n",(0,r.jsx)(g,{}),"\n",(0,r.jsx)(n.h3,{id:"19216-the-pathname-version-component",children:"19.2.1.6 The Pathname Version Component"}),"\n","\n",(0,r.jsx)(w,{}),"\n",(0,r.jsx)(n.h2,{id:"1922-interpreting-pathname-component-values",children:"19.2.2 Interpreting Pathname Component Values"}),"\n","\n",(0,r.jsx)(C,{}),"\n",(0,r.jsx)(n.h3,{id:"19221-strings-in-component-values",children:"19.2.2.1 Strings in Component Values"}),"\n","\n",(0,r.jsx)(P,{}),"\n",(0,r.jsx)(n.h4,{id:"192211-special-characters-in-pathname-components",children:"19.2.2.1.1 Special Characters in Pathname Components"}),"\n","\n",(0,r.jsx)(G,{}),"\n",(0,r.jsx)(n.h4,{id:"192212-case-in-pathname-components",children:"19.2.2.1.2 Case in Pathname Components"}),"\n","\n",(0,r.jsx)(D,{}),"\n",(0,r.jsx)(n.h5,{id:"1922121-local-case-in-pathname-components",children:"19.2.2.1.2.1 Local Case in Pathname Components"}),"\n","\n",(0,r.jsx)(I,{}),"\n",(0,r.jsx)(n.h5,{id:"1922122-common-case-in-pathname-components",children:"19.2.2.1.2.2 Common Case in Pathname Components"}),"\n","\n",(0,r.jsx)(N,{}),"\n",(0,r.jsx)(n.h3,{id:"19222-special-pathname-component-values",children:"19.2.2.2 Special Pathname Component Values"}),"\n","\n",(0,r.jsx)(V,{}),"\n",(0,r.jsx)(n.h4,{id:"192221-nil-as-a-component-value",children:"19.2.2.2.1 NIL as a Component Value"}),"\n","\n",(0,r.jsx)(M,{}),"\n",(0,r.jsx)(n.h4,{id:"wild-as-a-component-value",children:"WILD as a Component Value"}),"\n","\n",(0,r.jsx)(H,{}),"\n",(0,r.jsx)(n.h4,{id:"unspecific-as-a-component-value",children:"UNSPECIFIC as a Component Value"}),"\n","\n",(0,r.jsx)(Q,{}),"\n",(0,r.jsx)(n.h5,{id:"1922231-relation-between-component-values-nil-and",children:"19.2.2.2.3.1 Relation between component values NIL and"}),"\n","\n",(0,r.jsx)(Z,{}),"\n",(0,r.jsx)(n.h3,{id:"19223-restrictions-on-wildcard-pathnames",children:"19.2.2.3 Restrictions on Wildcard Pathnames"}),"\n","\n",(0,r.jsx)(_,{}),"\n",(0,r.jsx)(n.h3,{id:"19224-restrictions-on-examining-pathname-components",children:"19.2.2.4 Restrictions on Examining Pathname Components"}),"\n","\n",(0,r.jsx)(K,{}),"\n",(0,r.jsx)(n.h4,{id:"192241-restrictions-on-examining-a-pathname-host-component",children:"19.2.2.4.1 Restrictions on Examining a Pathname Host Component"}),"\n","\n",(0,r.jsx)(ee,{}),"\n",(0,r.jsx)(n.h4,{id:"192242-restrictions-on-examining-a-pathname-device-component",children:"19.2.2.4.2 Restrictions on Examining a Pathname Device Component"}),"\n","\n",(0,r.jsx)(te,{}),"\n",(0,r.jsx)(n.h4,{id:"192243-restrictions-on-examining-a-pathname-directory-component",children:"19.2.2.4.3 Restrictions on Examining a Pathname Directory Component"}),"\n","\n",(0,r.jsx)(se,{}),"\n",(0,r.jsx)(n.h5,{id:"1922431-directory-components-in-non",children:"19.2.2.4.3.1 Directory Components in Non"}),"\n","\n",(0,r.jsx)(ce,{}),"\n",(0,r.jsx)(n.h4,{id:"192244-restrictions-on-examining-a-pathname-name-component",children:"19.2.2.4.4 Restrictions on Examining a Pathname Name Component"}),"\n","\n",(0,r.jsx)(he,{}),"\n",(0,r.jsx)(n.h4,{id:"192245-restrictions-on-examining-a-pathname-type-component",children:"19.2.2.4.5 Restrictions on Examining a Pathname Type Component"}),"\n","\n",(0,r.jsx)(pe,{}),"\n",(0,r.jsx)(n.h4,{id:"192246-restrictions-on-examining-a-pathname-version-component",children:"19.2.2.4.6 Restrictions on Examining a Pathname Version Component"}),"\n","\n",(0,r.jsx)(ue,{}),"\n",(0,r.jsx)(n.h4,{id:"192247-notes-about-the-pathname-version-component",children:"19.2.2.4.7 Notes about the Pathname Version Component"}),"\n","\n",(0,r.jsx)(ge,{}),"\n",(0,r.jsx)(n.h3,{id:"19225-restrictions-on-constructing-pathnames",children:"19.2.2.5 Restrictions on Constructing Pathnames"}),"\n","\n",(0,r.jsx)(ve,{}),"\n",(0,r.jsx)(n.h2,{id:"1923-merging-pathnames",children:"19.2.3 Merging Pathnames"}),"\n","\n",(0,r.jsx)(Re,{}),"\n",(0,r.jsx)(n.h3,{id:"19231-examples-of-merging-pathnames",children:"19.2.3.1 Examples of Merging Pathnames"}),"\n","\n",(0,r.jsx)(Pe,{})]})}function Ie(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Le,{...e})}):Le(e)}}}]);