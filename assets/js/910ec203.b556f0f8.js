"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[72328],{28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>a});var t=n(96540);const i={},s=t.createContext(i);function l(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:r},e.children)}},34401:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>Te,contentTitle:()=>Pe,default:()=>Ce,frontMatter:()=>ke,metadata:()=>t,toc:()=>Se});const t=JSON.parse('{"id":"chap-22/cc-b-the-lisp-printer","title":"22.1 The Lisp Printer","description":"22.1.1 Overview of The Lisp Printer","source":"@site/docs/chap-22/cc-b-the-lisp-printer.md","sourceDirName":"chap-22","slug":"/chap-22/cc-b-the-lisp-printer","permalink":"/cl-language-reference/chap-22/cc-b-the-lisp-printer","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-22/cc-b-the-lisp-printer.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"22.1 The Lisp Printer"},"sidebar":"tutorialSidebar","previous":{"title":"y-or-n-p, yes-or-no-p","permalink":"/cl-language-reference/chap-21/cb-c-dictionary/y-or-n-p_yes-or-no-p_function"},"next":{"title":"22.2 The Lisp Pretty Printer","permalink":"/cl-language-reference/chap-22/cc-c-the-lisp-pretty-printer"}}');var i=n(74848),s=n(28453);function l(e){return(0,i.jsx)(i.Fragment,{})}function a(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l()}function c(e){const r={p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||o("DictionaryLink",!0),t||o("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["Common Lisp provides a representation of most ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," in the form of printed text called the printed representation. Functions such as ",(0,i.jsx)(n,{styled:!0,term:"print",children:(0,i.jsx)("b",{children:"print"})})," take an ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"object"})})," and send the characters of its printed representation to a ",(0,i.jsx)(t,{styled:!0,term:"stream",children:(0,i.jsx)("i",{children:"stream"})}),". The collection of routines that does this is known as the (Common Lisp) printer."]}),"\n",(0,i.jsxs)(r.p,{children:["Reading a printed representation typically produces an ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"object"})})," that is ",(0,i.jsx)(n,{styled:!0,term:"equal",children:(0,i.jsx)("b",{children:"equal"})})," to the originally printed ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"object"})}),"."]})]})}function d(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function o(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function h(e){const r={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||x("DictionaryLink",!0),t||x("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["Most ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," have more than one possible textual representation. For example, the positive ",(0,i.jsx)(r.em,{children:"integer"})," with a magnitude of twenty-seven can be textually expressed in any of these ways:"]}),"\n",(0,i.jsx)(r.p,{children:"27 27. #o33 #x1B #b11011 #.(* 3 3 3) 81/3"}),"\n",(0,i.jsx)(r.p,{children:"A list containing the two symbols A and B can also be textually expressed in a variety of ways:"}),"\n",(0,i.jsx)(r.p,{children:"(A B) (a b) ( a b ) (\\A |B|)"}),"\n",(0,i.jsx)(r.p,{children:"(|\\A|"}),"\n",(0,i.jsx)(r.p,{children:"B"}),"\n",(0,i.jsx)(r.p,{children:")"}),"\n",(0,i.jsxs)(r.p,{children:["In general, from the point of view of the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," , wherever ",(0,i.jsx)(t,{styled:!0,term:"whitespace",children:(0,i.jsx)("i",{children:"whitespace"})})," is permissible in a textual representation, any number of ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"spaces"})})," and ",(0,i.jsx)(t,{styled:!0,term:"newline",children:(0,i.jsx)("i",{children:"newlines"})})," can appear in ",(0,i.jsx)(t,{styled:!0,term:"standard syntax",children:(0,i.jsx)("i",{children:"standard syntax"})})," ."]}),"\n",(0,i.jsxs)(r.p,{children:["When a function such as ",(0,i.jsx)(n,{styled:!0,term:"print",children:(0,i.jsx)("b",{children:"print"})})," produces a printed representation, it must choose from among many possible textual representations. In most cases, it chooses a program readable representation, but in certain cases it might use a more compact notation that is not program-readable."]}),"\n",(0,i.jsxs)(r.p,{children:["A number of option variables, called ",(0,i.jsx)(t,{styled:!0,term:"printer control variable",children:(0,i.jsx)("i",{children:"printer control variables"})}),", are provided to permit control of individual aspects of the printed representation of ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})}),". Figure 22\u20131 shows the ",(0,i.jsx)(r.em,{children:"standardized printer control variables"}),"; there might also be ",(0,i.jsx)(r.em,{children:"implementation-defined printer control variables"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(r.strong,{children:"*print-array* *print-gensym* *print-pprint-dispatch* *print-base* *print-length* *print-pretty*"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(r.strong,{children:"*print-case* *print-level* *print-radix*"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(r.strong,{children:"*print-circle* *print-lines* *print-readably* *print-escape* *print-miser-width* *print-right-margin*"})}),"|"]}),"\n",(0,i.jsx)(r.p,{children:"| :- |"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Figure 22\u20131. Standardized Printer Control Variables"})}),"\n",(0,i.jsxs)(r.p,{children:["In addition to the ",(0,i.jsx)(t,{styled:!0,term:"printer control variable",children:(0,i.jsx)("i",{children:"printer control variables"})}),", the following additional ",(0,i.jsx)(t,{styled:!0,term:"defined name",children:(0,i.jsx)("i",{children:"defined names"})})," relate to or affect the behavior of the ",(0,i.jsx)(r.em,{children:"Lisp printer"})," :"]}),"\n",(0,i.jsxs)(r.p,{children:["|",(0,i.jsx)(r.strong,{children:"*package* *read-eval* readtable-case *read-default-float-format* *readtable*"}),"|"]}),"\n",(0,i.jsx)(r.p,{children:"| :- |"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Figure 22\u20132. Additional Influences on the Lisp printer."})})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function x(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function j(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||y("DictionaryLink",!0),t||y("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(t,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," ",(0,i.jsx)(n,{styled:!0,term:"print-escape",children:(0,i.jsx)("b",{children:"*print-escape*"})})," controls whether the ",(0,i.jsx)(r.em,{children:"Lisp printer"})," tries to produce notations such as escape characters and package prefixes."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(t,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," can be used to override many of the individual aspects controlled by the other ",(0,i.jsx)(t,{styled:!0,term:"printer control variable",children:(0,i.jsx)("i",{children:"printer control variables"})})," when program-readable output is especially important."]}),"\n",(0,i.jsxs)(r.p,{children:["One of the many effects of making the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," be ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," is that the ",(0,i.jsx)(r.em,{children:"Lisp printer"})," behaves as if ",(0,i.jsx)(n,{styled:!0,term:"print-escape",children:(0,i.jsx)("b",{children:"*print-escape*"})})," were also ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),". For notational convenience, we say that if the value of either ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," or ",(0,i.jsx)(n,{styled:!0,term:"print-escape",children:(0,i.jsx)("b",{children:"*print-escape*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),", then ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is \u201cenabled\u201d; and we say that if the values of both ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," and ",(0,i.jsx)(n,{styled:!0,term:"print-escape",children:(0,i.jsx)("b",{children:"*print-escape*"})})," are ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", then ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is \u201cdisabled\u201d."]})]})}function m(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(j,{...e})}):j(e)}function y(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function b(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||f("DictionaryLink",!0),t||f("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.em,{children:"Lisp printer"})," makes its determination of how to print an ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"object"})})," as follows:"]}),"\n",(0,i.jsxs)(r.p,{children:["If the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),", printing is controlled by the ",(0,i.jsx)(t,{styled:!0,term:"current pprint dispatch table",children:(0,i.jsx)("i",{children:"current pprint dispatch table"})}),"; see Section 22.2.1.4 (Pretty Print Dispatch Tables)."]}),"\n",(0,i.jsxs)(r.p,{children:["Otherwise (if the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),"), the object\u2019s ",(0,i.jsx)(n,{styled:!0,term:"print-object",children:(0,i.jsx)("b",{children:"print-object"})})," method is used; see Section 22.1.3 (Default Print-Object Methods)."]})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}function f(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function g(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DictionaryLink",!0),(0,i.jsxs)(r.p,{children:["This section describes the default behavior of ",(0,i.jsx)(n,{styled:!0,term:"print-object",children:(0,i.jsx)("b",{children:"print-object"})})," methods for the ",(0,i.jsx)(r.em,{children:"standardized types"}),"."]})}function v(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}function w(e){return(0,i.jsx)(i.Fragment,{})}function E(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(w,{...e})}):w()}function A(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||k("DictionaryLink",!0),t||k("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"Integers"})," are printed in the radix specified by the ",(0,i.jsx)(t,{styled:!0,term:"current output base",children:(0,i.jsx)("i",{children:"current output base"})})," in positional notation, most significant digit first. If appropriate, a radix specifier can be printed; see ",(0,i.jsx)(n,{styled:!0,term:"print-radix",children:(0,i.jsx)("b",{children:"*print-radix*"})}),". If an ",(0,i.jsx)(r.em,{children:"integer"})," is negative, a minus sign is printed and then the absolute value of the ",(0,i.jsx)(r.em,{children:"integer"})," is printed. The ",(0,i.jsx)(r.em,{children:"integer"})," zero is represented by the single digit 0 and never has a sign. A decimal point might be printed, depending on the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(n,{styled:!0,term:"print-radix",children:(0,i.jsx)("b",{children:"*print-radix*"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For related information about the syntax of an ",(0,i.jsx)(r.em,{children:"integer"})," , see Section 2.3.2.1.1 (Syntax of an Integer)."]})]})}function R(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(A,{...e})}):A(e)}function k(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function P(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||S("DictionaryLink",!0),t||S("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:[(0,i.jsx)(t,{styled:!0,term:"ratio",children:(0,i.jsx)("i",{children:"Ratios"})})," are printed as follows: the absolute value of the numerator is printed, as for an ",(0,i.jsx)(r.em,{children:"integer"})," ; then a /; then the denominator. The numerator and denominator are both printed in the radix specified by the ",(0,i.jsx)(t,{styled:!0,term:"current output base",children:(0,i.jsx)("i",{children:"current output base"})}),"; they are obtained as if by ",(0,i.jsx)(n,{styled:!0,term:"numerator",children:(0,i.jsx)("b",{children:"numerator"})})," and ",(0,i.jsx)(n,{styled:!0,term:"denominator",children:(0,i.jsx)("b",{children:"denominator"})}),", and so ",(0,i.jsx)(t,{styled:!0,term:"ratio",children:(0,i.jsx)("i",{children:"ratios"})})," are printed in reduced form (lowest terms). If appropriate, a radix specifier can be printed; see"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(n,{styled:!0,term:"print-radix",children:(0,i.jsx)("b",{children:"*print-radix*"})}),". If the ratio is negative, a minus sign is printed before the numerator. For related information about the syntax of a ",(0,i.jsx)(t,{styled:!0,term:"ratio",children:(0,i.jsx)("i",{children:"ratio"})}),", see Section 2.3.2.1.2 (Syntax of a Ratio)."]})]})}function T(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(P,{...e})}):P(e)}function S(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function L(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["If the magnitude of the ",(0,i.jsx)("i",{children:"float"})," is either zero or between 10",(0,i.jsxs)("sup",{children:[(0,i.jsx)("i",{children:"\u2212"}),"3"]}),"(inclusive) and 10",(0,i.jsx)("sup",{children:"7"}),"(exclusive), it is printed as the integer part of the number, then a decimal point, followed by the fractional part of the number; there is always at least one digit on each side of the decimal point. If the sign of the number (as determined by ",(0,i.jsx)("b",{children:"float-sign"}),") is negative, then a minus sign is printed before the number. If the format of the number does not match that specified by ",(0,i.jsx)("b",{children:(0,i.jsx)(r.em,{children:"read-default-float-format"})}),", then the ",(0,i.jsx)("i",{children:"exponent marker"})," for that format and the digit 0 are also printed. For example, the base of the natural logarithms as a ",(0,i.jsx)("i",{children:"short float"})," might be printed as 2.71828S0."]}),"\n",(0,i.jsxs)(r.p,{children:["For non-zero magnitudes outside of the range 10",(0,i.jsxs)("sup",{children:[(0,i.jsx)("i",{children:"\u2212"}),"3"]}),"to 10",(0,i.jsx)("sup",{children:"7"}),", a ",(0,i.jsx)("i",{children:"float"})," is printed in computerized scientific notation. The representation of the number is scaled to be between 1 (inclusive) and 10 (exclusive) and then printed, with one digit before the decimal point and at least one digit after the decimal point. Next the ",(0,i.jsx)("i",{children:"exponent marker"})," for the format is printed, except that if the format of the number matches that specified by ",(0,i.jsx)("b",{children:(0,i.jsx)(r.em,{children:"read-default-float-format"})}),", then the ",(0,i.jsx)("i",{children:"exponent marker"})," E is used. Finally, the power of ten by which the fraction must be multiplied to equal the original number is printed as a decimal integer. For example, Avogadro\u2019s number as a ",(0,i.jsx)("i",{children:"short float"})," is printed as 6.02S23."]}),"\n",(0,i.jsxs)(r.p,{children:["For related information about the syntax of a ",(0,i.jsx)(n,{styled:!0,term:"float",children:(0,i.jsx)("i",{children:"float"})}),", see Section 2.3.2.2 (Syntax of a Float)."]})]})}function C(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(L,{...e})}):L(e)}function I(e){const r={p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["A ",(0,i.jsx)(n,{styled:!0,term:"complex",children:(0,i.jsx)("i",{children:"complex"})})," is printed as #C, an open parenthesis, the printed representation of its real part, a space, the printed representation of its imaginary part, and finally a close parenthesis."]}),"\n",(0,i.jsxs)(r.p,{children:["For related information about the syntax of a ",(0,i.jsx)(n,{styled:!0,term:"complex",children:(0,i.jsx)("i",{children:"complex"})})," , see Section 2.3.2.3 (Syntax of a Complex) and Section 2.4.8.11 (Sharpsign C)."]})]})}function D(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(I,{...e})}):I(e)}function F(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(r.p,{children:["The printed representation of a number must not contain ",(0,i.jsx)(r.em,{children:"escape characters"}),"; see Section 2.3.1.1.1 (Escape Characters and Potential Numbers)."]})}function Z(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(F,{...e})}):F(e)}function B(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{GlossaryTerm:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(n,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is disabled, a ",(0,i.jsx)(n,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," prints as itself; it is sent directly to the output ",(0,i.jsx)(n,{styled:!0,term:"stream",children:(0,i.jsx)("i",{children:"stream"})}),". When ",(0,i.jsx)(n,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled, then #\\ syntax is used."]}),"\n",(0,i.jsxs)(r.p,{children:["When the printer types out the name of a ",(0,i.jsx)(n,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," , it uses the same table as the #\\ ",(0,i.jsx)(n,{styled:!0,term:"reader macro",children:(0,i.jsx)("i",{children:"reader macro"})})," would use; therefore any ",(0,i.jsx)(n,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," name that is typed out is acceptable as input (in that ",(0,i.jsx)(n,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})}),"). If a ",(0,i.jsx)(r.em,{children:"non-graphic character"})," has a ",(0,i.jsx)(r.em,{children:"standardized name"}),(0,i.jsx)("sub",{children:"5"}),", that ",(0,i.jsx)(n,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," is preferred over non-standard ",(0,i.jsx)(n,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"names"})})," for printing in #\\ notation. For the ",(0,i.jsx)(r.em,{children:"graphic standard characters"}),", the ",(0,i.jsx)(n,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," itself is always used for printing in #\\ notation\u2014even if the ",(0,i.jsx)(n,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," also has a ",(0,i.jsx)(n,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})}),(0,i.jsx)("sub",{children:"5"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For details about the #\\ ",(0,i.jsx)(n,{styled:!0,term:"reader macro",children:(0,i.jsx)("i",{children:"reader macro"})}),", see Section 2.4.8.1 (Sharpsign Backslash)."]})]})}function N(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(B,{...e})}):B(e)}function O(e){const r={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||z("DictionaryLink",!0),t||z("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is disabled, only the characters of the ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,i.jsx)(t,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," are output (but the case in which to print characters in the ",(0,i.jsx)(t,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," is controlled by ",(0,i.jsx)(n,{styled:!0,term:"print-case",children:(0,i.jsx)("b",{children:"*print-case*"})}),"; see Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp Printer))."]}),"\n",(0,i.jsxs)(r.p,{children:["The remainder of this section applies only when ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled."]}),"\n",(0,i.jsxs)(r.p,{children:["When printing a ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),", the printer inserts enough ",(0,i.jsx)(t,{styled:!0,term:"single escape",children:(0,i.jsx)("i",{children:"single escape"})})," and/or ",(0,i.jsx)(t,{styled:!0,term:"multiple escape",children:(0,i.jsx)("i",{children:"multiple escape"})})," characters (",(0,i.jsx)(r.em,{children:"backslashes"})," and/or ",(0,i.jsx)(t,{styled:!0,term:"vertical-bar",children:(0,i.jsx)("i",{children:"vertical-bars"})}),") so that if ",(0,i.jsx)(n,{styled:!0,term:"read",children:(0,i.jsx)("b",{children:"read"})})," were called with the same ",(0,i.jsx)(n,{styled:!0,term:"readtable",children:(0,i.jsx)("b",{children:"*readtable*"})})," and with ",(0,i.jsx)(r.strong,{children:"*read-base*"})," bound to the ",(0,i.jsx)(t,{styled:!0,term:"current output base",children:(0,i.jsx)("i",{children:"current output base"})}),", it would return the same ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," (if it is not ",(0,i.jsx)(t,{styled:!0,term:"apparently uninterned",children:(0,i.jsx)("i",{children:"apparently uninterned"})}),") or an ",(0,i.jsx)(r.em,{children:"uninterned symbol"})," with the same ",(0,i.jsx)(t,{styled:!0,term:"print name",children:(0,i.jsx)("i",{children:"print name"})})," (otherwise)."]}),"\n",(0,i.jsxs)(r.p,{children:["For example, if the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(r.strong,{children:"*print-base*"})," were 16 when printing the symbol face, it would have to be printed as \\FACE or \\Face or |FACE|, because the token face would be read as a hexadecimal number (decimal value 64206) if the ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(r.strong,{children:"*read-base*"})," were 16."]}),"\n",(0,i.jsxs)(r.p,{children:["For additional restrictions concerning characters with nonstandard ",(0,i.jsx)(t,{styled:!0,term:"syntax type",children:(0,i.jsx)("i",{children:"syntax types"})})," in the ",(0,i.jsx)(t,{styled:!0,term:"current readtable",children:(0,i.jsx)("i",{children:"current readtable"})}),", see the ",(0,i.jsx)(t,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})]}),"\n",(0,i.jsxs)(r.p,{children:["For information about how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),", see Section 2.3.4 (Symbols as Tokens) and Section 2.4.8.5 (Sharpsign Colon)."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(n,{styled:!0,term:"nil",children:(0,i.jsx)("b",{children:"nil"})})," might be printed as () when ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," and ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled."]})]})}function W(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(O,{...e})}):O(e)}function z(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function G(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||V("DictionaryLink",!0),t||V("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"Package prefixes"})," are printed if necessary. The rules for ",(0,i.jsx)(r.em,{children:"package prefixes"})," are as follows. When the ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is printed, if it is in the KEYWORD ",(0,i.jsx)(t,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),", then it is printed with a preceding ",(0,i.jsx)(t,{styled:!0,term:"colon",children:(0,i.jsx)("i",{children:"colon"})}),"; otherwise, if it is ",(0,i.jsx)(t,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in the ",(0,i.jsx)(t,{styled:!0,term:"current package",children:(0,i.jsx)("i",{children:"current package"})}),", it is printed without any ",(0,i.jsx)(t,{styled:!0,term:"package prefix",children:(0,i.jsx)("i",{children:"package prefix"})})," ; otherwise, it is printed with a ",(0,i.jsx)(t,{styled:!0,term:"package prefix",children:(0,i.jsx)("i",{children:"package prefix"})})," ."]}),"\n",(0,i.jsxs)(r.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," that is ",(0,i.jsx)(t,{styled:!0,term:"apparently uninterned",children:(0,i.jsx)("i",{children:"apparently uninterned"})})," is printed preceded by \u201c#:\u201d if ",(0,i.jsx)(n,{styled:!0,term:"print-gensym",children:(0,i.jsx)("b",{children:"*print-gensym*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," and ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled; if ",(0,i.jsx)(n,{styled:!0,term:"print-gensym",children:(0,i.jsx)("b",{children:"*print-gensym*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})})," or ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is disabled, then the ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is printed without a prefix, as if it were in the ",(0,i.jsx)(t,{styled:!0,term:"current package",children:(0,i.jsx)("i",{children:"current package"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Because the #: syntax does not intern the following symbol, it is necessary to use circular-list syntax if ",(0,i.jsx)(n,{styled:!0,term:"print-circle",children:(0,i.jsx)("b",{children:"*print-circle*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," and the same uninterned symbol appears several times in an expression to be printed. For example, the result of"]}),"\n",(0,i.jsx)(r.p,{children:'(let ((x (make-symbol "FOO"))) (list x x))'}),"\n",(0,i.jsxs)(r.p,{children:["would be printed as (#",":foo"," #",":foo",") if ",(0,i.jsx)(n,{styled:!0,term:"print-circle",children:(0,i.jsx)("b",{children:"*print-circle*"})})," were ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", but as (#1=#",":foo"," #1#) if ",(0,i.jsx)(n,{styled:!0,term:"print-circle",children:(0,i.jsx)("b",{children:"*print-circle*"})})," were ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),"."]}),"\n",(0,i.jsx)(r.p,{children:"A summary of the preceding package prefix rules follows:"}),"\n",(0,i.jsxs)(r.p,{children:["foo",":bar"]}),"\n",(0,i.jsxs)(r.p,{children:["foo",":bar"," is printed when ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," bar is external in its ",(0,i.jsx)(t,{styled:!0,term:"home package",children:(0,i.jsx)("i",{children:"home package"})})," foo and is not ",(0,i.jsx)(t,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in the ",(0,i.jsx)(t,{styled:!0,term:"current package",children:(0,i.jsx)("i",{children:"current package"})}),"."]}),"\n",(0,i.jsx)(r.p,{children:"foo::bar"}),"\n",(0,i.jsxs)(r.p,{children:["foo::bar is printed when bar is internal in its ",(0,i.jsx)(t,{styled:!0,term:"home package",children:(0,i.jsx)("i",{children:"home package"})})," foo and is not ",(0,i.jsx)(t,{styled:!0,term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})})," in the ",(0,i.jsx)(t,{styled:!0,term:"current package",children:(0,i.jsx)("i",{children:"current package"})}),"."]}),"\n",(0,i.jsx)(r.p,{children:":bar"}),"\n",(0,i.jsxs)(r.p,{children:[":bar"," is printed when the home package of bar is the KEYWORD ",(0,i.jsx)(t,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"package"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["#",":bar"]}),"\n",(0,i.jsxs)(r.p,{children:["#",":bar"," is printed when bar is ",(0,i.jsx)(r.em,{children:"apparently uninterned"}),", even in the pathological case that bar has no ",(0,i.jsx)(r.em,{children:"home package"})," but is nevertheless somehow ",(0,i.jsx)(r.em,{children:"accessible"})," in the ",(0,i.jsx)(r.em,{children:"current package"}),"."]})]})}function U(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(G,{...e})}):G(e)}function V(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function q(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||_("DictionaryLink",!0),t||_("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is disabled, or the characters under consideration are not already quoted specifically by ",(0,i.jsx)(t,{styled:!0,term:"single escape",children:(0,i.jsx)("i",{children:"single escape"})})," or ",(0,i.jsx)(t,{styled:!0,term:"multiple escape",children:(0,i.jsx)("i",{children:"multiple escape"})})," syntax, the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," of the ",(0,i.jsx)(t,{styled:!0,term:"current readtable",children:(0,i.jsx)("i",{children:"current readtable"})})," affects the way the ",(0,i.jsx)(r.em,{children:"Lisp printer"})," writes ",(0,i.jsx)(t,{styled:!0,term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," in the following ways:"]}),"\n",(0,i.jsx)(r.p,{children:":upcase"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":upcase",", ",(0,i.jsx)(r.em,{children:"uppercase characters"})," are printed in the case specified by ",(0,i.jsx)(n,{styled:!0,term:"print-case",children:(0,i.jsx)("b",{children:"*print-case*"})}),", and ",(0,i.jsx)(r.em,{children:"lowercase characters"})," are printed in their own case."]}),"\n",(0,i.jsx)(r.p,{children:":downcase"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":downcase",", ",(0,i.jsx)(r.em,{children:"uppercase characters"})," are printed in their own case, and ",(0,i.jsx)(r.em,{children:"lowercase characters"})," are printed in the case specified by ",(0,i.jsx)(n,{styled:!0,term:"print-case",children:(0,i.jsx)("b",{children:"*print-case*"})}),"."]}),"\n",(0,i.jsx)(r.p,{children:":preserve"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":preserve",", all ",(0,i.jsx)(r.em,{children:"alphabetic characters"})," are printed in their own case."]}),"\n",(0,i.jsx)(r.p,{children:":invert"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":invert",", the case of all ",(0,i.jsx)(r.em,{children:"alphabetic characters"})," in single case symbol names is inverted. Mixed-case symbol names are printed as is."]}),"\n",(0,i.jsxs)(r.p,{children:["The rules for escaping ",(0,i.jsx)(r.em,{children:"alphabetic characters"})," in symbol names are affected by the ",(0,i.jsx)(n,{styled:!0,term:"readtable-case",children:(0,i.jsx)("b",{children:"readtable-case"})})," if ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled. ",(0,i.jsx)(r.em,{children:"Alphabetic characters"})," are escaped as follows:"]}),"\n",(0,i.jsx)(r.p,{children:":upcase"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":upcase",", all ",(0,i.jsx)(r.em,{children:"lowercase characters"})," must be escaped."]}),"\n",(0,i.jsx)(r.p,{children:":downcase"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":downcase",", all ",(0,i.jsx)(r.em,{children:"uppercase characters"})," must be escaped."]}),"\n",(0,i.jsx)(r.p,{children:":preserve"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":preserve",", no ",(0,i.jsx)(r.em,{children:"alphabetic characters"})," need be escaped."]}),"\n",(0,i.jsx)(r.p,{children:":invert"}),"\n",(0,i.jsxs)(r.p,{children:["When the ",(0,i.jsx)(t,{styled:!0,term:"readtable case",children:(0,i.jsx)("i",{children:"readtable case"})})," is ",":invert",", no ",(0,i.jsx)(r.em,{children:"alphabetic characters"})," need be escaped."]})]})}function M(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}function _(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Y(e){const r={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-lisp",children:'(defun test-readtable-case-printing () \n  (let ((\\*readtable\\* (copy-readtable nil)) \n\t(\\*print-case\\* \\*print-case\\*)) \n    (format t "READTABLE-CASE \\*PRINT-CASE\\* Symbol-name Output~ \n~%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013~ \n~%") \n    (dolist (readtable-case \u2019(:upcase :downcase :preserve :invert)) \n      (setf (readtable-case \\*readtable\\*) readtable-case) \n      (dolist (print-case \u2019(:upcase :downcase :capitalize)) \n\t(dolist (symbol \u2019(|ZEBRA| |Zebra| |zebra|)) \n\t  (setq \\*print-case\\* print-case) \n\t  (format t "~&:~A~15T:~A~29T~A~42T~A" \n\t\t  \n\t\t  \n\t\t  (string-upcase readtable-case) \n\t\t  (string-upcase print-case) \n\t\t  (symbol-name symbol) \n\t\t  (prin1-to-string symbol))))))) \nThe output from (test-readtable-case-printing) should be as follows: \nREADTABLE-CASE \\*PRINT-CASE\\* Symbol-name Output \n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \n:UPCASE :UPCASE ZEBRA ZEBRA \n:UPCASE :UPCASE Zebra |Zebra| \n:UPCASE :UPCASE zebra |zebra| \n:UPCASE :DOWNCASE ZEBRA zebra \n:UPCASE :DOWNCASE Zebra |Zebra| \n:UPCASE :DOWNCASE zebra |zebra| \n:UPCASE :CAPITALIZE ZEBRA Zebra \n:UPCASE :CAPITALIZE Zebra |Zebra| \n:UPCASE :CAPITALIZE zebra |zebra| \n:DOWNCASE :UPCASE ZEBRA |ZEBRA| \n:DOWNCASE :UPCASE Zebra |Zebra| \n:DOWNCASE :UPCASE zebra ZEBRA \n:DOWNCASE :DOWNCASE ZEBRA |ZEBRA| \n:DOWNCASE :DOWNCASE Zebra |Zebra| \n:DOWNCASE :DOWNCASE zebra zebra \n:DOWNCASE :CAPITALIZE ZEBRA |ZEBRA| \n:DOWNCASE :CAPITALIZE Zebra |Zebra| \n:DOWNCASE :CAPITALIZE zebra Zebra \n:PRESERVE :UPCASE ZEBRA ZEBRA \n:PRESERVE :UPCASE Zebra Zebra \n:PRESERVE :UPCASE zebra zebra \n:PRESERVE :DOWNCASE ZEBRA ZEBRA \n:PRESERVE :DOWNCASE Zebra Zebra \n:PRESERVE :DOWNCASE zebra zebra \n:PRESERVE :CAPITALIZE ZEBRA ZEBRA \n:PRESERVE :CAPITALIZE Zebra Zebra \n:PRESERVE :CAPITALIZE zebra zebra \n:INVERT :UPCASE ZEBRA zebra \n:INVERT :UPCASE Zebra Zebra \n:INVERT :UPCASE zebra ZEBRA \n:INVERT :DOWNCASE ZEBRA zebra \n:INVERT :DOWNCASE Zebra Zebra \n:INVERT :DOWNCASE zebra ZEBRA \n:INVERT :CAPITALIZE ZEBRA zebra \n:INVERT :CAPITALIZE Zebra Zebra \n:INVERT :CAPITALIZE zebra ZEBRA \n\n\n'})})}function K(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(Y,{...e})}):Y(e)}function H(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||Q("DictionaryLink",!0),t||Q("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["The characters of the ",(0,i.jsx)(t,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"string"})})," are output in order. If ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is enabled, a ",(0,i.jsx)(t,{styled:!0,term:"double-quote",children:(0,i.jsx)("i",{children:"double-quote"})})," is output before and after, and all ",(0,i.jsx)(t,{styled:!0,term:"double-quote",children:(0,i.jsx)("i",{children:"double-quotes"})})," and ",(0,i.jsx)(t,{styled:!0,term:"single escape",children:(0,i.jsx)("i",{children:"single escapes"})})," are preceded by ",(0,i.jsx)(t,{styled:!0,term:"backslash",children:(0,i.jsx)("i",{children:"backslash"})}),". The printing of ",(0,i.jsx)(t,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"strings"})})," is not affected by ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})}),". Only the ",(0,i.jsx)(r.em,{children:"active elements"})," of the ",(0,i.jsx)(t,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"string"})})," are printed."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses ",(0,i.jsx)(t,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"strings"})}),", see Section 2.4.5 (Double-Quote)."]})]})}function J(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(H,{...e})}):H(e)}function Q(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function X(e){const r={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||ee("DictionaryLink",!0),t||ee("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["Wherever possible, list notation is preferred over dot notation. Therefore the following algorithm is used to print a ",(0,i.jsx)(r.em,{children:"cons x"}),":"]}),"\n",(0,i.jsxs)(r.p,{children:["1. A ",(0,i.jsx)(t,{styled:!0,term:"left-parenthesis",children:(0,i.jsx)("i",{children:"left-parenthesis"})})," is printed."]}),"\n",(0,i.jsxs)(r.p,{children:["2. The ",(0,i.jsx)(t,{styled:!0,term:"car",children:(0,i.jsx)("i",{children:"car"})})," of ",(0,i.jsx)(r.em,{children:"x"})," is printed."]}),"\n",(0,i.jsxs)(r.p,{children:["3. If the ",(0,i.jsx)(t,{styled:!0,term:"cdr",children:(0,i.jsx)("i",{children:"cdr"})})," of ",(0,i.jsx)(r.em,{children:"x"})," is itself a ",(0,i.jsx)(t,{styled:!0,term:"cons",children:(0,i.jsx)("i",{children:"cons"})}),", it is made to be the current ",(0,i.jsx)(t,{styled:!0,term:"cons",children:(0,i.jsx)("i",{children:"cons"})})," (",(0,i.jsx)(r.em,{children:"i.e."}),", ",(0,i.jsx)(r.em,{children:"x"})," becomes that ",(0,i.jsx)(t,{styled:!0,term:"cons",children:(0,i.jsx)("i",{children:"cons"})}),"), a ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"space"})})," is printed, and step 2 is re-entered."]}),"\n",(0,i.jsxs)(r.p,{children:["4. If the ",(0,i.jsx)(t,{styled:!0,term:"cdr",children:(0,i.jsx)("i",{children:"cdr"})})," of ",(0,i.jsx)(r.em,{children:"x"})," is not ",(0,i.jsx)(t,{styled:!0,term:"null",children:(0,i.jsx)("i",{children:"null"})}),", a ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"space"})}),", a ",(0,i.jsx)(t,{styled:!0,term:"dot",children:(0,i.jsx)("i",{children:"dot"})}),", a ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"space"})}),", and the ",(0,i.jsx)(t,{styled:!0,term:"cdr",children:(0,i.jsx)("i",{children:"cdr"})})," of ",(0,i.jsx)(r.em,{children:"x"})," are printed."]}),"\n",(0,i.jsxs)(r.p,{children:["5. A ",(0,i.jsx)(t,{styled:!0,term:"right-parenthesis",children:(0,i.jsx)("i",{children:"right-parenthesis"})})," is printed."]}),"\n",(0,i.jsxs)(r.p,{children:["Actually, the above algorithm is only used when ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),". When ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," (or when ",(0,i.jsx)(n,{styled:!0,term:"pprint",children:(0,i.jsx)("b",{children:"pprint"})})," is used), additional ",(0,i.jsx)(t,{styled:!0,term:"whitespace",children:(0,i.jsx)("i",{children:"whitespace"})}),(0,i.jsx)("sub",{children:"1"})," may replace the use of a single ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"space"})}),", and a more elaborate algorithm with similar goals but more presentational flexibility is used; see Section 22.1.2 (Printer Dispatching)."]}),"\n",(0,i.jsxs)(r.p,{children:["Although the two expressions below are equivalent, and the reader accepts either one and produces the same ",(0,i.jsx)(t,{styled:!0,term:"cons",children:(0,i.jsx)("i",{children:"cons"})}),", the printer always prints such a ",(0,i.jsx)(t,{styled:!0,term:"cons",children:(0,i.jsx)("i",{children:"cons"})})," in the second form."]}),"\n",(0,i.jsx)(r.p,{children:"(a . (b . ((c . (d . nil)) . (e . nil))))"}),"\n",(0,i.jsx)(r.p,{children:"(a b (c d) e)"}),"\n",(0,i.jsxs)(r.p,{children:["The printing of ",(0,i.jsx)(r.em,{children:"conses"})," is affected by ",(0,i.jsx)(r.strong,{children:"*print-level*"}),", ",(0,i.jsx)(n,{styled:!0,term:"print-length",children:(0,i.jsx)("b",{children:"*print-length*"})}),", and ",(0,i.jsx)(n,{styled:!0,term:"print-circle",children:(0,i.jsx)("b",{children:"*print-circle*"})}),". Following are examples of printed representations of ",(0,i.jsx)(t,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"lists"})}),":"]}),"\n",(0,i.jsx)(r.p,{children:"(a . b) ;A dotted pair of a and b"}),"\n",(0,i.jsx)(r.p,{children:"(a.b) ;A list of one element, the symbol named a.b"}),"\n",(0,i.jsx)(r.p,{children:"(a. b) ;A list of two elements a. and b"}),"\n",(0,i.jsx)(r.p,{children:"(a .b) ;A list of two elements a and .b"}),"\n",(0,i.jsx)(r.p,{children:"(a b . c) ;A dotted list of a and b with c at the end; two conses"}),"\n",(0,i.jsx)(r.p,{children:".iot ;The symbol whose name is .iot"}),"\n",(0,i.jsx)(r.p,{children:"(. b) ;Invalid \u2013 an error is signaled if an attempt is made to read"}),"\n",(0,i.jsx)(r.p,{children:";this syntax."}),"\n",(0,i.jsx)(r.p,{children:"(a .) ;Invalid \u2013 an error is signaled."}),"\n",(0,i.jsx)(r.p,{children:"(a .. b) ;Invalid \u2013 an error is signaled."}),"\n",(0,i.jsx)(r.p,{children:"(a . . b) ;Invalid \u2013 an error is signaled."}),"\n",(0,i.jsx)(r.p,{children:"(a b c ...) ;Invalid \u2013 an error is signaled."}),"\n",(0,i.jsx)(r.p,{children:"(a . b) ;A list of three elements a, ., and b"}),"\n",(0,i.jsx)(r.p,{children:"(a |.| b) ;A list of three elements a, ., and b"}),"\n",(0,i.jsx)(r.p,{children:"(a ... b) ;A list of three elements a, ..., and b"}),"\n",(0,i.jsx)(r.p,{children:"(a |...| b) ;A list of three elements a, ..., and b"}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses ",(0,i.jsx)(t,{styled:!0,term:"list",children:(0,i.jsx)("i",{children:"lists"})})," and ",(0,i.jsx)(r.em,{children:"conses"}),", see Section 2.4.1 (Left-Parenthesis)."]})]})}function $(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(X,{...e})}):X(e)}function ee(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function re(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||te("DictionaryLink",!0),t||te("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vector"})})," is printed as #* followed by the bits of the ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vector"})})," in order. If ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", then the ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vector"})})," is printed in a format (using #<) that is concise but not readable. Only the ",(0,i.jsx)(r.em,{children:"active elements"})," of the ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vector"})})," are printed."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parsing of ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vectors"})}),", see Section 2.4.8.4 (Sharpsign Asterisk)."]})]})}function ne(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(re,{...e})}):re(e)}function te(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ie(e){const r={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||le("DictionaryLink",!0),t||le("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," and ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", any ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," other than a ",(0,i.jsx)(t,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"string"})})," or ",(0,i.jsx)(t,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vector"})})," is printed using general-vector syntax; this means that information about specialized vector representations does not appear. The printed representation of a zero-length ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," is #(). The printed representation of a non-zero-length ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," begins with #(. Following that, the first element of the ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," is printed. If there are any other elements, they are printed in turn, with each such additional element preceded by a ",(0,i.jsx)(t,{styled:!0,term:"space",children:(0,i.jsx)("i",{children:"space"})})," if ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", or ",(0,i.jsx)(t,{styled:!0,term:"whitespace",children:(0,i.jsx)("i",{children:"whitespace"})}),(0,i.jsx)("sub",{children:"1"})," if ",(0,i.jsx)(n,{styled:!0,term:"print-pretty",children:(0,i.jsx)("b",{children:"*print-pretty*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),". A ",(0,i.jsx)(t,{styled:!0,term:"right-parenthesis",children:(0,i.jsx)("i",{children:"right-parenthesis"})})," after the last element terminates the printed representation of the ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," . The printing of ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vectors"})})," is affected by ",(0,i.jsx)(r.strong,{children:"*print-level*"})," and ",(0,i.jsx)(n,{styled:!0,term:"print-length",children:(0,i.jsx)("b",{children:"*print-length*"})}),". If the ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," has a ",(0,i.jsx)(t,{styled:!0,term:"fill pointer",children:(0,i.jsx)("i",{children:"fill pointer"})})," , then only those elements below the ",(0,i.jsx)(t,{styled:!0,term:"fill pointer",children:(0,i.jsx)("i",{children:"fill pointer"})})," are printed."]}),"\n",(0,i.jsxs)(r.p,{children:["If both ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})})," and ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," are ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", the ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," is not printed as described above, but in a format (using #<) that is concise but not readable."]}),"\n",(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),", the ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," prints in an ",(0,i.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,i.jsx)("i",{children:"implementation-defined"})})," manner; see the ",(0,i.jsx)(t,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses these \u201cother ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vectors"})}),",\u201d see Section 2.4.8.3 (Sharpsign Left-Parenthesis)."]})]})}function se(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(ie,{...e})}):ie(e)}function le(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ae(e){const r={em:"em",p:"p",strong:"strong",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||de("DictionaryLink",!0),t||de("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})})," and ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", any ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"array"})})," other than a ",(0,i.jsx)(t,{styled:!0,term:"vector",children:(0,i.jsx)("i",{children:"vector"})})," is printed using #nA format. Let n be the ",(0,i.jsx)(t,{styled:!0,term:"rank",children:(0,i.jsx)("i",{children:"rank"})})," of the ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"array"})}),". Then # is printed, then n as a decimal integer, then A, then n open parentheses. Next the ",(0,i.jsx)(t,{styled:!0,term:"element",children:(0,i.jsx)("i",{children:"elements"})})," are scanned in row-major order, using ",(0,i.jsx)(n,{styled:!0,term:"write",children:(0,i.jsx)("b",{children:"write"})})," on each ",(0,i.jsx)(t,{styled:!0,term:"element",children:(0,i.jsx)("i",{children:"element"})}),", and separating ",(0,i.jsx)(t,{styled:!0,term:"element",children:(0,i.jsx)("i",{children:"elements"})})," from each other with ",(0,i.jsx)(t,{styled:!0,term:"whitespace",children:(0,i.jsx)("i",{children:"whitespace"})}),(0,i.jsx)("sub",{children:"1"}),". The array\u2019s dimensions are numbered 0 to n-1 from left to right, and are enumerated with the rightmost index changing fastest. Every time the index for dimension j is incremented, the following actions are taken:"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"\u2022"})," If j < n-1, then a close parenthesis is printed."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"\u2022"})," If incrementing the index for dimension j caused it to equal dimension j, that index is reset to zero and the index for dimension j-1 is incremented (thereby performing these three steps recursively), unless j=0, in which case the entire algorithm is terminated. If incrementing the index for dimension j did not cause it to equal dimension j, then a space is printed."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"\u2022"})," If j < n-1, then an open parenthesis is printed."]}),"\n",(0,i.jsxs)(r.p,{children:["This causes the contents to be printed in a format suitable for ",":initial-contents"," to ",(0,i.jsx)(n,{styled:!0,term:"make-array",children:(0,i.jsx)("b",{children:"make-array"})}),". The lists effectively printed by this procedure are subject to truncation by ",(0,i.jsx)(r.strong,{children:"*print-level*"})," and ",(0,i.jsx)(n,{styled:!0,term:"print-length",children:(0,i.jsx)("b",{children:"*print-length*"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["If the ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"array"})})," is of a specialized ",(0,i.jsx)(t,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})}),", containing bits or characters, then the innermost lists generated by the algorithm given above can instead be printed using bit-vector or string syntax, provided that these innermost lists would not be subject to truncation by ",(0,i.jsx)(n,{styled:!0,term:"print-length",children:(0,i.jsx)("b",{children:"*print-length*"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["If both ",(0,i.jsx)(n,{styled:!0,term:"print-array",children:(0,i.jsx)("b",{children:"*print-array*"})})," and ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," are ",(0,i.jsx)(t,{styled:!0,term:"false",children:(0,i.jsx)("i",{children:"false"})}),", then the ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"array"})})," is printed in a format (using #<) that is concise but not readable."]}),"\n",(0,i.jsxs)(r.p,{children:["If ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})})," is ",(0,i.jsx)(t,{styled:!0,term:"true",children:(0,i.jsx)("i",{children:"true"})}),", the ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"array"})})," prints in an ",(0,i.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,i.jsx)("i",{children:"implementation-defined"})})," manner; see the ",(0,i.jsx)(t,{styled:!0,term:"variable",children:(0,i.jsx)("i",{children:"variable"})})," ",(0,i.jsx)(n,{styled:!0,term:"print-readably",children:(0,i.jsx)("b",{children:"*print-readably*"})}),". In particular, this may be important for arrays having some dimension 0."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses these \u201cother ",(0,i.jsx)(t,{styled:!0,term:"array",children:(0,i.jsx)("i",{children:"arrays"})}),",\u201d see Section 2.4.8.12 (Sharpsign A)."]})]})}function ce(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(ae,{...e})}):ae(e)}function de(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function oe(e){const r={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-lisp",children:'(let ((a (make-array \u2019(3 3))) \n      (\\*print-pretty\\* t) \n      (\\*print-array\\* t)) \n  (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j)))) (print a) \n  (print (make-array 9 :displaced-to a))) \n\u25b7 #2A(("<0,0>" "<0,1>" "<0,2>") \n      \u25b7 ("<1,0>" "<1,1>" "<1,2>") \n      \n      \n      \u25b7 ("<2,0>" "<2,1>" "<2,2>")) \n\u25b7 #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>") \n\u2192 #<ARRAY 9 indirect 36363476> \n'})})}function he(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(oe,{...e})}):oe(e)}function pe(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||je("DictionaryLink",!0),t||je("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["A specific syntax for printing ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," of ",(0,i.jsx)(t,{styled:!0,term:"type",children:(0,i.jsx)("i",{children:"type"})})," ",(0,i.jsx)(n,{styled:!0,term:"random-state",children:(0,i.jsx)("b",{children:"random-state"})})," is not specified. However, every ",(0,i.jsx)(t,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," must arrange to print a ",(0,i.jsx)(r.em,{children:"random state object"})," in such a way that, within the same implementation, ",(0,i.jsx)(n,{styled:!0,term:"read",children:(0,i.jsx)("b",{children:"read"})})," can construct from the printed representation a copy of the ",(0,i.jsx)(t,{styled:!0,term:"random state",children:(0,i.jsx)("i",{children:"random state"})})," object as if the copy had been made by ",(0,i.jsx)(n,{styled:!0,term:"make-random-state",children:(0,i.jsx)("b",{children:"make-random-state"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["If the type ",(0,i.jsx)(t,{styled:!0,term:"random state",children:(0,i.jsx)("i",{children:"random state"})})," is effectively implemented by using the machinery for ",(0,i.jsx)(n,{styled:!0,term:"defstruct",children:(0,i.jsx)("b",{children:"defstruct"})}),", the usual structure syntax can then be used for printing ",(0,i.jsx)(t,{styled:!0,term:"random state",children:(0,i.jsx)("i",{children:"random state"})})," objects; one might look something like"]}),"\n",(0,i.jsxs)(r.p,{children:["#S(RANDOM-STATE ",":DATA"," #(14 49 98436589 786345 8734658324 ... ))"]}),"\n",(0,i.jsxs)(r.p,{children:["where the components are ",(0,i.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,i.jsx)("i",{children:"implementation-dependent"})}),"."]})]})}function xe(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(pe,{...e})}):pe(e)}function je(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function me(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||be("DictionaryLink",!0),t||be("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})}),' is enabled, the syntax #P"..." is how a ',(0,i.jsx)(t,{styled:!0,term:"pathname",children:(0,i.jsx)("i",{children:"pathname"})})," is printed by ",(0,i.jsx)(n,{styled:!0,term:"write",children:(0,i.jsx)("b",{children:"write"})}),' and the other functions herein described. The "..." is the namestring representation of the pathname.']}),"\n",(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(t,{styled:!0,term:"printer escaping",children:(0,i.jsx)("i",{children:"printer escaping"})})," is disabled, ",(0,i.jsx)(n,{styled:!0,term:"write",children:(0,i.jsx)("b",{children:"write"})})," writes a ",(0,i.jsx)(r.em,{children:"pathname P"})," by writing (namestring ",(0,i.jsx)(r.em,{children:"P"}),") instead. For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses ",(0,i.jsx)(t,{styled:!0,term:"pathname",children:(0,i.jsx)("i",{children:"pathnames"})}),", see Section 2.4.8.14 (Sharpsign P)."]})]})}function ye(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(me,{...e})}):me(e)}function be(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ue(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||ge("DictionaryLink",!0),t||ge("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["By default, a ",(0,i.jsx)(t,{styled:!0,term:"structure",children:(0,i.jsx)("i",{children:"structure"})})," of type ",(0,i.jsx)(r.em,{children:"S"})," is printed using #S syntax. This behavior can be customized by specifying a ",":print-function"," or ",":print-object"," option to the ",(0,i.jsx)(n,{styled:!0,term:"defstruct",children:(0,i.jsx)("b",{children:"defstruct"})})," ",(0,i.jsx)(t,{styled:!0,term:"form",children:(0,i.jsx)("i",{children:"form"})})," that defines ",(0,i.jsx)(r.em,{children:"S"}),", or by writing a ",(0,i.jsx)(n,{styled:!0,term:"print-object",children:(0,i.jsx)("b",{children:"print-object"})})," ",(0,i.jsx)(t,{styled:!0,term:"method",children:(0,i.jsx)("i",{children:"method"})})," that is ",(0,i.jsx)(t,{styled:!0,term:"specialized",children:(0,i.jsx)("i",{children:"specialized"})})," for ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," of type ",(0,i.jsx)(r.em,{children:"S"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Different structures might print out in different ways; the default notation for structures is: #S(",(0,i.jsx)(r.em,{children:"structure-name {slot-key slot-value}"}),"*)"]}),"\n",(0,i.jsxs)(r.p,{children:["where #S indicates structure syntax, ",(0,i.jsx)(r.em,{children:"structure-name"})," is a ",(0,i.jsx)(t,{styled:!0,term:"structure name",children:(0,i.jsx)("i",{children:"structure name"})}),", each ",(0,i.jsx)(r.em,{children:"slot-key"})," is an initialization argument ",(0,i.jsx)(t,{styled:!0,term:"name",children:(0,i.jsx)("i",{children:"name"})})," for a ",(0,i.jsx)(t,{styled:!0,term:"slot",children:(0,i.jsx)("i",{children:"slot"})})," in the ",(0,i.jsx)(t,{styled:!0,term:"structure",children:(0,i.jsx)("i",{children:"structure"})}),", and each corresponding ",(0,i.jsx)(r.em,{children:"slot-value"})," is a representation of the ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"object"})})," in that ",(0,i.jsx)(t,{styled:!0,term:"slot",children:(0,i.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," parses ",(0,i.jsx)(t,{styled:!0,term:"structure",children:(0,i.jsx)("i",{children:"structures"})}),", see Section 2.4.8.13 (Sharpsign S)."]})]})}function fe(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(ue,{...e})}):ue(e)}function ge(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ve(e){const r={em:"em",p:"p",...(0,s.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||Ee("DictionaryLink",!0),t||Ee("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["Other ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," are printed in an ",(0,i.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,i.jsx)("i",{children:"implementation-dependent"})})," manner. It is not required that an ",(0,i.jsx)(t,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," print those ",(0,i.jsx)(r.em,{children:"objects readably"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For example, ",(0,i.jsx)(t,{styled:!0,term:"hash table",children:(0,i.jsx)("i",{children:"hash tables"})}),", ",(0,i.jsx)(t,{styled:!0,term:"readtable",children:(0,i.jsx)("i",{children:"readtables"})}),", ",(0,i.jsx)(t,{styled:!0,term:"package",children:(0,i.jsx)("i",{children:"packages"})}),", ",(0,i.jsx)(t,{styled:!0,term:"stream",children:(0,i.jsx)("i",{children:"streams"})}),", and ",(0,i.jsx)(t,{styled:!0,term:"function",children:(0,i.jsx)("i",{children:"functions"})})," might not print ",(0,i.jsx)(t,{styled:!0,term:"readably",children:(0,i.jsx)("i",{children:"readably"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["A common notation to use in this circumstance is #<...>. Since #< is not readable by the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," , the precise format of the text which follows is not important, but a common format to use is that provided by the ",(0,i.jsx)(n,{styled:!0,term:"print-unreadable-object",children:(0,i.jsx)("b",{children:"print-unreadable-object"})})," ",(0,i.jsx)(t,{styled:!0,term:"macro",children:(0,i.jsx)("i",{children:"macro"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For information on how the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," treats this notation, see Section 2.4.8.20 (Sharpsign Less-Than-Sign). For information on how to notate ",(0,i.jsx)(t,{styled:!0,term:"object",children:(0,i.jsx)("i",{children:"objects"})})," that cannot be printed ",(0,i.jsx)(t,{styled:!0,term:"readably",children:(0,i.jsx)("i",{children:"readably"})}),", see Section 2.4.8.6 (Sharpsign Dot)."]})]})}function we(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(ve,{...e})}):ve(e)}function Ee(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Ae(e){const r={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-lisp",children:'(let ((\\*print-escape\\* t)) (fresh-line) (write #\\a)) \n\u25b7 #\\a \n\u2192 #\\a \n(let ((\\*print-escape\\* nil) (\\*print-readably\\* nil)) \n  (fresh-line) \n  (write #\\a)) \n\u25b7 a \n\u2192 #\\a \n(progn (fresh-line) (prin1 #\\a)) \n\u25b7 #\\a \n\u2192 #\\a \n(progn (fresh-line) (print #\\a)) \n\u25b7 \n\u25b7 #\\a \n\u2192 #\\a \n(progn (fresh-line) (princ #\\a)) \n\u25b7 a \n\u2192 #\\a \n(dolist (val \u2019(t nil)) \n  (let ((\\*print-escape\\* val) (\\*print-readably\\* val)) \n    (print \u2019#\\a) \n    (prin1 #\\a) (write-char #\\Space) \n    (princ #\\a) (write-char #\\Space) \n    (write #\\a))) \n\u25b7 #\\a #\\a a #\\a \n\n\u25b7 #\\a #\\a a a \n\u2192 NIL \n(progn (fresh-line) (write \u2019(let ((a 1) (b 2)) (+ a b)))) \n\u25b7 (LET ((A 1) (B 2)) (+ A B)) \n\u2192 (LET ((A 1) (B 2)) (+ A B)) \n(progn (fresh-line) (pprint \u2019(let ((a 1) (b 2)) (+ a b)))) \n\u25b7 (LET ((A 1) \n\t\u25b7 (B 2)) \n    \u25b7 (+ A B)) \n\u2192 (LET ((A 1) (B 2)) (+ A B)) \n(progn (fresh-line) \n       (write \u2019(let ((a 1) (b 2)) (+ a b)) :pretty t)) \n\u25b7 (LET ((A 1) \n\t\u25b7 (B 2)) \n    \u25b7 (+ A B)) \n\u2192 (LET ((A 1) (B 2)) (+ A B)) \n(with-output-to-string (s) \n  (write \u2019write :stream s) \n  (prin1 \u2019prin1 s)) \n\u2192 "WRITEPRIN1" \n\n\n'})})}function Re(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(Ae,{...e})}):Ae(e)}const ke={title:"22.1 The Lisp Printer"},Pe="22.1 The Lisp Printer",Te={},Se=[{value:"22.1.1 Overview of The Lisp Printer",id:"2211-overview-of-the-lisp-printer",level:2},{value:"22.1.1.1 Multiple Possible Textual Representations",id:"22111-multiple-possible-textual-representations",level:3},{value:"22.1.1.1.1 Printer Escaping",id:"221111-printer-escaping",level:4},{value:"22.1.2 Printer Dispatching",id:"2212-printer-dispatching",level:2},{value:"22.1.3 Default Print",id:"2213-default-print",level:2},{value:"22.1.3.1 Printing Numbers",id:"22131-printing-numbers",level:3},{value:"22.1.3.1.1 Printing Integers",id:"221311-printing-integers",level:4},{value:"22.1.3.1.2 Printing Ratios",id:"221312-printing-ratios",level:4},{value:"22.1.3.1.3 Printing Floats",id:"221313-printing-floats",level:4},{value:"22.1.3.1.4 Printing Complexes",id:"221314-printing-complexes",level:4},{value:"22.1.3.1.5 Note about Printing Numbers",id:"221315-note-about-printing-numbers",level:4},{value:"22.1.3.2 Printing Characters",id:"22132-printing-characters",level:3},{value:"22.1.3.3 Printing Symbols",id:"22133-printing-symbols",level:3},{value:"22.1.3.3.1 Package Prefixes for Symbols",id:"221331-package-prefixes-for-symbols",level:4},{value:"22.1.3.3.2 Effect of Readtable Case on the Lisp Printer",id:"221332-effect-of-readtable-case-on-the-lisp-printer",level:4},{value:"22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer",id:"2213321-examples-of-effect-of-readtable-case-on-the-lisp-printer",level:5},{value:"22.1.3.4 Printing Strings",id:"22134-printing-strings",level:3},{value:"22.1.3.5 Printing Lists and Conses",id:"22135-printing-lists-and-conses",level:3},{value:"22.1.3.6 Printing Bit Vectors",id:"22136-printing-bit-vectors",level:3},{value:"22.1.3.7 Printing Other Vectors",id:"22137-printing-other-vectors",level:3},{value:"22.1.3.8 Printing Other Arrays",id:"22138-printing-other-arrays",level:3},{value:"22.1.3.9 Examples of Printing Arrays",id:"22139-examples-of-printing-arrays",level:3},{value:"22.1.3.10 Printing Random States",id:"221310-printing-random-states",level:3},{value:"22.1.3.11 Printing Pathnames",id:"221311-printing-pathnames",level:3},{value:"22.1.3.12 Printing Structures",id:"221312-printing-structures",level:3},{value:"22.1.3.13 Printing Other Objects",id:"221313-printing-other-objects",level:3},{value:"22.1.4 Examples of Printer Behavior",id:"2214-examples-of-printer-behavior",level:2}];function Le(e){const r={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"221-the-lisp-printer",children:"22.1 The Lisp Printer"})}),"\n","\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(r.h2,{id:"2211-overview-of-the-lisp-printer",children:"22.1.1 Overview of The Lisp Printer"}),"\n","\n",(0,i.jsx)(d,{}),"\n",(0,i.jsx)(r.h3,{id:"22111-multiple-possible-textual-representations",children:"22.1.1.1 Multiple Possible Textual Representations"}),"\n","\n",(0,i.jsx)(p,{}),"\n",(0,i.jsx)(r.h4,{id:"221111-printer-escaping",children:"22.1.1.1.1 Printer Escaping"}),"\n","\n",(0,i.jsx)(m,{}),"\n",(0,i.jsx)(r.h2,{id:"2212-printer-dispatching",children:"22.1.2 Printer Dispatching"}),"\n","\n",(0,i.jsx)(u,{}),"\n",(0,i.jsx)(r.h2,{id:"2213-default-print",children:"22.1.3 Default Print"}),"\n","\n",(0,i.jsx)(v,{}),"\n",(0,i.jsx)(r.h3,{id:"22131-printing-numbers",children:"22.1.3.1 Printing Numbers"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(r.h4,{id:"221311-printing-integers",children:"22.1.3.1.1 Printing Integers"}),"\n","\n",(0,i.jsx)(R,{}),"\n",(0,i.jsx)(r.h4,{id:"221312-printing-ratios",children:"22.1.3.1.2 Printing Ratios"}),"\n","\n",(0,i.jsx)(T,{}),"\n",(0,i.jsx)(r.h4,{id:"221313-printing-floats",children:"22.1.3.1.3 Printing Floats"}),"\n","\n",(0,i.jsx)(C,{}),"\n",(0,i.jsx)(r.h4,{id:"221314-printing-complexes",children:"22.1.3.1.4 Printing Complexes"}),"\n","\n",(0,i.jsx)(D,{}),"\n",(0,i.jsx)(r.h4,{id:"221315-note-about-printing-numbers",children:"22.1.3.1.5 Note about Printing Numbers"}),"\n","\n",(0,i.jsx)(Z,{}),"\n",(0,i.jsx)(r.h3,{id:"22132-printing-characters",children:"22.1.3.2 Printing Characters"}),"\n","\n",(0,i.jsx)(N,{}),"\n",(0,i.jsx)(r.h3,{id:"22133-printing-symbols",children:"22.1.3.3 Printing Symbols"}),"\n","\n",(0,i.jsx)(W,{}),"\n",(0,i.jsx)(r.h4,{id:"221331-package-prefixes-for-symbols",children:"22.1.3.3.1 Package Prefixes for Symbols"}),"\n","\n",(0,i.jsx)(U,{}),"\n",(0,i.jsx)(r.h4,{id:"221332-effect-of-readtable-case-on-the-lisp-printer",children:"22.1.3.3.2 Effect of Readtable Case on the Lisp Printer"}),"\n","\n",(0,i.jsx)(M,{}),"\n",(0,i.jsx)(r.h5,{id:"2213321-examples-of-effect-of-readtable-case-on-the-lisp-printer",children:"22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer"}),"\n","\n",(0,i.jsx)(K,{}),"\n",(0,i.jsx)(r.h3,{id:"22134-printing-strings",children:"22.1.3.4 Printing Strings"}),"\n","\n",(0,i.jsx)(J,{}),"\n",(0,i.jsx)(r.h3,{id:"22135-printing-lists-and-conses",children:"22.1.3.5 Printing Lists and Conses"}),"\n","\n",(0,i.jsx)($,{}),"\n",(0,i.jsx)(r.h3,{id:"22136-printing-bit-vectors",children:"22.1.3.6 Printing Bit Vectors"}),"\n","\n",(0,i.jsx)(ne,{}),"\n",(0,i.jsx)(r.h3,{id:"22137-printing-other-vectors",children:"22.1.3.7 Printing Other Vectors"}),"\n","\n",(0,i.jsx)(se,{}),"\n",(0,i.jsx)(r.h3,{id:"22138-printing-other-arrays",children:"22.1.3.8 Printing Other Arrays"}),"\n","\n",(0,i.jsx)(ce,{}),"\n",(0,i.jsx)(r.h3,{id:"22139-examples-of-printing-arrays",children:"22.1.3.9 Examples of Printing Arrays"}),"\n","\n",(0,i.jsx)(he,{}),"\n",(0,i.jsx)(r.h3,{id:"221310-printing-random-states",children:"22.1.3.10 Printing Random States"}),"\n","\n",(0,i.jsx)(xe,{}),"\n",(0,i.jsx)(r.h3,{id:"221311-printing-pathnames",children:"22.1.3.11 Printing Pathnames"}),"\n","\n",(0,i.jsx)(ye,{}),"\n",(0,i.jsx)(r.h3,{id:"221312-printing-structures",children:"22.1.3.12 Printing Structures"}),"\n","\n",(0,i.jsx)(fe,{}),"\n",(0,i.jsx)(r.h3,{id:"221313-printing-other-objects",children:"22.1.3.13 Printing Other Objects"}),"\n","\n",(0,i.jsx)(we,{}),"\n",(0,i.jsx)(r.h2,{id:"2214-examples-of-printer-behavior",children:"22.1.4 Examples of Printer Behavior"}),"\n","\n",(0,i.jsx)(Re,{})]})}function Ce(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(Le,{...e})}):Le(e)}}}]);