"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[44383],{25174:(n,e,l)=>{l.r(e),l.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>h});var s=l(85893),t=l(11151);function r(n){const e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"flet, labels, macrolet"})," ",(0,s.jsx)(e.em,{children:"Special Operator"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"flet"})," (",(0,s.jsx)(e.em,{children:"{"}),"(",(0,s.jsx)(e.em,{children:"function-name lambda-list"})," [[ ",(0,s.jsx)(e.em,{children:"{local-declaration}"}),"* ",(0,s.jsx)(e.em,{children:"| local-documentation"})," ]] ",(0,s.jsx)(e.em,{children:"{local-form}"}),"*)",(0,s.jsx)(e.em,{children:"}"}),"*) ",(0,s.jsx)(e.em,{children:"{declaration}"}),"* ",(0,s.jsx)(e.em,{children:"{form}"}),"*"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"labels"})," (",(0,s.jsx)(e.em,{children:"{"}),"(",(0,s.jsx)(e.em,{children:"function-name lambda-list"})," [[ ",(0,s.jsx)(e.em,{children:"{local-declaration}"}),"* ",(0,s.jsx)(e.em,{children:"| local-documentation"})," ]] ",(0,s.jsx)(e.em,{children:"{local-form}"}),"*)",(0,s.jsx)(e.em,{children:"}"}),"*) ",(0,s.jsx)(e.em,{children:"{declaration}"}),"* ",(0,s.jsx)(e.em,{children:"{form}"}),"*"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"macrolet"})," (",(0,s.jsx)(e.em,{children:"{"}),"(",(0,s.jsx)(e.em,{children:"name lambda-list"})," [[ ",(0,s.jsx)(e.em,{children:"{local-declaration}"}),"* ",(0,s.jsx)(e.em,{children:"| local-documentation"})," ]] ",(0,s.jsx)(e.em,{children:"{local-form}"}),"*)",(0,s.jsx)(e.em,{children:"}"}),"*) ",(0,s.jsx)(e.em,{children:"{declaration}"}),"* ",(0,s.jsx)(e.em,{children:"{form}"}),"*"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"function-name"}),"\u2014a ",(0,s.jsx)(e.em,{children:"function name"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"name"}),"\u2014a ",(0,s.jsx)(e.em,{children:"symbol"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"lambda-list"}),"\u2014a ",(0,s.jsx)(e.em,{children:"lambda list"}),"; for ",(0,s.jsx)(e.strong,{children:"flet"})," and ",(0,s.jsx)(e.strong,{children:"labels"}),", it is an ",(0,s.jsx)(e.em,{children:"ordinary lambda list"}),"; for ",(0,s.jsx)(e.strong,{children:"macrolet"}),", it is a ",(0,s.jsx)(e.em,{children:"macro lambda list"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"local-declaration"}),"\u2014a ",(0,s.jsx)(e.strong,{children:"declare"})," ",(0,s.jsx)(e.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"declaration"}),"\u2014a ",(0,s.jsx)(e.strong,{children:"declare"})," ",(0,s.jsx)(e.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"local-documentation"}),"\u2014a ",(0,s.jsx)(e.em,{children:"string"}),"; not evaluated."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"local-forms"}),", ",(0,s.jsx)(e.em,{children:"forms"}),"\u2014an ",(0,s.jsx)(e.em,{children:"implicit progn"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.em,{children:"results"}),"\u2014the ",(0,s.jsx)(e.em,{children:"values"})," of the ",(0,s.jsx)(e.em,{children:"forms"}),"."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"flet"}),", ",(0,s.jsx)(e.strong,{children:"labels"}),", and ",(0,s.jsx)(e.strong,{children:"macrolet"})," define local ",(0,s.jsx)(e.em,{children:"functions"})," and ",(0,s.jsx)(e.em,{children:"macros"}),", and execute ",(0,s.jsx)(e.em,{children:"forms"})," using the local definitions. ",(0,s.jsx)(e.em,{children:"Forms"})," are executed in order of occurrence."]}),"\n",(0,s.jsxs)(e.p,{children:["The body forms (but not the ",(0,s.jsx)(e.em,{children:"lambda list"}),") of each ",(0,s.jsx)(e.em,{children:"function"})," created by ",(0,s.jsx)(e.strong,{children:"flet"})," and ",(0,s.jsx)(e.strong,{children:"labels"})," and each ",(0,s.jsx)(e.em,{children:"macro"})," created by ",(0,s.jsx)(e.strong,{children:"macrolet"})," are enclosed in an ",(0,s.jsx)(e.em,{children:"implicit block"})," whose name is the ",(0,s.jsx)(e.em,{children:"function block name"})," of the ",(0,s.jsx)(e.em,{children:"function-name"})," or ",(0,s.jsx)(e.em,{children:"name"}),", as appropriate."]}),"\n",(0,s.jsxs)(e.p,{children:["The scope of the ",(0,s.jsx)(e.em,{children:"declarations"})," between the list of local function/macro definitions and the body ",(0,s.jsx)(e.em,{children:"forms"})," in ",(0,s.jsx)(e.strong,{children:"flet"})," and ",(0,s.jsx)(e.strong,{children:"labels"})," does not include the bodies of the locally defined ",(0,s.jsx)(e.em,{children:"functions"}),", except that"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"flet, labels, macrolet"})}),"\n",(0,s.jsxs)(e.p,{children:["for ",(0,s.jsx)(e.strong,{children:"labels"}),", any ",(0,s.jsx)(e.strong,{children:"inline"}),", ",(0,s.jsx)(e.strong,{children:"notinline"}),", or ",(0,s.jsx)(e.strong,{children:"ftype"})," declarations that refer to the locally defined functions do apply to the local function bodies. That is, their ",(0,s.jsx)(e.em,{children:"scope"})," is the same as the function name that they affect. The scope of these ",(0,s.jsx)(e.em,{children:"declarations"})," does not include the bodies of the macro expander functions defined by ",(0,s.jsx)(e.strong,{children:"macrolet"}),"."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"flet"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"flet"})," defines locally named ",(0,s.jsx)(e.em,{children:"functions"})," and executes a series of ",(0,s.jsx)(e.em,{children:"forms"})," with these definition ",(0,s.jsx)(e.em,{children:"bindings"}),". Any number of such local ",(0,s.jsx)(e.em,{children:"functions"})," can be defined."]}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.em,{children:"scope"})," of the name ",(0,s.jsx)(e.em,{children:"binding"})," encompasses only the body. Within the body of ",(0,s.jsx)(e.strong,{children:"flet"}),", ",(0,s.jsx)(e.em,{children:"function-names"})," matching those defined by ",(0,s.jsx)(e.strong,{children:"flet"})," refer to the locally defined ",(0,s.jsx)(e.em,{children:"functions"})," rather than to the global function definitions of the same name. Also, within the scope of ",(0,s.jsx)(e.strong,{children:"flet"}),", global ",(0,s.jsx)(e.em,{children:"setf expander"})," definitions of the ",(0,s.jsx)(e.em,{children:"function-name"})," defined by ",(0,s.jsx)(e.strong,{children:"flet"})," do not apply. Note that this applies to (defsetf ",(0,s.jsx)(e.em,{children:"f"})," ...), not (defmethod (setf ",(0,s.jsx)(e.em,{children:"f"}),") ...)."]}),"\n",(0,s.jsxs)(e.p,{children:["The names of ",(0,s.jsx)(e.em,{children:"functions"})," defined by ",(0,s.jsx)(e.strong,{children:"flet"})," are in the ",(0,s.jsx)(e.em,{children:"lexical environment"}),"; they retain their local definitions only within the body of ",(0,s.jsx)(e.strong,{children:"flet"}),". The function definition bindings are visible only in the body of ",(0,s.jsx)(e.strong,{children:"flet"}),", not the definitions themselves. Within the function definitions,"]}),"\n",(0,s.jsxs)(e.p,{children:["local function names that match those being defined refer to ",(0,s.jsx)(e.em,{children:"functions"})," or ",(0,s.jsx)(e.em,{children:"macros"})," defined outside the ",(0,s.jsx)(e.strong,{children:"flet"}),". ",(0,s.jsx)(e.strong,{children:"flet"})," can locally ",(0,s.jsx)(e.em,{children:"shadow"})," a global function name, and the new definition can refer to the global definition."]}),"\n",(0,s.jsxs)(e.p,{children:["Any ",(0,s.jsx)(e.em,{children:"local-documentation"})," is attached to the corresponding local ",(0,s.jsx)(e.em,{children:"function"})," (if one is actually created) as a ",(0,s.jsx)(e.em,{children:"documentation string"}),"."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"labels"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"labels"})," is equivalent to ",(0,s.jsx)(e.strong,{children:"flet"})," except that the scope of the defined function names for ",(0,s.jsx)(e.strong,{children:"labels"})," encompasses the function definitions themselves as well as the body."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"macrolet"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"macrolet"})," establishes local ",(0,s.jsx)(e.em,{children:"macro"})," definitions, using the same format used by ",(0,s.jsx)(e.strong,{children:"defmacro"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["Within the body of ",(0,s.jsx)(e.strong,{children:"macrolet"}),", global ",(0,s.jsx)(e.em,{children:"setf expander"})," definitions of the ",(0,s.jsx)(e.em,{children:"names"})," defined by the ",(0,s.jsx)(e.strong,{children:"macrolet"})," do not apply; rather, ",(0,s.jsx)(e.strong,{children:"setf"})," expands the ",(0,s.jsx)(e.em,{children:"macro form"})," and recursively process the resulting ",(0,s.jsx)(e.em,{children:"form"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["The macro-expansion functions defined by ",(0,s.jsx)(e.strong,{children:"macrolet"})," are defined in the ",(0,s.jsx)(e.em,{children:"lexical environment"})," in which the ",(0,s.jsx)(e.strong,{children:"macrolet"})," form appears. Declarations and ",(0,s.jsx)(e.strong,{children:"macrolet"})," and ",(0,s.jsx)(e.strong,{children:"symbol-macrolet"})," definitions affect the local macro definitions in a ",(0,s.jsx)(e.strong,{children:"macrolet"}),", but the consequences are undefined if the local macro definitions reference any local ",(0,s.jsx)(e.em,{children:"variable"})," or ",(0,s.jsx)(e.em,{children:"function bindings"})," that are visible in that ",(0,s.jsx)(e.em,{children:"lexical environment"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["Any ",(0,s.jsx)(e.em,{children:"local-documentation"})," is attached to the corresponding local ",(0,s.jsx)(e.em,{children:"macro function"})," as a ",(0,s.jsx)(e.em,{children:"documentation string"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"Data and Control"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"flet, labels, macrolet"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" \n\n\n\n(defun foo (x flag) \n\n\n\n(macrolet ((fudge (z) \n\n\n\n;The parameters x and flag are not accessible \n\n\n\n; at this point; a reference to flag would be to \n\n\n\n; the global variable of that name. \n\n\n\n\u2018(if flag (\\* ,z ,z) ,z))) \n\n\n\n;The parameters x and flag are accessible here. \n\n\n\n(+ x \n\n\n\n(fudge x) \n\n\n\n(fudge (+ x 1))))) \n\n\n\n*\u2261* \n\n\n\n(defun foo (x flag) \n\n\n\n(+ x \n\n\n\n(if flag (\\* x x) x) \n\n\n\n(if flag (\\* (+ x 1) (+ x 1)) (+ x 1)))) \n\n\n\nafter macro expansion. The occurrences of x and flag legitimately refer to the parameters of the function foo because those parameters are visible at the site of the macro call which produced the expansion. \n\n\n\n(flet ((flet1 (n) (+ n n))) \n\n\n\n(flet ((flet1 (n) (+ 2 (flet1 n)))) \n\n\n\n(flet1 2))) *\u2192* 6 \n\n\n\n(defun dummy-function () \u2019top-level) *\u2192* DUMMY-FUNCTION \n\n\n\n(funcall #\u2019dummy-function) *\u2192* TOP-LEVEL \n\n\n\n(flet ((dummy-function () \u2019shadow)) \n\n\n\n(funcall #\u2019dummy-function)) *\u2192* SHADOW \n\n\n\n(eq (funcall #\u2019dummy-function) (funcall \u2019dummy-function)) \n\n\n\n*\u2192 true* \n\n\n\n(flet ((dummy-function () \u2019shadow)) \n\n\n\n(eq (funcall #\u2019dummy-function) \n\n\n\n(funcall \u2019dummy-function))) \n\n\n\n*\u2192 false* \n\n\n\n(defun recursive-times (k n) \n\n\n\n(labels ((temp (n) \n\n\n\n(if (zerop n) 0 (+ k (temp (1- n)))))) \n\n\n\n(temp n))) *\u2192* RECURSIVE-TIMES \n\n\n\n(recursive-times 2 3) *\u2192* 6 \n\n\n\n(defmacro mlets (x &amp;environment env) \n\n\n\n(let ((form \u2018(babbit ,x))) \n\n\n\n(macroexpand form env))) *\u2192* MLETS \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**flet, labels, macrolet** \n\n\n\n(macrolet ((babbit (z) \u2018(+ ,z ,z))) (mlets 5)) *\u2192* 10 \n\n\n\n(flet ((safesqrt (x) (sqrt (abs x)))) \n\n\n\n;; The safesqrt function is used in two places. \n\n\n\n(safesqrt (apply #\u2019+ (map \u2019list #\u2019safesqrt \u2019(1 2 3 4 5 6))))) \n\n\n\n*\u2192* 3.291173 \n\n\n\n(defun integer-power (n k) \n\n\n\n(declare (integer n)) \n\n\n\n(declare (type (integer 0 \\*) k)) \n\n\n\n(labels ((expt0 (x k a) \n\n\n\n(declare (integer x a) (type (integer 0 \\*) k)) \n\n\n\n(cond ((zerop k) a) \n\n\n\n((evenp k) (expt1 (\\* x x) (floor k 2) a)) \n\n\n\n(t (expt0 (\\* x x) (floor k 2) (\\* x a))))) \n\n\n\n(expt1 (x k a) \n\n\n\n(declare (integer x a) (type (integer 0 \\*) k)) \n\n\n\n(cond ((evenp k) (expt1 (\\* x x) (floor k 2) a)) \n\n\n\n(t (expt0 (\\* x x) (floor k 2) (\\* x a)))))) \n\n\n\n(expt0 n k 1))) *\u2192* INTEGER-POWER \n\n\n\n(defun example (y l) \n\n\n\n(flet ((attach (x) \n\n\n\n(setq l (append l (list x))))) \n\n\n\n(declare (inline attach)) \n\n\n\n(dolist (x y) \n\n\n\n(unless (null (cdr x)) \n\n\n\n(attach x))) \n\n\n\nl)) \n\n\n\n(example \u2019((a apple apricot) (b banana) (c cherry) (d) (e)) \n\n\n\n\u2019((1) (2) (3) (4 2) (5) (6 3 2))) \n\n\n\n*\u2192* ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY)) \n\n\n\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"See Also:"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"declare"}),", ",(0,s.jsx)(e.strong,{children:"defmacro"}),", ",(0,s.jsx)(e.strong,{children:"defun"}),", ",(0,s.jsx)(e.strong,{children:"documentation"}),", ",(0,s.jsx)(e.strong,{children:"let"}),", Section 3.1 (Evaluation), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(e.p,{children:["It is not possible to define recursive ",(0,s.jsx)(e.em,{children:"functions"})," with ",(0,s.jsx)(e.strong,{children:"flet"}),". ",(0,s.jsx)(e.strong,{children:"labels"})," can be used to define mutually recursive ",(0,s.jsx)(e.em,{children:"functions"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["If a ",(0,s.jsx)(e.strong,{children:"macrolet"})," ",(0,s.jsx)(e.em,{children:"form"})," is a ",(0,s.jsx)(e.em,{children:"top level form"}),", the body ",(0,s.jsx)(e.em,{children:"forms"})," are also processed as ",(0,s.jsx)(e.em,{children:"top level forms"}),". See Section 3.2.3 (File Compilation)."]}),"\n",(0,s.jsx)(e.p,{children:"Data and Control"})]})}function i(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(r,{...n})}):r(n)}const c={},o="flet, labels, macrolet",a={id:"chap-5/f-d-dictionary/flet",title:"flet, labels, macrolet",description:"Expanded Reference: flet, labels, macrolet",source:"@site/docs/chap-5/f-d-dictionary/flet.md",sourceDirName:"chap-5/f-d-dictionary",slug:"/chap-5/f-d-dictionary/flet",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/flet",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-5/f-d-dictionary/flet.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"fdefinition",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/fdefinition"},next:{title:"fmakunbound",permalink:"/cl-language-reference/docs/chap-5/f-d-dictionary/fmakunbound"}},d={},h=[{value:"Expanded Reference: flet, labels, macrolet",id:"expanded-reference-flet-labels-macrolet",level:2}];function x(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"flet-labels-macrolet",children:"flet, labels, macrolet"}),"\n","\n","\n",(0,s.jsx)(i,{}),"\n",(0,s.jsx)(e.h2,{id:"expanded-reference-flet-labels-macrolet",children:"Expanded Reference: flet, labels, macrolet"}),"\n",(0,s.jsx)(e.admonition,{type:"tip",children:(0,s.jsx)(e.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(flet, labels, macrolet )\n"})})]})}function m(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(x,{...n})}):x(n)}},11151:(n,e,l)=>{l.d(e,{Z:()=>c,a:()=>i});var s=l(67294);const t={},r=s.createContext(t);function i(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);