"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[2592],{9088:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>L,contentTitle:()=>P,default:()=>W,frontMatter:()=>G,metadata:()=>R,toc:()=>V});var i=s(5893),r=s(1151);function t(e){const n={p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6 Generic Functions and Methods"})})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}function c(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.1 Introduction to Generic Functions"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"generic function"})," is a function whose behavior depends on the ",(0,i.jsx)(n.em,{children:"classes"})," or identities of the ",(0,i.jsx)(n.em,{children:"arguments"})," supplied to it. A ",(0,i.jsx)(n.em,{children:"generic function object"})," is associated with a set of ",(0,i.jsx)(n.em,{children:"methods"}),", a ",(0,i.jsx)(n.em,{children:"lambda list"}),", a ",(0,i.jsx)(n.em,{children:"method combination"}),"<sub>2</sub>, and other information."]}),"\n",(0,i.jsxs)(n.p,{children:["Like an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"generic function"})," takes ",(0,i.jsx)(n.em,{children:"arguments"}),", performs a series of operations, and perhaps returns useful ",(0,i.jsx)(n.em,{children:"values"}),". An ",(0,i.jsx)(n.em,{children:"ordinary function"})," has a single body of ",(0,i.jsx)(n.em,{children:"code"})," that is always ",(0,i.jsx)(n.em,{children:"executed"})," when the ",(0,i.jsx)(n.em,{children:"function"})," is called. A ",(0,i.jsx)(n.em,{children:"generic function"})," has a set of bodies of ",(0,i.jsx)(n.em,{children:"code"})," of which a subset is selected for ",(0,i.jsx)(n.em,{children:"execution"}),". The selected bodies of ",(0,i.jsx)(n.em,{children:"code"})," and the manner of their combination are determined by the ",(0,i.jsx)(n.em,{children:"classes"})," or identities of one or more of the ",(0,i.jsx)(n.em,{children:"arguments"})," to the ",(0,i.jsx)(n.em,{children:"generic function"})," and by its ",(0,i.jsx)(n.em,{children:"method combination"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Ordinary functions"})," and ",(0,i.jsx)(n.em,{children:"generic functions"})," are called with identical syntax."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Generic functions"})," are true ",(0,i.jsx)(n.em,{children:"functions"})," that can be passed as ",(0,i.jsx)(n.em,{children:"arguments"})," and used as the first ",(0,i.jsx)(n.em,{children:"argument"})," to ",(0,i.jsx)(n.strong,{children:"funcall"})," and ",(0,i.jsx)(n.strong,{children:"apply"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"binding"})," of a ",(0,i.jsx)(n.em,{children:"function name"})," to a ",(0,i.jsx)(n.em,{children:"generic function"})," can be ",(0,i.jsx)(n.em,{children:"established"})," in one of several ways. It can be ",(0,i.jsx)(n.em,{children:"established"})," in the ",(0,i.jsx)(n.em,{children:"global environment"})," by ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"}),", ",(0,i.jsx)(n.strong,{children:"defmethod"})," (implicitly, due to ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"}),") or ",(0,i.jsx)(n.strong,{children:"defgeneric"})," (also implicitly, due to ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"}),"). No ",(0,i.jsx)(n.em,{children:"standardized"})," mechanism is provided for ",(0,i.jsx)(n.em,{children:"establishing"})," a ",(0,i.jsx)(n.em,{children:"binding"})," of a ",(0,i.jsx)(n.em,{children:"function name"})," to a ",(0,i.jsx)(n.em,{children:"generic function"})," in the ",(0,i.jsx)(n.em,{children:"lexical environment"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form is evaluated, one of three actions is taken (due to ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"}),"):"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If a generic function of the given name already exists, the existing generic function object is modified. Methods specified by the current ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form are added, and any methods in the existing generic function that were defined by a previous ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form are removed. Methods added by the current ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form might replace methods defined by ",(0,i.jsx)(n.strong,{children:"defmethod"}),", ",(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"define-condition"}),", or ",(0,i.jsx)(n.strong,{children:"defstruct"}),". No other methods in the generic function are affected or replaced."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If the given name names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," Otherwise a generic function is created with the methods specified by the method definitions in the ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form."]}),"\n",(0,i.jsxs)(n.p,{children:["Some ",(0,i.jsx)(n.em,{children:"operators"})," permit specification of the options of a ",(0,i.jsx)(n.em,{children:"generic function"}),", such as the ",(0,i.jsx)(n.em,{children:"type"})," of ",(0,i.jsx)(n.em,{children:"method combination"})," it uses or its ",(0,i.jsx)(n.em,{children:"argument precedence order"})," . These ",(0,i.jsx)(n.em,{children:"operators"})," will be referred to as \u201coperators that specify generic function options.\u201d The only ",(0,i.jsx)(n.em,{children:"standardized operator"})," in this category is ",(0,i.jsx)(n.strong,{children:"defgeneric"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Some ",(0,i.jsx)(n.em,{children:"operators"})," define ",(0,i.jsx)(n.em,{children:"methods"})," for a ",(0,i.jsx)(n.em,{children:"generic function"}),". These ",(0,i.jsx)(n.em,{children:"operators"})," will be referred to as ",(0,i.jsx)(n.em,{children:"method-defining operators"}),"; their associated ",(0,i.jsx)(n.em,{children:"forms"})," are called ",(0,i.jsx)(n.em,{children:"method-defining forms"}),". The ",(0,i.jsx)(n.em,{children:"standardized method-defining operators"})," are listed in Figure 7\u20131."]}),"\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.th,{style:{textAlign:"left"},children:["<p>",(0,i.jsx)(n.strong,{children:"defgeneric defmethod defclass"})," </p><p>",(0,i.jsx)(n.strong,{children:"define-condition defstruct"}),"</p>"]})})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 7\u20131. Standardized Method-Defining Operators"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that of the ",(0,i.jsx)(n.em,{children:"standardized method-defining operators"})," only ",(0,i.jsx)(n.strong,{children:"defgeneric"})," can specify ",(0,i.jsx)(n.em,{children:"generic function"})," options. ",(0,i.jsx)(n.strong,{children:"defgeneric"})," and any ",(0,i.jsx)(n.em,{children:"implementation-defined operators"})," that can specify ",(0,i.jsx)(n.em,{children:"generic function"})," options are also referred to as \u201coperators that specify generic function options.\u201d"]})]})}function o(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function d(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.2 Introduction to Methods"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Methods"})," define the class-specific or identity-specific behavior and operations of a ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"method object"})," is associated with ",(0,i.jsx)(n.em,{children:"code"})," that implements the method\u2019s behavior, a sequence of ",(0,i.jsx)(n.em,{children:"parameter specializers"})," that specify when the given ",(0,i.jsx)(n.em,{children:"method"})," is applicable, a ",(0,i.jsx)(n.em,{children:"lambda list"}),", and a sequence of ",(0,i.jsx)(n.em,{children:"qualifiers"})," that are used by the method combination facility to distinguish among ",(0,i.jsx)(n.em,{children:"methods"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A method object is not a function and cannot be invoked as a function. Various mechanisms in the object system take a method object and invoke its method function, as is the case when a generic function is invoked. When this occurs it is said that the method is invoked or called."}),"\n",(0,i.jsxs)(n.p,{children:["A method-defining form contains the ",(0,i.jsx)(n.em,{children:"code"})," that is to be run when the arguments to the generic function cause the method that it defines to be invoked. When a method-defining form is evaluated, a method object is created and one of four actions is taken:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If a ",(0,i.jsx)(n.em,{children:"generic function"})," of the given name already exists and if a ",(0,i.jsx)(n.em,{children:"method object"})," already exists that agrees with the new one on ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and ",(0,i.jsx)(n.em,{children:"qualifiers"}),", the new ",(0,i.jsx)(n.em,{children:"method object"})," replaces the old one. For a definition of one method agreeing with another on ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and ",(0,i.jsx)(n.em,{children:"qualifiers"}),", see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If a ",(0,i.jsx)(n.em,{children:"generic function"})," of the given name already exists and if there is no ",(0,i.jsx)(n.em,{children:"method object"})," that agrees with the new one on ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and ",(0,i.jsx)(n.em,{children:"qualifiers"}),", the existing ",(0,i.jsx)(n.em,{children:"generic function object"})," is modified to contain the new ",(0,i.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If the given ",(0,i.jsx)(n.em,{children:"name"})," names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," Otherwise a ",(0,i.jsx)(n.em,{children:"generic function"})," is created with the ",(0,i.jsx)(n.em,{children:"method"})," specified by the ",(0,i.jsx)(n.em,{children:"method-defining form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201317"})]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.em,{children:"lambda list"})," of a new ",(0,i.jsx)(n.em,{children:"method"})," is not ",(0,i.jsx)(n.em,{children:"congruent"})," with the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),", an error is signaled. If a ",(0,i.jsx)(n.em,{children:"method-defining operator"})," that cannot specify ",(0,i.jsx)(n.em,{children:"generic function"})," options creates a new ",(0,i.jsx)(n.em,{children:"generic function"}),", a ",(0,i.jsx)(n.em,{children:"lambda list"})," for that ",(0,i.jsx)(n.em,{children:"generic function"})," is derived from the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"method"})," in the ",(0,i.jsx)(n.em,{children:"method-defining form"})," in such a way as to be ",(0,i.jsx)(n.em,{children:"congruent"})," with it. For a discussion of ",(0,i.jsx)(n.em,{children:"congruence"}),", see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,i.jsxs)(n.p,{children:["Each method has a ",(0,i.jsx)(n.em,{children:"specialized lambda list"}),", which determines when that method can be applied. A ",(0,i.jsx)(n.em,{children:"specialized lambda list"})," is like an ",(0,i.jsx)(n.em,{children:"ordinary lambda list"})," except that a specialized parameter may occur instead of the name of a required parameter. A specialized parameter is a list (",(0,i.jsx)(n.em,{children:"variable-name parameter-specializer-name"}),"), where ",(0,i.jsx)(n.em,{children:"parameter-specializer-name"})," is one of the following:"]}),"\n",(0,i.jsxs)(n.p,{children:["a ",(0,i.jsx)(n.em,{children:"symbol"})]}),"\n",(0,i.jsxs)(n.p,{children:["denotes a ",(0,i.jsx)(n.em,{children:"parameter specializer"})," which is the ",(0,i.jsx)(n.em,{children:"class"})," named by that ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["a ",(0,i.jsx)(n.em,{children:"class"})]}),"\n",(0,i.jsxs)(n.p,{children:["denotes a ",(0,i.jsx)(n.em,{children:"parameter specializer"})," which is the ",(0,i.jsx)(n.em,{children:"class"})," itself."]}),"\n",(0,i.jsxs)(n.p,{children:["(eql ",(0,i.jsx)(n.em,{children:"form"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["denotes a ",(0,i.jsx)(n.em,{children:"parameter specializer"})," which satisfies the ",(0,i.jsx)(n.em,{children:"type specifier"})," (eql ",(0,i.jsx)(n.em,{children:"object"}),"), where ",(0,i.jsx)(n.em,{children:"object"})," is the result of evaluating ",(0,i.jsx)(n.em,{children:"form"}),". The form ",(0,i.jsx)(n.em,{children:"form"})," is evaluated in the lexical environment in which the method-defining form is evaluated. Note that ",(0,i.jsx)(n.em,{children:"form"})," is evaluated only once, at the time the method is defined, not each time the generic function is called."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Parameter specializer names"})," are used in macros intended as the user-level interface (",(0,i.jsx)(n.strong,{children:"defmethod"}),"), while ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are used in the functional interface."]}),"\n",(0,i.jsxs)(n.p,{children:["Only required parameters may be specialized, and there must be a ",(0,i.jsx)(n.em,{children:"parameter specializer"})," for each required parameter. For notational simplicity, if some required parameter in a ",(0,i.jsx)(n.em,{children:"specialized lambda list"})," in a method-defining form is simply a variable name, its ",(0,i.jsx)(n.em,{children:"parameter specializer"})," defaults to the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Given a generic function and a set of arguments, an applicable method is a method for that generic function whose parameter specializers are satisfied by their corresponding arguments. The following definition specifies what it means for a method to be applicable and for an argument to satisfy a ",(0,i.jsx)(n.em,{children:"parameter specializer"})," ."]}),"\n",(0,i.jsx)(n.p,{children:"Let <i>hA</i><sub>1</sub><i>, . . . , A<sub>n</sub>i</i> be the required arguments to a generic function in order. Let <i>hP</i><sub>1</sub><i>, . . . , P<sub>n</sub>i</i> be the <i>parameter specializers</i> corresponding to the required parameters of the method <i>M</i> in order. The method <i>M</i> is applicable when each <i>A<sub>i</sub></i>is of the <i>type</i> specified by the <i>type specifier P<sub>i</sub></i>. Because every valid <i>parameter specializer</i> is also a valid <i>type specifier</i> , the <i>function</i> <b>typep</b> can be used during method selection to determine whether an argument satisfies a <i>parameter specializer</i> ."}),"\n",(0,i.jsxs)(n.p,{children:["A method all of whose ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"t"})," is called a ",(0,i.jsx)(n.em,{children:"default method"}),"; it is always applicable but may be shadowed by a more specific method."]}),"\n",(0,i.jsxs)(n.p,{children:["Methods can have ",(0,i.jsx)(n.em,{children:"qualifiers"}),", which give the method combination procedure a way to distinguish among methods. A method that has one or more ",(0,i.jsx)(n.em,{children:"qualifiers"})," is called a ",(0,i.jsx)(n.em,{children:"qualified method"}),". A method with no ",(0,i.jsx)(n.em,{children:"qualifiers"})," is called an ",(0,i.jsx)(n.em,{children:"unqualified method"}),". A ",(0,i.jsx)(n.em,{children:"qualifier"})," is any ",(0,i.jsx)(n.em,{children:"non-list"}),". The ",(0,i.jsx)(n.em,{children:"qualifiers"})," defined by the ",(0,i.jsx)(n.em,{children:"standardized"})," method combination types are ",(0,i.jsx)(n.em,{children:"symbols"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In this specification, the terms \u201c",(0,i.jsx)(n.em,{children:"primary method"}),"\u201d and \u201c",(0,i.jsx)(n.em,{children:"auxiliary method"}),"\u201d are used to partition ",(0,i.jsx)(n.em,{children:"methods"})," within a method combination type according to their intended use. In standard method combination, ",(0,i.jsx)(n.em,{children:"primary methods"})," are ",(0,i.jsx)(n.em,{children:"unqualified methods"})," and ",(0,i.jsx)(n.em,{children:"auxiliary methods"})," are methods with a single ",(0,i.jsx)(n.em,{children:"qualifier"})," that is one of ",":around",", ",":before",", or ",":after",". ",(0,i.jsx)(n.em,{children:"Methods"})," with these ",(0,i.jsx)(n.em,{children:"qualifiers"})," are called ",(0,i.jsx)(n.em,{children:"around methods"}),", ",(0,i.jsx)(n.em,{children:"before methods"}),", and ",(0,i.jsx)(n.em,{children:"after methods"}),", respectively. When a method combination type is defined using the short form of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),", ",(0,i.jsx)(n.em,{children:"primary methods"})," are methods qualified with the name of the type of method combination, and auxiliary methods have the ",(0,i.jsx)(n.em,{children:"qualifier"})," ",":around",". Thus the terms \u201c",(0,i.jsx)(n.em,{children:"primary method"}),"\u201d and \u201c",(0,i.jsx)(n.em,{children:"auxiliary method"}),"\u201d have only a relative definition within a given method combination type."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function a(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.3 Agreement on Parameter Specializers and Qualifiers"})}),"\n",(0,i.jsxs)(n.p,{children:["Two ",(0,i.jsx)(n.em,{children:"methods"})," are said to agree with each other on ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and ",(0,i.jsx)(n.em,{children:"qualifiers"})," if the following conditions hold:"]}),"\n",(0,i.jsx)(n.p,{children:"1. Both methods have the same number of required parameters. Suppose the <i>parameter specializers</i> of the two methods are <i>P</i><sub>1<i>,</i>1</sub> <i>. . . P</i><sub>1<i>,n</i></sub> and <i>P</i><sub>2<i>,</i>1</sub> <i>. . . P</i><sub>2<i>,n</i></sub>."}),"\n",(0,i.jsx)(n.p,{children:"2. For each 1 <i>\u2264 i \u2264 n</i>, <i>P</i><sub>1<i>,i</i></sub> agrees with <i>P</i><sub>2<i>,i</i></sub>. The <i>parameter specializer P</i><sub>1<i>,i</i></sub> agrees with <i>P</i><sub>2<i>,i</i></sub> if <i>P</i><sub>1<i>,i</i></sub> and <i>P</i><sub>2<i>,i</i></sub> are the same class or if <i>P</i><sub>1<i>,i</i></sub> = (<b>eql</b> <i>object</i><sub>1</sub>), <i>P</i><sub>2<i>,i</i></sub> = (<b>eql</b> <i>object</i><sub>2</sub>), and (<b>eql</b> <i>object</i><sub>1</sub> <i>object</i><sub>2</sub>). Otherwise <i>P</i><sub>1<i>,i</i></sub> and <i>P</i><sub>2<i>,i</i></sub> do not agree."}),"\n",(0,i.jsxs)(n.p,{children:["3. The two ",(0,i.jsx)(n.em,{children:"lists"})," of ",(0,i.jsx)(n.em,{children:"qualifiers"})," are the ",(0,i.jsx)(n.em,{children:"same"})," under ",(0,i.jsx)(n.strong,{children:"equal"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}function x(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.4 Congruent Lambda-lists for all Methods of a Generic Function"})}),"\n",(0,i.jsxs)(n.p,{children:["These rules define the congruence of a set of ",(0,i.jsx)(n.em,{children:"lambda lists"}),", including the ",(0,i.jsx)(n.em,{children:"lambda list"})," of each method for a given generic function and the ",(0,i.jsx)(n.em,{children:"lambda list"})," specified for the generic function itself, if given."]}),"\n",(0,i.jsxs)(n.p,{children:["1. Each ",(0,i.jsx)(n.em,{children:"lambda list"})," must have the same number of required parameters."]}),"\n",(0,i.jsxs)(n.p,{children:["2. Each ",(0,i.jsx)(n.em,{children:"lambda list"})," must have the same number of optional parameters. Each method can supply its own default for an optional parameter."]}),"\n",(0,i.jsxs)(n.p,{children:["3. If any ",(0,i.jsx)(n.em,{children:"lambda list"})," mentions ",(0,i.jsx)(n.strong,{children:"&rest"})," or ",(0,i.jsx)(n.strong,{children:"&key"}),", each ",(0,i.jsx)(n.em,{children:"lambda list"})," must mention one or both of them."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201319"})]}),"\n",(0,i.jsxs)(n.p,{children:["4. If the ",(0,i.jsx)(n.em,{children:"generic function lambda list"})," mentions ",(0,i.jsx)(n.strong,{children:"&key"}),", each method must accept all of the keyword names mentioned after ",(0,i.jsx)(n.strong,{children:"&key"}),", either by accepting them explicitly, by specifying ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"}),", or by specifying ",(0,i.jsx)(n.strong,{children:"&rest"})," but not ",(0,i.jsx)(n.strong,{children:"&key"}),". Each method can accept additional keyword arguments of its own. The checking of the validity of keyword names is done in the generic function, not in each method. A method is invoked as if the keyword argument pair whose name is ",":allow-other-keys"," and whose value is ",(0,i.jsx)(n.em,{children:"true"})," were supplied, though no such argument pair will be passed."]}),"\n",(0,i.jsxs)(n.p,{children:["5. The use of ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"})," need not be consistent across ",(0,i.jsx)(n.em,{children:"lambda lists"}),". If ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"})," is mentioned in the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any applicable ",(0,i.jsx)(n.em,{children:"method"})," or of the ",(0,i.jsx)(n.em,{children:"generic function"}),", any keyword arguments may be mentioned in the call to the ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["6. The use of ",(0,i.jsx)(n.strong,{children:"&aux"})," need not be consistent across methods."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.em,{children:"method-defining operator"})," that cannot specify ",(0,i.jsx)(n.em,{children:"generic function"})," options creates a ",(0,i.jsx)(n.em,{children:"generic function"}),", and if the ",(0,i.jsx)(n.em,{children:"lambda list"})," for the method mentions keyword arguments, the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the generic function will mention ",(0,i.jsx)(n.strong,{children:"&key"})," (but no keyword arguments)."]})]})}function j(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}function p(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.5 Keyword Arguments in Generic Functions and Methods"})}),"\n",(0,i.jsxs)(n.p,{children:["When a generic function or any of its methods mentions ",(0,i.jsx)(n.strong,{children:"&key"})," in a ",(0,i.jsx)(n.em,{children:"lambda list"}),", the specific set of keyword arguments accepted by the generic function varies according to the applicable methods. The set of keyword arguments accepted by the generic function for a particular call is the union of the keyword arguments accepted by all applicable methods and the keyword arguments mentioned after ",(0,i.jsx)(n.strong,{children:"&key"})," in the generic function definition, if any. A method that has ",(0,i.jsx)(n.strong,{children:"&rest"})," but not ",(0,i.jsx)(n.strong,{children:"&key"})," does not affect the set of acceptable keyword arguments. If the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any applicable method or of the generic function definition contains ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"}),", all keyword arguments are accepted by the generic function."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"lambda list"})," congruence rules require that each method accept all of the keyword arguments mentioned after ",(0,i.jsx)(n.strong,{children:"&key"})," in the generic function definition, by accepting them explicitly, by specifying ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"}),", or by specifying ",(0,i.jsx)(n.strong,{children:"&rest"})," but not ",(0,i.jsx)(n.strong,{children:"&key"}),". Each method can accept additional keyword arguments of its own, in addition to the keyword arguments mentioned in the generic function definition."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.em,{children:"generic function"})," is passed a keyword argument that no applicable method accepts, an error should be signaled; see Section 3.5 (Error Checking in Function Calls)."]})]})}function f(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}function u(e){const n={p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods"})," For example, suppose there are two methods defined for width as follows:"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod width ((c character-class) &key font) ...)"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod width ((p picture-class) &key pixel-size) ...)"}),"\n",(0,i.jsxs)(n.p,{children:["Assume that there are no other methods and no generic function definition for width. The evaluation of the following form should signal an error because the keyword argument ",":pixel-size"," is not accepted by the applicable method."]}),"\n",(0,i.jsxs)(n.p,{children:["(width (make-instance \u2018character-class ",":char"," #\\Q)"]}),"\n",(0,i.jsxs)(n.p,{children:[":font"," \u2019baskerville ",":pixel-size"," 10)"]}),"\n",(0,i.jsx)(n.p,{children:"The evaluation of the following form should signal an error."}),"\n",(0,i.jsxs)(n.p,{children:["(width (make-instance \u2018picture-class ",":glyph"," (glyph #\\Q))"]}),"\n",(0,i.jsxs)(n.p,{children:[":font"," \u2019baskerville ",":pixel-size"," 10)"]}),"\n",(0,i.jsx)(n.p,{children:"The evaluation of the following form will not signal an error if the class named character-picture class is a subclass of both picture-class and character-class."}),"\n",(0,i.jsxs)(n.p,{children:["(width (make-instance \u2018character-picture-class ",":char"," #\\Q)"]}),"\n",(0,i.jsxs)(n.p,{children:[":font"," \u2019baskerville ",":pixel-size"," 10)"]})]})}function g(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}function b(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6 Method Selection and Combination"})}),"\n",(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.em,{children:"generic function"})," is called with particular arguments, it must determine the code to execute. This code is called the ",(0,i.jsx)(n.em,{children:"effective method"})," for those ",(0,i.jsx)(n.em,{children:"arguments"}),". The ",(0,i.jsx)(n.em,{children:"effective method"})," is a combination of the ",(0,i.jsx)(n.em,{children:"applicable methods"})," in the ",(0,i.jsx)(n.em,{children:"generic function"})," that ",(0,i.jsx)(n.em,{children:"calls"})," some or all of the ",(0,i.jsx)(n.em,{children:"methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.em,{children:"generic function"})," is called and no ",(0,i.jsx)(n.em,{children:"methods"})," are ",(0,i.jsx)(n.em,{children:"applicable"}),", the ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"no-applicable-method"})," is invoked, with the ",(0,i.jsx)(n.em,{children:"results"})," from that call being used as the ",(0,i.jsx)(n.em,{children:"results"})," of the call to the original ",(0,i.jsx)(n.em,{children:"generic function"}),". Calling ",(0,i.jsx)(n.strong,{children:"no-applicable-method"})," takes precedence over checking for acceptable keyword arguments; see Section 7.6.5 (Keyword Arguments in Generic Functions and Methods)."]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.em,{children:"effective method"})," has been determined, it is invoked with the same ",(0,i.jsx)(n.em,{children:"arguments"})," as were passed to the ",(0,i.jsx)(n.em,{children:"generic function"}),". Whatever ",(0,i.jsx)(n.em,{children:"values"})," it returns are returned as the ",(0,i.jsx)(n.em,{children:"values"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),"."]})]})}function y(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}function v(e){const n={p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.1 Determining the Effective Method"})}),"\n",(0,i.jsx)(n.p,{children:"The effective method is determined by the following three-step procedure:"}),"\n",(0,i.jsx)(n.p,{children:"1. Select the applicable methods."}),"\n",(0,i.jsx)(n.p,{children:"2. Sort the applicable methods by precedence order, putting the most specific method first."}),"\n",(0,i.jsx)(n.p,{children:"3. Apply method combination to the sorted list of applicable methods, producing the effective method."}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201321"})]})]})}function w(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}function T(e){const n={p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.1.1 Selecting the Applicable Methods"})}),"\n",(0,i.jsx)(n.p,{children:"This step is described in Section 7.6.2 (Introduction to Methods)."})]})}function k(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(T,{...e})}):T(e)}function z(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.1.2 Sorting the Applicable Methods by Precedence Order"})}),"\n",(0,i.jsxs)(n.p,{children:["To compare the precedence of two methods, their ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are examined in order. The default examination order is from left to right, but an alternative order may be specified by the ",":argument-precedence-order"," option to ",(0,i.jsx)(n.strong,{children:"defgeneric"})," or to any of the other operators that specify generic function options."]}),"\n",(0,i.jsxs)(n.p,{children:["The corresponding ",(0,i.jsx)(n.em,{children:"parameter specializers"})," from each method are compared. When a pair of ",(0,i.jsx)(n.em,{children:"parameter specializers"})," agree, the next pair are compared for agreement. If all corresponding parameter specializers agree, the two methods must have different ",(0,i.jsx)(n.em,{children:"qualifiers"}),"; in this case, either method can be selected to precede the other. For information about agreement, see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,i.jsxs)(n.p,{children:["If some corresponding ",(0,i.jsx)(n.em,{children:"parameter specializers"})," do not agree, the first pair of ",(0,i.jsx)(n.em,{children:"parameter specializers"})," that do not agree determines the precedence. If both ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are classes, the more specific of the two methods is the method whose ",(0,i.jsx)(n.em,{children:"parameter specializer"})," appears earlier in the ",(0,i.jsx)(n.em,{children:"class precedence list"})," of the corresponding argument. Because of the way in which the set of applicable methods is chosen, the ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are guaranteed to be present in the class precedence list of the class of the argument."]}),"\n",(0,i.jsxs)(n.p,{children:["If just one of a pair of corresponding ",(0,i.jsx)(n.em,{children:"parameter specializers"})," is (eql ",(0,i.jsx)(n.em,{children:"object"}),"), the ",(0,i.jsx)(n.em,{children:"method"})," with that ",(0,i.jsx)(n.em,{children:"parameter specializer"})," precedes the other ",(0,i.jsx)(n.em,{children:"method"}),". If both ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are ",(0,i.jsx)(n.strong,{children:"eql"})," ",(0,i.jsx)(n.em,{children:"expressions"}),", the specializers must agree (otherwise the two ",(0,i.jsx)(n.em,{children:"methods"})," would not both have been applicable to this argument)."]}),"\n",(0,i.jsxs)(n.p,{children:["The resulting list of ",(0,i.jsx)(n.em,{children:"applicable methods"})," has the most specific ",(0,i.jsx)(n.em,{children:"method"})," first and the least specific ",(0,i.jsx)(n.em,{children:"method"})," last."]})]})}function S(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(z,{...e})}):z(e)}function I(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.1.3 Applying method combination to the sorted list of applicable methods"})}),"\n",(0,i.jsxs)(n.p,{children:["In the simple case\u2014if standard method combination is used and all applicable methods are primary methods\u2014the effective method is the most specific method. That method can call the next most specific method by using the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"call-next-method"}),". The method that ",(0,i.jsx)(n.strong,{children:"call-next-method"})," will call is referred to as the ",(0,i.jsx)(n.em,{children:"next method"}),". The predicate ",(0,i.jsx)(n.strong,{children:"next-method-p"})," tests whether a next method exists. If ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called and there is no next most specific method, the generic function ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is invoked."]}),"\n",(0,i.jsxs)(n.p,{children:["In general, the effective method is some combination of the applicable methods. It is described by a ",(0,i.jsx)(n.em,{children:"form"})," that contains calls to some or all of the applicable methods, returns the value or values that will be returned as the value or values of the generic function, and optionally makes some of the methods accessible by means of ",(0,i.jsx)(n.strong,{children:"call-next-method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The role of each method in the effective method is determined by its ",(0,i.jsx)(n.em,{children:"qualifiers"})," and the specificity of the method. A ",(0,i.jsx)(n.em,{children:"qualifier"})," serves to mark a method, and the meaning of a ",(0,i.jsx)(n.em,{children:"qualifier"})," is determined"]}),"\n",(0,i.jsxs)(n.p,{children:["by the way that these marks are used by this step of the procedure. If an applicable method has an unrecognized ",(0,i.jsx)(n.em,{children:"qualifier"})," , this step signals an error and does not include that method in the effective method."]}),"\n",(0,i.jsx)(n.p,{children:"When standard method combination is used together with qualified methods, the effective method is produced as described in Section 7.6.6.2 (Standard Method Combination)."}),"\n",(0,i.jsxs)(n.p,{children:["Another type of method combination can be specified by using the ",":method-combination"," option of ",(0,i.jsx)(n.strong,{children:"defgeneric"})," or of any of the other operators that specify generic function options. In this way this step of the procedure can be customized."]}),"\n",(0,i.jsxs)(n.p,{children:["New types of method combination can be defined by using the ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," ",(0,i.jsx)(n.em,{children:"macro"}),"."]})]})}function A(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(I,{...e})}):I(e)}function q(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.2 Standard Method Combination"})}),"\n",(0,i.jsxs)(n.p,{children:["Standard method combination is supported by the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),". It is used if no other type of method combination is specified or if the built-in method combination type ",(0,i.jsx)(n.strong,{children:"standard"})," is specified."]}),"\n",(0,i.jsxs)(n.p,{children:["Primary methods define the main action of the effective method, while auxiliary methods modify that action in one of three ways. A primary method has no method ",(0,i.jsx)(n.em,{children:"qualifiers"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An auxiliary method is a method whose ",(0,i.jsx)(n.em,{children:"qualifier"})," is ",":before",", ",":after",", or ",":around",". Standard method combination allows no more than one ",(0,i.jsx)(n.em,{children:"qualifier"})," per method; if a method definition specifies more than one ",(0,i.jsx)(n.em,{children:"qualifier"})," per method, an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," A ",(0,i.jsx)(n.em,{children:"before method"})," has the keyword ",":before"," as its only ",(0,i.jsx)(n.em,{children:"qualifier"})," . A ",(0,i.jsx)(n.em,{children:"before method"})," specifies ",(0,i.jsx)(n.em,{children:"code"})," that is to be run before any ",(0,i.jsx)(n.em,{children:"primary methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," An ",(0,i.jsx)(n.em,{children:"after method"})," has the keyword ",":after"," as its only ",(0,i.jsx)(n.em,{children:"qualifier"})," . An ",(0,i.jsx)(n.em,{children:"after method"})," specifies ",(0,i.jsx)(n.em,{children:"code"})," that is to be run after ",(0,i.jsx)(n.em,{children:"primary methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," An ",(0,i.jsx)(n.em,{children:"around method"})," has the keyword ",":around"," as its only ",(0,i.jsx)(n.em,{children:"qualifier"})," . An ",(0,i.jsx)(n.em,{children:"around method"})," specifies ",(0,i.jsx)(n.em,{children:"code"})," that is to be run instead of other ",(0,i.jsx)(n.em,{children:"applicable methods"}),", but which might contain explicit ",(0,i.jsx)(n.em,{children:"code"})," which calls some of those ",(0,i.jsx)(n.em,{children:"shadowed methods"})," (via ",(0,i.jsx)(n.strong,{children:"call-next-method"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"The semantics of standard method combination is as follows:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If there are any ",(0,i.jsx)(n.em,{children:"around methods"}),", the most specific ",(0,i.jsx)(n.em,{children:"around method"})," is called. It supplies the value or values of the generic function."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," Inside the body of an ",(0,i.jsx)(n.em,{children:"around method"}),", ",(0,i.jsx)(n.strong,{children:"call-next-method"})," can be used to call the ",(0,i.jsx)(n.em,{children:"next method"}),". When the next method returns, the ",(0,i.jsx)(n.em,{children:"around method"})," can execute more code, perhaps based on the returned value or values. The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is invoked if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is used and there is no ",(0,i.jsx)(n.em,{children:"applicable method"})," to call. The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"next-method-p"})," may be used to determine whether a ",(0,i.jsx)(n.em,{children:"next method"})," exists."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201323"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If an ",(0,i.jsx)(n.em,{children:"around method"})," invokes ",(0,i.jsx)(n.strong,{children:"call-next-method"}),", the next most specific ",(0,i.jsx)(n.em,{children:"around method"})," is called, if one is applicable. If there are no ",(0,i.jsx)(n.em,{children:"around methods"})," or if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called by the least specific ",(0,i.jsx)(n.em,{children:"around method"}),", the other methods are called as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 All the ",(0,i.jsx)(n.em,{children:"before methods"})," are called, in most-specific-first order. Their values are ignored. An error is signaled if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is used in a ",(0,i.jsx)(n.em,{children:"before method"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"\u2013 The most specific primary method is called. Inside the body of a primary"}),"\n",(0,i.jsxs)(n.p,{children:["method, ",(0,i.jsx)(n.strong,{children:"call-next-method"})," may be used to call the next most specific primary"]}),"\n",(0,i.jsx)(n.p,{children:"method. When that method returns, the previous primary method can execute"}),"\n",(0,i.jsx)(n.p,{children:"more code, perhaps based on the returned value or values. The generic function"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-next-method"})," is invoked if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is used and there are no more"]}),"\n",(0,i.jsxs)(n.p,{children:["applicable primary methods. The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"next-method-p"})," may be used to"]}),"\n",(0,i.jsxs)(n.p,{children:["determine whether a ",(0,i.jsx)(n.em,{children:"next method"})," exists. If ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is not used, only"]}),"\n",(0,i.jsxs)(n.p,{children:["the most specific ",(0,i.jsx)(n.em,{children:"primary method"})," is called."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 All the ",(0,i.jsx)(n.em,{children:"after methods"})," are called in most-specific-last order. Their values are"]}),"\n",(0,i.jsxs)(n.p,{children:["ignored. An error is signaled if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is used in an ",(0,i.jsx)(n.em,{children:"after method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If no ",(0,i.jsx)(n.em,{children:"around methods"})," were invoked, the most specific primary method supplies the value or values returned by the generic function. The value or values returned by the invocation of ",(0,i.jsx)(n.strong,{children:"call-next-method"})," in the least specific ",(0,i.jsx)(n.em,{children:"around method"})," are those returned by the most specific primary method."]}),"\n",(0,i.jsx)(n.p,{children:"In standard method combination, if there is an applicable method but no applicable primary method, an error is signaled."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"before methods"})," are run in most-specific-first order while the ",(0,i.jsx)(n.em,{children:"after methods"})," are run in least-specific-first order. The design rationale for this difference can be illustrated with an example. Suppose class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub> modifies the behavior of its superclass, ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub>, by adding ",(0,i.jsx)(n.em,{children:"before methods"})," and ",(0,i.jsx)(n.em,{children:"after methods"}),". Whether the behavior of the class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> is defined directly by methods on ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> or is inherited from its superclasses does not affect the relative order of invocation of methods on instances of the class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub>. Class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub>\u2019s ",(0,i.jsx)(n.em,{children:"before method"})," runs before all of class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub>\u2019s methods. Class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub>\u2019s ",(0,i.jsx)(n.em,{children:"after method"})," runs after all of class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub>\u2019s methods."]}),"\n",(0,i.jsxs)(n.p,{children:["By contrast, all ",(0,i.jsx)(n.em,{children:"around methods"})," run before any other methods run. Thus a less specific ",(0,i.jsx)(n.em,{children:"around method"})," runs before a more specific primary method."]}),"\n",(0,i.jsxs)(n.p,{children:["If only primary methods are used and if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is not used, only the most specific method is invoked; that is, more specific methods shadow more general ones."]})]})}function M(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}function F(e){const n={em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.3 Declarative Method Combination"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," defines new forms of method combination. It provides a mechanism for customizing the production of the effective method. The default procedure for producing an effective method is described in Section 7.6.6.1 (Determining the Effective Method)."]}),"\n",(0,i.jsxs)(n.p,{children:["There are two forms of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),". The short form is a simple facility while the long form is more powerful and more verbose. The long form resembles ",(0,i.jsx)(n.strong,{children:"defmacro"})," in that the body is an expression that computes a Lisp form; it provides mechanisms for implementing arbitrary control structures within method combination and for arbitrary processing of method ",(0,i.jsx)(n.em,{children:"qualifiers"}),"."]})]})}function E(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(F,{...e})}):F(e)}function C(e){const n={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.6.4 Built-in Method Combination Types"})}),"\n",(0,i.jsxs)(n.p,{children:["The object system provides a set of built-in method combination types. To specify that a generic function is to use one of these method combination types, the name of the method combination type is given as the argument to the ",":method-combination"," option to ",(0,i.jsx)(n.strong,{children:"defgeneric"})," or to the ",":method-combination"," option to any of the other operators that specify generic function options."]}),"\n",(0,i.jsx)(n.p,{children:"The names of the built-in method combination types are listed in Figure 7\u20132."}),"\n",(0,i.jsx)(n.table,{children:(0,i.jsx)(n.thead,{children:(0,i.jsx)(n.tr,{children:(0,i.jsx)(n.th,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"+ append max nconc progn and list min or standard"})})})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 7\u20132. Built-in Method Combination Types"})}),"\n",(0,i.jsxs)(n.p,{children:["The semantics of the ",(0,i.jsx)(n.strong,{children:"standard"})," built-in method combination type is described in Section 7.6.6.2 (Standard Method Combination). The other built-in method combination types are called simple built-in method combination types."]}),"\n",(0,i.jsxs)(n.p,{children:["The simple built-in method combination types act as though they were defined by the short form of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),". They recognize two roles for ",(0,i.jsx)(n.em,{children:"methods"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," An ",(0,i.jsx)(n.em,{children:"around method"})," has the keyword symbol ",":around"," as its sole ",(0,i.jsx)(n.em,{children:"qualifier"})," . The meaning of ",":around"," ",(0,i.jsx)(n.em,{children:"methods"})," is the same as in standard method combination. Use of the functions ",(0,i.jsx)(n.strong,{children:"call-next-method"})," and ",(0,i.jsx)(n.strong,{children:"next-method-p"})," is supported in ",(0,i.jsx)(n.em,{children:"around methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," A primary method has the name of the method combination type as its sole ",(0,i.jsx)(n.em,{children:"qualifier"})," . For example, the built-in method combination type and recognizes methods whose sole ",(0,i.jsx)(n.em,{children:"qualifier"})," is and; these are primary methods. Use of the functions ",(0,i.jsx)(n.strong,{children:"call-next-method"})," and ",(0,i.jsx)(n.strong,{children:"next-method-p"})," is not supported in ",(0,i.jsx)(n.em,{children:"primary methods"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The semantics of the simple built-in method combination types is as follows:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If there are any ",(0,i.jsx)(n.em,{children:"around methods"}),", the most specific ",(0,i.jsx)(n.em,{children:"around method"})," is called. It supplies the value or values of the ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," Inside the body of an ",(0,i.jsx)(n.em,{children:"around method"}),", the function ",(0,i.jsx)(n.strong,{children:"call-next-method"})," can be used to call the ",(0,i.jsx)(n.em,{children:"next method"}),". The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is invoked if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is used and there is no applicable method to call. The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"next-method-p"})," may be used to determine whether a ",(0,i.jsx)(n.em,{children:"next method"})," exists. When the ",(0,i.jsx)(n.em,{children:"next method"})," returns, the ",(0,i.jsx)(n.em,{children:"around method"})," can execute more code, perhaps based on the returned value or values."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201325"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If an ",(0,i.jsx)(n.em,{children:"around method"})," invokes ",(0,i.jsx)(n.strong,{children:"call-next-method"}),", the next most specific ",(0,i.jsx)(n.em,{children:"around method"})," is called, if one is applicable. If there are no ",(0,i.jsx)(n.em,{children:"around methods"})," or if ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called by the least specific ",(0,i.jsx)(n.em,{children:"around method"}),", a Lisp form derived from the name of the built-in method combination type and from the list of applicable primary methods is evaluated to produce the value of the generic function. Suppose the name of the method combination type is ",(0,i.jsx)(n.em,{children:"operator"})," and the call to the generic function is of the form"]}),"\n",(0,i.jsx)(n.p,{children:"(<i>generic-function a</i><sub>1</sub> <i>. . . a<sub>n</sub></i>)"}),"\n",(0,i.jsx)(n.p,{children:"Let <i>M</i><sub>1</sub><i>, . . . , M<sub>k</sub></i> be the applicable primary methods in order; then the derived Lisp form is (<i>operator hM</i><sub>1</sub> <i>a</i><sub>1</sub> <i>. . . a<sub>n</sub>i. . .hM<sub>k</sub> a</i><sub>1</sub> <i>. . . a<sub>n</sub>i</i>)"}),"\n",(0,i.jsx)(n.p,{children:"If the expression <i>hM<sub>i</sub> a</i><sub>1</sub> <i>. . . a<sub>n</sub>i</i> is evaluated, the method <i>M<sub>i</sub></i> will be applied to the arguments <i>a</i><sub>1</sub> <i>. . . a<sub>n</sub></i>. For example, if <i>operator</i> is or, the expression <i>hM<sub>i</sub> a</i><sub>1</sub> <i>. . . a<sub>n</sub>i</i> is evaluated only if <i>hM<sub>j</sub> a</i><sub>1</sub> <i>. . . a<sub>n</sub>i</i>, 1 <i>\u2264 j</i> < <i>i</i>, returned nil."}),"\n",(0,i.jsxs)(n.p,{children:["The default order for the primary methods is ",":most-specific-first",". However, the order can be reversed by supplying ",":most-specific-last"," as the second argument to the ",":method-combination"," option."]}),"\n",(0,i.jsxs)(n.p,{children:["The simple built-in method combination types require exactly one ",(0,i.jsx)(n.em,{children:"qualifier"})," per method. An error is signaled if there are applicable methods with no ",(0,i.jsx)(n.em,{children:"qualifiers"})," or with ",(0,i.jsx)(n.em,{children:"qualifiers"})," that are not supported by the method combination type. An error is signaled if there are applicable ",(0,i.jsx)(n.em,{children:"around methods"})," and no applicable primary methods."]})]})}function O(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(C,{...e})}):C(e)}function D(e){const n={del:"del",em:"em",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7.6.7 Inheritance of Methods"})}),"\n",(0,i.jsx)(n.p,{children:"A subclass inherits methods in the sense that any method applicable to all instances of a class is also applicable to all instances of any subclass of that class."}),"\n",(0,i.jsxs)(n.p,{children:["The inheritance of methods acts the same way regardless of which of the ",(0,i.jsx)(n.em,{children:"method-defining operators"})," created the methods."]}),"\n",(0,i.jsx)(n.p,{children:"The inheritance of methods is described in detail in Section 7.6.6 (Method Selection and Combination)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"function-keywords"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"function-keywords"})," ",(0,i.jsx)(n.em,{children:"method \u2192 keys, allow-other-keys-p"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"function-keywords"})," (",(0,i.jsx)(n.em,{children:"method"})," ",(0,i.jsx)(n.strong,{children:"standard-method"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method"}),"\u2014a ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"keys"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"allow-other-keys-p"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns the keyword parameter specifiers for a ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Two values are returned: a ",(0,i.jsx)(n.em,{children:"list"})," of the explicitly named keywords and a ",(0,i.jsx)(n.em,{children:"generalized boolean"})," that states whether ",(0,i.jsx)(n.strong,{children:"&allow-other-keys"})," had been specified in the ",(0,i.jsx)(n.em,{children:"method"})," definition."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defmethod gf1 ((a integer) &optional (b 2)"}),"\n",(0,i.jsxs)(n.p,{children:["&key (c 3) ((",":dee"," d) 4) e ((eff f)))"]}),"\n",(0,i.jsx)(n.p,{children:"(list a b c d e f))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD GF1 (INTEGER) 36324653>"]}),"\n",(0,i.jsx)(n.p,{children:"(find-method #\u2019gf1 \u2019() (list (find-class \u2019integer)))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD GF1 (INTEGER) 36324653>"]}),"\n",(0,i.jsx)(n.p,{children:"(function-keywords *)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," (",":C"," ",":DEE"," ",":E"," EFF), ",(0,i.jsx)(n.em,{children:"false"})]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod gf2 ((a integer))"}),"\n",(0,i.jsx)(n.p,{children:"(list a b c d e f))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD GF2 (INTEGER) 42701775>"]}),"\n",(0,i.jsx)(n.p,{children:"(function-keywords (find-method #\u2019gf1 \u2019() (list (find-class \u2019integer))))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," (), ",(0,i.jsx)(n.em,{children:"false"})]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod gf3 ((a integer) &key b c d &allow-other-keys)"}),"\n",(0,i.jsx)(n.p,{children:"(list a b c d e f))"}),"\n",(0,i.jsx)(n.p,{children:"(function-keywords *)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," (",":B"," ",":C"," ",":D","), ",(0,i.jsx)(n.em,{children:"true"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201327"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ensure-generic-function"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ensure-generic-function"})," ",(0,i.jsx)(n.em,{children:"function-name"})," &key ",(0,i.jsx)(n.em,{children:"argument-precedence-order declare"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"documentation environment"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"generic-function-class lambda-list"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"method-class method-combination"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 generic-function"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"function name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The keyword arguments correspond to the ",(0,i.jsx)(n.em,{children:"option"})," arguments of ",(0,i.jsx)(n.strong,{children:"defgeneric"}),", except that the ",":method-class"," and ",":generic-function-class"," arguments can be ",(0,i.jsx)(n.em,{children:"class object"}),"s as well as names."]}),"\n",(0,i.jsx)(n.p,{children:"Method-combination \u2013 method combination object."}),"\n",(0,i.jsxs)(n.p,{children:["Environment \u2013 the same as the ",(0,i.jsx)(n.strong,{children:"&environment"})," argument to macro expansion functions and is used to distinguish between compile-time and run-time environments."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"})," is used to define a globally named ",(0,i.jsx)(n.em,{children:"generic function"})," with no ",(0,i.jsx)(n.em,{children:"methods"})," or to specify or modify options and declarations that pertain to a globally named ",(0,i.jsx)(n.em,{children:"generic function"})," as a whole."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," is not ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"}),", a new ",(0,i.jsx)(n.em,{children:"generic function"})," is created. If (fdefinition ",(0,i.jsx)(n.em,{children:"function-name"}),") is an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"list"}),", it must be of the form (setf ",(0,i.jsx)(n.em,{children:"symbol"}),"). If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for any of the following arguments, the ",(0,i.jsx)(n.em,{children:"generic function"})," is modified to have the new value: ",":argument-precedence-order",", ",":declare",", ",":documentation",", ",":method-combination","."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":lambda-list"," argument, and the new value is congruent with the ",(0,i.jsx)(n.em,{children:"lambda lists"})," of all existing ",(0,i.jsx)(n.em,{children:"methods"})," or there are no ",(0,i.jsx)(n.em,{children:"methods"}),", the value is changed; otherwise an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":generic-function-class"," argument and if the new generic function class is compatible with the old, ",(0,i.jsx)(n.strong,{children:"change-class"})," is called to change the ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),"; otherwise an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":method-class"," argument, the value is changed, but any existing ",(0,i.jsx)(n.em,{children:"methods"})," are not changed."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:["Existing function binding of ",(0,i.jsx)(n.em,{children:"function-name"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If (fdefinition ",(0,i.jsx)(n.em,{children:"function-name"}),") is an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":lambda-list"," argument, and the new value is not congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any existing ",(0,i.jsx)(n.em,{children:"method"}),", an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies a ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":generic-function-class"," argument and if the new generic function class not is compatible with the old, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defgeneric"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"allocate-instance"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"allocate-instance"})," ",(0,i.jsx)(n.em,{children:"class"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 new-instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"allocate-instance"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"allocate-instance"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"structure-class"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of ",(0,i.jsx)(n.em,{children:"keyword/value pairs"})," (initialization argument ",(0,i.jsx)(n.em,{children:"names"})," and ",(0,i.jsx)(n.em,{children:"values"}),"). ",(0,i.jsx)(n.em,{children:"new-instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"})," whose ",(0,i.jsx)(n.em,{children:"class"})," is ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201329"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," creates and returns a new instance of the ",(0,i.jsx)(n.em,{children:"class"}),", without initializing it. When the ",(0,i.jsx)(n.em,{children:"class"})," is a ",(0,i.jsx)(n.em,{children:"standard class"}),", this means that the ",(0,i.jsx)(n.em,{children:"slots"})," are ",(0,i.jsx)(n.em,{children:"unbound"}),"; when the ",(0,i.jsx)(n.em,{children:"class"})," is a ",(0,i.jsx)(n.em,{children:"structure class"}),", this means the ",(0,i.jsx)(n.em,{children:"slots"}),"\u2019 ",(0,i.jsx)(n.em,{children:"values"})," are unspecified."]}),"\n",(0,i.jsxs)(n.p,{children:["The caller of ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," is expected to have already checked the initialization arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," is called by ",(0,i.jsx)(n.strong,{children:"make-instance"}),", as described in Section 7.1 (Object Creation and Initialization)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"make-instance"}),", ",(0,i.jsx)(n.strong,{children:"class-of"}),", Section 7.1 (Object Creation and Initialization)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The consequences of adding ",(0,i.jsx)(n.em,{children:"methods"})," to ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," is unspecified. This capability might be added by the ",(0,i.jsx)(n.em,{children:"Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," ",(0,i.jsx)(n.em,{children:"instance"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," (",(0,i.jsx)(n.em,{children:"instance"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," can be used to change the values of ",(0,i.jsx)(n.em,{children:"local slots"})," of an ",(0,i.jsx)(n.em,{children:"instance"})," according to ",(0,i.jsx)(n.em,{children:"initargs"}),". This ",(0,i.jsx)(n.em,{children:"generic function"})," can be called by users."]}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," for ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," checks the validity of ",(0,i.jsx)(n.em,{children:"initargs"})," and signals an error if an ",(0,i.jsx)(n.em,{children:"initarg"})," is supplied that is not declared as valid. The ",(0,i.jsx)(n.em,{children:"method"})," then calls the generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," with the following arguments: the ",(0,i.jsx)(n.em,{children:"instance"}),", ",(0,i.jsx)(n.strong,{children:"nil"})," (which means no ",(0,i.jsx)(n.em,{children:"slots"})," should be initialized according to their initforms), and the ",(0,i.jsx)(n.em,{children:"initargs"})," it received."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," changes the values of ",(0,i.jsx)(n.em,{children:"local slots"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," for ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," signals an error if an ",(0,i.jsx)(n.em,{children:"initarg"})," is supplied that is not declared as valid."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"initialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),", ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"}),","]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),", ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", Section 7.3 (Reinitial izing an Instance), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization Arguments)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initargs"})," are declared as valid by using the ",":initarg"," option to ",(0,i.jsx)(n.strong,{children:"defclass"}),", or by defining ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),". The keyword name of each keyword parameter specifier in the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any ",(0,i.jsx)(n.em,{children:"method"})," defined on ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is declared as a valid initialization argument name for all ",(0,i.jsx)(n.em,{children:"classes"})," for which that ",(0,i.jsx)(n.em,{children:"method"})," is applicable."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"shared-initialize"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"shared-initialize"})," ",(0,i.jsx)(n.em,{children:"instance slot-names"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"shared-initialize"})," (",(0,i.jsx)(n.em,{children:"instance"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),") ",(0,i.jsx)(n.em,{children:"slot-names"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-names"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," or ",(0,i.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of ",(0,i.jsx)(n.em,{children:"keyword/value pairs"})," (of initialization argument ",(0,i.jsx)(n.em,{children:"names"})," and ",(0,i.jsx)(n.em,{children:"values"}),")."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is used to fill the ",(0,i.jsx)(n.em,{children:"slots"})," of an ",(0,i.jsx)(n.em,{children:"instance"})," using ",(0,i.jsx)(n.em,{children:"initargs"})," and ",":initform"," forms. It is called when an instance is created, when an instance is re-initialized, when an instance is updated to conform to a redefined ",(0,i.jsx)(n.em,{children:"class"}),", and when an instance is updated to conform to a different ",(0,i.jsx)(n.em,{children:"class"}),". The generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is called by the system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," for ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"}),", and ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," takes the following arguments: the ",(0,i.jsx)(n.em,{children:"instance"})," to be initialized, a specification of a set of ",(0,i.jsx)(n.em,{children:"slot-names accessible"})," in that ",(0,i.jsx)(n.em,{children:"instance"}),", and any number of ",(0,i.jsx)(n.em,{children:"initargs"}),". The arguments after the first two must form an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),". The system-supplied"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201331"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"shared-initialize"})}),"\n",(0,i.jsxs)(n.p,{children:["primary ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," initializes the ",(0,i.jsx)(n.em,{children:"slots"})," with values according to the ",(0,i.jsx)(n.em,{children:"initargs"})," and supplied ",":initform"," forms. ",(0,i.jsx)(n.em,{children:"Slot-names"})," indicates which ",(0,i.jsx)(n.em,{children:"slots"})," should be initialized according to their ",":initform"," forms if no ",(0,i.jsx)(n.em,{children:"initargs"})," are provided for those ",(0,i.jsx)(n.em,{children:"slots"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," behaves as follows, regardless of whether the ",(0,i.jsx)(n.em,{children:"slots"})," are local or shared:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If an ",(0,i.jsx)(n.em,{children:"initarg"})," in the ",(0,i.jsx)(n.em,{children:"initialization argument list"})," specifies a value for that ",(0,i.jsx)(n.em,{children:"slot"}),", that value is stored into the ",(0,i.jsx)(n.em,{children:"slot"}),", even if a value has already been stored in the ",(0,i.jsx)(n.em,{children:"slot"})," before the ",(0,i.jsx)(n.em,{children:"method"})," is run."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," Any ",(0,i.jsx)(n.em,{children:"slots"})," indicated by ",(0,i.jsx)(n.em,{children:"slot-names"})," that are still unbound at this point are initialized according to their ",":initform"," forms. For any such ",(0,i.jsx)(n.em,{children:"slot"})," that has an ",":initform"," form, that ",(0,i.jsx)(n.em,{children:"form"})," is evaluated in the lexical environment of its defining ",(0,i.jsx)(n.strong,{children:"defclass"})," ",(0,i.jsx)(n.em,{children:"form"})," and the result is stored into the ",(0,i.jsx)(n.em,{children:"slot"}),". For example, if a ",(0,i.jsx)(n.em,{children:"before method"})," stores a value in the ",(0,i.jsx)(n.em,{children:"slot"}),", the ",":initform"," form will not be used to supply a value for the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The rules mentioned in Section 7.1.4 (Rules for Initialization Arguments) are obeyed."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"slots-names"})," argument specifies the ",(0,i.jsx)(n.em,{children:"slots"})," that are to be initialized according to their ",":initform"," forms if no initialization arguments apply. It can be a ",(0,i.jsx)(n.em,{children:"list"})," of slot ",(0,i.jsx)(n.em,{children:"names"}),", which specifies the set of those slot ",(0,i.jsx)(n.em,{children:"names"}),"; or it can be the ",(0,i.jsx)(n.em,{children:"symbol"})," ",(0,i.jsx)(n.strong,{children:"t"}),", which specifies the set of all of the ",(0,i.jsx)(n.em,{children:"slots"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"initialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"reinitialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"}),","]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),", ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", Section 7.1 (Object Creation and Initialization), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization Arguments)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initargs"})," are declared as valid by using the ",":initarg"," option to ",(0,i.jsx)(n.strong,{children:"defclass"}),", or by defining ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),". The keyword name of each keyword parameter specifier in the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any ",(0,i.jsx)(n.em,{children:"method"})," defined on ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is declared as a valid ",(0,i.jsx)(n.em,{children:"initarg"})," name for all ",(0,i.jsx)(n.em,{children:"classes"})," for which that ",(0,i.jsx)(n.em,{children:"method"})," is applicable."]}),"\n",(0,i.jsxs)(n.p,{children:["Implementations are permitted to optimize ",":initform"," forms that neither produce nor depend on side effects, by evaluating these ",(0,i.jsx)(n.em,{children:"forms"})," and storing them into slots before running any ",(0,i.jsx)(n.strong,{children:"initialize-instance"})," methods, rather than by handling them in the primary ",(0,i.jsx)(n.strong,{children:"initialize-instance"})," method. (This optimization might be implemented by having the ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," method copy a prototype instance.)"]}),"\n",(0,i.jsxs)(n.p,{children:["Implementations are permitted to optimize default initial value forms for ",(0,i.jsx)(n.em,{children:"initargs"})," associated with slots by not actually creating the complete initialization argument ",(0,i.jsx)(n.em,{children:"list"})," when the only ",(0,i.jsx)(n.em,{children:"method"})," that would receive the complete ",(0,i.jsx)(n.em,{children:"list"})," is the ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"standard-object"}),". In this case default initial value"]}),"\n",(0,i.jsxs)(n.p,{children:["forms can be treated like ",":initform"," forms. This optimization has no visible effects other than a performance improvement."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," ",(0,i.jsx)(n.em,{children:"previous current"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 implementation-dependent"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," (",(0,i.jsx)(n.em,{children:"previous"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["(",(0,i.jsx)(n.em,{children:"current"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["&rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"previous"}),"\u2014a copy of the original ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"current"}),"\u2014the original ",(0,i.jsx)(n.em,{children:"instance"})," (altered)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," is not intended to be called by program mers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it. The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," is called only by the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"change-class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," checks the validity of ",(0,i.jsx)(n.em,{children:"initargs"})," and signals an error if an ",(0,i.jsx)(n.em,{children:"initarg"})," is supplied that is not declared as valid. This ",(0,i.jsx)(n.em,{children:"method"})," then initializes ",(0,i.jsx)(n.em,{children:"slots"})," with values according to the ",(0,i.jsx)(n.em,{children:"initargs"}),", and initializes the newly added ",(0,i.jsx)(n.em,{children:"slots"})," with values according to their ",":initform"," forms. It does this by calling the generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," with the following arguments: the instance (",(0,i.jsx)(n.em,{children:"current"}),"), a list of ",(0,i.jsx)(n.em,{children:"names"})," of the newly added ",(0,i.jsx)(n.em,{children:"slots"}),", and the ",(0,i.jsx)(n.em,{children:"initargs"})," it received. Newly added ",(0,i.jsx)(n.em,{children:"slots"})," are those ",(0,i.jsx)(n.em,{children:"local slots"})," for which no ",(0,i.jsx)(n.em,{children:"slot"})," of the same name exists in the ",(0,i.jsx)(n.em,{children:"previous"})," class."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Methods"})," for ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," can be defined to specify actions to be taken when an ",(0,i.jsx)(n.em,{children:"instance"})," is updated. If only ",(0,i.jsx)(n.em,{children:"after methods"})," for ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," are defined, they will be run after the system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," for initialization and therefore will not interfere with the default behavior of ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Methods"})," on ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," can be defined to initialize ",(0,i.jsx)(n.em,{children:"slots"})," differently from ",(0,i.jsx)(n.strong,{children:"change-class"}),". The default behavior of ",(0,i.jsx)(n.strong,{children:"change-class"})," is described in Section 7.2 (Changing the Class of an Instance)."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201333"})]}),"\n",(0,i.jsxs)(n.p,{children:["The arguments to ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," are computed by ",(0,i.jsx)(n.strong,{children:"change-class"}),". When ",(0,i.jsx)(n.strong,{children:"change-class"})," is invoked on an ",(0,i.jsx)(n.em,{children:"instance"}),", a copy of that ",(0,i.jsx)(n.em,{children:"instance"})," is made; ",(0,i.jsx)(n.strong,{children:"change-class"})," then de structively alters the original ",(0,i.jsx)(n.em,{children:"instance"}),". The first argument to ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),", ",(0,i.jsx)(n.em,{children:"previous"}),", is that copy; it holds the old ",(0,i.jsx)(n.em,{children:"slot"})," values temporarily. This argument has dynamic extent within ",(0,i.jsx)(n.strong,{children:"change-class"}),"; if it is referenced in any way once ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," returns, the results are undefined. The second argument to ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),", ",(0,i.jsx)(n.em,{children:"current"}),", is the altered original ",(0,i.jsx)(n.em,{children:"instance"}),". The intended use of ",(0,i.jsx)(n.em,{children:"previous"})," is to extract old ",(0,i.jsx)(n.em,{children:"slot"})," values by using ",(0,i.jsx)(n.strong,{children:"slot-value"})," or ",(0,i.jsx)(n.strong,{children:"with-slots"})," or by invoking a reader generic function, or to run other ",(0,i.jsx)(n.em,{children:"methods"})," that were applicable to ",(0,i.jsx)(n.em,{children:"instances"})," of the original ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(n.p,{children:["See the example for the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"change-class"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," signals an error if an initialization argument is supplied that is not declared as valid."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"change-class"}),", ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),", Section 7.2 (Changing the Class of an Instance), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization Arguments)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initargs"})," are declared as valid by using the ",":initarg"," option to ",(0,i.jsx)(n.strong,{children:"defclass"}),", or by defining ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),". The keyword name of each keyword parameter specifier in the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any ",(0,i.jsx)(n.em,{children:"method"})," defined on ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is declared as a valid ",(0,i.jsx)(n.em,{children:"initarg"})," name for all ",(0,i.jsx)(n.em,{children:"classes"})," for which that ",(0,i.jsx)(n.em,{children:"method"})," is applicable."]}),"\n",(0,i.jsxs)(n.p,{children:["The value returned by ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," is ignored by ",(0,i.jsx)(n.strong,{children:"change-class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," ",(0,i.jsx)(n.em,{children:"instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"added-slots discarded-slots"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"property-list"})}),"\n",(0,i.jsxs)(n.p,{children:["&rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," (",(0,i.jsx)(n.em,{children:"instance"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"added-slots discarded-slots"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"property-list"})}),"\n",(0,i.jsxs)(n.p,{children:["&rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"added-slots"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"discarded-slots"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"property-list"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"result"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," is not intended to be called by programmers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it. The ",(0,i.jsx)(n.em,{children:"generic func tion"})," ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," is called by the mechanism activated by ",(0,i.jsx)(n.strong,{children:"make-instances-obsolete"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," checks the validity of ",(0,i.jsx)(n.em,{children:"initargs"})," and signals an error if an ",(0,i.jsx)(n.em,{children:"initarg"})," is supplied that is not declared as valid. This ",(0,i.jsx)(n.em,{children:"method"})," then initializes ",(0,i.jsx)(n.em,{children:"slots"})," with values according to the ",(0,i.jsx)(n.em,{children:"initargs"}),", and initializes the newly ",(0,i.jsx)(n.em,{children:"added-slots"})," with values according to their ",":initform"," forms. It does this by calling the generic function ",(0,i.jsx)(n.strong,{children:"shared-initialize"})]}),"\n",(0,i.jsxs)(n.p,{children:["with the following arguments: the ",(0,i.jsx)(n.em,{children:"instance"}),", a list of names of the newly ",(0,i.jsx)(n.em,{children:"added-slots"})," to ",(0,i.jsx)(n.em,{children:"instance"}),", and the ",(0,i.jsx)(n.em,{children:"initargs"})," it received. Newly ",(0,i.jsx)(n.em,{children:"added-slots"})," are those ",(0,i.jsx)(n.em,{children:"local slots"})," for which no ",(0,i.jsx)(n.em,{children:"slot"})," of the same name exists in the old version of the ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," is invoked or when a ",(0,i.jsx)(n.em,{children:"class"})," has been redefined and an ",(0,i.jsx)(n.em,{children:"instance"})," is being updated, a ",(0,i.jsx)(n.em,{children:"property-list"})," is created that captures the slot names and values of all the ",(0,i.jsx)(n.em,{children:"discarded slots"})," with values in the original ",(0,i.jsx)(n.em,{children:"instance"}),". The structure of the ",(0,i.jsx)(n.em,{children:"instance"})," is transformed so that it conforms to the current class definition. The arguments to ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," are this transformed ",(0,i.jsx)(n.em,{children:"instance"}),", a list of ",(0,i.jsx)(n.em,{children:"added-slots"})," to the ",(0,i.jsx)(n.em,{children:"instance"}),", a list ",(0,i.jsx)(n.em,{children:"discarded-slots"})," from the ",(0,i.jsx)(n.em,{children:"instance"}),", and the ",(0,i.jsx)(n.em,{children:"property-list"})," containing the slot names and values for ",(0,i.jsx)(n.em,{children:"slots"})," that were discarded and had values. Included in this list of discarded ",(0,i.jsx)(n.em,{children:"slots"})," are ",(0,i.jsx)(n.em,{children:"slots"})," that were local in the old ",(0,i.jsx)(n.em,{children:"class"})," and are shared in the new ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The value returned by ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," is ignored."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201335"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass position () ())"}),"\n",(0,i.jsx)(n.p,{children:"(defclass x-y-position (position)"}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initform"," 0 ",":accessor"," position-x)"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initform"," 0 ",":accessor"," position-y)))"]}),"\n",(0,i.jsx)(n.p,{children:";;; It turns out polar coordinates are used more than Cartesian ;;; coordinates, so the representation is altered and some new ;;; accessor methods are added."}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod update-instance-for-redefined-class ",":before"]}),"\n",(0,i.jsx)(n.p,{children:"((pos x-y-position) added deleted plist &key)"}),"\n",(0,i.jsx)(n.p,{children:";; Transform the x-y coordinates to polar coordinates"}),"\n",(0,i.jsx)(n.p,{children:";; and store into the new slots."}),"\n",(0,i.jsx)(n.p,{children:"(let ((x (getf plist \u2019x))"}),"\n",(0,i.jsx)(n.p,{children:"(y (getf plist \u2019y)))"}),"\n",(0,i.jsx)(n.p,{children:"(setf (position-rho pos) (sqrt (+ (* x x) (* y y)))"}),"\n",(0,i.jsx)(n.p,{children:"(position-theta pos) (atan y x))))"}),"\n",(0,i.jsx)(n.p,{children:"(defclass x-y-position (position)"}),"\n",(0,i.jsxs)(n.p,{children:["((rho ",":initform"," 0 ",":accessor"," position-rho)"]}),"\n",(0,i.jsxs)(n.p,{children:["(theta ",":initform"," 0 ",":accessor"," position-theta)))"]}),"\n",(0,i.jsx)(n.p,{children:";;; All instances of the old x-y-position class will be updated ;;; automatically."}),"\n",(0,i.jsx)(n.p,{children:";;; The new representation is given the look and feel of the old one."}),"\n",(0,i.jsx)(n.p,{children:"(defmethod position-x ((pos x-y-position))"}),"\n",(0,i.jsx)(n.p,{children:"(with-slots (rho theta) pos (* rho (cos theta))))"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod (setf position-x) (new-x (pos x-y-position))"}),"\n",(0,i.jsx)(n.p,{children:"(with-slots (rho theta) pos"}),"\n",(0,i.jsx)(n.p,{children:"(let ((y (position-y pos)))"}),"\n",(0,i.jsx)(n.p,{children:"(setq rho (sqrt (+ (* new-x new-x) (* y y)))"}),"\n",(0,i.jsx)(n.p,{children:"theta (atan y new-x))"}),"\n",(0,i.jsx)(n.p,{children:"new-x)))"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod position-y ((pos x-y-position))"}),"\n",(0,i.jsx)(n.p,{children:"(with-slots (rho theta) pos (* rho (sin theta))))"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod (setf position-y) (new-y (pos x-y-position))"}),"\n",(0,i.jsx)(n.p,{children:"(with-slots (rho theta) pos"}),"\n",(0,i.jsx)(n.p,{children:"(let ((x (position-x pos)))"}),"\n",(0,i.jsx)(n.p,{children:"(setq rho (sqrt (+ (* x x) (* new-y new-y)))"}),"\n",(0,i.jsx)(n.p,{children:"theta (atan new-y x))"}),"\n",(0,i.jsx)(n.p,{children:"new-y)))"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied primary ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," signals an error if an ",(0,i.jsx)(n.em,{children:"initarg"})," is supplied that is not declared as valid."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instances-obsolete"}),", ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),", Section 4.3.6 (Redefining Classes), Section 7.1.4 (Rules for Initialization Arguments), Section 7.1.2 (Declaring the Validity of Initialization Arguments)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initargs"})," are declared as valid by using the ",":initarg"," option to ",(0,i.jsx)(n.strong,{children:"defclass"}),", or by defining ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"}),". The keyword name of each keyword parameter specifier in the ",(0,i.jsx)(n.em,{children:"lambda list"})," of any ",(0,i.jsx)(n.em,{children:"method"})," defined on ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," or ",(0,i.jsx)(n.strong,{children:"shared-initialize"})," is declared as a valid ",(0,i.jsx)(n.em,{children:"initarg"})," name for all ",(0,i.jsx)(n.em,{children:"classes"})," for which that ",(0,i.jsx)(n.em,{children:"method"})," is applicable."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"change-class"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"change-class"})," ",(0,i.jsx)(n.em,{children:"instance new-class"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"change-class"})," (",(0,i.jsx)(n.em,{children:"instance"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),") (",(0,i.jsx)(n.em,{children:"new-class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"change-class"})," (",(0,i.jsx)(n.em,{children:"instance"})," ",(0,i.jsx)(n.strong,{children:"t"}),") (",(0,i.jsx)(n.em,{children:"new-class"})," ",(0,i.jsx)(n.strong,{children:"symbol"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"new-class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"class designator"})," ."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"change-class"})," changes the ",(0,i.jsx)(n.em,{children:"class"})," of an ",(0,i.jsx)(n.em,{children:"instance"})," to ",(0,i.jsx)(n.em,{children:"new-class"}),". It destructively modifies and returns the ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201337"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"change-class"})}),"\n",(0,i.jsxs)(n.p,{children:["If in the old ",(0,i.jsx)(n.em,{children:"class"})," there is any ",(0,i.jsx)(n.em,{children:"slot"})," of the same name as a local ",(0,i.jsx)(n.em,{children:"slot"})," in the ",(0,i.jsx)(n.em,{children:"new-class"}),", the value of that ",(0,i.jsx)(n.em,{children:"slot"})," is retained. This means that if the ",(0,i.jsx)(n.em,{children:"slot"})," has a value, the value returned by ",(0,i.jsx)(n.strong,{children:"slot-value"})," after ",(0,i.jsx)(n.strong,{children:"change-class"})," is invoked is ",(0,i.jsx)(n.strong,{children:"eql"})," to the value returned by ",(0,i.jsx)(n.strong,{children:"slot-value"})," before ",(0,i.jsx)(n.strong,{children:"change-class"})," is invoked. Similarly, if the ",(0,i.jsx)(n.em,{children:"slot"})," was unbound, it remains unbound. The other ",(0,i.jsx)(n.em,{children:"slots"})," are initialized as described in Section 7.2 (Changing the Class of an Instance)."]}),"\n",(0,i.jsxs)(n.p,{children:["After completing all other actions, ",(0,i.jsx)(n.strong,{children:"change-class"})," invokes ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),". The generic function ",(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"})," can be used to assign values to slots in the transformed instance. See Section 7.2.2 (Initializing Newly Added Local Slots)."]}),"\n",(0,i.jsxs)(n.p,{children:["If the second of the above ",(0,i.jsx)(n.em,{children:"methods"})," is selected, that ",(0,i.jsx)(n.em,{children:"method"})," invokes ",(0,i.jsx)(n.strong,{children:"change-class"})," on ",(0,i.jsx)(n.em,{children:"instance"}),", (find-class ",(0,i.jsx)(n.em,{children:"new-class"}),"), and the ",(0,i.jsx)(n.em,{children:"initargs"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass position () ())"}),"\n",(0,i.jsx)(n.p,{children:"(defclass x-y-position (position)"}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initform"," 0 ",":initarg"," ",":x",")"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initform"," 0 ",":initarg"," ",":y",")))"]}),"\n",(0,i.jsx)(n.p,{children:"(defclass rho-theta-position (position)"}),"\n",(0,i.jsxs)(n.p,{children:["((rho ",":initform"," 0)"]}),"\n",(0,i.jsxs)(n.p,{children:["(theta ",":initform"," 0)))"]}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod update-instance-for-different-class ",":before"," ((old x-y-position)"]}),"\n",(0,i.jsx)(n.p,{children:"(new rho-theta-position)"}),"\n",(0,i.jsx)(n.p,{children:"&key)"}),"\n",(0,i.jsx)(n.p,{children:";; Copy the position information from old to new to make new"}),"\n",(0,i.jsx)(n.p,{children:";; be a rho-theta-position at the same position as old."}),"\n",(0,i.jsx)(n.p,{children:"(let ((x (slot-value old \u2019x))"}),"\n",(0,i.jsx)(n.p,{children:"(y (slot-value old \u2019y)))"}),"\n",(0,i.jsx)(n.p,{children:"(setf (slot-value new \u2019rho) (sqrt (+ (* x x) (* y y)))"}),"\n",(0,i.jsx)(n.p,{children:"(slot-value new \u2019theta) (atan y x))))"}),"\n",(0,i.jsx)(n.p,{children:";;; At this point an instance of the class x-y-position can be"}),"\n",(0,i.jsx)(n.p,{children:";;; changed to be an instance of the class rho-theta-position using"}),"\n",(0,i.jsx)(n.p,{children:";;; change-class:"}),"\n",(0,i.jsxs)(n.p,{children:["(setq p1 (make-instance \u2019x-y-position ",":x"," 2 ",":y"," 0))"]}),"\n",(0,i.jsx)(n.p,{children:"(change-class p1 \u2019rho-theta-position)"}),"\n",(0,i.jsx)(n.p,{children:";;; The result is that the instance bound to p1 is now an instance of"}),"\n",(0,i.jsx)(n.p,{children:";;; the class rho-theta-position. The update-instance-for-different-class"}),"\n",(0,i.jsx)(n.p,{children:";;; method performed the initialization of the rho and theta slots based"}),"\n",(0,i.jsx)(n.p,{children:";;; on the value of the x and y slots, which were maintained by"}),"\n",(0,i.jsx)(n.p,{children:";;; the old instance."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-different-class"}),", Section 7.2 (Changing the Class of an Instance)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"change-class"})," has several semantic difficulties. First, it performs a destructive operation that can be invoked within a ",(0,i.jsx)(n.em,{children:"method"})," on an ",(0,i.jsx)(n.em,{children:"instance"})," that was used to select that ",(0,i.jsx)(n.em,{children:"method"}),". When multiple ",(0,i.jsx)(n.em,{children:"methods"})," are involved because ",(0,i.jsx)(n.em,{children:"methods"})," are being combined, the ",(0,i.jsx)(n.em,{children:"methods"})," currently"]}),"\n",(0,i.jsxs)(n.p,{children:["executing or about to be executed may no longer be applicable. Second, some implementations might use compiler optimizations of slot ",(0,i.jsx)(n.em,{children:"access"}),", and when the ",(0,i.jsx)(n.em,{children:"class"})," of an ",(0,i.jsx)(n.em,{children:"instance"})," is changed the assumptions the compiler made might be violated. This implies that a programmer must not use ",(0,i.jsx)(n.strong,{children:"change-class"})," inside a ",(0,i.jsx)(n.em,{children:"method"})," if any ",(0,i.jsx)(n.em,{children:"methods"})," for that ",(0,i.jsx)(n.em,{children:"generic function access"})," any ",(0,i.jsx)(n.em,{children:"slots"}),", or the results are undefined."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-boundp"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-boundp"})," ",(0,i.jsx)(n.em,{children:"instance slot-name \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"})," naming a ",(0,i.jsx)(n.em,{children:"slot"})," of ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.em,{children:"true"})," if the ",(0,i.jsx)(n.em,{children:"slot"})," named ",(0,i.jsx)(n.em,{children:"slot-name"})," in ",(0,i.jsx)(n.em,{children:"instance"})," is bound; otherwise, returns ",(0,i.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If no ",(0,i.jsx)(n.em,{children:"slot"})," of the ",(0,i.jsx)(n.em,{children:"name slot-name"})," exists in the ",(0,i.jsx)(n.em,{children:"instance"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is called as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-missing (class-of ",(0,i.jsx)(n.em,{children:"instance"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"instance"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"slot-name"})}),"\n",(0,i.jsx)(n.p,{children:"\u2019slot-boundp)"}),"\n",(0,i.jsxs)(n.p,{children:["(If ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is invoked and returns a value, a ",(0,i.jsx)(n.em,{children:"boolean equivalent"})," to its ",(0,i.jsx)(n.em,{children:"primary value"})," is returned by ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),".)"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201339"})]}),"\n",(0,i.jsxs)(n.p,{children:["The specific behavior depends on ",(0,i.jsx)(n.em,{children:"instance"}),"\u2019s ",(0,i.jsx)(n.em,{children:"metaclass"}),". An error is never signaled if ",(0,i.jsx)(n.em,{children:"instance"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),". An error is always signaled if ",(0,i.jsx)(n.em,{children:"instance"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"built-in-class"}),". The consequences are undefined if ",(0,i.jsx)(n.em,{children:"instance"})," has any other ",(0,i.jsx)(n.em,{children:"metaclass"}),"\u2013an error might or might not be signaled in this situation. Note in particular that the behavior for ",(0,i.jsx)(n.em,{children:"conditions"})," and ",(0,i.jsx)(n.em,{children:"structures"})," is not specified."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-boundp"})," allows for writing ",(0,i.jsx)(n.em,{children:"after methods"})," on ",(0,i.jsx)(n.strong,{children:"initialize-instance"})," in order to initialize only those ",(0,i.jsx)(n.em,{children:"slots"})," that have not already been bound."]}),"\n",(0,i.jsxs)(n.p,{children:["Although no ",(0,i.jsx)(n.em,{children:"implementation"})," is required to do so, implementors are strongly encouraged to implement the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-boundp"})," using the ",(0,i.jsx)(n.em,{children:"function"})," slot-boundp-using-class described in the ",(0,i.jsx)(n.em,{children:"Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-exists-p"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-exists-p"})," ",(0,i.jsx)(n.em,{children:"object slot-name \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.em,{children:"true"})," if the ",(0,i.jsx)(n.em,{children:"object"})," has a ",(0,i.jsx)(n.em,{children:"slot"})," named ",(0,i.jsx)(n.em,{children:"slot-name"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"defstruct"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["Although no ",(0,i.jsx)(n.em,{children:"implementation"})," is required to do so, implementors are strongly encouraged to implement the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-exists-p"})," using the ",(0,i.jsx)(n.em,{children:"function"})," slot-exists-p-using-class described in the ",(0,i.jsx)(n.em,{children:"Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-makunbound"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-makunbound"})," ",(0,i.jsx)(n.em,{children:"instance slot-name \u2192 instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"})," \u2013 instance."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Slot-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-makunbound"})," restores a ",(0,i.jsx)(n.em,{children:"slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," in an ",(0,i.jsx)(n.em,{children:"instance"})," to the unbound state."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If no ",(0,i.jsx)(n.em,{children:"slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," exists in the ",(0,i.jsx)(n.em,{children:"instance"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is called as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-missing (class-of ",(0,i.jsx)(n.em,{children:"instance"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"instance"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"slot-name"})}),"\n",(0,i.jsx)(n.p,{children:"\u2019slot-makunbound)"}),"\n",(0,i.jsxs)(n.p,{children:["(Any values returned by ",(0,i.jsx)(n.strong,{children:"slot-missing"})," in this case are ignored by ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),".)"]}),"\n",(0,i.jsxs)(n.p,{children:["The specific behavior depends on ",(0,i.jsx)(n.em,{children:"instance"}),"\u2019s ",(0,i.jsx)(n.em,{children:"metaclass"}),". An error is never signaled if ",(0,i.jsx)(n.em,{children:"instance"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),". An error is always signaled if ",(0,i.jsx)(n.em,{children:"instance"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"built-in-class"}),". The consequences are undefined if ",(0,i.jsx)(n.em,{children:"instance"})," has any other ",(0,i.jsx)(n.em,{children:"metaclass"}),"\u2013an error might or might not be signaled in this situation. Note in particular that the behavior for ",(0,i.jsx)(n.em,{children:"conditions"})," and ",(0,i.jsx)(n.em,{children:"structures"})," is not specified."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-boundp"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["Although no ",(0,i.jsx)(n.em,{children:"implementation"})," is required to do so, implementors are strongly encouraged to implement the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-makunbound"})," using the ",(0,i.jsx)(n.em,{children:"function"})," slot-makunbound-using-class described in the ",(0,i.jsx)(n.em,{children:"Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201341"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"slot-missing"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-missing"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-missing"})," ",(0,i.jsx)(n.em,{children:"class object slot-name operation"})," &optional ",(0,i.jsx)(n.em,{children:"new-value \u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-missing"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"t"}),") ",(0,i.jsx)(n.em,{children:"object slot-name"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"operation"})," &optional ",(0,i.jsx)(n.em,{children:"new-value"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014the ",(0,i.jsx)(n.em,{children:"class"})," of ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"})," (the ",(0,i.jsx)(n.em,{children:"name"})," of a would-be ",(0,i.jsx)(n.em,{children:"slot"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"operation"}),"\u2014one of the ",(0,i.jsx)(n.em,{children:"symbols"})," ",(0,i.jsx)(n.strong,{children:"setf"}),", ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", or ",(0,i.jsx)(n.strong,{children:"slot-value"}),". ",(0,i.jsx)(n.em,{children:"new-value"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"result"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is invoked when an attempt is made to ",(0,i.jsx)(n.em,{children:"access"})," a ",(0,i.jsx)(n.em,{children:"slot"})," in an ",(0,i.jsx)(n.em,{children:"object"})," whose ",(0,i.jsx)(n.em,{children:"metaclass"})," is ",(0,i.jsx)(n.strong,{children:"standard-class"})," and the ",(0,i.jsx)(n.em,{children:"slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," is not a ",(0,i.jsx)(n.em,{children:"name"})," of a ",(0,i.jsx)(n.em,{children:"slot"})," in that ",(0,i.jsx)(n.em,{children:"class"}),". The default ",(0,i.jsx)(n.em,{children:"method"})," signals an error."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is not intended to be called by programmers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"slot-missing"})," may be called during evaluation of ",(0,i.jsx)(n.strong,{children:"slot-value"}),", (setf slot-value), ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", and ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),". For each of these operations the corresponding ",(0,i.jsx)(n.em,{children:"symbol"})," for the ",(0,i.jsx)(n.em,{children:"operation"})," argument is ",(0,i.jsx)(n.strong,{children:"slot-value"}),", ",(0,i.jsx)(n.strong,{children:"setf"}),", ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", and ",(0,i.jsx)(n.strong,{children:"slot-makunbound"})," respectively."]}),"\n",(0,i.jsxs)(n.p,{children:["The optional ",(0,i.jsx)(n.em,{children:"new-value"})," argument to ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is used when the operation is attempting to set the value of the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.strong,{children:"slot-missing"})," returns, its values will be treated as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If the ",(0,i.jsx)(n.em,{children:"operation"})," is ",(0,i.jsx)(n.strong,{children:"setf"})," or ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", any ",(0,i.jsx)(n.em,{children:"values"})," will be ignored by the caller."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If the ",(0,i.jsx)(n.em,{children:"operation"})," is ",(0,i.jsx)(n.strong,{children:"slot-value"}),", only the ",(0,i.jsx)(n.em,{children:"primary value"})," will be used by the caller, and all other values will be ignored."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," If the ",(0,i.jsx)(n.em,{children:"operation"})," is ",(0,i.jsx)(n.strong,{children:"slot-boundp"}),", any ",(0,i.jsx)(n.em,{children:"boolean equivalent"})," of the ",(0,i.jsx)(n.em,{children:"primary value"})," of the ",(0,i.jsx)(n.em,{children:"method"})," might be is used, and all other values will be ignored."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"slot-missing"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"slot-exists-p"}),", ",(0,i.jsx)(n.strong,{children:"slot-value"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The set of arguments (including the ",(0,i.jsx)(n.em,{children:"class"})," of the instance) facilitates defining methods on the metaclass for ",(0,i.jsx)(n.strong,{children:"slot-missing"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-unbound"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-unbound"})," ",(0,i.jsx)(n.em,{children:"class instance slot-name \u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-unbound"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"t"}),") ",(0,i.jsx)(n.em,{children:"instance slot-name"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014the ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014the ",(0,i.jsx)(n.em,{children:"instance"})," in which an attempt was made to ",(0,i.jsx)(n.em,{children:"read"})," the ",(0,i.jsx)(n.em,{children:"unbound slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"\u2014the ",(0,i.jsx)(n.em,{children:"name"})," of the ",(0,i.jsx)(n.em,{children:"unbound slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"result"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," is called when an unbound ",(0,i.jsx)(n.em,{children:"slot"})," is read in an ",(0,i.jsx)(n.em,{children:"instance"})," whose metaclass is ",(0,i.jsx)(n.strong,{children:"standard-class"}),". The default ",(0,i.jsx)(n.em,{children:"method"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"unbound-slot"}),". The name slot of the ",(0,i.jsx)(n.strong,{children:"unbound-slot"})," ",(0,i.jsx)(n.em,{children:"condition"})," is initialized to the name of the offending variable, and the instance slot of the ",(0,i.jsx)(n.strong,{children:"unbound-slot"})," ",(0,i.jsx)(n.em,{children:"condition"})," is initialized to the offending instance."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," is not intended to be called by programmers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it. The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," is called only indirectly by ",(0,i.jsx)(n.strong,{children:"slot-value"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," returns, only the ",(0,i.jsx)(n.em,{children:"primary value"})," will be used by the caller, and all other values will be ignored."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"unbound-slot"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"slot-makunbound"})}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201343"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["An unbound ",(0,i.jsx)(n.em,{children:"slot"})," may occur if no ",":initform"," form was specified for the ",(0,i.jsx)(n.em,{children:"slot"})," and the ",(0,i.jsx)(n.em,{children:"slot"})," value has not been set, or if ",(0,i.jsx)(n.strong,{children:"slot-makunbound"})," has been called on the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-value"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-value"})," ",(0,i.jsx)(n.em,{children:"object slot-name \u2192 value"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"value"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-value"})," returns the ",(0,i.jsx)(n.em,{children:"value"})," of the ",(0,i.jsx)(n.em,{children:"slot"})," named ",(0,i.jsx)(n.em,{children:"slot-name"})," in the ",(0,i.jsx)(n.em,{children:"object"}),". If there is no ",(0,i.jsx)(n.em,{children:"slot"})," named ",(0,i.jsx)(n.em,{children:"slot-name"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is called. If the ",(0,i.jsx)(n.em,{children:"slot"})," is unbound, ",(0,i.jsx)(n.strong,{children:"slot-unbound"})," is called."]}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"setf"})," can be used with ",(0,i.jsx)(n.strong,{children:"slot-value"})," to change the value of a ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass foo ()"}),"\n",(0,i.jsxs)(n.p,{children:["((a ",":accessor"," foo-a ",":initarg"," ",":a"," ",":initform"," 1)"]}),"\n",(0,i.jsxs)(n.p,{children:["(b ",":accessor"," foo-b ",":initarg"," ",":b",")"]}),"\n",(0,i.jsxs)(n.p,{children:["(c ",":accessor"," foo-c ",":initform"," 3)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-CLASS FOO 244020371>"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq foo1 (make-instance \u2019foo ",":a"," \u2019one ",":b"," \u2019two))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<FOO 36325624>"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-value foo1 \u2019a) ",(0,i.jsx)(n.em,{children:"\u2192"})," ONE"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-value foo1 \u2019b) ",(0,i.jsx)(n.em,{children:"\u2192"})," TWO"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-value foo1 \u2019c) ",(0,i.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,i.jsxs)(n.p,{children:["(setf (slot-value foo1 \u2019a) \u2019uno) ",(0,i.jsx)(n.em,{children:"\u2192"})," UNO"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-value foo1 \u2019a) ",(0,i.jsx)(n.em,{children:"\u2192"})," UNO"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod foo-method ((x foo))"}),"\n",(0,i.jsx)(n.p,{children:"(slot-value x \u2019a))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>"]}),"\n",(0,i.jsxs)(n.p,{children:["(foo-method foo1) ",(0,i.jsx)(n.em,{children:"\u2192"})," UNO"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If an attempt is made to read a ",(0,i.jsx)(n.em,{children:"slot"})," and no ",(0,i.jsx)(n.em,{children:"slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," exists in the ",(0,i.jsx)(n.em,{children:"object"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is called as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-missing (class-of ",(0,i.jsx)(n.em,{children:"instance"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"instance"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"slot-name"})}),"\n",(0,i.jsx)(n.p,{children:"\u2019slot-value)"}),"\n",(0,i.jsxs)(n.p,{children:["(If ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is invoked, its ",(0,i.jsx)(n.em,{children:"primary value"})," is returned by ",(0,i.jsx)(n.strong,{children:"slot-value"}),".)"]}),"\n",(0,i.jsxs)(n.p,{children:["If an attempt is made to write a ",(0,i.jsx)(n.em,{children:"slot"})," and no ",(0,i.jsx)(n.em,{children:"slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," exists in the ",(0,i.jsx)(n.em,{children:"object"}),", ",(0,i.jsx)(n.strong,{children:"slot-missing"})," is called as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:["(slot-missing (class-of ",(0,i.jsx)(n.em,{children:"instance"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"instance"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"slot-name"})}),"\n",(0,i.jsx)(n.p,{children:"\u2019setf"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"new-value"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["(If ",(0,i.jsx)(n.strong,{children:"slot-missing"})," returns in this case, any ",(0,i.jsx)(n.em,{children:"values"})," are ignored.)"]}),"\n",(0,i.jsxs)(n.p,{children:["The specific behavior depends on ",(0,i.jsx)(n.em,{children:"object"}),"\u2019s ",(0,i.jsx)(n.em,{children:"metaclass"}),". An error is never signaled if ",(0,i.jsx)(n.em,{children:"object"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),". An error is always signaled if ",(0,i.jsx)(n.em,{children:"object"})," has ",(0,i.jsx)(n.em,{children:"metaclass"})," ",(0,i.jsx)(n.strong,{children:"built-in-class"}),". The consequences are unspecified if ",(0,i.jsx)(n.em,{children:"object"})," has any other ",(0,i.jsx)(n.em,{children:"metaclass"}),"\u2013an error might or might not be signaled in this situation. Note in particular that the behavior for ",(0,i.jsx)(n.em,{children:"conditions"})," and ",(0,i.jsx)(n.em,{children:"structures"})," is not specified."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"slot-missing"}),", ",(0,i.jsx)(n.strong,{children:"slot-unbound"}),", ",(0,i.jsx)(n.strong,{children:"with-slots"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["Although no ",(0,i.jsx)(n.em,{children:"implementation"})," is required to do so, implementors are strongly encouraged to implement the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-value"})," using the ",(0,i.jsx)(n.em,{children:"function"})," slot-value-using-class described in the ",(0,i.jsx)(n.em,{children:"Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Implementations may optimize ",(0,i.jsx)(n.strong,{children:"slot-value"})," by compiling it inline."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"method-qualifiers"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"method-qualifiers"})," ",(0,i.jsx)(n.em,{children:"method \u2192 qualifiers"})]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201345"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"method-qualifiers"})," (",(0,i.jsx)(n.em,{children:"method"})," ",(0,i.jsx)(n.strong,{children:"standard-method"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method"}),"\u2014a ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"qualifiers"}),"\u2014a ",(0,i.jsx)(n.em,{children:"proper list"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns a ",(0,i.jsx)(n.em,{children:"list"})," of the ",(0,i.jsx)(n.em,{children:"qualifiers"})," of the ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod some-gf ",":before"," ((a integer)) a)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD SOME-GF (",":BEFORE",") (INTEGER) 42736540>"]}),"\n",(0,i.jsxs)(n.p,{children:["(method-qualifiers *) ",(0,i.jsx)(n.em,{children:"\u2192"})," (",":BEFORE",")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"define-method-combination"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-applicable-method"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-applicable-method"})," ",(0,i.jsx)(n.em,{children:"generic-function"})," &rest ",(0,i.jsx)(n.em,{children:"function-arguments \u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-applicable-method"})," (",(0,i.jsx)(n.em,{children:"generic-function"})," ",(0,i.jsx)(n.strong,{children:"t"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["&rest ",(0,i.jsx)(n.em,{children:"function-arguments"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function"})," on which no ",(0,i.jsx)(n.em,{children:"applicable method"})," was found."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-arguments"}),"\u2014",(0,i.jsx)(n.em,{children:"arguments"})," to the ",(0,i.jsx)(n.em,{children:"generic-function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"result"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"no-applicable-method"})," is called when a ",(0,i.jsx)(n.em,{children:"generic function"})," is invoked and no ",(0,i.jsx)(n.em,{children:"method"})," on that ",(0,i.jsx)(n.em,{children:"generic function"})," is applicable. The ",(0,i.jsx)(n.em,{children:"default method"})," signals an error."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"no-applicable-method"})," is not intended to be called by programmers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.em,{children:"method"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-next-method"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-next-method"})," ",(0,i.jsx)(n.em,{children:"generic-function method"})," &rest ",(0,i.jsx)(n.em,{children:"args \u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"no-next-method"})," (",(0,i.jsx)(n.em,{children:"generic-function"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["(",(0,i.jsx)(n.em,{children:"method"})," ",(0,i.jsx)(n.strong,{children:"standard-method"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["&rest ",(0,i.jsx)(n.em,{children:"args"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function"})," \u2013 ",(0,i.jsx)(n.em,{children:"generic function"})," to which ",(0,i.jsx)(n.em,{children:"method"})," belongs."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method"})," \u2013 ",(0,i.jsx)(n.em,{children:"method"})," that contained the call to ",(0,i.jsx)(n.strong,{children:"call-next-method"})," for which there is no next ",(0,i.jsx)(n.em,{children:"method"}),". ",(0,i.jsx)(n.em,{children:"args"})," \u2013 arguments to ",(0,i.jsx)(n.strong,{children:"call-next-method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"result"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is called by ",(0,i.jsx)(n.strong,{children:"call-next-method"})," when there is no ",(0,i.jsx)(n.em,{children:"next method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is not intended to be called by programmers. Programmers may write ",(0,i.jsx)(n.em,{children:"methods"})," for it."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The system-supplied ",(0,i.jsx)(n.em,{children:"method"})," on ",(0,i.jsx)(n.strong,{children:"no-next-method"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"call-next-method"})}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201347"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"remove-method"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"remove-method"})," ",(0,i.jsx)(n.em,{children:"generic-function method \u2192 generic-function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"remove-method"})," (",(0,i.jsx)(n.em,{children:"generic-function"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"method"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method"}),"\u2014a ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"remove-method"})," removes a ",(0,i.jsx)(n.em,{children:"method"})," from ",(0,i.jsx)(n.em,{children:"generic-function"})," by modifying the ",(0,i.jsx)(n.em,{children:"generic-function"})," (if necessary)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"remove-method"})," must not signal an error if the ",(0,i.jsx)(n.em,{children:"method"})," is not one of the ",(0,i.jsx)(n.em,{children:"methods"})," on the ",(0,i.jsx)(n.em,{children:"generic-function"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"find-method"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instance"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instance"})," ",(0,i.jsx)(n.em,{children:"class"})," &rest ",(0,i.jsx)(n.em,{children:"initargs"})," &key &allow-other-keys ",(0,i.jsx)(n.em,{children:"\u2192 instance"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instance"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instance"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"symbol"}),") &rest ",(0,i.jsx)(n.em,{children:"initargs"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"class"}),", or a ",(0,i.jsx)(n.em,{children:"symbol"})," that names a ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initargs"}),"\u2014an ",(0,i.jsx)(n.em,{children:"initialization argument list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014a ",(0,i.jsx)(n.em,{children:"fresh instance"})," of ",(0,i.jsx)(n.em,{children:"class class"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"make-instance"})," creates and returns a new ",(0,i.jsx)(n.em,{children:"instance"})," of the given ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If the second of the above ",(0,i.jsx)(n.em,{children:"methods"})," is selected, that ",(0,i.jsx)(n.em,{children:"method"})," invokes ",(0,i.jsx)(n.strong,{children:"make-instance"})," on the arguments (find-class ",(0,i.jsx)(n.em,{children:"class"}),") and ",(0,i.jsx)(n.em,{children:"initargs"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The initialization arguments are checked within ",(0,i.jsx)(n.strong,{children:"make-instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"make-instance"})," may be used as described in Section 7.1 (Object Creation and Initialization)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If any of the initialization arguments has not been declared as valid, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"}),", ",(0,i.jsx)(n.strong,{children:"class-of"}),", ",(0,i.jsx)(n.strong,{children:"allocate-instance"}),", ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),", Section 7.1 (Object Creation and Initialization)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," ",(0,i.jsx)(n.em,{children:"class \u2192 class"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," (",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"symbol"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"class designator"})," ."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," has the effect of initiating the process of updating the instances of the ",(0,i.jsx)(n.em,{children:"class"}),". During updating, the generic function ",(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"})," will be invoked."]}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," is invoked automatically by the system when ",(0,i.jsx)(n.strong,{children:"defclass"})," has been used to redefine an existing standard class and the set of local ",(0,i.jsx)(n.em,{children:"slots accessible"})," in an instance is changed or the order of ",(0,i.jsx)(n.em,{children:"slots"})," in storage is changed. It can also be explicitly invoked by the user."]}),"\n",(0,i.jsxs)(n.p,{children:["If the second of the above ",(0,i.jsx)(n.em,{children:"methods"})," is selected, that ",(0,i.jsx)(n.em,{children:"method"})," invokes ",(0,i.jsx)(n.strong,{children:"make-instances-obsolete"})," on (find-class ",(0,i.jsx)(n.em,{children:"class"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201349"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"update-instance-for-redefined-class"}),", Section 4.3.6 (Redefining Classes)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"object"})," &optional ",(0,i.jsx)(n.em,{children:"environment \u2192 creation-form"}),"[",(0,i.jsx)(n.em,{children:", initialization-form"}),"]"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"standard-object"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"structure-object"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"condition"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"})," (",(0,i.jsx)(n.em,{children:"object"})," ",(0,i.jsx)(n.strong,{children:"class"}),") &optional ",(0,i.jsx)(n.em,{children:"environment"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"environment"}),"\u2014an ",(0,i.jsx)(n.em,{children:"environment object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"creation-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initialization-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"})," creates and returns one or two ",(0,i.jsx)(n.em,{children:"forms"}),", a ",(0,i.jsx)(n.em,{children:"creation-form"})," and an ",(0,i.jsx)(n.em,{children:"initialization-form"}),", that enable ",(0,i.jsx)(n.strong,{children:"load"})," to construct an ",(0,i.jsx)(n.em,{children:"object"})," equivalent to ",(0,i.jsx)(n.em,{children:"object"}),". ",(0,i.jsx)(n.em,{children:"Environment"})," is an ",(0,i.jsx)(n.em,{children:"environment object"})," corresponding to the ",(0,i.jsx)(n.em,{children:"lexical environment"})," in which the ",(0,i.jsx)(n.em,{children:"forms"})," will be processed."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"file compiler"})," calls ",(0,i.jsx)(n.strong,{children:"make-load-form"})," to process certain ",(0,i.jsx)(n.em,{children:"classes"})," of ",(0,i.jsx)(n.em,{children:"literal objects"}),"; see Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Conforming programs"})," may call ",(0,i.jsx)(n.strong,{children:"make-load-form"})," directly, providing ",(0,i.jsx)(n.em,{children:"object"})," is a ",(0,i.jsx)(n.em,{children:"generalized instance"})," of ",(0,i.jsx)(n.strong,{children:"standard-object"}),", ",(0,i.jsx)(n.strong,{children:"structure-object"}),", or ",(0,i.jsx)(n.strong,{children:"condition"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The creation form is a ",(0,i.jsx)(n.em,{children:"form"})," that, when evaluated at ",(0,i.jsx)(n.strong,{children:"load"})," time, should return an ",(0,i.jsx)(n.em,{children:"object"})," that is equivalent to ",(0,i.jsx)(n.em,{children:"object"}),". The exact meaning of equivalent depends on the ",(0,i.jsx)(n.em,{children:"type"})," of ",(0,i.jsx)(n.em,{children:"object"})," and is up to the programmer who defines a ",(0,i.jsx)(n.em,{children:"method"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"; see Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsxs)(n.p,{children:["The initialization form is a ",(0,i.jsx)(n.em,{children:"form"})," that, when evaluated at ",(0,i.jsx)(n.strong,{children:"load"})," time, should perform further initialization of the ",(0,i.jsx)(n.em,{children:"object"}),". The value returned by the initialization form is ignored. If ",(0,i.jsx)(n.strong,{children:"make-load-form"})," returns only one value, the initialization form is ",(0,i.jsx)(n.strong,{children:"nil"}),", which has no effect. If ",(0,i.jsx)(n.em,{children:"object"})," appears as a constant in the initialization form, at ",(0,i.jsx)(n.strong,{children:"load"})," time it will be replaced by the equivalent ",(0,i.jsx)(n.em,{children:"object"})," constructed by the creation form; this is how the further initialization gains access to the ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Both the ",(0,i.jsx)(n.em,{children:"creation-form"})," and the ",(0,i.jsx)(n.em,{children:"initialization-form"})," may contain references to any ",(0,i.jsx)(n.em,{children:"externalizable object"}),". However, there must not be any circular dependencies in creation forms. An example of a circular dependency is when the creation form for the object X contains a reference to the object Y, and the creation form for the object Y contains a reference to the object X. Initialization forms are not subject to any restriction against circular dependencies, which is the reason that initialization forms exist; see the example of circular data structures below."]}),"\n",(0,i.jsxs)(n.p,{children:["The creation form for an ",(0,i.jsx)(n.em,{children:"object"})," is always ",(0,i.jsx)(n.em,{children:"evaluated"})," before the initialization form for that ",(0,i.jsx)(n.em,{children:"object"}),". When either the creation form or the initialization form references other ",(0,i.jsx)(n.em,{children:"objects"})," that have not been referenced earlier in the ",(0,i.jsx)(n.em,{children:"file"})," being ",(0,i.jsx)(n.em,{children:"compiled"}),", the ",(0,i.jsx)(n.em,{children:"compiler"})," ensures that all of the referenced ",(0,i.jsx)(n.em,{children:"objects"})," have been created before ",(0,i.jsx)(n.em,{children:"evaluating"})," the referencing ",(0,i.jsx)(n.em,{children:"form"}),". When the referenced ",(0,i.jsx)(n.em,{children:"object"})," is of a ",(0,i.jsx)(n.em,{children:"type"})," which the ",(0,i.jsx)(n.em,{children:"file compiler"})," processes using ",(0,i.jsx)(n.strong,{children:"make-load-form"}),", this involves ",(0,i.jsx)(n.em,{children:"evaluating"})," the creation form returned for it. (This is the reason for the prohibition against circular references among creation forms)."]}),"\n",(0,i.jsxs)(n.p,{children:["Each initialization form is ",(0,i.jsx)(n.em,{children:"evaluated"})," as soon as possible after its associated creation form, as determined by data flow. If the initialization form for an ",(0,i.jsx)(n.em,{children:"object"})," does not reference any other ",(0,i.jsx)(n.em,{children:"objects"})," not referenced earlier in the ",(0,i.jsx)(n.em,{children:"file"})," and processed by the ",(0,i.jsx)(n.em,{children:"file compiler"})," using ",(0,i.jsx)(n.strong,{children:"make-load-form"}),", the initialization form is evaluated immediately after the creation form. If a creation or initialization form ",(0,i.jsx)(n.em,{children:"F"})," does contain references to such ",(0,i.jsx)(n.em,{children:"objects"}),", the creation forms for those other objects are evaluated before ",(0,i.jsx)(n.em,{children:"F"}),", and the initialization forms for those other ",(0,i.jsx)(n.em,{children:"objects"})," are also evaluated before ",(0,i.jsx)(n.em,{children:"F"})," whenever they do not depend on the ",(0,i.jsx)(n.em,{children:"object"})," created or initialized by ",(0,i.jsx)(n.em,{children:"F"}),". Where these rules do not uniquely determine an order of ",(0,i.jsx)(n.em,{children:"evaluation"})," between two creation/initialization forms, the order of ",(0,i.jsx)(n.em,{children:"evaluation"})," is unspecified."]}),"\n",(0,i.jsxs)(n.p,{children:["While these creation and initialization forms are being evaluated, the ",(0,i.jsx)(n.em,{children:"objects"})," are possibly in an uninitialized state, analogous to the state of an ",(0,i.jsx)(n.em,{children:"object"})," between the time it has been created by ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," and it has been processed fully by ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),". Programmers writing"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"})," must take care in manipulating ",(0,i.jsx)(n.em,{children:"objects"})," not to depend on ",(0,i.jsx)(n.em,{children:"slots"})," that have not yet been initialized."]}),"\n",(0,i.jsxs)(n.p,{children:["It is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(n.strong,{children:"load"})," calls ",(0,i.jsx)(n.strong,{children:"eval"})," on the ",(0,i.jsx)(n.em,{children:"forms"})," or does some other operation that has an equivalent effect. For example, the ",(0,i.jsx)(n.em,{children:"forms"})," might be translated into different but equivalent ",(0,i.jsx)(n.em,{children:"forms"})," and then evaluated, they might be compiled and the resulting functions called by ",(0,i.jsx)(n.strong,{children:"load"}),", or they might be interpreted by a special-purpose function different from ",(0,i.jsx)(n.strong,{children:"eval"}),". All that is required is that the effect be equivalent to evaluating the ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"method specialized"})," on ",(0,i.jsx)(n.strong,{children:"class"})," returns a creation ",(0,i.jsx)(n.em,{children:"form"})," using the ",(0,i.jsx)(n.em,{children:"name"})," of the ",(0,i.jsx)(n.em,{children:"class"})," if the ",(0,i.jsx)(n.em,{children:"class"})," has a ",(0,i.jsx)(n.em,{children:"proper name"})," in ",(0,i.jsx)(n.em,{children:"environment"}),", signaling an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," if it does not have a ",(0,i.jsx)(n.em,{children:"proper name"}),". ",(0,i.jsx)(n.em,{children:"Evaluation"})," of the creation ",(0,i.jsx)(n.em,{children:"form"})," uses the ",(0,i.jsx)(n.em,{children:"name"})," to find the ",(0,i.jsx)(n.em,{children:"class"})," with that ",(0,i.jsx)(n.em,{children:"name"}),", as if by"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201351"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"calling"})," ",(0,i.jsx)(n.strong,{children:"find-class"}),". If a ",(0,i.jsx)(n.em,{children:"class"})," with that ",(0,i.jsx)(n.em,{children:"name"})," has not been defined, then a ",(0,i.jsx)(n.em,{children:"class"})," may be computed in an ",(0,i.jsx)(n.em,{children:"implementation-defined"})," manner. If a ",(0,i.jsx)(n.em,{children:"class"})," cannot be returned as the result of ",(0,i.jsx)(n.em,{children:"evaluating"})," the creation ",(0,i.jsx)(n.em,{children:"form"}),", then an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.em,{children:"conforming implementations"})," and ",(0,i.jsx)(n.em,{children:"conforming programs"})," may further ",(0,i.jsx)(n.em,{children:"specialize"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass obj ()"}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initarg"," ",":x"," ",":reader"," obj-x)"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initarg"," ",":y"," ",":reader"," obj-y)"]}),"\n",(0,i.jsxs)(n.p,{children:["(dist ",":accessor"," obj-dist)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-CLASS OBJ 250020030>"]}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod shared-initialize ",":after"," ((self obj) slot-names &rest keys)"]}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore slot-names keys))"}),"\n",(0,i.jsx)(n.p,{children:"(unless (slot-boundp self \u2019dist)"}),"\n",(0,i.jsx)(n.p,{children:"(setf (obj-dist self)"}),"\n",(0,i.jsx)(n.p,{children:"(sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD SHARED-INITIALIZE (",":AFTER",") (OBJ T) 26266714>"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self obj) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsx)(n.p,{children:";; Note that this definition only works because X and Y do not"}),"\n",(0,i.jsx)(n.p,{children:";; contain information which refers back to the object itself."}),"\n",(0,i.jsx)(n.p,{children:";; For a more general solution to this problem, see revised example below."}),"\n",(0,i.jsx)(n.p,{children:"\u2018(make-instance \u2019,(class-of self)"}),"\n",(0,i.jsxs)(n.p,{children:[":x"," \u2019,(obj-x self) ",":y"," \u2019,(obj-y self)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq obj1 (make-instance \u2019obj ",":x"," 3.0 ",":y"," 4.0)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<OBJ 26274136>"]}),"\n",(0,i.jsxs)(n.p,{children:["(obj-dist obj1) ",(0,i.jsx)(n.em,{children:"\u2192"})," 5.0"]}),"\n",(0,i.jsxs)(n.p,{children:["(make-load-form obj1) ",(0,i.jsx)(n.em,{children:"\u2192"})," (MAKE-INSTANCE \u2019OBJ ",":X"," \u20193.0 ",":Y"," \u20194.0)"]}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, an equivalent ",(0,i.jsx)(n.em,{children:"instance"})," of obj is reconstructed by using the values of two of its ",(0,i.jsx)(n.em,{children:"slots"}),". The value of the third ",(0,i.jsx)(n.em,{children:"slot"})," is derived from those two values."]}),"\n",(0,i.jsxs)(n.p,{children:["Another way to write the ",(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"method"})," in that example is to use ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"}),". The code it generates might yield a slightly different result from the ",(0,i.jsx)(n.strong,{children:"make-load-form"})," ",(0,i.jsx)(n.em,{children:"method"})," shown above, but the operational effect will be the same. For example:"]}),"\n",(0,i.jsx)(n.p,{children:";; Redefine method defined above."}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self obj) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(make-load-form-saving-slots self"}),"\n",(0,i.jsxs)(n.p,{children:[":slot-names"," \u2019(x y)"]}),"\n",(0,i.jsxs)(n.p,{children:[":environment"," environment))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"make-load-form"})}),"\n",(0,i.jsx)(n.p,{children:";; Try MAKE-LOAD-FORM on object created above."}),"\n",(0,i.jsx)(n.p,{children:"(make-load-form obj1)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," (ALLOCATE-INSTANCE \u2019#<STANDARD-CLASS OBJ 250020030>),"]}),"\n",(0,i.jsx)(n.p,{children:"(PROGN"}),"\n",(0,i.jsx)(n.p,{children:"(SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019X) \u20193.0)"}),"\n",(0,i.jsx)(n.p,{children:"(SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019Y) \u20194.0)"}),"\n",(0,i.jsx)(n.p,{children:"(INITIALIZE-INSTANCE \u2019#<OBJ 26274136>))"}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, ",(0,i.jsx)(n.em,{children:"instances"})," of my-frob are \u201cinterned\u201d in some way. An equivalent ",(0,i.jsx)(n.em,{children:"instance"})," is reconstructed by using the value of the name slot as a key for searching existing ",(0,i.jsx)(n.em,{children:"objects"}),". In this case the programmer has chosen to create a new ",(0,i.jsx)(n.em,{children:"object"})," if no existing ",(0,i.jsx)(n.em,{children:"object"})," is found; alternatively an error could have been signaled in that case."]}),"\n",(0,i.jsx)(n.p,{children:"(defclass my-frob ()"}),"\n",(0,i.jsxs)(n.p,{children:["((name ",":initarg"," ",":name"," ",":reader"," my-name)))"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((self my-frob) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsxs)(n.p,{children:["\u2018(find-my-frob \u2019,(my-name self) ",":if-does-not-exist"," ",":create","))"]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, the data structure to be dumped is circular, because each parent has a list of its children and each child has a reference back to its parent. If ",(0,i.jsx)(n.strong,{children:"make-load-form"})," is called on one ",(0,i.jsx)(n.em,{children:"object"})," in such a structure, the creation form creates an equivalent ",(0,i.jsx)(n.em,{children:"object"})," and fills in the children slot, which forces creation of equivalent ",(0,i.jsx)(n.em,{children:"objects"})," for all of its children, grandchildren, etc."]}),"\n",(0,i.jsxs)(n.p,{children:["At this point none of the parent ",(0,i.jsx)(n.em,{children:"slots"})," have been filled in. The initialization form fills in the parent ",(0,i.jsx)(n.em,{children:"slot"}),", which forces creation of an equivalent ",(0,i.jsx)(n.em,{children:"object"})," for the parent if it was not already created. Thus the entire tree is recreated at ",(0,i.jsx)(n.strong,{children:"load"})," time. At compile time, ",(0,i.jsx)(n.strong,{children:"make-load-form"})," is called once for each ",(0,i.jsx)(n.em,{children:"object"})," in the tree. All of the creation forms are evaluated, in ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," order, and then all of the initialization forms are evaluated, also in ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," order."]}),"\n",(0,i.jsxs)(n.p,{children:["(defclass tree-with-parent () ((parent ",":accessor"," tree-parent)"]}),"\n",(0,i.jsxs)(n.p,{children:["(children ",":initarg"," ",":children",")))"]}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((x tree-with-parent) &optional environment)"}),"\n",(0,i.jsx)(n.p,{children:"(declare (ignore environment))"}),"\n",(0,i.jsx)(n.p,{children:"(values"}),"\n",(0,i.jsx)(n.p,{children:";; creation form"}),"\n",(0,i.jsxs)(n.p,{children:["\u2018(make-instance \u2019,(class-of x) ",":children"," \u2019,(slot-value x \u2019children))"]}),"\n",(0,i.jsx)(n.p,{children:";; initialization form"}),"\n",(0,i.jsx)(n.p,{children:"\u2018(setf (tree-parent \u2019,x) \u2019,(slot-value x \u2019parent))))"}),"\n",(0,i.jsxs)(n.p,{children:["In the following example, the data structure to be dumped has no special properties and an equivalent structure can be reconstructed simply by reconstructing the ",(0,i.jsx)(n.em,{children:"slots"}),"\u2019 contents."]}),"\n",(0,i.jsx)(n.p,{children:"(defstruct my-struct a b c)"}),"\n",(0,i.jsx)(n.p,{children:"(defmethod make-load-form ((s my-struct) &optional environment)"}),"\n",(0,i.jsxs)(n.p,{children:["(make-load-form-saving-slots s ",":environment"," environment))"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201353"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"methods specialized"})," on ",(0,i.jsx)(n.strong,{children:"standard-object"}),", ",(0,i.jsx)(n.strong,{children:"structure-object"}),", and ",(0,i.jsx)(n.strong,{children:"condition"})," all signal an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It is ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,i.jsx)(n.em,{children:"calling"})," ",(0,i.jsx)(n.strong,{children:"make-load-form"})," on a ",(0,i.jsx)(n.em,{children:"generalized instance"})," of a ",(0,i.jsx)(n.em,{children:"system class"})," signals an error or returns creation and initialization ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compile-file"}),", ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"}),", Section 3.2.4.4 (Additional Constraints on Externaliz able Objects) Section 3.1 (Evaluation), Section 3.2 (Compilation)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"file compiler"})," calls ",(0,i.jsx)(n.strong,{children:"make-load-form"})," in specific circumstances detailed in Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,i.jsxs)(n.p,{children:["Some ",(0,i.jsx)(n.em,{children:"implementations"})," may provide facilities for defining new ",(0,i.jsx)(n.em,{children:"subclasses"})," of ",(0,i.jsx)(n.em,{children:"classes"})," which are specified as ",(0,i.jsx)(n.em,{children:"system classes"}),". (Some likely candidates include ",(0,i.jsx)(n.strong,{children:"generic-function"}),", ",(0,i.jsx)(n.strong,{children:"method"}),", and ",(0,i.jsx)(n.strong,{children:"stream"}),"). Such ",(0,i.jsx)(n.em,{children:"implementations"})," should document how the ",(0,i.jsx)(n.em,{children:"file compiler"})," processes ",(0,i.jsx)(n.em,{children:"instances"})," of such ",(0,i.jsx)(n.em,{children:"classes"})," when encountered as ",(0,i.jsx)(n.em,{children:"literal objects"}),", and should document any relevant ",(0,i.jsx)(n.em,{children:"methods"})," for ",(0,i.jsx)(n.strong,{children:"make-load-form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," ",(0,i.jsx)(n.em,{children:"object"})," &key ",(0,i.jsx)(n.em,{children:"slot-names environment"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 creation-form, initialization-form"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-names"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"environment"}),"\u2014an ",(0,i.jsx)(n.em,{children:"environment object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"creation-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"initialization-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.em,{children:"forms"})," that, when ",(0,i.jsx)(n.em,{children:"evaluated"}),", will construct an ",(0,i.jsx)(n.em,{children:"object"})," equivalent to ",(0,i.jsx)(n.em,{children:"object"}),", without ",(0,i.jsx)(n.em,{children:"executing initialization forms"}),". The ",(0,i.jsx)(n.em,{children:"slots"})," in the new ",(0,i.jsx)(n.em,{children:"object"})," that correspond to initialized ",(0,i.jsx)(n.em,{children:"slots"})," in ",(0,i.jsx)(n.em,{children:"object"})," are initialized using the values from ",(0,i.jsx)(n.em,{children:"object"}),". Uninitialized ",(0,i.jsx)(n.em,{children:"slots"})," in ",(0,i.jsx)(n.em,{children:"object"})," are not initialized in the new ",(0,i.jsx)(n.em,{children:"object"}),". ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," works for any ",(0,i.jsx)(n.em,{children:"instance"})," of ",(0,i.jsx)(n.strong,{children:"standard-object"})," or ",(0,i.jsx)(n.strong,{children:"structure-object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Slot-names"})," is a ",(0,i.jsx)(n.em,{children:"list"})," of the names of the ",(0,i.jsx)(n.em,{children:"slots"})," to preserve. If ",(0,i.jsx)(n.em,{children:"slot-names"})," is not supplied, its value is all of the ",(0,i.jsx)(n.em,{children:"local slots"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," returns two values, thus it can deal with circular structures. Whether the result is useful in an application depends on whether the ",(0,i.jsx)(n.em,{children:"object"}),"\u2019s ",(0,i.jsx)(n.em,{children:"type"})," and slot contents fully capture the application\u2019s idea of the ",(0,i.jsx)(n.em,{children:"object"}),"\u2019s state."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Environment"})," is the environment in which the forms will be processed."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form"}),", ",(0,i.jsx)(n.strong,{children:"make-instance"}),", ",(0,i.jsx)(n.strong,{children:"setf"}),", ",(0,i.jsx)(n.strong,{children:"slot-value"}),", ",(0,i.jsx)(n.strong,{children:"slot-makunbound"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," can be useful in user-written ",(0,i.jsx)(n.strong,{children:"make-load-form"})," methods."]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.em,{children:"object"})," is an ",(0,i.jsx)(n.em,{children:"instance"})," of ",(0,i.jsx)(n.strong,{children:"standard-object"}),", ",(0,i.jsx)(n.strong,{children:"make-load-form-saving-slots"})," could return a creation form that ",(0,i.jsx)(n.em,{children:"calls"})," ",(0,i.jsx)(n.strong,{children:"allocate-instance"})," and an initialization form that contains ",(0,i.jsx)(n.em,{children:"calls"})," to ",(0,i.jsx)(n.strong,{children:"setf"})," of ",(0,i.jsx)(n.strong,{children:"slot-value"})," and ",(0,i.jsx)(n.strong,{children:"slot-makunbound"}),", though other ",(0,i.jsx)(n.em,{children:"functions"})," of similar effect might actually be used."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-accessors"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-accessors"})," (",(0,i.jsx)(n.em,{children:"{slot-entry}"}),"*) ",(0,i.jsx)(n.em,{children:"instance-form {declaration}"}),"* ",(0,i.jsx)(n.em,{children:"{form}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-entry::"}),"=(",(0,i.jsx)(n.em,{children:"variable-name accessor-name"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"variable-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"variable name"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"accessor-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"function name"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"; evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"forms"}),"\u2014an ",(0,i.jsx)(n.em,{children:"implicit progn"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"results"}),"\u2014the ",(0,i.jsx)(n.em,{children:"values"})," returned by the ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Creates a lexical environment in which the slots specified by ",(0,i.jsx)(n.em,{children:"slot-entry"})," are lexically available through their accessors as if they were variables. The macro ",(0,i.jsx)(n.strong,{children:"with-accessors"})," invokes the appropriate accessors to ",(0,i.jsx)(n.em,{children:"access"})," the ",(0,i.jsx)(n.em,{children:"slots"})," specified by ",(0,i.jsx)(n.em,{children:"slot-entry"}),". Both ",(0,i.jsx)(n.strong,{children:"setf"})," and ",(0,i.jsx)(n.strong,{children:"setq"})," can be used to set the value of the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201355"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"with-accessors"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass thing ()"}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initarg"," ",":x"," ",":accessor"," thing-x)"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initarg"," ",":y"," ",":accessor"," thing-y)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-CLASS THING 250020173>"]}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod (setf thing-x) ",":before"," (new-x (thing thing))"]}),"\n",(0,i.jsxs)(n.p,{children:['(format t "~&Changing X from ~D to ~D in ',(0,i.jsx)(n.del,{children:"S."}),'%"']}),"\n",(0,i.jsx)(n.p,{children:"(thing-x thing) new-x thing))"}),"\n",(0,i.jsxs)(n.p,{children:["(setq thing1 (make-instance \u2019thing ",":x"," 1 ",":y"," 2)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<THING 43135676>"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq thing2 (make-instance \u2019thing ",":x"," 7 ",":y"," 8)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<THING 43147374>"]}),"\n",(0,i.jsx)(n.p,{children:"(with-accessors ((x1 thing-x) (y1 thing-y))"}),"\n",(0,i.jsx)(n.p,{children:"thing1"}),"\n",(0,i.jsx)(n.p,{children:"(with-accessors ((x2 thing-x) (y2 thing-y))"}),"\n",(0,i.jsx)(n.p,{children:"thing2"}),"\n",(0,i.jsx)(n.p,{children:"(list (list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2))"}),"\n",(0,i.jsx)(n.p,{children:"(setq x1 (+ y1 x2))"}),"\n",(0,i.jsx)(n.p,{children:"(list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2))"}),"\n",(0,i.jsx)(n.p,{children:"(setf (thing-x thing2) (list x1))"}),"\n",(0,i.jsx)(n.p,{children:"(list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2)))))"}),"\n",(0,i.jsx)(n.p,{children:"\u25b7 Changing X from 1 to 9 in #<THING 43135676>."}),"\n",(0,i.jsx)(n.p,{children:"\u25b7 Changing X from 7 to (9) in #<THING 43147374>."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," ((1 1 2 2 7 7 8 8)"]}),"\n",(0,i.jsx)(n.p,{children:"9"}),"\n",(0,i.jsx)(n.p,{children:"(9 9 2 2 7 7 8 8)"}),"\n",(0,i.jsx)(n.p,{children:"(9)"}),"\n",(0,i.jsx)(n.p,{children:"(9 9 2 2 (9) (9) 8 8))"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The consequences are undefined if any ",(0,i.jsx)(n.em,{children:"accessor-name"})," is not the name of an accessor for the ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-slots"}),", ",(0,i.jsx)(n.strong,{children:"symbol-macrolet"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"with-accessors"})," expression of the form:"]}),"\n",(0,i.jsx)(n.p,{children:"(with-accessors (<i>slot-entry</i><sub>1</sub><i>. . . slot-entry<sub>n</sub></i>) <i>instance-form form</i><sub>1</sub><i>. . . form<sub>k</sub></i>)"}),"\n",(0,i.jsx)(n.p,{children:"expands into the equivalent of"}),"\n",(0,i.jsxs)(n.p,{children:["(let ((",(0,i.jsx)(n.em,{children:"in instance-form"}),"))"]}),"\n",(0,i.jsx)(n.p,{children:"(symbol-macrolet (<i>Q</i><sub>1</sub><i>. . . Q<sub>n</sub></i>) <i>form</i><sub>1</sub><i>. . . form<sub>k</sub></i>))"}),"\n",(0,i.jsx)(n.p,{children:"where <i>Q<sub>i</sub></i>is"}),"\n",(0,i.jsx)(n.p,{children:"(<i>variable-name<sub>i</sub></i> () (<i>accessor-name<sub>i</sub> in</i>))"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-slots"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-slots"})," (",(0,i.jsx)(n.em,{children:"{slot-entry}"}),"*) ",(0,i.jsx)(n.em,{children:"instance-form {declaration}"}),"* ",(0,i.jsx)(n.em,{children:"{form}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-entry::"}),"=",(0,i.jsx)(n.em,{children:"slot-name |"})," (",(0,i.jsx)(n.em,{children:"variable-name slot-name"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"slot name"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"variable-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"variable name"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"; evaluted to produce ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instance"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"forms"}),"\u2014an ",(0,i.jsx)(n.em,{children:"implicit progn"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"results"}),"\u2014the ",(0,i.jsx)(n.em,{children:"values"})," returned by the ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"with-slots"})," ",(0,i.jsx)(n.em,{children:"establishes"})," a ",(0,i.jsx)(n.em,{children:"lexical environment"})," for referring to the ",(0,i.jsx)(n.em,{children:"slots"})," in the ",(0,i.jsx)(n.em,{children:"instance"})," named by the given ",(0,i.jsx)(n.em,{children:"slot-names"})," as though they were ",(0,i.jsx)(n.em,{children:"variables"}),". Within such a context the value of the ",(0,i.jsx)(n.em,{children:"slot"})," can be specified by using its slot name, as if it were a lexically bound variable. Both ",(0,i.jsx)(n.strong,{children:"setf"})," and ",(0,i.jsx)(n.strong,{children:"setq"})," can be used to set the value of the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"with-slots"})," translates an appearance of the slot name as a ",(0,i.jsx)(n.em,{children:"variable"})," into a call to ",(0,i.jsx)(n.strong,{children:"slot-value"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:"(defclass thing ()"}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201357"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"with-slots"})}),"\n",(0,i.jsxs)(n.p,{children:["((x ",":initarg"," ",":x"," ",":accessor"," thing-x)"]}),"\n",(0,i.jsxs)(n.p,{children:["(y ",":initarg"," ",":y"," ",":accessor"," thing-y)))"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," #<STANDARD-CLASS THING 250020173>"]}),"\n",(0,i.jsxs)(n.p,{children:["(defmethod (setf thing-x) ",":before"," (new-x (thing thing))"]}),"\n",(0,i.jsxs)(n.p,{children:['(format t "~&Changing X from ~D to ~D in ',(0,i.jsx)(n.del,{children:"S."}),'%"']}),"\n",(0,i.jsx)(n.p,{children:"(thing-x thing) new-x thing))"}),"\n",(0,i.jsxs)(n.p,{children:["(setq thing (make-instance \u2019thing ",":x"," 0 ",":y"," 1)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<THING 62310540>"]}),"\n",(0,i.jsxs)(n.p,{children:["(with-slots (x y) thing (incf x) (incf y)) ",(0,i.jsx)(n.em,{children:"\u2192"})," 2"]}),"\n",(0,i.jsxs)(n.p,{children:["(values (thing-x thing) (thing-y thing)) ",(0,i.jsx)(n.em,{children:"\u2192"})," 1, 2"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq thing1 (make-instance \u2019thing ",":x"," 1 ",":y"," 2)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<THING 43135676>"]}),"\n",(0,i.jsxs)(n.p,{children:["(setq thing2 (make-instance \u2019thing ",":x"," 7 ",":y"," 8)) ",(0,i.jsx)(n.em,{children:"\u2192"})," #<THING 43147374>"]}),"\n",(0,i.jsx)(n.p,{children:"(with-slots ((x1 x) (y1 y))"}),"\n",(0,i.jsx)(n.p,{children:"thing1"}),"\n",(0,i.jsx)(n.p,{children:"(with-slots ((x2 x) (y2 y))"}),"\n",(0,i.jsx)(n.p,{children:"thing2"}),"\n",(0,i.jsx)(n.p,{children:"(list (list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2))"}),"\n",(0,i.jsx)(n.p,{children:"(setq x1 (+ y1 x2))"}),"\n",(0,i.jsx)(n.p,{children:"(list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2))"}),"\n",(0,i.jsx)(n.p,{children:"(setf (thing-x thing2) (list x1))"}),"\n",(0,i.jsx)(n.p,{children:"(list x1 (thing-x thing1) y1 (thing-y thing1)"}),"\n",(0,i.jsx)(n.p,{children:"x2 (thing-x thing2) y2 (thing-y thing2)))))"}),"\n",(0,i.jsx)(n.p,{children:"\u25b7 Changing X from 7 to (9) in #<THING 43147374>."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2192"})," ((1 1 2 2 7 7 8 8)"]}),"\n",(0,i.jsx)(n.p,{children:"9"}),"\n",(0,i.jsx)(n.p,{children:"(9 9 2 2 7 7 8 8)"}),"\n",(0,i.jsx)(n.p,{children:"(9)"}),"\n",(0,i.jsx)(n.p,{children:"(9 9 2 2 (9) (9) 8 8))"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The consequences are undefined if any ",(0,i.jsx)(n.em,{children:"slot-name"})," is not the name of a ",(0,i.jsx)(n.em,{children:"slot"})," in the ",(0,i.jsx)(n.em,{children:"instance"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"with-accessors"}),", ",(0,i.jsx)(n.strong,{children:"slot-value"}),", ",(0,i.jsx)(n.strong,{children:"symbol-macrolet"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"with-slots"})," expression of the form:"]}),"\n",(0,i.jsx)(n.p,{children:"(with-slots (<i>slot-entry</i><sub>1</sub><i>. . . slot-entry<sub>n</sub></i>) <i>instance-form form</i><sub>1</sub><i>. . . form<sub>k</sub></i>)"}),"\n",(0,i.jsx)(n.p,{children:"expands into the equivalent of"}),"\n",(0,i.jsxs)(n.p,{children:["(let ((",(0,i.jsx)(n.em,{children:"in instance-form"}),"))"]}),"\n",(0,i.jsx)(n.p,{children:"(symbol-macrolet (<i>Q</i><sub>1</sub><i>. . . Q<sub>n</sub></i>) <i>form</i><sub>1</sub><i>. . . form<sub>k</sub></i>))"}),"\n",(0,i.jsx)(n.p,{children:"where <i>Q<sub>i</sub></i>is"}),"\n",(0,i.jsx)(n.p,{children:"(<i>slot-entry<sub>i</sub></i>() (slot-value <i>in</i> \u2019<i>slot-entry<sub>i</sub></i>))"}),"\n",(0,i.jsx)(n.p,{children:"if <i>slot-entry<sub>i</sub></i>is a <i>symbol</i> and is"}),"\n",(0,i.jsx)(n.p,{children:"(<i>variable-name<sub>i</sub></i> () (slot-value <i>in</i> \u2019<i>slot-name<sub>i</sub></i>))"}),"\n",(0,i.jsx)(n.p,{children:"if <i>slot-entry<sub>i</sub></i>is of the form"}),"\n",(0,i.jsx)(n.p,{children:"(<i>variable-name<sub>i</sub> slot-name<sub>i</sub></i>)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defclass"})," ",(0,i.jsx)(n.em,{children:"class-name"})," (",(0,i.jsx)(n.em,{children:"{superclass-name}"}),"*) (",(0,i.jsx)(n.em,{children:"{slot-specifier}"}),"*) [[",(0,i.jsx)(n.em,{children:"\u2193class-option"})," ]]"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 new-class"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-specifier"}),"::= ",(0,i.jsx)(n.em,{children:"slot-name |"})," (",(0,i.jsx)(n.em,{children:"slot-name"})," [[",(0,i.jsx)(n.em,{children:"\u2193slot-option"})," ]])"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-name"}),"::= ",(0,i.jsx)(n.em,{children:"symbol"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"slot-option"}),"::= ",(0,i.jsx)(n.em,{children:"{"}),":reader"," ",(0,i.jsx)(n.em,{children:"reader-function-name}"}),"* ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":writer"," ",(0,i.jsx)(n.em,{children:"writer-function-name}"}),"* ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":accessor"," ",(0,i.jsx)(n.em,{children:"reader-function-name}"}),"* ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":allocation"," ",(0,i.jsx)(n.em,{children:"allocation-type} |"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":initarg"," ",(0,i.jsx)(n.em,{children:"initarg-name}"}),"* ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":initform"," ",(0,i.jsx)(n.em,{children:"form} |"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":type"," ",(0,i.jsx)(n.em,{children:"type-specifier} |"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{"}),":documentation"," ",(0,i.jsx)(n.em,{children:"string}"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-name"}),"::= ",(0,i.jsx)(n.em,{children:"{symbol |"})," (setf ",(0,i.jsx)(n.em,{children:"symbol"}),")",(0,i.jsx)(n.em,{children:"}"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class-option"}),"::= (",":default-initargs"," . ",(0,i.jsx)(n.em,{children:"initarg-list"}),") ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":documentation"," ",(0,i.jsx)(n.em,{children:"string"}),") ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":metaclass"," ",(0,i.jsx)(n.em,{children:"class-name"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201359"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Class-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Superclass-name"}),"\u2013a ",(0,i.jsx)(n.em,{children:"non-nil symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Slot-name"}),"\u2013a ",(0,i.jsx)(n.em,{children:"symbol"}),". The ",(0,i.jsx)(n.em,{children:"slot-name"})," argument is a ",(0,i.jsx)(n.em,{children:"symbol"})," that is syntactically valid for use as a variable name."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Reader-function-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"}),". ",":reader"," can be supplied more than once for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Writer-function-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function"})," name. ",":writer"," can be supplied more than once for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Reader-function-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"}),". ",":accessor"," can be supplied more than once for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Allocation-type"}),"\u2014(member ",":instance"," ",":class","). ",":allocation"," can be supplied once at most for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initarg-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),". ",":initarg"," can be supplied more than once for a given ",(0,i.jsx)(n.em,{children:"slot"}),". ",(0,i.jsx)(n.em,{children:"Form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),". ",":init-form"," can be supplied once at most for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Type-specifier"}),"\u2014a ",(0,i.jsx)(n.em,{children:"type specifier"})," . ",":type"," can be supplied once at most for a given ",(0,i.jsx)(n.em,{children:"slot"}),". ",(0,i.jsx)(n.em,{children:"Class-option"}),"\u2014 refers to the ",(0,i.jsx)(n.em,{children:"class"})," as a whole or to all class ",(0,i.jsx)(n.em,{children:"slots"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initarg-list"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of alternating initialization argument ",(0,i.jsx)(n.em,{children:"names"})," and default initial value ",(0,i.jsx)(n.em,{children:"forms"}),". ",":default-initargs"," can be supplied at most once."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Class-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"}),". ",":metaclass"," can be supplied once at most."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"new-class"}),"\u2014the new ",(0,i.jsx)(n.em,{children:"class object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"defclass"})," defines a new named ",(0,i.jsx)(n.em,{children:"class"}),". It returns the new ",(0,i.jsx)(n.em,{children:"class object"})," as its result."]}),"\n",(0,i.jsxs)(n.p,{children:["The syntax of ",(0,i.jsx)(n.strong,{children:"defclass"})," provides options for specifying initialization arguments for ",(0,i.jsx)(n.em,{children:"slots"}),", for specifying default initialization values for ",(0,i.jsx)(n.em,{children:"slots"}),", and for requesting that ",(0,i.jsx)(n.em,{children:"methods"})," on specified ",(0,i.jsx)(n.em,{children:"generic functions"})," be automatically generated for reading and writing the values of ",(0,i.jsx)(n.em,{children:"slots"}),". No reader or writer functions are defined by default; their generation must be explicitly requested. However, ",(0,i.jsx)(n.em,{children:"slots"})," can always be ",(0,i.jsx)(n.em,{children:"accessed"})," using ",(0,i.jsx)(n.strong,{children:"slot-value"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Defining a new ",(0,i.jsx)(n.em,{children:"class"})," also causes a ",(0,i.jsx)(n.em,{children:"type"})," of the same name to be defined. The predicate (typep ",(0,i.jsx)(n.em,{children:"object class-name"}),") returns true if the ",(0,i.jsx)(n.em,{children:"class"})," of the given ",(0,i.jsx)(n.em,{children:"object"})," is the ",(0,i.jsx)(n.em,{children:"class"})," named by ",(0,i.jsx)(n.em,{children:"class-name"})," itself or a subclass of the class ",(0,i.jsx)(n.em,{children:"class-name"}),". A ",(0,i.jsx)(n.em,{children:"class object"})," can be used as a ",(0,i.jsx)(n.em,{children:"type specifier"})," . Thus (typep ",(0,i.jsx)(n.em,{children:"object class"}),") returns ",(0,i.jsx)(n.em,{children:"true"})," if the ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"object"})," is ",(0,i.jsx)(n.em,{children:"class"})," itself or a subclass of ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"class-name"})," argument specifies the ",(0,i.jsx)(n.em,{children:"proper name"})," of the new ",(0,i.jsx)(n.em,{children:"class"}),". If a ",(0,i.jsx)(n.em,{children:"class"})," with the same"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"proper name"})," already exists and that ",(0,i.jsx)(n.em,{children:"class"})," is an ",(0,i.jsx)(n.em,{children:"instance"})," of ",(0,i.jsx)(n.strong,{children:"standard-class"}),", and if the ",(0,i.jsx)(n.strong,{children:"defclass"})," form for the definition of the new ",(0,i.jsx)(n.em,{children:"class"})," specifies a ",(0,i.jsx)(n.em,{children:"class"})," of ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),", the existing ",(0,i.jsx)(n.em,{children:"class"})," is redefined, and instances of it (and its ",(0,i.jsx)(n.em,{children:"subclasses"}),") are updated to the new definition at the time that they are next ",(0,i.jsx)(n.em,{children:"accessed"}),". For details, see Section 4.3.6 (Redefining Classes)."]}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.em,{children:"superclass-name"})," argument specifies a direct ",(0,i.jsx)(n.em,{children:"superclass"})," of the new ",(0,i.jsx)(n.em,{children:"class"}),". If the ",(0,i.jsx)(n.em,{children:"superclass"})," list is empty, then the ",(0,i.jsx)(n.em,{children:"superclass"})," defaults depending on the ",(0,i.jsx)(n.em,{children:"metaclass"}),", with ",(0,i.jsx)(n.strong,{children:"standard-object"})," being the default for ",(0,i.jsx)(n.strong,{children:"standard-class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The new ",(0,i.jsx)(n.em,{children:"class"})," will inherit ",(0,i.jsx)(n.em,{children:"slots"})," and ",(0,i.jsx)(n.em,{children:"methods"})," from each of its direct ",(0,i.jsx)(n.em,{children:"superclasses"}),", from their direct ",(0,i.jsx)(n.em,{children:"superclasses"}),", and so on. For a discussion of how ",(0,i.jsx)(n.em,{children:"slots"})," and ",(0,i.jsx)(n.em,{children:"methods"})," are inherited, see Section 4.3.4 (Inheritance)."]}),"\n",(0,i.jsx)(n.p,{children:"The following slot options are available:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":reader"," slot option specifies that an ",(0,i.jsx)(n.em,{children:"unqualified method"})," is to be defined on the ",(0,i.jsx)(n.em,{children:"generic function"})," named ",(0,i.jsx)(n.em,{children:"reader-function-name"})," to read the value of the given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":writer"," slot option specifies that an ",(0,i.jsx)(n.em,{children:"unqualified method"})," is to be defined on the ",(0,i.jsx)(n.em,{children:"generic function"})," named ",(0,i.jsx)(n.em,{children:"writer-function-name"})," to write the value of the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":accessor"," slot option specifies that an ",(0,i.jsx)(n.em,{children:"unqualified method"})," is to be defined on the generic function named ",(0,i.jsx)(n.em,{children:"reader-function-name"})," to read the value of the given ",(0,i.jsx)(n.em,{children:"slot"})," and that an ",(0,i.jsx)(n.em,{children:"unqualified method"})," is to be defined on the ",(0,i.jsx)(n.em,{children:"generic function"})," named (setf ",(0,i.jsx)(n.em,{children:"reader-function-name"}),") to be used with ",(0,i.jsx)(n.strong,{children:"setf"})," to modify the value of the ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":allocation"," slot option is used to specify where storage is to be allocated for the given ",(0,i.jsx)(n.em,{children:"slot"}),". Storage for a ",(0,i.jsx)(n.em,{children:"slot"})," can be located in each instance or in the ",(0,i.jsx)(n.em,{children:"class object"})," itself. The value of the ",(0,i.jsx)(n.em,{children:"allocation-type"})," argument can be either the keyword ",":instance"," or the keyword ",":class",". If the ",":allocation"," slot option is not specified, the effect is the same as specifying ",":allocation"," ",":instance","."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 If ",(0,i.jsx)(n.em,{children:"allocation-type"})," is ",":instance",", a ",(0,i.jsx)(n.em,{children:"local slot"})," of the name ",(0,i.jsx)(n.em,{children:"slot-name"})," is allocated in each instance of the ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["\u2013 If ",(0,i.jsx)(n.em,{children:"allocation-type"})," is ",":class",", a shared ",(0,i.jsx)(n.em,{children:"slot"})," of the given name is allocated in the ",(0,i.jsx)(n.em,{children:"class object"})," created by this ",(0,i.jsx)(n.strong,{children:"defclass"})," form. The value of the ",(0,i.jsx)(n.em,{children:"slot"})," is shared by all"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"instances"})," of the ",(0,i.jsx)(n.em,{children:"class"}),". If a class ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub> defines such a ",(0,i.jsx)(n.em,{children:"shared slot"}),", any subclass ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> of"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub> will share this single ",(0,i.jsx)(n.em,{children:"slot"})," unless the ",(0,i.jsx)(n.strong,{children:"defclass"})," form for ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> specifies a ",(0,i.jsx)(n.em,{children:"slot"})," of the"]}),"\n",(0,i.jsxs)(n.p,{children:["same ",(0,i.jsx)(n.em,{children:"name"})," or there is a superclass of ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> that precedes ",(0,i.jsx)(n.em,{children:"C"}),"<sub>1</sub> in the class precedence"]}),"\n",(0,i.jsxs)(n.p,{children:["list of ",(0,i.jsx)(n.em,{children:"C"}),"<sub>2</sub> and that defines a ",(0,i.jsx)(n.em,{children:"slot"})," of the same ",(0,i.jsx)(n.em,{children:"name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":initform"," slot option is used to provide a default initial value form to be used in the initialization of the ",(0,i.jsx)(n.em,{children:"slot"}),". This ",(0,i.jsx)(n.em,{children:"form"})," is evaluated every time it is used to initialize the ",(0,i.jsx)(n.em,{children:"slot"}),". The lexical environment in which this ",(0,i.jsx)(n.em,{children:"form"})," is evaluated is the lexical environment in which the ",(0,i.jsx)(n.strong,{children:"defclass"})," form was evaluated. Note that the lexical environment refers both to variables"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201361"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsxs)(n.p,{children:["and to functions. For ",(0,i.jsx)(n.em,{children:"local slots"}),", the dynamic environment is the dynamic environment in which ",(0,i.jsx)(n.strong,{children:"make-instance"})," is called; for shared ",(0,i.jsx)(n.em,{children:"slots"}),", the dynamic environment is the dynamic environment in which the ",(0,i.jsx)(n.strong,{children:"defclass"})," form was evaluated. See Section 7.1 (Object Creation and Initialization)."]}),"\n",(0,i.jsxs)(n.p,{children:["No implementation is permitted to extend the syntax of ",(0,i.jsx)(n.strong,{children:"defclass"})," to allow (",(0,i.jsx)(n.em,{children:"slot-name form"}),") as an abbreviation for (",(0,i.jsx)(n.em,{children:"slot-name"})," ",":initform"," ",(0,i.jsx)(n.em,{children:"form"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":initarg"," slot option declares an initialization argument named ",(0,i.jsx)(n.em,{children:"initarg-name"})," and specifies that this initialization argument initializes the given ",(0,i.jsx)(n.em,{children:"slot"}),". If the initialization argument has a value in the call to ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),", the value will be stored into the given ",(0,i.jsx)(n.em,{children:"slot"}),", and the slot\u2019s ",":initform"," slot option, if any, is not evaluated. If none of the initialization arguments specified for a given ",(0,i.jsx)(n.em,{children:"slot"})," has a value, the ",(0,i.jsx)(n.em,{children:"slot"})," is initialized according to the ",":initform"," slot option, if specified."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":type"," slot option specifies that the contents of the ",(0,i.jsx)(n.em,{children:"slot"})," will always be of the specified data type. It effectively declares the result type of the reader generic function when applied to an ",(0,i.jsx)(n.em,{children:"object"})," of this ",(0,i.jsx)(n.em,{children:"class"}),". The consequences of attempting to store in a ",(0,i.jsx)(n.em,{children:"slot"})," a value that does not satisfy the type of the ",(0,i.jsx)(n.em,{children:"slot"})," are undefined. The ",":type"," slot option is further discussed in Section 7.5.3 (Inheritance of Slots and Slot Options)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":documentation"," slot option provides a ",(0,i.jsx)(n.em,{children:"documentation string"})," for the ",(0,i.jsx)(n.em,{children:"slot"}),". ",":documentation"," can be supplied once at most for a given ",(0,i.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Each class option is an option that refers to the ",(0,i.jsx)(n.em,{children:"class"})," as a whole. The following class options are available:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":default-initargs"," class option is followed by a list of alternating initialization argument ",(0,i.jsx)(n.em,{children:"names"})," and default initial value forms. If any of these initialization arguments does not appear in the initialization argument list supplied to ",(0,i.jsx)(n.strong,{children:"make-instance"}),", the corresponding default initial value form is evaluated, and the initialization argument ",(0,i.jsx)(n.em,{children:"name"})," and the ",(0,i.jsx)(n.em,{children:"form"}),"\u2019s value are added to the end of the initialization argument list before the instance is created; see Section 7.1 (Object Creation and Initialization). The default initial value form is evaluated each time it is used. The lexical environment in which this ",(0,i.jsx)(n.em,{children:"form"})," is evaluated is the lexical environment in which the ",(0,i.jsx)(n.strong,{children:"defclass"})," form was evaluated. The dynamic environment is the dynamic environment in which ",(0,i.jsx)(n.strong,{children:"make-instance"})," was called. If an initialization argument ",(0,i.jsx)(n.em,{children:"name"})," appears more than once in a ",":default-initargs"," class option, an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":documentation"," class option causes a ",(0,i.jsx)(n.em,{children:"documentation string"})," to be attached with the ",(0,i.jsx)(n.em,{children:"class object"}),", and attached with kind ",(0,i.jsx)(n.strong,{children:"type"})," to the ",(0,i.jsx)(n.em,{children:"class-name"}),". ",":documentation"," can be supplied once at most."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":metaclass"," class option is used to specify that instances of the ",(0,i.jsx)(n.em,{children:"class"})," being defined are to have a different metaclass than the default provided by the system (the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-class"}),")."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defclass"})}),"\n",(0,i.jsxs)(n.p,{children:["Note the following rules of ",(0,i.jsx)(n.strong,{children:"defclass"})," for ",(0,i.jsx)(n.em,{children:"standard classes"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," It is not required that the ",(0,i.jsx)(n.em,{children:"superclasses"})," of a ",(0,i.jsx)(n.em,{children:"class"})," be defined before the ",(0,i.jsx)(n.strong,{children:"defclass"})," form for that ",(0,i.jsx)(n.em,{children:"class"})," is evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," All the ",(0,i.jsx)(n.em,{children:"superclasses"})," of a ",(0,i.jsx)(n.em,{children:"class"})," must be defined before an ",(0,i.jsx)(n.em,{children:"instance"})," of the ",(0,i.jsx)(n.em,{children:"class"})," can be made."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," A ",(0,i.jsx)(n.em,{children:"class"})," must be defined before it can be used as a parameter specializer in a ",(0,i.jsx)(n.strong,{children:"defmethod"})," form."]}),"\n",(0,i.jsx)(n.p,{children:"The object system can be extended to cover situations where these rules are not obeyed."}),"\n",(0,i.jsxs)(n.p,{children:["Some slot options are inherited by a ",(0,i.jsx)(n.em,{children:"class"})," from its ",(0,i.jsx)(n.em,{children:"superclasses"}),", and some can be shadowed or altered by providing a local slot description. No class options except ",":default-initargs"," are inherited. For a detailed description of how ",(0,i.jsx)(n.em,{children:"slots"})," and slot options are inherited, see Section 7.5.3 (Inheritance of Slots and Slot Options)."]}),"\n",(0,i.jsxs)(n.p,{children:["The options to ",(0,i.jsx)(n.strong,{children:"defclass"})," can be extended. It is required that all implementations signal an error if they observe a class option or a slot option that is not implemented locally."]}),"\n",(0,i.jsxs)(n.p,{children:["It is valid to specify more than one reader, writer, accessor, or initialization argument for a ",(0,i.jsx)(n.em,{children:"slot"}),". No other slot option can appear more than once in a single slot description, or an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If no reader, writer, or accessor is specified for a ",(0,i.jsx)(n.em,{children:"slot"}),", the ",(0,i.jsx)(n.em,{children:"slot"})," can only be ",(0,i.jsx)(n.em,{children:"accessed"})," by the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"slot-value"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.strong,{children:"defclass"})," ",(0,i.jsx)(n.em,{children:"form"})," appears as a ",(0,i.jsx)(n.em,{children:"top level form"}),", the ",(0,i.jsx)(n.em,{children:"compiler"})," must make the ",(0,i.jsx)(n.em,{children:"class name"})," be recognized as a valid ",(0,i.jsx)(n.em,{children:"type name"})," in subsequent declarations (as for ",(0,i.jsx)(n.strong,{children:"deftype"}),") and be recognized as a valid ",(0,i.jsx)(n.em,{children:"class name"})," for ",(0,i.jsx)(n.strong,{children:"defmethod"})," ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and for use as the ",":metaclass"," option of a subsequent ",(0,i.jsx)(n.strong,{children:"defclass"}),". The ",(0,i.jsx)(n.em,{children:"compiler"})," must make the ",(0,i.jsx)(n.em,{children:"class"})," definition available to be returned by ",(0,i.jsx)(n.strong,{children:"find-class"})," when its ",(0,i.jsx)(n.em,{children:"environment argument"})," is a value received as the ",(0,i.jsx)(n.em,{children:"environment parameter"})," of a ",(0,i.jsx)(n.em,{children:"macro"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If there are any duplicate slot names, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If an initialization argument ",(0,i.jsx)(n.em,{children:"name"})," appears more than once in ",":default-initargs"," class option, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If any of the following slot options appears more than once in a single slot description, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled: ",":allocation",", ",":initform",", ",":type",", ",":documentation","."]}),"\n",(0,i.jsxs)(n.p,{children:["It is required that all implementations signal an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," if they observe a class option or a slot option that is not implemented locally."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"documentation"}),", ",(0,i.jsx)(n.strong,{children:"initialize-instance"}),", ",(0,i.jsx)(n.strong,{children:"make-instance"}),", ",(0,i.jsx)(n.strong,{children:"slot-value"}),", Section 4.3 (Classes), Section 4.3.4 (Inheritance), Section 4.3.6 (Redefining Classes), Section 4.3.5 (Determining the Class Precedence"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201363"})]}),"\n",(0,i.jsx)(n.p,{children:"List), Section 7.1 (Object Creation and Initialization)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defgeneric"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defgeneric"})," ",(0,i.jsx)(n.em,{children:"function-name gf-lambda-list"})," [[ ",(0,i.jsx)(n.em,{children:"\u2193option | {\u2193method-description}"}),"* ]]"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 new-generic"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"option::"}),"=(",":argument-precedence-order"," ",(0,i.jsx)(n.em,{children:"{parameter-name}"}),"<sup>+</sup>) ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"{gf-declaration}"}),"<sup>+</sup>) ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":documentation"," ",(0,i.jsx)(n.em,{children:"gf-documentation"}),") ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":method-combination"," ",(0,i.jsx)(n.em,{children:"method-combination {method-combination-argument}"}),"*) ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":generic-function-class"," ",(0,i.jsx)(n.em,{children:"generic-function-class"}),") ",(0,i.jsx)(n.em,{children:"|"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",":method-class"," ",(0,i.jsx)(n.em,{children:"method-class"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-description::"}),"=(",":method"," ",(0,i.jsx)(n.em,{children:"{method-qualifier}"}),"* ",(0,i.jsx)(n.em,{children:"specialized-lambda-list"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:["[[ ",(0,i.jsx)(n.em,{children:"{declaration}"}),"* ",(0,i.jsx)(n.em,{children:"| documentation"})," ]] ",(0,i.jsx)(n.em,{children:"{form}"}),"*)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"function name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function-class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"})," naming a ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"gf-declaration"}),"\u2014an ",(0,i.jsx)(n.strong,{children:"optimize"})," ",(0,i.jsx)(n.em,{children:"declaration specifier"})," ; other ",(0,i.jsx)(n.em,{children:"declaration specifiers"})," are not permitted. ",(0,i.jsx)(n.em,{children:"gf-documentation"}),"\u2014a ",(0,i.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"gf-lambda-list"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function lambda list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"non-nil symbol"})," naming a ",(0,i.jsx)(n.em,{children:"class"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-combination-argument"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object."})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-combination-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"})," naming a ",(0,i.jsx)(n.em,{children:"method combination type"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-qualifiers"}),", ",(0,i.jsx)(n.em,{children:"specialized-lambda-list"}),", ",(0,i.jsx)(n.em,{children:"declarations"}),", ",(0,i.jsx)(n.em,{children:"documentation"}),", ",(0,i.jsx)(n.em,{children:"forms"}),"\u2014as per ",(0,i.jsx)(n.strong,{children:"defmethod"}),". ",(0,i.jsx)(n.em,{children:"new-generic"}),"\u2014the ",(0,i.jsx)(n.em,{children:"generic function object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"parameter-name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"})," that names a ",(0,i.jsx)(n.em,{children:"required parameter"})," in the ",(0,i.jsx)(n.em,{children:"lambda-list"}),". (If the ",":argument-precedence-order"," option is specified, each ",(0,i.jsx)(n.em,{children:"required parameter"})," in the ",(0,i.jsx)(n.em,{children:"lambda-list"})," must be used exactly once as a ",(0,i.jsx)(n.em,{children:"parameter-name"}),".)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defgeneric"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"defgeneric"})," is used to define a ",(0,i.jsx)(n.em,{children:"generic function"})," or to specify options and declarations that pertain to a ",(0,i.jsx)(n.em,{children:"generic function"})," as a whole."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"list"})," it must be of the form (setf ",(0,i.jsx)(n.em,{children:"symbol"}),"). If (fboundp ",(0,i.jsx)(n.em,{children:"function-name"}),") is ",(0,i.jsx)(n.em,{children:"false"}),", a new ",(0,i.jsx)(n.em,{children:"generic function"})," is created. If (fdefinition ",(0,i.jsx)(n.em,{children:"function-name"}),") is a ",(0,i.jsx)(n.em,{children:"generic function"}),", that ",(0,i.jsx)(n.em,{children:"generic function"})," is modified. If ",(0,i.jsx)(n.em,{children:"function-name"})," names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["The effect of the ",(0,i.jsx)(n.strong,{children:"defgeneric"})," macro is as if the following three steps were performed: first, ",(0,i.jsx)(n.em,{children:"methods"})," defined by previous ",(0,i.jsx)(n.strong,{children:"defgeneric"})," ",(0,i.jsx)(n.em,{children:"forms"})," are removed; second, ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"})," is called; and finally, ",(0,i.jsx)(n.em,{children:"methods"})," specified by the current ",(0,i.jsx)(n.strong,{children:"defgeneric"})," ",(0,i.jsx)(n.em,{children:"form"})," are added to the ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.em,{children:"method-description"})," defines a ",(0,i.jsx)(n.em,{children:"method"})," on the ",(0,i.jsx)(n.em,{children:"generic function"}),". The ",(0,i.jsx)(n.em,{children:"lambda list"})," of each ",(0,i.jsx)(n.em,{children:"method"})," must be congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," specified by the ",(0,i.jsx)(n.em,{children:"gf-lambda-list"})," option. If no ",(0,i.jsx)(n.em,{children:"method"})," descriptions are specified and a ",(0,i.jsx)(n.em,{children:"generic function"})," of the same name does not already exist, a ",(0,i.jsx)(n.em,{children:"generic function"})," with no ",(0,i.jsx)(n.em,{children:"methods"})," is created."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"gf-lambda-list"})," argument of ",(0,i.jsx)(n.strong,{children:"defgeneric"})," specifies the shape of ",(0,i.jsx)(n.em,{children:"lambda lists"})," for the ",(0,i.jsx)(n.em,{children:"methods"})," on this ",(0,i.jsx)(n.em,{children:"generic function"}),". All ",(0,i.jsx)(n.em,{children:"methods"})," on the resulting ",(0,i.jsx)(n.em,{children:"generic function"})," must have ",(0,i.jsx)(n.em,{children:"lambda lists"})," that are congruent with this shape. If a ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form is evaluated and some ",(0,i.jsx)(n.em,{children:"methods"})," for that ",(0,i.jsx)(n.em,{children:"generic function"})," have ",(0,i.jsx)(n.em,{children:"lambda lists"})," that are not congruent with that given in the ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form, an error is signaled. For further details on method congruence, see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"generic function"})," passes to the ",(0,i.jsx)(n.em,{children:"method"})," all the argument values passed to it, and only those; default values are not supported. Note that optional and keyword arguments in method definitions, however, can have default initial value forms and can use supplied-p parameters."]}),"\n",(0,i.jsx)(n.p,{children:"The following options are provided. Except as otherwise noted, a given option may occur only once."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":argument-precedence-order"," option is used to specify the order in which the required arguments in a call to the ",(0,i.jsx)(n.em,{children:"generic function"})," are tested for specificity when selecting a particular ",(0,i.jsx)(n.em,{children:"method"}),". Each required argument, as specified in the ",(0,i.jsx)(n.em,{children:"gf-lambda-list"})," argument, must be included exactly once as a ",(0,i.jsx)(n.em,{children:"parameter-name"})," so that the full and unambiguous precedence order is supplied. If this condition is not met, an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",(0,i.jsx)(n.strong,{children:"declare"})," option is used to specify declarations that pertain to the ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.strong,{children:"optimize"})," ",(0,i.jsx)(n.em,{children:"declaration specifier"})," is allowed. It specifies whether method selection should be optimized for speed or space, but it has no effect on ",(0,i.jsx)(n.em,{children:"methods"}),". To control how a ",(0,i.jsx)(n.em,{children:"method"})," is optimized, an ",(0,i.jsx)(n.strong,{children:"optimize"})," declaration must be placed directly in the ",(0,i.jsx)(n.strong,{children:"defmethod"})," ",(0,i.jsx)(n.em,{children:"form"})," or method description. The optimization qualities ",(0,i.jsx)(n.strong,{children:"speed"})," and ",(0,i.jsx)(n.strong,{children:"space"})," are the only qualities this standard requires, but an implementation can extend the object system to recognize other qualities. A simple implementation that has only one method selection technique and ignores ",(0,i.jsx)(n.strong,{children:"optimize"})," ",(0,i.jsx)(n.em,{children:"declaration specifiers"})," is valid."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201365"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defgeneric"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"special"}),", ",(0,i.jsx)(n.strong,{children:"ftype"}),", ",(0,i.jsx)(n.strong,{children:"function"}),", ",(0,i.jsx)(n.strong,{children:"inline"}),", ",(0,i.jsx)(n.strong,{children:"notinline"}),", and ",(0,i.jsx)(n.strong,{children:"declaration"})," declarations are not permitted. Individual implementations can extend the ",(0,i.jsx)(n.strong,{children:"declare"})," option to support additional declarations. If an implementation notices a ",(0,i.jsx)(n.em,{children:"declaration specifier"})," that it does not support and that has not been proclaimed as a non-standard ",(0,i.jsx)(n.em,{children:"declaration identifier"})," name in a ",(0,i.jsx)(n.strong,{children:"declaration"})," ",(0,i.jsx)(n.em,{children:"proclamation"}),", it should issue a warning."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"declare"})," option may be specified more than once. The effect is the same as if the lists of ",(0,i.jsx)(n.em,{children:"declaration specifiers"})," had been appended together into a single list and specified as a single ",(0,i.jsx)(n.strong,{children:"declare"})," option."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":documentation"," argument is a ",(0,i.jsx)(n.em,{children:"documentation string"})," to be attached to the ",(0,i.jsx)(n.em,{children:"generic function object"}),", and to be attached with kind ",(0,i.jsx)(n.strong,{children:"function"})," to the ",(0,i.jsx)(n.em,{children:"function-name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":generic-function-class"," option may be used to specify that the ",(0,i.jsx)(n.em,{children:"generic function"})," is to have a different ",(0,i.jsx)(n.em,{children:"class"})," than the default provided by the system (the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),"). The ",(0,i.jsx)(n.em,{children:"class-name"})," argument is the name of a ",(0,i.jsx)(n.em,{children:"class"})," that can be the ",(0,i.jsx)(n.em,{children:"class"})," of a ",(0,i.jsx)(n.em,{children:"generic function"}),". If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies an existing ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":generic-function-class"," argument and the new generic function ",(0,i.jsx)(n.em,{children:"class"})," is compatible with the old, ",(0,i.jsx)(n.strong,{children:"change-class"})," is called to change the ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),"; otherwise an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":method-class"," option is used to specify that all ",(0,i.jsx)(n.em,{children:"methods"})," on this ",(0,i.jsx)(n.em,{children:"generic function"})," are to have a different ",(0,i.jsx)(n.em,{children:"class"})," from the default provided by the system (the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-method"}),"). The ",(0,i.jsx)(n.em,{children:"class-name"})," argument is the name of a ",(0,i.jsx)(n.em,{children:"class"})," that is capable of being the ",(0,i.jsx)(n.em,{children:"class"})," of a ",(0,i.jsx)(n.em,{children:"method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":method-combination"," option is followed by a symbol that names a type of method combination. The arguments (if any) that follow that symbol depend on the type of method combination. Note that the standard method combination type does not support any arguments. However, all types of method combination defined by the short form of ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," accept an optional argument named ",(0,i.jsx)(n.em,{children:"order"}),", defaulting to ",":most-specific-first",", where a value of ",":most-specific-last"," reverses the order of the primary ",(0,i.jsx)(n.em,{children:"methods"})," without affecting the order of the auxiliary ",(0,i.jsx)(n.em,{children:"methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"method-description"})," arguments define ",(0,i.jsx)(n.em,{children:"methods"})," that will be associated with the ",(0,i.jsx)(n.em,{children:"generic function"}),". The ",(0,i.jsx)(n.em,{children:"method-qualifier"})," and ",(0,i.jsx)(n.em,{children:"specialized-lambda-list"})," arguments in a method description are the same as for ",(0,i.jsx)(n.strong,{children:"defmethod"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"form"})," arguments specify the method body. The body of the ",(0,i.jsx)(n.em,{children:"method"})," is enclosed in an ",(0,i.jsx)(n.em,{children:"implicit block"}),". If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"symbol"}),", this block bears the same name as the ",(0,i.jsx)(n.em,{children:"generic function"}),". If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"list"})," of the form (setf ",(0,i.jsx)(n.em,{children:"symbol"}),"), the name of the block is ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Implementations can extend ",(0,i.jsx)(n.strong,{children:"defgeneric"})," to include other options. It is required that an implementation signal an error if it observes an option that is not implemented locally."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defgeneric"})," is not required to perform any compile-time side effects. In particular, the ",(0,i.jsx)(n.em,{children:"methods"})," are not installed for invocation during compilation. An ",(0,i.jsx)(n.em,{children:"implementation"})," may choose to store"]}),"\n",(0,i.jsxs)(n.p,{children:["information about the ",(0,i.jsx)(n.em,{children:"generic function"})," for the purposes of compile-time error-checking (such as checking the number of arguments on calls, or noting that a definition for the function name has been seen)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["Each required argument, as specified in the ",(0,i.jsx)(n.em,{children:"gf-lambda-list"})," argument, must be included exactly once as a ",(0,i.jsx)(n.em,{children:"parameter-name"}),", or an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"lambda list"})," of each ",(0,i.jsx)(n.em,{children:"method"})," specified by a ",(0,i.jsx)(n.em,{children:"method-description"})," must be congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," specified by the ",(0,i.jsx)(n.em,{children:"gf-lambda-list"})," option, or an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form is evaluated and some ",(0,i.jsx)(n.em,{children:"methods"})," for that ",(0,i.jsx)(n.em,{children:"generic function"})," have ",(0,i.jsx)(n.em,{children:"lambda lists"})," that are not congruent with that given in the ",(0,i.jsx)(n.strong,{children:"defgeneric"})," form, an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["A given ",(0,i.jsx)(n.em,{children:"option"})," may occur only once, or an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," specifies an existing ",(0,i.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":generic-function-class"," argument and the new generic function ",(0,i.jsx)(n.em,{children:"class"})," is compatible with the old, ",(0,i.jsx)(n.strong,{children:"change-class"})," is called to change the ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),"; otherwise an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["Implementations can extend ",(0,i.jsx)(n.strong,{children:"defgeneric"})," to include other options. It is required that an implementation signal an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"program-error"})," if it observes an option that is not implemented locally."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmethod"}),", ",(0,i.jsx)(n.strong,{children:"documentation"}),", ",(0,i.jsx)(n.strong,{children:"ensure-generic-function"}),", ",(0,i.jsx)(n.strong,{children:"generic-function"}),", Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmethod"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmethod"})," ",(0,i.jsx)(n.em,{children:"function-name {method-qualifier}"}),"* ",(0,i.jsx)(n.em,{children:"specialized-lambda-list"})]}),"\n",(0,i.jsxs)(n.p,{children:["[[ ",(0,i.jsx)(n.em,{children:"{declaration}"}),"* ",(0,i.jsx)(n.em,{children:"| documentation"})," ]] ",(0,i.jsx)(n.em,{children:"{form}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 new-method"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-name"}),"::= ",(0,i.jsx)(n.em,{children:"{symbol |"})," (setf ",(0,i.jsx)(n.em,{children:"symbol"}),")",(0,i.jsx)(n.em,{children:"}"})]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201367"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-qualifier"}),"::= ",(0,i.jsx)(n.em,{children:"non-list"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"specialized-lambda-list"}),"::= (",(0,i.jsx)(n.em,{children:"{var |"})," (",(0,i.jsx)(n.em,{children:"var parameter-specializer-name"}),")",(0,i.jsx)(n.em,{children:"}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:["[&optional ",(0,i.jsx)(n.em,{children:"{var |"})," (var [",(0,i.jsx)(n.em,{children:"initform"})," [",(0,i.jsx)(n.em,{children:"supplied-p-parameter"}),"] ])",(0,i.jsx)(n.em,{children:"}"}),"*]"]}),"\n",(0,i.jsxs)(n.p,{children:["[&rest ",(0,i.jsx)(n.em,{children:"var"}),"]"]}),"\n",(0,i.jsxs)(n.p,{children:["[&key*{var |* (",(0,i.jsx)(n.em,{children:"{var |"})," (",(0,i.jsx)(n.em,{children:"keywordvar"}),")",(0,i.jsx)(n.em,{children:"}"})," [",(0,i.jsx)(n.em,{children:"initform"})," [",(0,i.jsx)(n.em,{children:"supplied-p-parameter"}),"] ])",(0,i.jsx)(n.em,{children:"}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:["[",(0,i.jsx)(n.strong,{children:"&allow-other-keys"}),"] ]"]}),"\n",(0,i.jsxs)(n.p,{children:["[&aux ",(0,i.jsx)(n.em,{children:"{var |"})," (",(0,i.jsx)(n.em,{children:"var"})," [",(0,i.jsx)(n.em,{children:"initform"}),"] )",(0,i.jsx)(n.em,{children:"}"}),"*] )"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"parameter-specializer-name"}),"::= ",(0,i.jsx)(n.em,{children:"symbol |"})," (eql ",(0,i.jsx)(n.em,{children:"eql-specializer-form"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"documentation"}),"\u2014a ",(0,i.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"var"}),"\u2014a ",(0,i.jsx)(n.em,{children:"variable name"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"eql-specializer-form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Form"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Initform"}),"\u2014a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Supplied-p-parameter"}),"\u2014variable name."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"new-method"}),"\u2014the new ",(0,i.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"defmethod"})," defines a ",(0,i.jsx)(n.em,{children:"method"})," on a ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If (fboundp ",(0,i.jsx)(n.em,{children:"function-name"}),") is ",(0,i.jsx)(n.strong,{children:"nil"}),", a ",(0,i.jsx)(n.em,{children:"generic function"})," is created with default values for the argument precedence order (each argument is more specific than the arguments to its right in the argument list), for the generic function class (the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),"), for the method class (the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"standard-method"}),"), and for the method combination type (the standard method combination"]}),"\n",(0,i.jsxs)(n.p,{children:["type). The ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"generic function"})," is congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"method"})," being defined; if the ",(0,i.jsx)(n.strong,{children:"defmethod"})," form mentions keyword arguments, the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"generic function"})," will mention &key (but no keyword arguments). If ",(0,i.jsx)(n.em,{children:"function-name"})," names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.em,{children:"generic function"})," is currently named by ",(0,i.jsx)(n.em,{children:"function-name"}),", the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"method"})," must be congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),". If this condition does not hold, an error is signaled. For a definition of congruence in this context, see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.em,{children:"method-qualifier"})," argument is an ",(0,i.jsx)(n.em,{children:"object"})," that is used by method combination to identify the given ",(0,i.jsx)(n.em,{children:"method"}),". The method combination type might further restrict what a method ",(0,i.jsx)(n.em,{children:"qualifier"})," can be. The standard method combination type allows for ",(0,i.jsx)(n.em,{children:"unqualified methods"})," and ",(0,i.jsx)(n.em,{children:"methods"})," whose sole"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"qualifier"})," is one of the keywords ",":before",", ",":after",", or ",":around","."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"specialized-lambda-list"})," argument is like an ordinary ",(0,i.jsx)(n.em,{children:"lambda list"})," except that the ",(0,i.jsx)(n.em,{children:"names"})," of required parameters can be replaced by specialized parameters. A specialized parameter is a list of the form (",(0,i.jsx)(n.em,{children:"var parameter-specializer-name"}),"). Only required parameters can be specialized. If ",(0,i.jsx)(n.em,{children:"parameter-specializer-name"})," is a ",(0,i.jsx)(n.em,{children:"symbol"})," it names a ",(0,i.jsx)(n.em,{children:"class"}),"; if it is a ",(0,i.jsx)(n.em,{children:"list"}),", it is of the form (eql ",(0,i.jsx)(n.em,{children:"eql-specializer-form"}),"). The parameter specializer name (eql ",(0,i.jsx)(n.em,{children:"eql-specializer-form"}),") indicates that the corresponding argument must be ",(0,i.jsx)(n.strong,{children:"eql"})," to the ",(0,i.jsx)(n.em,{children:"object"})," that is the value of ",(0,i.jsx)(n.em,{children:"eql-specializer-form"})," for the ",(0,i.jsx)(n.em,{children:"method"})," to be applicable. The ",(0,i.jsx)(n.em,{children:"eql-specializer-form"})," is evaluated at the time that the expansion of the ",(0,i.jsx)(n.strong,{children:"defmethod"})," macro is evaluated. If no ",(0,i.jsx)(n.em,{children:"parameter specializer name"})," is specified for a given required parameter, the ",(0,i.jsx)(n.em,{children:"parameter specializer"})," defaults to the ",(0,i.jsx)(n.em,{children:"class"})," ",(0,i.jsx)(n.strong,{children:"t"}),". For further discussion, see Section 7.6.2 (Introduction to Methods)."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"form"})," arguments specify the method body. The body of the ",(0,i.jsx)(n.em,{children:"method"})," is enclosed in an ",(0,i.jsx)(n.em,{children:"implicit block"}),". If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"symbol"}),", this block bears the same ",(0,i.jsx)(n.em,{children:"name"})," as the ",(0,i.jsx)(n.em,{children:"generic function"}),". If ",(0,i.jsx)(n.em,{children:"function-name"})," is a ",(0,i.jsx)(n.em,{children:"list"})," of the form (setf ",(0,i.jsx)(n.em,{children:"symbol"}),"), the ",(0,i.jsx)(n.em,{children:"name"})," of the block is ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"class"})," of the ",(0,i.jsx)(n.em,{children:"method object"})," that is created is that given by the method class option of the ",(0,i.jsx)(n.em,{children:"generic function"})," on which the ",(0,i.jsx)(n.em,{children:"method"})," is defined."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.em,{children:"generic function"})," already has a ",(0,i.jsx)(n.em,{children:"method"})," that agrees with the ",(0,i.jsx)(n.em,{children:"method"})," being defined on ",(0,i.jsx)(n.em,{children:"parameter specializers"})," and ",(0,i.jsx)(n.em,{children:"qualifiers"}),", ",(0,i.jsx)(n.strong,{children:"defmethod"})," replaces the existing ",(0,i.jsx)(n.em,{children:"method"})," with the one now being defined. For a definition of agreement in this context. see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"parameter specializers"})," are derived from the ",(0,i.jsx)(n.em,{children:"parameter specializer names"})," as described in Section 7.6.2 (Introduction to Methods)."]}),"\n",(0,i.jsxs)(n.p,{children:["The expansion of the ",(0,i.jsx)(n.strong,{children:"defmethod"})," macro \u201crefers to\u201d each specialized parameter (see the description of ",(0,i.jsx)(n.strong,{children:"ignore"})," within the description of ",(0,i.jsx)(n.strong,{children:"declare"}),"). This includes parameters that have an explicit ",(0,i.jsx)(n.em,{children:"parameter specializer name"})," of ",(0,i.jsx)(n.strong,{children:"t"}),". This means that a compiler warning does not occur if the body of the ",(0,i.jsx)(n.em,{children:"method"})," does not refer to a specialized parameter, while a warning might occur if the body of the ",(0,i.jsx)(n.em,{children:"method"})," does not refer to an unspecialized parameter. For this reason, a parameter that specializes on ",(0,i.jsx)(n.strong,{children:"t"})," is not quite synonymous with an unspecialized parameter in this context."]}),"\n",(0,i.jsxs)(n.p,{children:["Declarations at the head of the method body that apply to the method\u2019s ",(0,i.jsx)(n.em,{children:"lambda variables"})," are treated as ",(0,i.jsx)(n.em,{children:"bound declarations"})," whose ",(0,i.jsx)(n.em,{children:"scope"})," is the same as the corresponding ",(0,i.jsx)(n.em,{children:"bindings"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Declarations at the head of the method body that apply to the functional bindings of ",(0,i.jsx)(n.strong,{children:"call-next-method"})," or ",(0,i.jsx)(n.strong,{children:"next-method-p"})," apply to references to those functions within the method body ",(0,i.jsx)(n.em,{children:"forms"}),". Any outer ",(0,i.jsx)(n.em,{children:"bindings"})," of the ",(0,i.jsx)(n.em,{children:"function names"})," ",(0,i.jsx)(n.strong,{children:"call-next-method"})," and ",(0,i.jsx)(n.strong,{children:"next-method-p"}),", and declarations associated with such ",(0,i.jsx)(n.em,{children:"bindings"})," are ",(0,i.jsx)(n.em,{children:"shadowed"})," <sub>2</sub> within the method body ",(0,i.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"scope"})," of ",(0,i.jsx)(n.em,{children:"free declarations"})," at the head of the method body is the entire method body, which includes any implicit local function definitions but excludes ",(0,i.jsx)(n.em,{children:"initialization forms"})," for the ",(0,i.jsx)(n.em,{children:"lambda variables"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmethod"})," is not required to perform any compile-time side effects. In particular, the ",(0,i.jsx)(n.em,{children:"methods"})," Objects ",(0,i.jsx)(n.strong,{children:"7\u201369"})]}),"\n",(0,i.jsxs)(n.p,{children:["are not installed for invocation during compilation. An ",(0,i.jsx)(n.em,{children:"implementation"})," may choose to store information about the ",(0,i.jsx)(n.em,{children:"generic function"})," for the purposes of compile-time error-checking (such as checking the number of arguments on calls, or noting that a definition for the function name has been seen)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Documentation"})," is attached as a ",(0,i.jsx)(n.em,{children:"documentation string"})," to the ",(0,i.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:["The definition of the referenced ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"function-name"})," names an ",(0,i.jsx)(n.em,{children:"ordinary function"}),", a ",(0,i.jsx)(n.em,{children:"macro"}),", or a ",(0,i.jsx)(n.em,{children:"special operator"})," , an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.em,{children:"generic function"})," is currently named by ",(0,i.jsx)(n.em,{children:"function-name"}),", the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"method"})," must be congruent with the ",(0,i.jsx)(n.em,{children:"lambda list"})," of the ",(0,i.jsx)(n.em,{children:"generic function"}),", or an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defgeneric"}),", ",(0,i.jsx)(n.strong,{children:"documentation"}),", Section 7.6.2 (Introduction to Methods), Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function), Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"find-class"})," ",(0,i.jsx)(n.em,{children:"Accessor"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"find-class"})," ",(0,i.jsx)(n.em,{children:"symbol"})," &optional ",(0,i.jsx)(n.em,{children:"errorp environment \u2192 class"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"(setf (find-class"})," ",(0,i.jsx)(n.em,{children:"symbol"})," &optional ",(0,i.jsx)(n.em,{children:"errorp environment"}),"**)** ",(0,i.jsx)(n.em,{children:"new-class"}),"**)**"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"symbol"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"errorp"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),". The default is ",(0,i.jsx)(n.em,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"environment"})," \u2013 same as the ",(0,i.jsx)(n.strong,{children:"&environment"})," argument to macro expansion functions and is used to distinguish between compile-time and run-time environments. The ",(0,i.jsx)(n.strong,{children:"&environment"})," argument has ",(0,i.jsx)(n.em,{children:"dynamic extent"}),"; the consequences are undefined if the ",(0,i.jsx)(n.strong,{children:"&environment"})," argument is referred to outside the ",(0,i.jsx)(n.em,{children:"dynamic extent"})," of the macro expansion function."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"class"}),"\u2014a ",(0,i.jsx)(n.em,{children:"class object"}),", or ",(0,i.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns the ",(0,i.jsx)(n.em,{children:"class object"})," named by the ",(0,i.jsx)(n.em,{children:"symbol"})," in the ",(0,i.jsx)(n.em,{children:"environment"}),". If there is no such ",(0,i.jsx)(n.em,{children:"class"}),", ",(0,i.jsx)(n.strong,{children:"nil"})," is returned if ",(0,i.jsx)(n.em,{children:"errorp"})," is ",(0,i.jsx)(n.em,{children:"false"}),"; otherwise, if ",(0,i.jsx)(n.em,{children:"errorp"})," is ",(0,i.jsx)(n.em,{children:"true"}),", an error is signaled."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"class"})," associated with a particular ",(0,i.jsx)(n.em,{children:"symbol"})," can be changed by using ",(0,i.jsx)(n.strong,{children:"setf"})," with ",(0,i.jsx)(n.strong,{children:"find-class"}),"; or, if the new ",(0,i.jsx)(n.em,{children:"class"})," given to ",(0,i.jsx)(n.strong,{children:"setf"})," is ",(0,i.jsx)(n.strong,{children:"nil"}),", the ",(0,i.jsx)(n.em,{children:"class"})," association is removed (but the ",(0,i.jsx)(n.em,{children:"class object"})," itself is not affected). The results are undefined if the user attempts to change or remove the ",(0,i.jsx)(n.em,{children:"class"})," associated"]}),"\n",(0,i.jsxs)(n.p,{children:["with a ",(0,i.jsx)(n.em,{children:"symbol"})," that is defined as a ",(0,i.jsx)(n.em,{children:"type specifier"})," in this standard. See Section 4.3.7 (Integrating Types and Classes)."]}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.strong,{children:"setf"})," of ",(0,i.jsx)(n.strong,{children:"find-class"}),", any ",(0,i.jsx)(n.em,{children:"errorp"})," argument is ",(0,i.jsx)(n.em,{children:"evaluated"})," for effect, but any ",(0,i.jsx)(n.em,{children:"values"})," it returns are ignored; the ",(0,i.jsx)(n.em,{children:"errorp parameter"})," is permitted primarily so that the ",(0,i.jsx)(n.em,{children:"environment parameter"})," can be used."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"environment"})," might be used to distinguish between a compile-time and a run-time environment."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["If there is no such ",(0,i.jsx)(n.em,{children:"class"})," and ",(0,i.jsx)(n.em,{children:"errorp"})," is ",(0,i.jsx)(n.em,{children:"true"}),", ",(0,i.jsx)(n.strong,{children:"find-class"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmacro"}),", Section 4.3.7 (Integrating Types and Classes)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"next-method-p"})," ",(0,i.jsx)(n.em,{children:"Local Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"next-method-p"})," ",(0,i.jsx)(n.em,{children:"hno argumentsi \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The locally defined function ",(0,i.jsx)(n.strong,{children:"next-method-p"})," can be used within the body ",(0,i.jsx)(n.em,{children:"forms"})," (but not the ",(0,i.jsx)(n.em,{children:"lambda list"}),") defined by a ",(0,i.jsx)(n.em,{children:"method-defining form"})," to determine whether a next ",(0,i.jsx)(n.em,{children:"method"})," exists."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"next-method-p"})," has ",(0,i.jsx)(n.em,{children:"lexical scope"})," and ",(0,i.jsx)(n.em,{children:"indefinite extent"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Whether or not ",(0,i.jsx)(n.strong,{children:"next-method-p"})," is ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"})," is ",(0,i.jsx)(n.em,{children:"implementation-dependent"}),"; however, the restrictions on redefinition and ",(0,i.jsx)(n.em,{children:"shadowing"})," of ",(0,i.jsx)(n.strong,{children:"next-method-p"})," are the same as for ",(0,i.jsx)(n.em,{children:"symbols"})," in the COMMON-LISP ",(0,i.jsx)(n.em,{children:"package"})," which are ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"}),". The consequences of attempting to use ",(0,i.jsx)(n.strong,{children:"next-method-p"})," outside of a ",(0,i.jsx)(n.em,{children:"method-defining form"})," are undefined."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-next-method"}),", ",(0,i.jsx)(n.strong,{children:"defmethod"}),", ",(0,i.jsx)(n.strong,{children:"call-method"})]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201371"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-method, make-method"})," ",(0,i.jsx)(n.em,{children:"Local Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-method"})," ",(0,i.jsx)(n.em,{children:"method"})," &optional ",(0,i.jsx)(n.em,{children:"next-method-list \u2192 {result}"}),"*"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"make-method"})," ",(0,i.jsx)(n.em,{children:"form \u2192 method-object"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method"}),"\u2014a ",(0,i.jsx)(n.em,{children:"method object"}),", or a ",(0,i.jsx)(n.em,{children:"list"})," (see below); not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-object"}),"\u2014a ",(0,i.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"next-method-list"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of ",(0,i.jsx)(n.em,{children:"method objects"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"results"}),"\u2014the ",(0,i.jsx)(n.em,{children:"values"})," returned by the ",(0,i.jsx)(n.em,{children:"method"})," invocation."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"call-method"})," is used in method combination. It hides the ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," details of how ",(0,i.jsx)(n.em,{children:"methods"})," are called. The macro ",(0,i.jsx)(n.strong,{children:"call-method"})," has ",(0,i.jsx)(n.em,{children:"lexical scope"})," and can only be used within an ",(0,i.jsx)(n.em,{children:"effective method form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Whether or not ",(0,i.jsx)(n.strong,{children:"call-method"})," is ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"})," is ",(0,i.jsx)(n.em,{children:"implementation-dependent"}),"; however, the restrictions on redefinition and ",(0,i.jsx)(n.em,{children:"shadowing"})," of ",(0,i.jsx)(n.strong,{children:"call-method"})," are the same as for ",(0,i.jsx)(n.em,{children:"symbols"})," in the COMMON-LISP ",(0,i.jsx)(n.em,{children:"package"})," which are ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"}),". The consequences of attempting to use ",(0,i.jsx)(n.strong,{children:"call-method"})," outside of an ",(0,i.jsx)(n.em,{children:"effective method form"})," are undefined."]}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"call-method"})," invokes the specified ",(0,i.jsx)(n.em,{children:"method"}),", supplying it with arguments and with definitions for ",(0,i.jsx)(n.strong,{children:"call-next-method"})," and for ",(0,i.jsx)(n.strong,{children:"next-method-p"}),". If the invocation of ",(0,i.jsx)(n.strong,{children:"call-method"})," is lexically inside of a ",(0,i.jsx)(n.strong,{children:"make-method"}),", the arguments are those that were supplied to that method. Otherwise the arguments are those that were supplied to the generic function. The definitions of ",(0,i.jsx)(n.strong,{children:"call-next-method"})," and ",(0,i.jsx)(n.strong,{children:"next-method-p"})," rely on the specified ",(0,i.jsx)(n.em,{children:"next-method-list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"method"})," is a ",(0,i.jsx)(n.em,{children:"list"}),", the first element of the ",(0,i.jsx)(n.em,{children:"list"})," must be the symbol ",(0,i.jsx)(n.strong,{children:"make-method"})," and the second element must be a ",(0,i.jsx)(n.em,{children:"form"}),". Such a ",(0,i.jsx)(n.em,{children:"list"})," specifies a ",(0,i.jsx)(n.em,{children:"method object"})," whose ",(0,i.jsx)(n.em,{children:"method"})," function has a body that is the given ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Next-method-list"})," can contain ",(0,i.jsx)(n.em,{children:"method objects"})," or ",(0,i.jsx)(n.em,{children:"lists"}),", the first element of which must be the symbol ",(0,i.jsx)(n.strong,{children:"make-method"})," and the second element of which must be a ",(0,i.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Those are the only two places where ",(0,i.jsx)(n.strong,{children:"make-method"})," can be used. The ",(0,i.jsx)(n.em,{children:"form"})," used with ",(0,i.jsx)(n.strong,{children:"make-method"})," is evaluated in the ",(0,i.jsx)(n.em,{children:"null lexical environment"})," augmented with a local macro definition for ",(0,i.jsx)(n.strong,{children:"call-method"})," and with bindings named by symbols not ",(0,i.jsx)(n.em,{children:"accessible"})," from the COMMON-LISP-USER ",(0,i.jsx)(n.em,{children:"package"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"call-next-method"})," function available to ",(0,i.jsx)(n.em,{children:"method"})," will call the first ",(0,i.jsx)(n.em,{children:"method"})," in ",(0,i.jsx)(n.em,{children:"next-method-list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"call-next-method"})," function available in that ",(0,i.jsx)(n.em,{children:"method"}),", in turn, will call the second ",(0,i.jsx)(n.em,{children:"method"})," in ",(0,i.jsx)(n.em,{children:"next-method-list"}),", and so on, until the list of next ",(0,i.jsx)(n.em,{children:"methods"})," is exhausted."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"next-method-list"})," is not supplied, the ",(0,i.jsx)(n.strong,{children:"call-next-method"})," function available to ",(0,i.jsx)(n.em,{children:"method"})," signals an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"control-error"})," and the ",(0,i.jsx)(n.strong,{children:"next-method-p"})," function available to ",(0,i.jsx)(n.em,{children:"method"})," returns ",(0,i.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-next-method"}),", ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),", ",(0,i.jsx)(n.strong,{children:"next-method-p"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-next-method"})," ",(0,i.jsx)(n.em,{children:"Local Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-next-method"})," &rest ",(0,i.jsx)(n.em,{children:"args \u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"arg"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"results"}),"\u2014the ",(0,i.jsx)(n.em,{children:"values"})," returned by the ",(0,i.jsx)(n.em,{children:"method"})," it calls."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"call-next-method"})," can be used within the body ",(0,i.jsx)(n.em,{children:"forms"})," (but not the ",(0,i.jsx)(n.em,{children:"lambda list"}),") of a ",(0,i.jsx)(n.em,{children:"method"})," defined by a ",(0,i.jsx)(n.em,{children:"method-defining form"})," to call the ",(0,i.jsx)(n.em,{children:"next method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If there is no next ",(0,i.jsx)(n.em,{children:"method"}),", the generic function ",(0,i.jsx)(n.strong,{children:"no-next-method"})," is called."]}),"\n",(0,i.jsxs)(n.p,{children:["The type of method combination used determines which ",(0,i.jsx)(n.em,{children:"methods"})," can invoke ",(0,i.jsx)(n.strong,{children:"call-next-method"}),". The standard ",(0,i.jsx)(n.em,{children:"method combination"})," type allows ",(0,i.jsx)(n.strong,{children:"call-next-method"})," to be used within primary ",(0,i.jsx)(n.em,{children:"methods"})," and ",(0,i.jsx)(n.em,{children:"around methods"}),". For generic functions using a type of method combination defined by the short form of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),", ",(0,i.jsx)(n.strong,{children:"call-next-method"})," can be used in ",(0,i.jsx)(n.em,{children:"around methods"})," only."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called with no arguments, it passes the current ",(0,i.jsx)(n.em,{children:"method"}),"\u2019s original arguments to the next ",(0,i.jsx)(n.em,{children:"method"}),". Neither argument defaulting, nor using ",(0,i.jsx)(n.strong,{children:"setq"}),", nor rebinding variables with the same ",(0,i.jsx)(n.em,{children:"names"})," as parameters of the ",(0,i.jsx)(n.em,{children:"method"})," affects the values ",(0,i.jsx)(n.strong,{children:"call-next-method"})," passes to the ",(0,i.jsx)(n.em,{children:"method"})," it calls."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called with arguments, the ",(0,i.jsx)(n.em,{children:"next method"})," is called with those arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is called with arguments but omits optional arguments, the ",(0,i.jsx)(n.em,{children:"next method"})," called defaults those arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"call-next-method"})," returns any ",(0,i.jsx)(n.em,{children:"values"})," that are returned by the ",(0,i.jsx)(n.em,{children:"next method"}),". Objects ",(0,i.jsx)(n.strong,{children:"7\u201373"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"call-next-method"})," has ",(0,i.jsx)(n.em,{children:"lexical scope"})," and ",(0,i.jsx)(n.em,{children:"indefinite extent"})," and can only be used within the body of a ",(0,i.jsx)(n.em,{children:"method"})," defined by a ",(0,i.jsx)(n.em,{children:"method-defining form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Whether or not ",(0,i.jsx)(n.strong,{children:"call-next-method"})," is ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"})," is ",(0,i.jsx)(n.em,{children:"implementation-dependent"}),"; however, the restrictions on redefinition and ",(0,i.jsx)(n.em,{children:"shadowing"})," of ",(0,i.jsx)(n.strong,{children:"call-next-method"})," are the same as for ",(0,i.jsx)(n.em,{children:"symbols"})," in the COMMON-LISP ",(0,i.jsx)(n.em,{children:"package"})," which are ",(0,i.jsx)(n.em,{children:"fbound"})," in the ",(0,i.jsx)(n.em,{children:"global environment"}),". The consequences of attempting to use ",(0,i.jsx)(n.strong,{children:"call-next-method"})," outside of a ",(0,i.jsx)(n.em,{children:"method-defining form"})," are undefined."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"defmethod"}),", ",(0,i.jsx)(n.strong,{children:"call-method"}),", ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["When providing arguments to ",(0,i.jsx)(n.strong,{children:"call-next-method"}),", the following rule must be satisfied or an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"error"})," should be signaled: the ordered set of ",(0,i.jsx)(n.em,{children:"applicable methods"})," for a changed set of arguments for ",(0,i.jsx)(n.strong,{children:"call-next-method"})," must be the same as the ordered set of ",(0,i.jsx)(n.em,{children:"applicable methods"})," for the original arguments to the ",(0,i.jsx)(n.em,{children:"generic function"}),". Optimizations of the error checking are possible, but they must not change the semantics of ",(0,i.jsx)(n.strong,{children:"call-next-method"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"define-method-combination"}),", ",(0,i.jsx)(n.strong,{children:"defmethod"}),", ",(0,i.jsx)(n.strong,{children:"next-method-p"}),", ",(0,i.jsx)(n.strong,{children:"no-next-method"}),", ",(0,i.jsx)(n.strong,{children:"call-method"}),", Section 7.6.6 (Method Selection and Combination), Section 7.6.6.2 (Standard Method Combination), Section 7.6.6.4 (Built-in Method Combination Types)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compute-applicable-methods"})," ",(0,i.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compute-applicable-methods"})," ",(0,i.jsx)(n.em,{children:"generic-function function-arguments \u2192 methods"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"compute-applicable-methods"})," (",(0,i.jsx)(n.em,{children:"generic-function"})," ",(0,i.jsx)(n.strong,{children:"standard-generic-function"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"function-arguments"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of arguments for the ",(0,i.jsx)(n.em,{children:"generic-function"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"methods"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"})," of ",(0,i.jsx)(n.em,{children:"method objects"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Given a ",(0,i.jsx)(n.em,{children:"generic-function"})," and a set of ",(0,i.jsx)(n.em,{children:"function-arguments"}),", the function ",(0,i.jsx)(n.strong,{children:"compute-applicable-methods"})," returns the set of ",(0,i.jsx)(n.em,{children:"methods"})," that are applicable for those arguments sorted according to precedence order. See Section 7.6.6 (Method Selection and Combination)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(n.p,{children:"Section 7.6.6 (Method Selection and Combination)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"define-method-combination"})," ",(0,i.jsx)(n.em,{children:"Macro"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"define-method-combination"})," ",(0,i.jsx)(n.em,{children:"name"})," [[ ",(0,i.jsx)(n.em,{children:"\u2193short-form-option"})," ]]"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 name"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"define-method-combination"})," ",(0,i.jsx)(n.em,{children:"name lambda-list"})]}),"\n",(0,i.jsxs)(n.p,{children:["(",(0,i.jsx)(n.em,{children:"{method-group-specifier}"}),"*)"]}),"\n",(0,i.jsxs)(n.p,{children:["[(",":arguments"," ",(0,i.jsx)(n.em,{children:". args-lambda-list"}),")]"]}),"\n",(0,i.jsxs)(n.p,{children:["[(",":generic-function"," ",(0,i.jsx)(n.em,{children:"generic-function-symbol"}),")]"]}),"\n",(0,i.jsxs)(n.p,{children:["[[ ",(0,i.jsx)(n.em,{children:"{declaration}"}),"* ",(0,i.jsx)(n.em,{children:"| documentation"})," ]]"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"{form}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"\u2192 name"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"short-form-option::"}),"=",":documentation"," ",(0,i.jsx)(n.em,{children:"documentation |"})]}),"\n",(0,i.jsxs)(n.p,{children:[":identity-with-one-argument"," ",(0,i.jsx)(n.em,{children:"identity-with-one-argument |"})]}),"\n",(0,i.jsxs)(n.p,{children:[":operator"," ",(0,i.jsx)(n.em,{children:"operator"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"method-group-specifier::"}),"=(",(0,i.jsx)(n.em,{children:"name {{qualifier-pattern}"}),"<sup>+</sup>",(0,i.jsx)(n.em,{children:"| predicate}"})," [[ ",(0,i.jsx)(n.em,{children:"\u2193long-form-option"})," ]])"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"long-form-option::"}),"=",":description"," ",(0,i.jsx)(n.em,{children:"description |"})]}),"\n",(0,i.jsxs)(n.p,{children:[":order"," ",(0,i.jsx)(n.em,{children:"order |"})]}),"\n",(0,i.jsxs)(n.p,{children:[":required"," ",(0,i.jsx)(n.em,{children:"required-p"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"args-lambda-list"}),"\u2014a ",(0,i.jsx)(n.em,{children:"define-method-combination arguments lambda list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"description"}),"\u2014a ",(0,i.jsx)(n.em,{children:"format control"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"documentation"}),"\u2014a ",(0,i.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"forms"}),"\u2014an ",(0,i.jsx)(n.em,{children:"implicit progn"})," that must compute and return the ",(0,i.jsx)(n.em,{children:"form"})," that specifies how the ",(0,i.jsx)(n.em,{children:"methods"})," are combined, that is, the ",(0,i.jsx)(n.em,{children:"effective method"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201375"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"define-method-combination"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"generic-function-symbol"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"identity-with-one-argument"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"lambda-list"}),"\u2014",(0,i.jsx)(n.em,{children:"ordinary lambda list"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"name"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"}),". Non-",(0,i.jsx)(n.em,{children:"keyword"}),", ",(0,i.jsx)(n.em,{children:"non-nil symbols"})," are usually used."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"operator"}),"\u2014an ",(0,i.jsx)(n.em,{children:"operator"})," . ",(0,i.jsx)(n.em,{children:"Name"})," and ",(0,i.jsx)(n.em,{children:"operator"})," are often the ",(0,i.jsx)(n.em,{children:"same symbol"}),". This is the default, but it is not required."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"order"}),"\u2014",":most-specific-first"," or ",":most-specific-last","; evaluated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"predicate"}),"\u2014a ",(0,i.jsx)(n.em,{children:"symbol"})," that names a ",(0,i.jsx)(n.em,{children:"function"})," of one argument that returns a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),". ",(0,i.jsx)(n.em,{children:"qualifier-pattern"}),"\u2014a ",(0,i.jsx)(n.em,{children:"list"}),", or the ",(0,i.jsx)(n.em,{children:"symbol"})," ",(0,i.jsx)(n.strong,{children:"*"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"required-p"}),"\u2014a ",(0,i.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["The macro ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," is used to define new types of method combination."]}),"\n",(0,i.jsxs)(n.p,{children:["There are two forms of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),". The short form is a simple facility for the cases that are expected to be most commonly needed. The long form is more powerful but more verbose. It resembles ",(0,i.jsx)(n.strong,{children:"defmacro"})," in that the body is an expression, usually using backquote, that computes a ",(0,i.jsx)(n.em,{children:"form"}),". Thus arbitrary control structures can be implemented. The long form also allows"]}),"\n",(0,i.jsxs)(n.p,{children:["arbitrary processing of method ",(0,i.jsx)(n.em,{children:"qualifiers"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Short Form"})}),"\n",(0,i.jsxs)(n.p,{children:["The short form syntax of ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," is recognized when the sec ond ",(0,i.jsx)(n.em,{children:"subform"})," is a ",(0,i.jsx)(n.em,{children:"non-nil"})," symbol or is not present. When the short form is"]}),"\n",(0,i.jsxs)(n.p,{children:["used, ",(0,i.jsx)(n.em,{children:"name"})," is defined as a type of method combination that produces a Lisp form (",(0,i.jsx)(n.em,{children:"operator method-call method-call . . ."}),"). The ",(0,i.jsx)(n.em,{children:"operator"})," is a ",(0,i.jsx)(n.em,{children:"symbol"})," that can be the ",(0,i.jsx)(n.em,{children:"name"})," of a ",(0,i.jsx)(n.em,{children:"function"}),", ",(0,i.jsx)(n.em,{children:"macro"}),", or ",(0,i.jsx)(n.em,{children:"special operator"})," . The ",(0,i.jsx)(n.em,{children:"operator"})," can be supplied by a keyword option; it defaults to ",(0,i.jsx)(n.em,{children:"name"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Keyword options for the short form are the following:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":documentation"," option is used to document the method-combination type; see description of long form below."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":identity-with-one-argument"," option enables an optimization when its value is ",(0,i.jsx)(n.em,{children:"true"})," (the default is ",(0,i.jsx)(n.em,{children:"false"}),"). If there is exactly one applicable method and it is a"]}),"\n",(0,i.jsxs)(n.p,{children:["primary method, that method serves as the effective method and ",(0,i.jsx)(n.em,{children:"operator"})," is not"]}),"\n",(0,i.jsx)(n.p,{children:"called. This optimization avoids the need to create a new effective method and"}),"\n",(0,i.jsxs)(n.p,{children:["avoids the overhead of a ",(0,i.jsx)(n.em,{children:"function"})," call. This option is designed to be used with"]}),"\n",(0,i.jsxs)(n.p,{children:["operators such as ",(0,i.jsx)(n.strong,{children:"progn"}),", ",(0,i.jsx)(n.strong,{children:"and"}),", +, and ",(0,i.jsx)(n.strong,{children:"max"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"define-method-combination"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":operator"," option specifies the ",(0,i.jsx)(n.em,{children:"name"})," of the operator. The ",(0,i.jsx)(n.em,{children:"operator"})," argument is a ",(0,i.jsx)(n.em,{children:"symbol"})," that can be the ",(0,i.jsx)(n.em,{children:"name"})," of a ",(0,i.jsx)(n.em,{children:"function"}),", ",(0,i.jsx)(n.em,{children:"macro"}),", or ",(0,i.jsx)(n.em,{children:"special form"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["These types of method combination require exactly one ",(0,i.jsx)(n.em,{children:"qualifier"})," per method. An error is signaled if there are applicable methods with no ",(0,i.jsx)(n.em,{children:"qualifiers"})," or with ",(0,i.jsx)(n.em,{children:"qualifiers"})," that are not supported by the method combination type."]}),"\n",(0,i.jsxs)(n.p,{children:["A method combination procedure defined in this way recognizes two roles for methods. A method whose one ",(0,i.jsx)(n.em,{children:"qualifier"})," is the symbol naming this type of method combination is defined to be a primary method. At least one primary method must be applicable or an error is signaled. A method with ",":around"," as its one ",(0,i.jsx)(n.em,{children:"qualifier"})," is an auxiliary method that behaves the same as an ",(0,i.jsx)(n.em,{children:"around method"})," in standard method combination. The ",(0,i.jsx)(n.em,{children:"function"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"call-next-method"})," can only be used in ",(0,i.jsx)(n.em,{children:"around methods"}),"; it cannot be used in primary methods defined by the short form of the ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," macro."]}),"\n",(0,i.jsxs)(n.p,{children:["A method combination procedure defined in this way accepts an optional argument named ",(0,i.jsx)(n.em,{children:"order"}),", which defaults to ",":most-specific-first",". A value of ",":most-specific-last"," reverses the order of the primary methods without affecting the order of the auxiliary methods."]}),"\n",(0,i.jsxs)(n.p,{children:["The short form automatically includes error checking and support for ",(0,i.jsx)(n.em,{children:"around methods"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For a discussion of built-in method combination types, see Section 7.6.6.4 (Built-in Method Combination Types)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Long Form"})}),"\n",(0,i.jsxs)(n.p,{children:["The long form syntax of ",(0,i.jsx)(n.strong,{children:"define-method-combination"})," is recognized when the second ",(0,i.jsx)(n.em,{children:"subform"})," is a list."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"lambda-list"})," receives any arguments provided after the ",(0,i.jsx)(n.em,{children:"name"})," of the method combination type in the ",":method-combination"," option to ",(0,i.jsx)(n.strong,{children:"defgeneric"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A list of method group specifiers follows. Each specifier selects a subset of the applicable methods to play a particular role, either by matching their ",(0,i.jsx)(n.em,{children:"qualifiers"})," against some patterns or by testing their ",(0,i.jsx)(n.em,{children:"qualifiers"})," with a ",(0,i.jsx)(n.em,{children:"predicate"}),". These method group specifiers define all method ",(0,i.jsx)(n.em,{children:"qualifiers"})," that can be used with this type of method combination."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"car"})," of each ",(0,i.jsx)(n.em,{children:"method-group-specifier"})," is a ",(0,i.jsx)(n.em,{children:"symbol"})," which ",(0,i.jsx)(n.em,{children:"names"})," a ",(0,i.jsx)(n.em,{children:"variable"}),". During the execution of the ",(0,i.jsx)(n.em,{children:"forms"})," in the body of ",(0,i.jsx)(n.strong,{children:"define-method-combination"}),", this ",(0,i.jsx)(n.em,{children:"variable"})," is bound to a list of the ",(0,i.jsx)(n.em,{children:"methods"})," in the method group. The ",(0,i.jsx)(n.em,{children:"methods"})," in this list occur in the order specified by the ",":order"," option."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," is a ",(0,i.jsx)(n.em,{children:"symbol"})," it must be ",(0,i.jsx)(n.strong,{children:"*"}),". A method matches a ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," if the method\u2019s list of ",(0,i.jsx)(n.em,{children:"qualifiers"})," is ",(0,i.jsx)(n.strong,{children:"equal"})," to the ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," (except that the symbol ",(0,i.jsx)(n.strong,{children:"*"})," in a ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," matches anything). Thus a ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," can be one of the following: the ",(0,i.jsx)(n.em,{children:"empty list"}),", which matches ",(0,i.jsx)(n.em,{children:"unqualified methods"}),"; the symbol ",(0,i.jsx)(n.strong,{children:"*"}),", which matches all methods; a true list, which matches methods with the same number of ",(0,i.jsx)(n.em,{children:"qualifiers"})," as the length of the list when each ",(0,i.jsx)(n.em,{children:"qualifier"})," matches the corresponding list element; or a dotted list that ends"]}),"\n",(0,i.jsxs)(n.p,{children:["Objects ",(0,i.jsx)(n.strong,{children:"7\u201377"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"define-method-combination"})}),"\n",(0,i.jsxs)(n.p,{children:["in the symbol ",(0,i.jsx)(n.strong,{children:"*"})," (the ",(0,i.jsx)(n.strong,{children:"*"})," matches any number of additional ",(0,i.jsx)(n.em,{children:"qualifiers"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Each applicable method is tested against the ",(0,i.jsx)(n.em,{children:"qualifier-patterns"})," and ",(0,i.jsx)(n.em,{children:"predicates"})," in left-to-right order. As soon as a ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," matches or a ",(0,i.jsx)(n.em,{children:"predicate"})," returns true, the method becomes a member of the corresponding method group and no further tests are made. Thus if a method could be a member of more than one method group, it joins only the first such group. If a method group has more than one ",(0,i.jsx)(n.em,{children:"qualifier-pattern"}),", a method need only satisfy one of the ",(0,i.jsx)(n.em,{children:"qualifier-patterns"})," to be a member of the group."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"name"})," of a ",(0,i.jsx)(n.em,{children:"predicate"})," function can appear instead of ",(0,i.jsx)(n.em,{children:"qualifier-patterns"})," in a method group specifier. The ",(0,i.jsx)(n.em,{children:"predicate"})," is called for each method that has not been assigned to an earlier method group; it is called with one argument, the method\u2019s ",(0,i.jsx)(n.em,{children:"qualifier list"}),". The ",(0,i.jsx)(n.em,{children:"predicate"})," should return true if the method is to be a member of the method group. A ",(0,i.jsx)(n.em,{children:"predicate"})," can be distinguished from a ",(0,i.jsx)(n.em,{children:"qualifier-pattern"})," because it is a ",(0,i.jsx)(n.em,{children:"symbol"})," other than ",(0,i.jsx)(n.strong,{children:"nil"})," or ",(0,i.jsx)(n.strong,{children:"*"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If there is an applicable method that does not fall into any method group, the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"invalid-method-error"})," is called."]}),"\n",(0,i.jsxs)(n.p,{children:["Method group specifiers can have keyword options following the ",(0,i.jsx)(n.em,{children:"qualifier"})," patterns or predicate. Keyword options can be distinguished from additional ",(0,i.jsx)(n.em,{children:"qualifier"})," patterns because they are neither lists nor the symbol ",(0,i.jsx)(n.strong,{children:"*"}),". The keyword options are as follows:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":description"," option is used to provide a description of the role of methods in the method group. Programming environment tools use (apply #\u2019format stream"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"format-control"})," (method-qualifiers ",(0,i.jsx)(n.em,{children:"method"}),")) to print this description, which is"]}),"\n",(0,i.jsx)(n.p,{children:"expected to be concise. This keyword option allows the description of a method"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"qualifier"})," to be defined in the same module that defines the meaning of the method"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"qualifier"})," . In most cases, ",(0,i.jsx)(n.em,{children:"format-control"})," will not contain any ",(0,i.jsx)(n.strong,{children:"format"})," directives,"]}),"\n",(0,i.jsxs)(n.p,{children:["but they are available for generality. If ",":description"," is not supplied, a default"]}),"\n",(0,i.jsxs)(n.p,{children:["description is generated based on the variable name and the ",(0,i.jsx)(n.em,{children:"qualifier"})," patterns and"]}),"\n",(0,i.jsxs)(n.p,{children:["on whether this method group includes the ",(0,i.jsx)(n.em,{children:"unqualified methods"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":order"," option specifies the order of methods. The ",(0,i.jsx)(n.em,{children:"order"})," argument is a ",(0,i.jsx)(n.em,{children:"form"})," that evaluates to ",":most-specific-first"," or ",":most-specific-last",". If it evaluates"]}),"\n",(0,i.jsxs)(n.p,{children:["to any other value, an error is signaled. If ",":order"," is not supplied, it defaults to"]}),"\n",(0,i.jsxs)(n.p,{children:[":most-specific-first","."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"\u2022"})," The ",":required"," option specifies whether at least one method in this method group is required. If its value is ",(0,i.jsx)(n.em,{children:"true"})," and the method group is empty (that is, no"]}),"\n",(0,i.jsxs)(n.p,{children:["applicable methods match the ",(0,i.jsx)(n.em,{children:"qualifier"})," patterns or satisfy the predicate), an error"]}),"\n",(0,i.jsxs)(n.p,{children:["is signaled. If ",":required"," is not supplied, it defaults to ",(0,i.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The use of method group specifiers provides a convenient syntax to select methods, to divide them among the possible roles, and to perform the necessary error checking. It is possible to perform further filtering of methods in the body ",(0,i.jsx)(n.em,{children:"forms"})," by using normal list-processing operations and the functions ",(0,i.jsx)(n.strong,{children:"method-qualifiers"})," and ",(0,i.jsx)(n.strong,{children:"invalid-method-error"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It is permissible to use ",(0,i.jsx)(n.strong,{children:"setq"})," on the variables named in the method group specifiers and"]})]})}function N(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(D,{...e})}):D(e)}const G={title:"7.6 Generic Functions and Methods"},P="7.6 Generic Functions and Methods",R={id:"chap-7/h-g-generic-functions-and-methods",title:"7.6 Generic Functions and Methods",description:"7.6.1 Introduction to Generic Functions",source:"@site/docs/chap-7/h-g-generic-functions-and-methods.md",sourceDirName:"chap-7",slug:"/chap-7/h-g-generic-functions-and-methods",permalink:"/cl-language-reference/docs/chap-7/h-g-generic-functions-and-methods",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chap-7/h-g-generic-functions-and-methods.md",tags:[],version:"current",frontMatter:{title:"7.6 Generic Functions and Methods"},sidebar:"tutorialSidebar",previous:{title:"7.5 Slots",permalink:"/cl-language-reference/docs/chap-7/h-f-slots"},next:{title:"intro",permalink:"/cl-language-reference/docs/chap-7/intro"}},L={},V=[{value:"7.6.1 Introduction to Generic Functions",id:"761-introduction-to-generic-functions",level:2},{value:"7.6.2 Introduction to Methods",id:"762-introduction-to-methods",level:2},{value:"7.6.3 Agreement on Parameter Specializers and Qualifiers",id:"763-agreement-on-parameter-specializers-and-qualifiers",level:2},{value:"7.6.4 Congruent Lambda",id:"764-congruent-lambda",level:2},{value:"7.6.5 Keyword Arguments in Generic Functions and Methods",id:"765-keyword-arguments-in-generic-functions-and-methods",level:2},{value:"7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods",id:"7651-examples-of-keyword-arguments-in-generic-functions-and-methods",level:3},{value:"7.6.6 Method Selection and Combination",id:"766-method-selection-and-combination",level:2},{value:"7.6.6.1 Determining the Effective Method",id:"7661-determining-the-effective-method",level:3},{value:"7.6.6.1.1 Selecting the Applicable Methods",id:"76611-selecting-the-applicable-methods",level:4},{value:"7.6.6.1.2 Sorting the Applicable Methods by Precedence Order",id:"76612-sorting-the-applicable-methods-by-precedence-order",level:4},{value:"7.6.6.1.3 Applying method combination to the sorted list of applicable methods",id:"76613-applying-method-combination-to-the-sorted-list-of-applicable-methods",level:4},{value:"7.6.6.2 Standard Method Combination",id:"7662-standard-method-combination",level:3},{value:"7.6.6.3 Declarative Method Combination",id:"7663-declarative-method-combination",level:3},{value:"7.6.6.4 Built",id:"7664-built",level:3},{value:"7.6.7 Inheritance of Methods",id:"767-inheritance-of-methods",level:2}];function B(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"76-generic-functions-and-methods",children:"7.6 Generic Functions and Methods"}),"\n","\n",(0,i.jsx)(l,{}),"\n",(0,i.jsx)(n.h2,{id:"761-introduction-to-generic-functions",children:"7.6.1 Introduction to Generic Functions"}),"\n","\n",(0,i.jsx)(o,{}),"\n",(0,i.jsx)(n.h2,{id:"762-introduction-to-methods",children:"7.6.2 Introduction to Methods"}),"\n","\n",(0,i.jsx)(h,{}),"\n",(0,i.jsx)(n.h2,{id:"763-agreement-on-parameter-specializers-and-qualifiers",children:"7.6.3 Agreement on Parameter Specializers and Qualifiers"}),"\n","\n",(0,i.jsx)(m,{}),"\n",(0,i.jsx)(n.h2,{id:"764-congruent-lambda",children:"7.6.4 Congruent Lambda"}),"\n","\n",(0,i.jsx)(j,{}),"\n",(0,i.jsx)(n.h2,{id:"765-keyword-arguments-in-generic-functions-and-methods",children:"7.6.5 Keyword Arguments in Generic Functions and Methods"}),"\n","\n",(0,i.jsx)(f,{}),"\n",(0,i.jsx)(n.h3,{id:"7651-examples-of-keyword-arguments-in-generic-functions-and-methods",children:"7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods"}),"\n","\n",(0,i.jsx)(g,{}),"\n",(0,i.jsx)(n.h2,{id:"766-method-selection-and-combination",children:"7.6.6 Method Selection and Combination"}),"\n","\n",(0,i.jsx)(y,{}),"\n",(0,i.jsx)(n.h3,{id:"7661-determining-the-effective-method",children:"7.6.6.1 Determining the Effective Method"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(n.h4,{id:"76611-selecting-the-applicable-methods",children:"7.6.6.1.1 Selecting the Applicable Methods"}),"\n","\n",(0,i.jsx)(k,{}),"\n",(0,i.jsx)(n.h4,{id:"76612-sorting-the-applicable-methods-by-precedence-order",children:"7.6.6.1.2 Sorting the Applicable Methods by Precedence Order"}),"\n","\n",(0,i.jsx)(S,{}),"\n",(0,i.jsx)(n.h4,{id:"76613-applying-method-combination-to-the-sorted-list-of-applicable-methods",children:"7.6.6.1.3 Applying method combination to the sorted list of applicable methods"}),"\n","\n",(0,i.jsx)(A,{}),"\n",(0,i.jsx)(n.h3,{id:"7662-standard-method-combination",children:"7.6.6.2 Standard Method Combination"}),"\n","\n",(0,i.jsx)(M,{}),"\n",(0,i.jsx)(n.h3,{id:"7663-declarative-method-combination",children:"7.6.6.3 Declarative Method Combination"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(n.h3,{id:"7664-built",children:"7.6.6.4 Built"}),"\n","\n",(0,i.jsx)(O,{}),"\n",(0,i.jsx)(n.h2,{id:"767-inheritance-of-methods",children:"7.6.7 Inheritance of Methods"}),"\n","\n","\n",(0,i.jsx)(N,{})]})}function W(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(B,{...e})}):B(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>l});var i=s(7294);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);