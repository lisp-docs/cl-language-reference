"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[69276],{21186:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>x,frontMatter:()=>o,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"chap-9/j-c-dictionary/handler-bind_macro","title":"handler-bind","description":"Expanded Reference: handler-bind","source":"@site/docs/chap-9/j-c-dictionary/handler-bind_macro.md","sourceDirName":"chap-9/j-c-dictionary","slug":"/chap-9/j-c-dictionary/handler-bind_macro","permalink":"/cl-language-reference/chap-9/j-c-dictionary/handler-bind_macro","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-9/j-c-dictionary/handler-bind_macro.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"handler-bind"},"sidebar":"tutorialSidebar","previous":{"title":"find-restart","permalink":"/cl-language-reference/chap-9/j-c-dictionary/find-restart_function"},"next":{"title":"handler-case","permalink":"/cl-language-reference/chap-9/j-c-dictionary/handler-case_macro"}}');var s=r(74848),t=r(28453);function d(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:r,GlossaryTerm:i}=n;return r||l("DictionaryLink",!0),i||l("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"handler-bind"})," ",(0,s.jsx)(i,{styled:!0,term:"macro",children:(0,s.jsx)("i",{children:"Macro"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{styled:!0,term:"handler-bind",children:(0,s.jsx)("b",{children:"handler-bind"})})," (",(0,s.jsx)(i,{styled:!0,term:"binding",children:(0,s.jsx)("i",{children:"{\u2193binding}"})}),"*) ",(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"{form}"})}),"* \u2192 {result}*"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{styled:!0,term:"binding",children:(0,s.jsx)("i",{children:"binding::"})}),"=(",(0,s.jsx)(n.em,{children:"type handler"}),")"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})}),"\u2014a ",(0,s.jsx)(i,{styled:!0,term:"type specifier",children:(0,s.jsx)("i",{children:"type specifier"})})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})}),"\u2014a ",(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"form"})}),"; evaluated to produce a ",(0,s.jsx)(n.em,{children:"handler-function"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"handler-function"}),"\u2014a ",(0,s.jsx)(i,{styled:!0,term:"designator",children:(0,s.jsx)("i",{children:"designator"})})," for a ",(0,s.jsx)(i,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"function"})})," of one ",(0,s.jsx)(i,{styled:!0,term:"argument",children:(0,s.jsx)("i",{children:"argument"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"forms"})}),"\u2014an ",(0,s.jsx)(i,{styled:!0,term:"implicit progn",children:(0,s.jsx)("i",{children:"implicit progn"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"results"}),"\u2014the ",(0,s.jsx)(i,{styled:!0,term:"value",children:(0,s.jsx)("i",{children:"values"})})," returned by the ",(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"forms"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["Executes ",(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"forms"})})," in a ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," where the indicated ",(0,s.jsx)(n.em,{children:"handler bindings"})," are in effect."]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})})," should evaluate to a ",(0,s.jsx)(n.em,{children:"handler-function"}),", which is used to handle ",(0,s.jsx)(i,{styled:!0,term:"condition",children:(0,s.jsx)("i",{children:"conditions"})})," of the given ",(0,s.jsx)(i,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})})," during execution of the ",(0,s.jsx)(i,{styled:!0,term:"form",children:(0,s.jsx)("i",{children:"forms"})}),". This ",(0,s.jsx)(i,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"function"})})," should take a single argument, the ",(0,s.jsx)(i,{styled:!0,term:"condition",children:(0,s.jsx)("i",{children:"condition"})})," being signaled."]}),"\n",(0,s.jsxs)(n.p,{children:["If more than one ",(0,s.jsx)(n.em,{children:"handler binding"})," is supplied, the ",(0,s.jsx)(n.em,{children:"handler bindings"})," are searched sequentially from top to bottom in search of a match (by visual analogy with ",(0,s.jsx)(r,{styled:!0,term:"typecase",children:(0,s.jsx)("b",{children:"typecase"})}),"). If an appropriate ",(0,s.jsx)(i,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})})," is found, the associated handler is run in a ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," where none of these ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})})," bindings are visible (to avoid recursive errors). If the ",(0,s.jsx)(n.em,{children:"handler declines"}),", the search continues for another ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})})," ."]}),"\n",(0,s.jsxs)(n.p,{children:["If no appropriate ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})})," is found, other ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handlers"})})," are sought from dynamically enclosing contours. If no ",(0,s.jsx)(i,{styled:!0,term:"handler",children:(0,s.jsx)("i",{children:"handler"})})," is found outside, then ",(0,s.jsx)(r,{styled:!0,term:"signal",children:(0,s.jsx)("b",{children:"signal"})})," returns or ",(0,s.jsx)(r,{styled:!0,term:"error",children:(0,s.jsx)("b",{children:"error"})})," enters the debugger."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.p,{children:"In the following code, if an unbound variable error is signaled in the body (and not handled by an intervening handler), the first function is called."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(handler-bind ((unbound-variable #\u2019(lambda ...)) \n\t       (error #\u2019(lambda ...))) \n  ...) \n"})}),"\n",(0,s.jsx)(n.p,{children:"If any other kind of error is signaled, the second function is called. In either case, neither handler is active while executing the code in the associated function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun trap-error-handler (condition) \n  (format \\*error-output\\* "~&~A~&" condition) \n  (throw \u2019trap-errors nil)) \n(defmacro trap-errors (&rest forms) \n  \u2018(catch \u2019trap-errors \n     (handler-bind ((error #\u2019trap-error-handler)) \n       ,@forms))) \n(list (trap-errors (signal "Foo.") 1) \n      (trap-errors (error "Bar.") 2) \n      (+ 1 2)) \n\u25b7 Bar. \n\u2192 (1 NIL 3) \n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that \u201cFoo.\u201d is not printed because the condition made by ",(0,s.jsx)(n.strong,{children:"signal"})," is a ",(0,s.jsx)(n.em,{children:"simple condition"}),", which is not of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"error"}),", so it doesn\u2019t trigger the handler for ",(0,s.jsx)(n.strong,{children:"error"})," set up by ",(0,s.jsx)(n.code,{children:"trap-errors"}),".\n",(0,s.jsx)(n.strong,{children:"See Also:"})]}),"\n",(0,s.jsx)(r,{styled:!0,term:"handler-case",children:(0,s.jsx)("b",{children:"handler-case"})})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function l(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const o={title:"handler-bind"},c="handler-bind",h={},p=[{value:"Expanded Reference: handler-bind",id:"expanded-reference-handler-bind",level:2},{value:"Basic Condition Handling",id:"basic-condition-handling",level:3},{value:"Handling Multiple Conditions",id:"handling-multiple-conditions",level:3},{value:"Declining to Handle a Condition",id:"declining-to-handle-a-condition",level:3},{value:"Transferring Control with a Restart",id:"transferring-control-with-a-restart",level:3},{value:"Capturing and Muffling Warnings",id:"capturing-and-muffling-warnings",level:3}];function m(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"handler-bind",children:"handler-bind"})}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(n.h2,{id:"expanded-reference-handler-bind",children:"Expanded Reference: handler-bind"}),"\n",(0,s.jsx)(n.h3,{id:"basic-condition-handling",children:"Basic Condition Handling"}),"\n",(0,s.jsx)(n.p,{children:"Demonstrates how to establish a handler for a simple error condition. The handler is invoked, prints a message, and since it doesn't transfer control, the program terminates."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(handler-bind ((error #\'(lambda (c)\n                          (format t "Caught an error: ~a~%" c)\n                          ;; Without a transfer of control, the thread is terminated\n                          )))\n  (error "This is an error condition."))\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'Caught an error: This is an error condition.\n; Debugger entered on #<SIMPLE-ERROR "This is an error condition." {7007D435D3}>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"handling-multiple-conditions",children:"Handling Multiple Conditions"}),"\n",(0,s.jsxs)(n.p,{children:["Shows how to define handlers for different types of conditions. The first bound handler is invoked first. Even if it's ",(0,s.jsx)(n.strong,{children:"less specific"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"If more than one handler binding is supplied, the handler bindings are searched sequentially from top to bottom in search of a match"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(handler-bind ((error        #\'(lambda (c) (format t "Caught a general error: ~a~%" c)))\n               (simple-error #\'(lambda (c) (format t "Caught a simple-error: ~a~%" c))))\n  (error \'simple-error :format-control "Another simple-error."))\n'})}),"\n",(0,s.jsx)(n.p,{children:"Results in this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'Caught a general error: Another simple-error.\nCaught a simple-error: Another simple-error.\n; Debugger entered on #<SIMPLE-ERROR "Another simple-error." {7008596B73}>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notice the order of the printouts is not based on what's more specific, rather on what was defined first top to bottom."}),"\n",(0,s.jsx)(n.h3,{id:"declining-to-handle-a-condition",children:"Declining to Handle a Condition"}),"\n",(0,s.jsxs)(n.p,{children:["If a handler returns normally, it is said to have declined to handle the condition. The system then searches for the next available handler. In this example, two handlers for ",(0,s.jsx)(n.code,{children:"warning"})," are established. When a warning is signaled, both handlers are run because they both return normally. They are run in top to bottom"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(handler-bind ((warning #\'(lambda (c) (format t "Top handler sees: ~a~%" c)))\n               (warning #\'(lambda (c) (format t "Bottom handler sees: ~a~%" c))))\n  (warn "A warning is signaled."))\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"Top handler sees: A warning is signaled.\nBottom handler sees: A warning is signaled.\nWARNING: A warning is signaled.\nNIL\n"})}),"\n",(0,s.jsx)(n.h3,{id:"transferring-control-with-a-restart",children:"Transferring Control with a Restart"}),"\n",(0,s.jsx)(n.p,{children:"A handler can transfer control by invoking a restart. This bypasses other handlers and can allow the program to continue execution."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(defun my-function (x)\n  (restart-case\n      (if (zerop x)\n          (error "Cannot divide by zero.")\n          (/ 10 x))\n    (continue ()\n      :report "Return a default value of 1 instead."\n      1)))\n\n(handler-bind ((error #\'(lambda (c)\n                          (declare (ignore c))\n                          (invoke-restart \'continue))))\n  (print (my-function 0))\n  (print (my-function 2)))\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"1 \n5 \n5 (3 bits, #x5, #o5, #b101)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notice that there was no printout in the REPL about an error or even a warning."}),"\n",(0,s.jsx)(n.p,{children:"Note (since we don't have a way to color code these code blocks like in slime/sly): The first two lines are print outs, the third line is a value returned."}),"\n",(0,s.jsx)(n.h3,{id:"capturing-and-muffling-warnings",children:"Capturing and Muffling Warnings"}),"\n",(0,s.jsxs)(n.p,{children:["Demonstrates how to capture warnings and prevent them from being printed to ",(0,s.jsx)(n.code,{children:"*error-output*"}),". The handler pushes the warning condition onto a list and then invokes the ",(0,s.jsx)(n.code,{children:"muffle-warning"})," restart."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'(let ((warnings-caught \'()))\n  (handler-bind ((warning #\'(lambda (c)\n                              (push (princ-to-string c) warnings-caught)\n                              (muffle-warning c))))\n    (warn "First warning.")\n    (warn "Second warning."))\n  (format t "Collected warnings: ~a~%" (reverse warnings-caught)))\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"Collected warnings: (First warning. Second warning.)\nNIL\n"})})]})}function x(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var i=r(96540);const s={},t=i.createContext(s);function d(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);