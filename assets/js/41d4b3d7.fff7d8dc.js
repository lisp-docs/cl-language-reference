"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[99558],{23164:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>t,metadata:()=>l,toc:()=>h});var s=r(85893),i=r(11151);const t={title:"N",sidebar_position:110},c=void 0,l={id:"chap-26/cg-b-glossary/n",title:"N",description:"N",source:"@site/docs/chap-26/cg-b-glossary/n.md",sourceDirName:"chap-26/cg-b-glossary",slug:"/chap-26/cg-b-glossary/n",permalink:"/cl-language-reference/docs/chap-26/cg-b-glossary/n",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-26/cg-b-glossary/n.md",tags:[],version:"current",sidebarPosition:110,frontMatter:{title:"N",sidebar_position:110},sidebar:"tutorialSidebar",previous:{title:"M",permalink:"/cl-language-reference/docs/chap-26/cg-b-glossary/m"},next:{title:"O",permalink:"/cl-language-reference/docs/chap-26/cg-b-glossary/o"}},a={},h=[];function o(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"N"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"name"})," ",(0,s.jsx)(n.em,{children:"n."}),", ",(0,s.jsx)(n.em,{children:"v.t."})," 1. ",(0,s.jsx)(n.em,{children:"n."})," an ",(0,s.jsx)(n.em,{children:"identifier"})," by which an ",(0,s.jsx)(n.em,{children:"object"}),", a ",(0,s.jsx)(n.em,{children:"binding"}),", or an ",(0,s.jsx)(n.em,{children:"exit point"})," is referred to by association using a ",(0,s.jsx)(n.em,{children:"binding"}),". 2. ",(0,s.jsx)(n.em,{children:"v.t."})," to give a ",(0,s.jsx)(n.em,{children:"name"})," to. 3. ",(0,s.jsx)(n.em,{children:"n."})," (of an ",(0,s.jsx)(n.em,{children:"object"})," having a name component) the ",(0,s.jsx)(n.em,{children:"object"})," which is that component. \u201cThe string"]}),"\n",(0,s.jsxs)(n.p,{children:["which is a symbol\u2019s name is returned by ",(0,s.jsx)(n.strong,{children:"symbol-name"}),".\u201d 4. ",(0,s.jsx)(n.em,{children:"n."})," (of a ",(0,s.jsx)(n.em,{children:"pathname"}),") a. the name component, returned by ",(0,s.jsx)(n.strong,{children:"pathname-name"}),". b. the entire namestring, returned by ",(0,s.jsx)(n.strong,{children:"namestring"}),". 5. ",(0,s.jsx)(n.em,{children:"n."})," (of a ",(0,s.jsx)(n.em,{children:"character"})," ) a ",(0,s.jsx)(n.em,{children:"string"})," that names the ",(0,s.jsx)(n.em,{children:"character"})," and that"]}),"\n",(0,s.jsxs)(n.p,{children:["has ",(0,s.jsx)(n.em,{children:"length"})," greater than one. (All ",(0,s.jsx)(n.em,{children:"non-graphic characters"})," are required to have ",(0,s.jsx)(n.em,{children:"names"})," unless they have some ",(0,s.jsx)(n.em,{children:"implementation-defined attribute"})," which is not ",(0,s.jsx)(n.em,{children:"null"}),". Whether or not other ",(0,s.jsx)(n.em,{children:"characters"})," have ",(0,s.jsx)(n.em,{children:"names"})," is ",(0,s.jsx)(n.em,{children:"implementation-dependent"}),".)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"named constant"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"variable"})," that is defined by Common Lisp, by the ",(0,s.jsx)(n.em,{children:"implementation"}),", or by user code (see the ",(0,s.jsx)(n.em,{children:"macro"})," ",(0,s.jsx)(n.strong,{children:"defconstant"}),") to always ",(0,s.jsx)(n.em,{children:"yield"})," the same ",(0,s.jsx)(n.em,{children:"value"})," when ",(0,s.jsx)(n.em,{children:"evaluated"}),". \u201cThe value of a named constant may not be changed by assignment or by binding.\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"namespace"})," ",(0,s.jsx)(n.em,{children:"n."})," 1. ",(0,s.jsx)(n.em,{children:"bindings"})," whose denotations are restricted to a particular kind. \u201cThe bindings of names to tags is the tag namespace.\u201d 2. any ",(0,s.jsx)(n.em,{children:"mapping"})," whose domain is a set of ",(0,s.jsx)(n.em,{children:"names"}),". \u201cA package defines a namespace.\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"namestring"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"string"})," that represents a ",(0,s.jsx)(n.em,{children:"filename"})," using either the ",(0,s.jsx)(n.em,{children:"standardized"})," notation for naming ",(0,s.jsx)(n.em,{children:"logical pathnames"})," described in Section 19.3.1 (Syntax of Logical Pathname Namestrings), or some ",(0,s.jsx)(n.em,{children:"implementation-defined"})," notation for naming a"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"physical pathname"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"newline"})," ",(0,s.jsx)(n.em,{children:"n."})," the ",(0,s.jsx)(n.em,{children:"standard character \u27e8Newline\u27e9"}),", notated for the ",(0,s.jsx)(n.em,{children:"Lisp reader"})," as #\\Newline."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"next method"})," ",(0,s.jsx)(n.em,{children:"n."})," the next ",(0,s.jsx)(n.em,{children:"method"})," to be invoked with respect to a given ",(0,s.jsx)(n.em,{children:"method"})," for a particular set of arguments or argument ",(0,s.jsx)(n.em,{children:"classes"}),". See Section 7.6.6.1.3 (Applying method combination to the sorted list of applicable methods)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"nickname"})," ",(0,s.jsx)(n.em,{children:"n."})," (of a ",(0,s.jsx)(n.em,{children:"package"}),") one of possibly several ",(0,s.jsx)(n.em,{children:"names"})," that can be used to refer to the ",(0,s.jsx)(n.em,{children:"package"})," but that is not the primary ",(0,s.jsx)(n.em,{children:"name"})," of the ",(0,s.jsx)(n.em,{children:"package"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"nil"})," ",(0,s.jsx)(n.em,{children:"n."})," the ",(0,s.jsx)(n.em,{children:"object"})," that is at once the ",(0,s.jsx)(n.em,{children:"symbol"}),' named "NIL" in the COMMON-LISP ',(0,s.jsx)(n.em,{children:"package"}),", the ",(0,s.jsx)(n.em,{children:"empty list"}),", the ",(0,s.jsx)(n.em,{children:"boolean"})," (or ",(0,s.jsx)(n.em,{children:"generalized boolean"}),") representing ",(0,s.jsx)(n.em,{children:"false"}),", and the ",(0,s.jsx)(n.em,{children:"name"})," of the ",(0,s.jsx)(n.em,{children:"empty type"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-atomic"})," ",(0,s.jsx)(n.em,{children:"adj."})," being other than an ",(0,s.jsx)(n.em,{children:"atom"}),"; ",(0,s.jsx)(n.em,{children:"i.e."}),", being a ",(0,s.jsx)(n.em,{children:"cons"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-constant variable"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"variable"})," that is not a ",(0,s.jsx)(n.em,{children:"constant variable"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-correctable"})," ",(0,s.jsx)(n.em,{children:"adj."})," (of an ",(0,s.jsx)(n.em,{children:"error"})," ) not intentionally ",(0,s.jsx)(n.em,{children:"correctable"}),". (Because of the dynamic nature of ",(0,s.jsx)(n.em,{children:"restarts"}),", it is neither possible nor generally useful to completely prohibit an ",(0,s.jsx)(n.em,{children:"error"})," from being ",(0,s.jsx)(n.em,{children:"correctable"}),". This term is used in order to express an"]}),"\n",(0,s.jsxs)(n.p,{children:["intent that no special effort should be made by ",(0,s.jsx)(n.em,{children:"code"})," signaling an ",(0,s.jsx)(n.em,{children:"error"})," to make that ",(0,s.jsx)(n.em,{children:"error correctable"}),"; however, there is no actual requirement on ",(0,s.jsx)(n.em,{children:"conforming programs"})," or ",(0,s.jsx)(n.em,{children:"conforming implementations"})," imposed by this term.)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-empty"})," ",(0,s.jsx)(n.em,{children:"adj."})," having at least one ",(0,s.jsx)(n.em,{children:"element"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-generic function"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"function"})," that is not a ",(0,s.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-graphic"})," ",(0,s.jsx)(n.em,{children:"adj."})," (of a ",(0,s.jsx)(n.em,{children:"character"})," ) not ",(0,s.jsx)(n.em,{children:"graphic"}),". See Section 13.1.4.1 (Graphic"]}),"\n",(0,s.jsx)(n.p,{children:"Characters)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-list"})," ",(0,s.jsx)(n.em,{children:"n."}),", ",(0,s.jsx)(n.em,{children:"adj."})," other than a ",(0,s.jsx)(n.em,{children:"list"}),"; ",(0,s.jsx)(n.em,{children:"i.e."}),", a ",(0,s.jsx)(n.em,{children:"non-nil atom"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-local exit"})," ",(0,s.jsx)(n.em,{children:"n."})," a transfer of control (and sometimes ",(0,s.jsx)(n.em,{children:"values"}),") to an ",(0,s.jsx)(n.em,{children:"exit point"})," for reasons other than a ",(0,s.jsx)(n.em,{children:"normal return"}),". \u201cThe operators ",(0,s.jsx)(n.strong,{children:"go"}),", ",(0,s.jsx)(n.strong,{children:"throw"}),", and ",(0,s.jsx)(n.strong,{children:"return-from"})," cause a non-local exit.\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-nil"})," ",(0,s.jsx)(n.em,{children:"n."}),", ",(0,s.jsx)(n.em,{children:"adj."})," not ",(0,s.jsx)(n.strong,{children:"nil"}),". Technically, any ",(0,s.jsx)(n.em,{children:"object"})," which is not ",(0,s.jsx)(n.strong,{children:"nil"})," can be referred to as ",(0,s.jsx)(n.em,{children:"true"}),", but that would tend to imply a unique view of the ",(0,s.jsx)(n.em,{children:"object"})," as a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),". Referring to such an ",(0,s.jsx)(n.em,{children:"object"})," as ",(0,s.jsx)(n.em,{children:"non-nil"})," avoids this implication."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-null lexical environment"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"lexical environment"})," that has additional"]}),"\n",(0,s.jsxs)(n.p,{children:["information not present in the ",(0,s.jsx)(n.em,{children:"global environment"}),", such as one or more ",(0,s.jsx)(n.em,{children:"bindings"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-simple"})," ",(0,s.jsx)(n.em,{children:"adj."})," not ",(0,s.jsx)(n.em,{children:"simple"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-terminating"})," ",(0,s.jsx)(n.em,{children:"adj."})," (of a ",(0,s.jsx)(n.em,{children:"macro character"})," ) being such that it is treated as a"]}),"\n",(0,s.jsxs)(n.p,{children:["constituent ",(0,s.jsx)(n.em,{children:"character"})," when it appears in the middle of an extended token. See Section 2.2 (Reader Algorithm)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"non-top-level form"})," ",(0,s.jsx)(n.em,{children:"n."})," a ",(0,s.jsx)(n.em,{children:"form"})," that, by virtue of its position as a ",(0,s.jsx)(n.em,{children:"subform"})," of another ",(0,s.jsx)(n.em,{children:"form"}),", is not a ",(0,s.jsx)(n.em,{children:"top level form"}),". See Section 3.2.3.1 (Processing of Top Level Forms)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"normal return"})," ",(0,s.jsx)(n.em,{children:"n."})," the natural transfer of control and ",(0,s.jsx)(n.em,{children:"values"})," which occurs after the complete ",(0,s.jsx)(n.em,{children:"execution"})," of a ",(0,s.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"normalized"})," ",(0,s.jsx)(n.em,{children:"adj."}),", ",(0,s.jsx)(n.em,{children:"ANSI"}),", ",(0,s.jsx)(n.em,{children:"IEEE"})," (of a ",(0,s.jsx)(n.em,{children:"float"}),") conforming to the description of"]}),"\n",(0,s.jsxs)(n.p,{children:["\u201cnormalized\u201d as described by ",(0,s.jsx)(n.em,{children:"IEEE Standard for Binary Floating-Point Arithmetic"}),". See ",(0,s.jsx)(n.em,{children:"denormalized"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"null"})," ",(0,s.jsx)(n.em,{children:"adj."}),", ",(0,s.jsx)(n.em,{children:"n."})," 1. ",(0,s.jsx)(n.em,{children:"adj."})," a. (of a ",(0,s.jsx)(n.em,{children:"list"}),") having no ",(0,s.jsx)(n.em,{children:"elements"}),": empty. See ",(0,s.jsx)(n.em,{children:"empty list"}),". b. (of a ",(0,s.jsx)(n.em,{children:"string"}),") having a ",(0,s.jsx)(n.em,{children:"length"})," of zero. (It is common, both within this document and in observed spoken behavior, to refer to an empty string by an apparent definite reference, as in \u201cthe ",(0,s.jsx)(n.em,{children:"null string"}),"\u201d even though no attempt is made to ",(0,s.jsx)(n.em,{children:"intern"}),(0,s.jsx)("sub",{children:"2"})," null strings. The phrase \u201ca ",(0,s.jsx)(n.em,{children:"null string"}),"\u201d is technically more correct, but is generally considered awkward by most Lisp programmers. As such, the phrase \u201cthe ",(0,s.jsx)(n.em,{children:"null string"}),"\u201d should be treated as an indefinite reference in all cases except for anaphoric references.) c. (of an ",(0,s.jsx)(n.em,{children:"implementation-defined attribute"})," of a ",(0,s.jsx)(n.em,{children:"character"})," ) An ",(0,s.jsx)(n.em,{children:"object"})," to which the value of that ",(0,s.jsx)(n.em,{children:"attribute"})," defaults if no specific value was requested. 2. ",(0,s.jsx)(n.em,{children:"n."})," an ",(0,s.jsx)(n.em,{children:"object"})," of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"null"})," (the only such ",(0,s.jsx)(n.em,{children:"object"})," being ",(0,s.jsx)(n.strong,{children:"nil"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"null lexical environment"})," ",(0,s.jsx)(n.em,{children:"n."})," the ",(0,s.jsx)(n.em,{children:"lexical environment"})," which has no ",(0,s.jsx)(n.em,{children:"bindings"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"number"})," ",(0,s.jsx)(n.em,{children:"n."})," an ",(0,s.jsx)(n.em,{children:"object"})," of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"number"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"numeric"})," ",(0,s.jsx)(n.em,{children:"adj."})," (of a ",(0,s.jsx)(n.em,{children:"character"})," ) being one of the ",(0,s.jsx)(n.em,{children:"standard characters"})," 0 through ",(0,s.jsx)(n.em,{children:"9"})," , or being some other ",(0,s.jsx)(n.em,{children:"graphic character"})," defined by the ",(0,s.jsx)(n.em,{children:"implementation"})," to be ",(0,s.jsx)(n.em,{children:"numeric"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>c});var s=r(67294);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);