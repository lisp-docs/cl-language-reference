"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[84977],{28453:(e,s,t)=>{t.d(s,{R:()=>d,x:()=>l});var n=t(96540);const r={},i=n.createContext(r);function d(e){const s=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:s},e.children)}},35517:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>u,contentTitle:()=>o,default:()=>a,frontMatter:()=>h,metadata:()=>n,toc:()=>b});const n=JSON.parse('{"id":"chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function","title":"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not","description":"Expanded Reference: subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not","source":"@site/docs/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function.md","sourceDirName":"chap-14/be-c-dictionary","slug":"/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function","permalink":"/cl-language-reference/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"},"sidebar":"tutorialSidebar","previous":{"title":"subsetp","permalink":"/cl-language-reference/chap-14/be-c-dictionary/subsetp_function"},"next":{"title":"tree-equal","permalink":"/cl-language-reference/chap-14/be-c-dictionary/tree-equal_function"}}');var r=t(74848),i=t(28453);function d(e){const s={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:n}=s;return t||c("DictionaryLink",!0),n||c("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"})," ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"Function"})})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})})," ",(0,r.jsx)(s.em,{children:"new old tree"})," &key ",(0,r.jsx)(s.em,{children:"key test test-not \u2192 new-tree"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"subst-if",children:(0,r.jsx)("b",{children:"subst-if"})})," ",(0,r.jsx)(s.em,{children:"new predicate tree"})," &key ",(0,r.jsx)(s.em,{children:"key \u2192 new-tree"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"subst-if-not",children:(0,r.jsx)("b",{children:"subst-if-not"})})," ",(0,r.jsx)(s.em,{children:"new predicate tree"})," &key ",(0,r.jsx)(s.em,{children:"key \u2192 new-tree"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst",children:(0,r.jsx)("b",{children:"nsubst"})})," ",(0,r.jsx)(s.em,{children:"new old tree"})," &key ",(0,r.jsx)(s.em,{children:"key test test-not \u2192 new-tree"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst-if",children:(0,r.jsx)("b",{children:"nsubst-if"})})," ",(0,r.jsx)(s.em,{children:"new predicate tree"})," &key ",(0,r.jsx)(s.em,{children:"key \u2192 new-tree"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst-if-not",children:(0,r.jsx)("b",{children:"nsubst-if-not"})})," ",(0,r.jsx)(s.em,{children:"new predicate tree"})," &key ",(0,r.jsx)(s.em,{children:"key \u2192 new-tree"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"new"}),"\u2014an ",(0,r.jsx)(n,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"old"}),"\u2014an ",(0,r.jsx)(n,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"subst, subst-if, subst-if-not, nsubst, nsubst-if,"})," ",(0,r.jsx)(s.em,{children:". . ."})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(n,{styled:!0,term:"predicate",children:(0,r.jsx)("i",{children:"predicate"})}),"\u2014a ",(0,r.jsx)(n,{styled:!0,term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," that names a ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"function"})}),", or a ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"function"})})," of one argument that returns a ",(0,r.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,r.jsx)("i",{children:"generalized boolean"})})," value."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),"\u2014a ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"test"}),"\u2014a ",(0,r.jsx)(n,{styled:!0,term:"designator",children:(0,r.jsx)("i",{children:"designator"})})," for a ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"function"})})," of two ",(0,r.jsx)(n,{styled:!0,term:"argument",children:(0,r.jsx)("i",{children:"arguments"})})," that returns a ",(0,r.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,r.jsx)("i",{children:"generalized boolean"})}),". ",(0,r.jsxs)(s.em,{children:["test-not",(0,r.jsx)(n,{styled:!0,term:"t",children:(0,r.jsx)("i",{children:"\u2014a "})}),"designator"]})," for a ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"function"})})," of two ",(0,r.jsx)(n,{styled:!0,term:"argument",children:(0,r.jsx)("i",{children:"arguments"})})," that returns a ",(0,r.jsx)(n,{styled:!0,term:"generalized boolean",children:(0,r.jsx)("i",{children:"generalized boolean"})}),". ",(0,r.jsx)(n,{styled:!0,term:"key",children:(0,r.jsx)("i",{children:"key"})}),"\u2014a ",(0,r.jsx)(n,{styled:!0,term:"designator",children:(0,r.jsx)("i",{children:"designator"})})," for a ",(0,r.jsx)(n,{styled:!0,term:"function",children:(0,r.jsx)("i",{children:"function"})})," of one argument, or ",(0,r.jsx)(t,{styled:!0,term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.em,{children:"new-tree"}),"\u2014a ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"subst-if",children:(0,r.jsx)("b",{children:"subst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"subst-if-not",children:(0,r.jsx)("b",{children:"subst-if-not"})})," perform substitution operations on ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),". Each function searches ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," for occurrences of a particular ",(0,r.jsx)(s.em,{children:"old"})," item of an element or subexpression that ",(0,r.jsx)(s.em,{children:"satisfies the test"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst",children:(0,r.jsx)("b",{children:"nsubst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if",children:(0,r.jsx)("b",{children:"nsubst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if-not",children:(0,r.jsx)("b",{children:"nsubst-if-not"})})," are like ",(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"subst-if",children:(0,r.jsx)("b",{children:"subst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"subst-if-not",children:(0,r.jsx)("b",{children:"subst-if-not"})})," respectively, except that the original ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," is modified."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})})," makes a copy of ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),", substituting ",(0,r.jsx)(s.em,{children:"new"})," for every subtree or leaf of ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," (whether the subtree or leaf is a ",(0,r.jsx)(n,{styled:!0,term:"car",children:(0,r.jsx)("i",{children:"car"})})," or a ",(0,r.jsx)(n,{styled:!0,term:"cdr",children:(0,r.jsx)("i",{children:"cdr"})})," of its parent) such that ",(0,r.jsx)(s.em,{children:"old"})," and the subtree or leaf ",(0,r.jsx)(n,{styled:!0,term:"satisfy the test",children:(0,r.jsx)("i",{children:"satisfy the test"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst",children:(0,r.jsx)("b",{children:"nsubst"})})," is a destructive version of ",(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})}),". The list structure of ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," is altered by destructively replacing with ",(0,r.jsx)(s.em,{children:"new"})," each leaf of the ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," such that ",(0,r.jsx)(s.em,{children:"old"})," and the leaf ",(0,r.jsx)(n,{styled:!0,term:"satisfy the test",children:(0,r.jsx)("i",{children:"satisfy the test"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["For ",(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"subst-if",children:(0,r.jsx)("b",{children:"subst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"subst-if-not",children:(0,r.jsx)("b",{children:"subst-if-not"})}),", if the functions succeed, a new copy of the tree is returned in which each occurrence of such an element is replaced by the ",(0,r.jsx)(s.em,{children:"new"})," element or subexpression. If no changes are made, the original ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," may be returned. The original ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," is left unchanged, but the result tree may share storage with it."]}),"\n",(0,r.jsxs)(s.p,{children:["For ",(0,r.jsx)(t,{styled:!0,term:"nsubst",children:(0,r.jsx)("b",{children:"nsubst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if",children:(0,r.jsx)("b",{children:"nsubst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if-not",children:(0,r.jsx)("b",{children:"nsubst-if-not"})})," the original ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})})," is modified and returned as the function result, but the result may not be ",(0,r.jsx)(t,{styled:!0,term:"eq",children:(0,r.jsx)("b",{children:"eq"})})," to ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-lisp",children:'(setq tree1 \u2019(1 (1 2) (1 2 3) (1 2 3 4))) \u2192 (1 (1 2) (1 2 3) (1 2 3 4)) \n(subst "two" 2 tree1) \u2192 (1 (1 "two") (1 "two" 3) (1 "two" 3 4)) \n(subst "five" 5 tree1) \u2192 (1 (1 2) (1 2 3) (1 2 3 4)) \n(eq tree1 (subst "five" 5 tree1)) \u2192 implementation-dependent \n(subst \u2019tempest \u2019hurricane \n\t\u2019(shakespeare wrote (the hurricane))) \n\u2192 (SHAKESPEARE WROTE (THE TEMPEST)) \n(subst \u2019foo \u2019nil \u2019(shakespeare wrote (twelfth night))) \n\u2192 (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO) \n(subst \u2019(a . cons) \u2019(old . pair) \n\t\u2019((old . spice) ((old . shoes) old . pair) (old . pair)) \n\t\n\t\n\t:test #\u2019equal) \n\u2192 ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS)) \n(subst-if 5 #\u2019listp tree1) \u2192 5 \n(subst-if-not \u2019(x) #\u2019consp tree1) \n\u2192 (1 X) \ntree1 \u2192 (1 (1 2) (1 2 3) (1 2 3 4)) \n(nsubst \u2019x 3 tree1 :key #\u2019(lambda (y) (and (listp y) (third y)))) \n\u2192 (1 (1 2) X X) \ntree1 \u2192 (1 (1 2) X X) \n'})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Side Effects:"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(t,{styled:!0,term:"nsubst",children:(0,r.jsx)("b",{children:"nsubst"})}),", ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if",children:(0,r.jsx)("b",{children:"nsubst-if"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if-not",children:(0,r.jsx)("b",{children:"nsubst-if-not"})})," might alter the ",(0,r.jsx)(n,{styled:!0,term:"tree structure",children:(0,r.jsx)("i",{children:"tree structure"})})," of ",(0,r.jsx)(n,{styled:!0,term:"tree",children:(0,r.jsx)("i",{children:"tree"})}),"."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"substitute"}),", ",(0,r.jsx)(s.strong,{children:"nsubstitute"}),", Section 3.2.1 (Compiler Terminology), Section 3.6 (Traversal Rules and Side Effects)"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",":test-not"," parameter is deprecated."]}),"\n",(0,r.jsxs)(s.p,{children:["The functions ",(0,r.jsx)(t,{styled:!0,term:"subst-if-not",children:(0,r.jsx)("b",{children:"subst-if-not"})})," and ",(0,r.jsx)(t,{styled:!0,term:"nsubst-if-not",children:(0,r.jsx)("b",{children:"nsubst-if-not"})})," are deprecated."]}),"\n",(0,r.jsxs)(s.p,{children:["One possible definition of ",(0,r.jsx)(t,{styled:!0,term:"subst",children:(0,r.jsx)("b",{children:"subst"})}),":"]}),"\n",(0,r.jsx)(s.p,{children:"(defun subst (old new tree &rest x &key test test-not key)"}),"\n",(0,r.jsxs)(s.p,{children:["(cond ((satisfies-the-test old tree ",":test"," test"]}),"\n",(0,r.jsxs)(s.p,{children:[":test-not"," test-not ",":key"," key)"]}),"\n",(0,r.jsx)(s.p,{children:"new)"}),"\n",(0,r.jsx)(s.p,{children:"((atom tree) tree)"}),"\n",(0,r.jsx)(s.p,{children:"(t (let ((a (apply #\u2019subst old new (car tree) x))"}),"\n",(0,r.jsx)(s.p,{children:"(d (apply #\u2019subst old new (cdr tree) x)))"}),"\n",(0,r.jsx)(s.p,{children:"(if (and (eql a (car tree))"}),"\n",(0,r.jsx)(s.p,{children:"(eql d (cdr tree)))"}),"\n",(0,r.jsx)(s.p,{children:"tree"}),"\n",(0,r.jsx)(s.p,{children:"(cons a d))))))"}),"\n",(0,r.jsx)(t,{styled:!0,term:"tree-equal",children:(0,r.jsx)("b",{children:"tree-equal"})})]})}function l(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function c(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const h={title:"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"},o="subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not",u={},b=[{value:"Expanded Reference: subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not",id:"expanded-reference-subst-subst-if-subst-if-not-nsubst-nsubst-if-nsubst-if-not",level:2}];function x(e){const s={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"subst-subst-if-subst-if-not-nsubst-nsubst-if-nsubst-if-not",children:"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"})}),"\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(s.h2,{id:"expanded-reference-subst-subst-if-subst-if-not-nsubst-nsubst-if-nsubst-if-not",children:"Expanded Reference: subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not"}),"\n",(0,r.jsx)(s.admonition,{type:"tip",children:(0,r.jsx)(s.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-lisp",children:"(subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not )\n"})})]})}function a(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}}}]);