"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[78885],{28453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>c});var s=t(96540);const n={},r=s.createContext(n);function o(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:i},e.children)}},64263:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>I,contentTitle:()=>S,default:()=>K,frontMatter:()=>P,metadata:()=>s,toc:()=>B});const s=JSON.parse('{"id":"chap-18/bi-b-hash-table-concepts","title":"18.1 Hash Table Concepts","description":"18.1.1 Hash","source":"@site/docs/chap-18/bi-b-hash-table-concepts.md","sourceDirName":"chap-18","slug":"/chap-18/bi-b-hash-table-concepts","permalink":"/cl-language-reference/chap-18/bi-b-hash-table-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-18/bi-b-hash-table-concepts.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"18.1 Hash Table Concepts"},"sidebar":"tutorialSidebar","previous":{"title":"subseq","permalink":"/cl-language-reference/chap-17/bh-d-dictionary/subseq_accessor"},"next":{"title":"18.2 Hash Tables Dictionary","permalink":"/cl-language-reference/category/182-hash-tables-dictionary"}}');var n=t(74848),r=t(28453);function o(e){return(0,n.jsx)(n.Fragment,{})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(o,{...e})}):o()}function a(e){const i={code:"code",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||h("DictionaryLink",!0),s||h("GlossaryTerm",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["Figure 18\u20131 lists some ",(0,n.jsx)(s,{styled:!0,term:"defined name",children:(0,n.jsx)("i",{children:"defined names"})})," that are applicable to ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})}),". The following rules apply to ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 A ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," can only associate one value with a given key. If an attempt is made to add a second value for a given key, the second value will replace the first. Thus, adding a value to a ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," is a destructive operation; the ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," is modified."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 There are four kinds of ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})}),": those whose keys are compared with ",(0,n.jsx)(t,{term:"eq",children:(0,n.jsx)("b",{children:"eq"})}),", those whose keys are compared with ",(0,n.jsx)(t,{term:"eql",children:(0,n.jsx)("b",{children:"eql"})}),", those whose keys are compared with ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),", and those whose keys are compared with ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"Hash tables"})})," are created by ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})}),". ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})})," is used to look up a key and find the associated value. New entries are added to ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})})," using ",(0,n.jsx)(t,{term:"setf",children:(0,n.jsx)("b",{children:"setf"})})," with ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})}),". ",(0,n.jsx)(t,{term:"remhash",children:(0,n.jsx)("b",{children:"remhash"})})," is used to remove an entry. For example:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-lisp",children:"(setq a (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32536573>\n(setf (gethash \u2019color a) \u2019brown) \u2192 BROWN\n(setf (gethash \u2019name a) \u2019fred) \u2192 FRED\n(gethash \u2019color a) \u2192 BROWN, *true*\n(gethash \u2019name a) \u2192 FRED, *true*\n(gethash \u2019pointy a) \u2192 NIL, *false*\n"})}),"\n",(0,n.jsxs)(i.p,{children:["In this example, the symbols color and name are being used as keys, and the symbols brown and fred are being used as the associated values. The ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," has two items in it, one of which associates from color to brown, and the other of which associates from name to fred."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 A key or a value may be any ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 The existence of an entry in the ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," can be determined from the ",(0,n.jsx)(s,{styled:!0,term:"secondary value",children:(0,n.jsx)("i",{children:"secondary value"})})," returned by ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["|",(0,n.jsxs)("p",{children:[(0,n.jsx)(i.strong,{children:"clrhash hash-table-p remhash gethash make-hash-table sxhash"})," "]}),"\n",(0,n.jsx)("p",{children:(0,n.jsx)(i.strong,{children:"hash-table-count maphash"})}),"|"]}),"\n",(0,n.jsx)(i.p,{children:"| :- |"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Figure 18\u20131. Hash-table defined names"})}),"\n",(0,n.jsx)(i.p,{children:"Hash"})]})}function l(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}function h(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function d(e){const i={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||p("DictionaryLink",!0),s||p("GlossaryTerm",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["The function supplied as the ",":test"," argument to ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})})," specifies the \u2018equivalence test\u2019 for the ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," it creates."]}),"\n",(0,n.jsxs)(i.p,{children:["An ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," is \u2018visibly modified\u2019 with regard to an equivalence test if there exists some set of ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," (or potential ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"objects"})}),") which are equivalent to the ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," before the modification but are no longer equivalent afterwards."]}),"\n",(0,n.jsxs)(i.p,{children:["If an ",(0,n.jsx)(i.em,{children:"object O"}),(0,n.jsx)("sub",{children:"1"})," is used as a key in a ",(0,n.jsx)(i.em,{children:"hash table H"})," and is then visibly modified with regard to the equivalence test of ",(0,n.jsx)(i.em,{children:"H"}),", then the consequences are unspecified if ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"}),", or any ",(0,n.jsx)(i.em,{children:"object O"}),(0,n.jsx)("sub",{children:"2"})," equivalent to ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," under the equivalence test (either before or after the modification), is used as a key in further operations on ",(0,n.jsx)(i.em,{children:"H"}),". The consequences of using ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," as a key are unspecified even if ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," is visibly"]}),"\n",(0,n.jsx)(i.p,{children:"modified and then later modified again in such a way as to undo the visible modification."}),"\n",(0,n.jsxs)(i.p,{children:["Following are specifications of the modifications which are visible to the equivalence tests which must be supported by ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})}),". The modifications are described in terms of modification of components, and are defined recursively. Visible modifications of components of the ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," are visible modifications of the ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})}),"."]})]})}function j(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function p(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function m(e){const i={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||b("DictionaryLink",!0),s||b("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["No ",(0,n.jsx)(i.em,{children:"standardized function"})," is provided that is capable of visibly modifying an ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," with regard to ",(0,n.jsx)(t,{term:"eq",children:(0,n.jsx)("b",{children:"eq"})})," or ",(0,n.jsx)(t,{term:"eql",children:(0,n.jsx)("b",{children:"eql"})}),"."]})}function x(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}function b(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function f(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||y("DictionaryLink",!0),s||y("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),", the rules for visible modification of ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modification of Objects with respect to EQ and EQL)."]})}function u(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(f,{...e})}):f(e)}function y(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function v(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||w("DictionaryLink",!0),s||w("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["Any visible change to the ",(0,n.jsx)(s,{term:"car",children:(0,n.jsx)("i",{children:"car"})})," or the ",(0,n.jsx)(s,{term:"cdr",children:(0,n.jsx)("i",{children:"cdr"})})," of a ",(0,n.jsx)(s,{term:"cons",children:(0,n.jsx)("i",{children:"cons"})})," is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),"."]})}function g(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(v,{...e})}):v(e)}function w(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function k(e){const i={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||E("DictionaryLink",!0),s||E("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["For a ",(0,n.jsx)(s,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," of ",(0,n.jsx)(s,{term:"type",children:(0,n.jsx)("i",{children:"type"})})," ",(0,n.jsx)(t,{term:"bit-vector",children:(0,n.jsx)("b",{children:"bit-vector"})})," or of ",(0,n.jsx)(s,{term:"type",children:(0,n.jsx)("i",{children:"type"})})," ",(0,n.jsx)(t,{term:"string",children:(0,n.jsx)("b",{children:"string"})}),", any visible change to an ",(0,n.jsx)(i.em,{children:"active element"})," of the ",(0,n.jsx)(s,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," , or to the ",(0,n.jsx)(s,{term:"length",children:(0,n.jsx)("i",{children:"length"})})," of the ",(0,n.jsx)(s,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," (if it is ",(0,n.jsx)(s,{styled:!0,term:"actually adjustable",children:(0,n.jsx)("i",{children:"actually adjustable"})})," or has a ",(0,n.jsx)(s,{styled:!0,term:"fill pointer",children:(0,n.jsx)("i",{children:"fill pointer"})})," ) is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),"."]})}function q(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(k,{...e})}):k(e)}function E(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function L(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||R("DictionaryLink",!0),s||R("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),", the rules for visible modification of ",(0,n.jsx)(s,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modification of Objects with respect to EQUAL)."]})}function T(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(L,{...e})}):L(e)}function R(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function D(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||M("DictionaryLink",!0),s||M("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["Any visible change to a ",(0,n.jsx)(s,{term:"slot",children:(0,n.jsx)("i",{children:"slot"})})," of a ",(0,n.jsx)(s,{term:"structure",children:(0,n.jsx)("i",{children:"structure"})})," is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})}function A(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(D,{...e})}):D(e)}function M(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function V(e){const i={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||H("DictionaryLink",!0),s||H("GlossaryTerm",!0),(0,n.jsxs)(i.p,{children:["In an ",(0,n.jsx)(s,{term:"array",children:(0,n.jsx)("i",{children:"array"})}),", any visible change to an ",(0,n.jsx)(i.em,{children:"active element"}),", to the ",(0,n.jsx)(s,{styled:!0,term:"fill pointer",children:(0,n.jsx)("i",{children:"fill pointer"})})," (if the ",(0,n.jsx)(s,{term:"array",children:(0,n.jsx)("i",{children:"array"})})," can and does have one), or to the ",(0,n.jsx)(s,{term:"dimension",children:(0,n.jsx)("i",{children:"dimensions"})})," (if the ",(0,n.jsx)(s,{term:"array",children:(0,n.jsx)("i",{children:"array"})})," is ",(0,n.jsx)(s,{styled:!0,term:"actually adjustable",children:(0,n.jsx)("i",{children:"actually adjustable"})}),") is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})}function G(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(V,{...e})}):V(e)}function H(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Q(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||U("DictionaryLink",!0),s||U("GlossaryTerm",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["In a ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})}),", any visible change to the count of entries in the ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})}),", to the keys, or to the values associated with the keys is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Note that the visibility of modifications to the keys depends on the equivalence test of the ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})}),", not on the specification of ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})]})}function O(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(Q,{...e})}):Q(e)}function U(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function F(e){const i={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:s}=i;return t||N("DictionaryLink",!0),s||N("GlossaryTerm",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:[(0,n.jsx)(s,{term:"implementation",children:(0,n.jsx)("i",{children:"Implementations"})})," that extend the language by providing additional mutator functions (or additional behavior for existing mutator functions) must document how the use of these extensions interacts with equivalence tests and ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash table"})})," searches."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(s,{term:"implementation",children:(0,n.jsx)("i",{children:"Implementations"})})," that extend the language by defining additional acceptable equivalence tests for ",(0,n.jsx)(s,{styled:!0,term:"hash table",children:(0,n.jsx)("i",{children:"hash tables"})})," (allowing additional values for the ",":test"," argument to ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})}),") must document the visible components of these tests."]}),"\n",(0,n.jsx)(i.p,{children:"Hash"})]})}function C(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(F,{...e})}):F(e)}function N(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const P={title:"18.1 Hash Table Concepts"},S="18.1 Hash Table Concepts",I={},B=[{value:"18.1.1 Hash",id:"1811-hash",level:2},{value:"18.1.2 Modifying Hash Table Keys",id:"1812-modifying-hash-table-keys",level:2},{value:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL",id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",level:3},{value:"18.1.2.2 Visible Modification of Objects with respect to EQUAL",id:"18122-visible-modification-of-objects-with-respect-to-equal",level:3},{value:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL",id:"181221-visible-modification-of-conses-with-respect-to-equal",level:4},{value:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL",id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",level:4},{value:"18.1.2.3 Visible Modification of Objects with respect to EQUALP",id:"18123-visible-modification-of-objects-with-respect-to-equalp",level:3},{value:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP",id:"181231-visible-modification-of-structures-with-respect-to-equalp",level:4},{value:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP",id:"181232-visible-modification-of-arrays-with-respect-to-equalp",level:4},{value:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP",id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",level:4},{value:"18.1.2.4 Visible Modifications by Language Extensions",id:"18124-visible-modifications-by-language-extensions",level:3}];function _(e){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"181-hash-table-concepts",children:"18.1 Hash Table Concepts"})}),"\n","\n",(0,n.jsx)(c,{}),"\n",(0,n.jsx)(i.h2,{id:"1811-hash",children:"18.1.1 Hash"}),"\n","\n",(0,n.jsx)(l,{}),"\n",(0,n.jsx)(i.h2,{id:"1812-modifying-hash-table-keys",children:"18.1.2 Modifying Hash Table Keys"}),"\n","\n",(0,n.jsx)(j,{}),"\n",(0,n.jsx)(i.h3,{id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"}),"\n","\n",(0,n.jsx)(x,{}),"\n",(0,n.jsx)(i.h3,{id:"18122-visible-modification-of-objects-with-respect-to-equal",children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"}),"\n","\n",(0,n.jsx)(u,{}),"\n",(0,n.jsx)(i.h4,{id:"181221-visible-modification-of-conses-with-respect-to-equal",children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"}),"\n","\n",(0,n.jsx)(g,{}),"\n",(0,n.jsx)(i.h4,{id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"}),"\n","\n",(0,n.jsx)(q,{}),"\n",(0,n.jsx)(i.h3,{id:"18123-visible-modification-of-objects-with-respect-to-equalp",children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"}),"\n","\n",(0,n.jsx)(T,{}),"\n",(0,n.jsx)(i.h4,{id:"181231-visible-modification-of-structures-with-respect-to-equalp",children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"}),"\n","\n",(0,n.jsx)(A,{}),"\n",(0,n.jsx)(i.h4,{id:"181232-visible-modification-of-arrays-with-respect-to-equalp",children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"}),"\n","\n",(0,n.jsx)(G,{}),"\n",(0,n.jsx)(i.h4,{id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"}),"\n","\n",(0,n.jsx)(O,{}),"\n",(0,n.jsx)(i.h3,{id:"18124-visible-modifications-by-language-extensions",children:"18.1.2.4 Visible Modifications by Language Extensions"}),"\n","\n",(0,n.jsx)(C,{})]})}function K(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(_,{...e})}):_(e)}}}]);