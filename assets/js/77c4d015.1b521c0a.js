"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[10686],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var r=i(96540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},39085:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>ve,contentTitle:()=>ye,default:()=>Te,frontMatter:()=>be,metadata:()=>r,toc:()=>ge});const r=JSON.parse('{"id":"chap-3/d-b-evaluation","title":"3.1 Evaluation","description":"3.1.1 Introduction to Environments","source":"@site/docs/chap-3/d-b-evaluation.md","sourceDirName":"chap-3","slug":"/chap-3/d-b-evaluation","permalink":"/cl-language-reference/chap-3/d-b-evaluation","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-3/d-b-evaluation.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"3.1 Evaluation"},"sidebar":"tutorialSidebar","previous":{"title":"2.4 Standard Macro Characters","permalink":"/cl-language-reference/chap-2/c-e-standard-macro-characters"},"next":{"title":"3.2 Compilation","permalink":"/cl-language-reference/chap-3/d-c-compilation"}}');var s=i(74848),t=i(28453);function l(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||d("DictionaryLink",!0),r||d("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Execution"})," of ",(0,s.jsx)(r,{term:"code",children:(0,s.jsx)("i",{children:"code"})})," can be accomplished by a variety of means ranging from direct interpretation of a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," representing a ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," to invocation of ",(0,s.jsx)(r,{styled:!0,term:"compiled code",children:(0,s.jsx)("i",{children:"compiled code"})})," produced by a ",(0,s.jsx)(r,{term:"compiler",children:(0,s.jsx)("i",{children:"compiler"})})," .\n",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"Evaluation"})})," is the process by which a ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," is ",(0,s.jsx)(n.em,{children:"executed"})," in Common Lisp. The mechanism of ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," is manifested both implicitly through the effect of the ",(0,s.jsx)(n.em,{children:"Lisp read-eval-print loop"}),", and explicitly through the presence of the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})})," ",(0,s.jsx)(i,{term:"eval",children:(0,s.jsx)("b",{children:"eval"})}),", ",(0,s.jsx)(i,{term:"compile",children:(0,s.jsx)("b",{children:"compile"})}),", ",(0,s.jsx)(i,{term:"compile-file",children:(0,s.jsx)("b",{children:"compile-file"})}),", and ",(0,s.jsx)(i,{term:"load",children:(0,s.jsx)("b",{children:"load"})}),". Any of these facilities might share the same execution strategy, or each might use a different one."]}),"\n",(0,s.jsxs)(n.p,{children:["The behavior of a ",(0,s.jsx)(r,{styled:!0,term:"conforming program",children:(0,s.jsx)("i",{children:"conforming program"})})," processed by ",(0,s.jsx)(i,{term:"eval",children:(0,s.jsx)("b",{children:"eval"})})," and by ",(0,s.jsx)(i,{term:"compile-file",children:(0,s.jsx)("b",{children:"compile-file"})})," might differ; see Section 3.2.2.3 (Semantic Constraints)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"Evaluation"})})," can be understood in terms of a model in which an interpreter recursively traverses a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," performing each step of the computation as it goes. This model, which describes the semantics of Common Lisp ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"programs"})}),", is described in Section 3.1.2 (The Evaluation Model)."]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function o(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," is an association between a ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," and that which the name denotes. ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"Bindings"})})," are ",(0,s.jsx)(n.em,{children:"established"})," in a ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," or a ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," by particular ",(0,s.jsx)(i,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operators"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," is a set of ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," and other information used during evaluation (",(0,s.jsx)(n.em,{children:"e.g."}),", to associate meanings with names)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"Bindings"})})," in an ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," are partitioned into ",(0,s.jsx)(i,{term:"namespace",children:(0,s.jsx)("i",{children:"namespaces"})}),". A single ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," can simultaneously have more than one associated ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," per ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})}),", but can have only one associated ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," per ",(0,s.jsx)(i,{term:"namespace",children:(0,s.jsx)("i",{children:"namespace"})}),"."]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function h(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(i,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})})," is that part of an ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," that contains ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," with both ",(0,s.jsx)(i,{styled:!0,term:"indefinite scope",children:(0,s.jsx)("i",{children:"indefinite scope"})})," and ",(0,s.jsx)(i,{styled:!0,term:"indefinite extent",children:(0,s.jsx)("i",{children:"indefinite extent"})}),". The ",(0,s.jsx)(i,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variables"})})," and ",(0,s.jsx)(i,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variables"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("i",{children:"functions"})}),", ",(0,s.jsx)(i,{term:"macro",children:(0,s.jsx)("i",{children:"macros"})}),", and ",(0,s.jsx)(i,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operators"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{styled:!0,term:"compiler macro",children:(0,s.jsx)("i",{children:"compiler macros"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," and ",(0,s.jsx)(n.em,{children:"class names"}),"\n",(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(i,{term:"proclamation",children:(0,s.jsx)("i",{children:"proclamations"})}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}function x(e){const n={code:"code",em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," for ",(0,s.jsx)(i,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," is that part of an ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," that contains ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," whose duration is bounded by points of ",(0,s.jsx)(n.em,{children:"establishment"})," and ",(0,s.jsx)(n.em,{children:"disestablishment"})," within the execution of the ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that established the ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),". A ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," for ",(0,s.jsx)(i,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variables"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"active catch tags"}),".\n",(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(i,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit points"})})," established by ",(0,s.jsx)(n.code,{children:"unwind-protect"}),".\n",(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(n.em,{children:"active handlers"})," and ",(0,s.jsx)(i,{term:"restart",children:(0,s.jsx)("i",{children:"restarts"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," that is active at any given point in the ",(0,s.jsx)(n.em,{children:"execution"})," of a ",(0,s.jsx)(i,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," is referred to by definite reference as \u201cthe current ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})}),",\u201d or sometimes as just \u201cthe ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})}),".\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:["Within a given ",(0,s.jsx)(i,{term:"namespace",children:(0,s.jsx)("i",{children:"namespace"})}),", a ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," is said to be ",(0,s.jsx)(i,{term:"bound",children:(0,s.jsx)("i",{children:"bound"})})," in a ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," if there is a ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," associated with its ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," in the ",(0,s.jsx)(i,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," or, if not, there is a ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," associated with its name in the ",(0,s.jsx)(i,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})}),"."]})]})}function j(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}function u(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," for ",(0,s.jsx)(i,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," at some position in a ",(0,s.jsx)(i,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," is that part of the ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," that contains information having ",(0,s.jsx)(i,{styled:!0,term:"lexical scope",children:(0,s.jsx)("i",{children:"lexical scope"})})," within the ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"forms"})})," containing that position. A ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," contains, among other things, the following:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variables"})})," and ",(0,s.jsx)(i,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macros"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("i",{children:"functions"})})," and ",(0,s.jsx)(i,{term:"macro",children:(0,s.jsx)("i",{children:"macros"})}),". (Implicit in this is information about those ",(0,s.jsx)(i,{styled:!0,term:"compiler macro",children:(0,s.jsx)("i",{children:"compiler macros"})})," that are locally disabled.)\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{styled:!0,term:"block tag",children:(0,s.jsx)("i",{children:"block tags"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022 bindings"})," of ",(0,s.jsx)(i,{styled:!0,term:"go tag",children:(0,s.jsx)("i",{children:"go tags"})}),".\n",(0,s.jsx)(n.em,{children:"\u2022"})," information about ",(0,s.jsx)(i,{term:"declaration",children:(0,s.jsx)("i",{children:"declarations"})}),".\nThe ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," that is active at any given position in a ",(0,s.jsx)(i,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," being semantically processed is referred to by definite reference as \u201cthe current ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),",\u201d or sometimes as just \u201cthe ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),".\u201d"]}),"\n",(0,s.jsxs)(n.p,{children:["Within a given ",(0,s.jsx)(i,{term:"namespace",children:(0,s.jsx)("i",{children:"namespace"})}),", a ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," is said to be ",(0,s.jsx)(i,{term:"bound",children:(0,s.jsx)("i",{children:"bound"})})," in a ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," if there is a ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," associated with its ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," in the ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," or, if not, there is a ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," associated with its name in the ",(0,s.jsx)(i,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}function f(e){const n={code:"code",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(i,{styled:!0,term:"null lexical environment",children:(0,s.jsx)("i",{children:"null lexical environment"})})," is equivalent to the ",(0,s.jsx)(i,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Although in general the representation of an ",(0,s.jsx)(i,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," is ",(0,s.jsx)(i,{term:"implementation-dependent",children:(0,s.jsx)("i",{children:"implementation-dependent"})}),", ",(0,s.jsx)(n.code,{children:"nil"})," can be used in any situation where an ",(0,s.jsx)(i,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," is called for in order to denote the ",(0,s.jsx)(i,{styled:!0,term:"null lexical environment",children:(0,s.jsx)("i",{children:"null lexical environment"})}),"."]})]})}function b(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}function y(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||g("DictionaryLink",!0),r||g("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operators"})})," make use of an ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"object"})}),", called an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})}),", that represents the set of ",(0,s.jsx)(r,{styled:!0,term:"lexical binding",children:(0,s.jsx)("i",{children:"lexical bindings"})})," needed to perform semantic analysis on a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," in a given ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),". The set of ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," in an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," may be a subset of the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," that would be needed to actually perform an ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})}),"; for example, ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," associated with ",(0,s.jsx)(n.em,{children:"variable names"})," and ",(0,s.jsx)(r,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function names"})})," in the corresponding ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," might not be available in an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," and nature of an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," is ",(0,s.jsx)(r,{term:"implementation-dependent",children:(0,s.jsx)("i",{children:"implementation-dependent"})}),". The ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," of ",(0,s.jsx)(r,{styled:!0,term:"environment parameter",children:(0,s.jsx)("i",{children:"environment parameters"})})," to ",(0,s.jsx)(r,{styled:!0,term:"macro function",children:(0,s.jsx)("i",{children:"macro functions"})})," are examples of ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment objects"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"object"})})," ",(0,s.jsx)(i,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})})," when used as an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," denotes the ",(0,s.jsx)(r,{styled:!0,term:"null lexical environment",children:(0,s.jsx)("i",{children:"null lexical environment"})}),"; see Section 3.1.1.3.1 (The Null Lexical Environment)."]})]})}function v(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function g(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function w(e){const n={p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(n.p,{children:["A Common Lisp system evaluates ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"forms"})})," with respect to lexical, dynamic, and global ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environments"})}),". The following sections describe the components of the Common Lisp evaluation model."]})}function T(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(w,{...e})}):w(e)}function k(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"Forms"})})," fall into three categories: ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})}),", ",(0,s.jsx)(n.em,{children:"conses"}),", and ",(0,s.jsx)(i,{styled:!0,term:"self-evaluating object",children:(0,s.jsx)("i",{children:"self-evaluating objects"})}),". The following sections explain these categories."]})}function E(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}function L(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||R("DictionaryLink",!0),r||R("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", then it is either a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})})," or a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," names a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})})," if there is a ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," as a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})})," in the current ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," (see ",(0,s.jsx)(i,{term:"define-symbol-macro",children:(0,s.jsx)("b",{children:"define-symbol-macro"})})," and ",(0,s.jsx)(i,{term:"symbol-macrolet",children:(0,s.jsx)("b",{children:"symbol-macrolet"})}),"). If the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})}),", its expansion function is obtained. The expansion function is a function of two arguments, and is invoked by calling the ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})})," with the expansion function as its"]}),"\n",(0,s.jsxs)(n.p,{children:["first argument, the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," as its second argument, and an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," (corresponding to the current ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),") as its third argument. The ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})}),", in turn, calls the expansion function with the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," as its first argument and the ",(0,s.jsx)(r,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," as its second argument. The ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," of the expansion function, which is passed through by the ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})}),", is a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),". This resulting ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is processed in place of the original ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," that is not a ",(0,s.jsx)(r,{styled:!0,term:"symbol macro",children:(0,s.jsx)("i",{children:"symbol macro"})}),", then it is the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})}),", and the ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," of that ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," is returned. There are three kinds of variables: ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variables"})}),", ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variables"})}),", and ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variables"})}),". A ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," can store one ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"object"})}),". The main operations on a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," are to ",(0,s.jsx)(r,{term:"read",children:(0,s.jsx)("i",{children:"read"})})," ",(0,s.jsx)("sub",{children:"1"})," and to ",(0,s.jsx)(r,{term:"write",children:(0,s.jsx)("i",{children:"write"})}),(0,s.jsx)("sub",{children:"1"})," its ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An error of ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{term:"unbound-variable",children:(0,s.jsx)("b",{children:"unbound-variable"})})," should be signaled if an ",(0,s.jsx)(r,{styled:!0,term:"unbound variable",children:(0,s.jsx)("i",{children:"unbound variable"})})," is referenced."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{styled:!0,term:"non-constant variable",children:(0,s.jsx)("i",{children:"Non-constant variables"})})," can be ",(0,s.jsx)(n.em,{children:"assigned"})," by using ",(0,s.jsx)(i,{term:"setq",children:(0,s.jsx)("b",{children:"setq"})})," or ",(0,s.jsx)(r,{term:"bound",children:(0,s.jsx)("i",{children:"bound"})})," ",(0,s.jsx)("sub",{children:"3"})," by using ",(0,s.jsx)(i,{term:"let",children:(0,s.jsx)("b",{children:"let"})}),". Figure 3\u20131 lists some ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," that are applicable to assigning, binding, and defining ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variables"})}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"boundp let progv\ndefconstant let* psetq\ndefparameter makunbound set\ndefvar multiple-value-bind setq\nlambda multiple-value-setq symbol-value\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20131. Some Defined Names Applicable to Variables"})}),"\n",(0,s.jsx)(n.p,{children:"The following is a description of each kind of variable."})]})}function F(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(L,{...e})}):L(e)}function R(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function G(e){const n={code:"code",em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||D("DictionaryLink",!0),r||D("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," is a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," that can be referenced only within the ",(0,s.jsx)(r,{styled:!0,term:"lexical scope",children:(0,s.jsx)("i",{children:"lexical scope"})})," of the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that establishes that ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})}),"; ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variables"})})," have ",(0,s.jsx)(r,{styled:!0,term:"lexical scope",children:(0,s.jsx)("i",{children:"lexical scope"})}),". Each time a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," creates a ",(0,s.jsx)(r,{styled:!0,term:"lexical binding",children:(0,s.jsx)("i",{children:"lexical binding"})})," of a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})}),", a ",(0,s.jsx)(n.em,{children:"fresh binding"})," is ",(0,s.jsx)(n.em,{children:"established"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Within the ",(0,s.jsx)(r,{term:"scope",children:(0,s.jsx)("i",{children:"scope"})})," of a ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(n.code,{children:"lexical variable name"}),", uses of that ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," as a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," are considered to be references to that ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," except where the ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," is ",(0,s.jsx)(n.em,{children:"shadowed"})," ",(0,s.jsx)("sub",{children:"2"})," by a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that ",(0,s.jsx)(n.em,{children:"establishes"})," a ",(0,s.jsx)(n.em,{children:"fresh binding"})," for that ",(0,s.jsx)(n.code,{children:"variable name"}),", or by a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that locally ",(0,s.jsx)(r,{term:"declare",children:(0,s.jsx)("i",{children:"declares"})})," the ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," always has a ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),". There is no ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," that introduces a ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," without giving it an initial ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),", nor is there any ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," that can make a ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," be ",(0,s.jsx)(r,{term:"unbound",children:(0,s.jsx)("i",{children:"unbound"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"Bindings"})})," of ",(0,s.jsx)(r,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variables"})})," are found in the ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),"."]})]})}function A(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(G,{...e})}):G(e)}function D(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function S(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||N("DictionaryLink",!0),r||N("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," is a ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," if one of the following conditions hold:"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," It is locally declared or globally proclaimed ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"\u2022"})," It occurs textually within a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that creates a ",(0,s.jsx)(r,{styled:!0,term:"dynamic binding",children:(0,s.jsx)("i",{children:"dynamic binding"})})," for a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," of the ",(0,s.jsx)(n.em,{children:"same name"}),", and the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," is not ",(0,s.jsx)(n.em,{children:"shadowed"})," ",(0,s.jsx)("sub",{children:"2"})," by a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that creates a ",(0,s.jsx)(r,{styled:!0,term:"lexical binding",children:(0,s.jsx)("i",{children:"lexical binding"})})," of the same ",(0,s.jsx)(n.em,{children:"variable name"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," can be referenced at any time in any ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"program"})}),"; there is no textual limitation on references to ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variables"})}),". At any given time, all ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variables"})})," with a given name refer to exactly one ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),", either in the ",(0,s.jsx)(r,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})})," or in the ",(0,s.jsx)(r,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," part of the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," might be empty; in this case, the ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," is said to have no ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})}),", or to be ",(0,s.jsx)(r,{term:"unbound",children:(0,s.jsx)("i",{children:"unbound"})}),". A ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," can be made ",(0,s.jsx)(r,{term:"unbound",children:(0,s.jsx)("i",{children:"unbound"})})," by using ",(0,s.jsx)(i,{term:"makunbound",children:(0,s.jsx)("b",{children:"makunbound"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The effect of ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," a ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," is to create a new ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," to which all references to that ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," in any ",(0,s.jsx)(r,{term:"program",children:(0,s.jsx)("i",{children:"program"})})," refer for the duration of the ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that creates the ",(0,s.jsx)(r,{styled:!0,term:"dynamic binding",children:(0,s.jsx)("i",{children:"dynamic binding"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," can be referenced outside the ",(0,s.jsx)(r,{styled:!0,term:"dynamic extent",children:(0,s.jsx)("i",{children:"dynamic extent"})})," of a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that ",(0,s.jsx)(r,{term:"bind",children:(0,s.jsx)("i",{children:"binds"})})," it. Such a ",(0,s.jsx)(r,{term:"variable",children:(0,s.jsx)("i",{children:"variable"})})," is sometimes called a \u201cglobal variable\u201d but is still in all respects just a ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," whose ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," happens to exist in the ",(0,s.jsx)(r,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})})," rather than in some ",(0,s.jsx)(r,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})})," is ",(0,s.jsx)(r,{term:"unbound",children:(0,s.jsx)("i",{children:"unbound"})})," unless and until explicitly assigned a value, except for those variables whose initial value is defined in this specification or by an ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})}),"."]})]})}function C(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(S,{...e})}):S(e)}function N(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function I(e){const n={code:"code",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||z("DictionaryLink",!0),r||z("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Certain variables, called ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variables"})}),", are reserved as \u201cnamed constants.\u201d The consequences are undefined if an attempt is made to assign a value to, or create a ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variable"})}),", except that a \u2018compatible\u2019 redefinition of a ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variable"})})," using ",(0,s.jsx)(i,{term:"defconstant",children:(0,s.jsx)(n.code,{children:"defconstant"})})," is permitted; see the ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," ",(0,s.jsx)(i,{term:"defconstant",children:(0,s.jsx)(n.code,{children:"defconstant"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(r,{term:"keyword",children:(0,s.jsx)("i",{children:"Keywords"})}),", ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," defined by Common Lisp or the ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})})," as constant (such as ",(0,s.jsx)(i,{term:"nil",children:(0,s.jsx)(n.code,{children:"nil"})}),", ",(0,s.jsx)(i,{term:"t",children:(0,s.jsx)(n.code,{children:"t"})}),", and ",(0,s.jsx)(n.code,{children:"pi"}),"), and ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," declared as constant using ",(0,s.jsx)(i,{term:"defconstant",children:(0,s.jsx)(n.code,{children:"defconstant"})})," are ",(0,s.jsx)(r,{styled:!0,term:"constant variable",children:(0,s.jsx)("i",{children:"constant variables"})}),"."]})]})}function q(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(I,{...e})}):I(e)}function z(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function B(e){const n={code:"code",p:"p",pre:"pre",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The same ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," can name both a ",(0,s.jsx)(i,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," and a ",(0,s.jsx)(i,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})}),", but never in the same ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, the ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," x is used, at different times, as the ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(i,{styled:!0,term:"lexical variable",children:(0,s.jsx)("i",{children:"lexical variable"})})," and as the ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of a ",(0,s.jsx)(i,{styled:!0,term:"dynamic variable",children:(0,s.jsx)("i",{children:"dynamic variable"})}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(let ((x 1)) ;Binds a special variable X\n  (declare (special x))\n  (let ((x 2)) ;Binds a lexical variable X\n    (+ x ;Reads a lexical variable X\n       (locally (declare (special x))\n         x)))) ;Reads a special variable X\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u2192 3"})]})}function O(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(B,{...e})}):B(e)}function V(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{term:"cons",children:(0,s.jsx)("i",{children:"cons"})})," that is used as a ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is called a ",(0,s.jsx)(i,{styled:!0,term:"compound form",children:(0,s.jsx)("i",{children:"compound form"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(i,{term:"car",children:(0,s.jsx)("i",{children:"car"})})," of that ",(0,s.jsx)(i,{styled:!0,term:"compound form",children:(0,s.jsx)("i",{children:"compound form"})})," is a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", that ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," is the ",(0,s.jsx)(i,{term:"name",children:(0,s.jsx)("i",{children:"name"})})," of an ",(0,s.jsx)(i,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," , and the ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is either a ",(0,s.jsx)(i,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})}),", a ",(0,s.jsx)(i,{styled:!0,term:"macro form",children:(0,s.jsx)("i",{children:"macro form"})}),", or a ",(0,s.jsx)(i,{styled:!0,term:"function form",children:(0,s.jsx)("i",{children:"function form"})}),", depending on the ",(0,s.jsx)(n.em,{children:"function binding"})," of the ",(0,s.jsx)(i,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," in the current ",(0,s.jsx)(i,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),". If the ",(0,s.jsx)(i,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," is neither a ",(0,s.jsx)(i,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})]}),"\n",(0,s.jsxs)(n.p,{children:["nor a ",(0,s.jsx)(i,{styled:!0,term:"macro name",children:(0,s.jsx)("i",{children:"macro name"})}),", it is assumed to be a ",(0,s.jsx)(i,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function name"})})," (even if there is no definition for such a ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(i,{term:"car",children:(0,s.jsx)("i",{children:"car"})})," of the ",(0,s.jsx)(i,{styled:!0,term:"compound form",children:(0,s.jsx)("i",{children:"compound form"})})," is not a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})}),", then that ",(0,s.jsx)(i,{term:"car",children:(0,s.jsx)("i",{children:"car"})})," must be a ",(0,s.jsx)(i,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),", in which case the ",(0,s.jsx)(i,{styled:!0,term:"compound form",children:(0,s.jsx)("i",{children:"compound form"})})," is a ",(0,s.jsx)(i,{styled:!0,term:"lambda form",children:(0,s.jsx)("i",{children:"lambda form"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["How a ",(0,s.jsx)(i,{styled:!0,term:"compound form",children:(0,s.jsx)("i",{children:"compound form"})})," is processed depends on whether it is classified as a ",(0,s.jsx)(i,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})}),", a ",(0,s.jsx)(i,{styled:!0,term:"macro form",children:(0,s.jsx)("i",{children:"macro form"})}),", a ",(0,s.jsx)(i,{styled:!0,term:"function form",children:(0,s.jsx)("i",{children:"function form"})}),", or a ",(0,s.jsx)(i,{styled:!0,term:"lambda form",children:(0,s.jsx)("i",{children:"lambda form"})}),"."]})]})}function M(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(V,{...e})}):V(e)}function X(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||W("DictionaryLink",!0),r||W("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})})," is a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both. A ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," has access to the current ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," and the current ",(0,s.jsx)(r,{styled:!0,term:"dynamic environment",children:(0,s.jsx)("i",{children:"dynamic environment"})}),". Each ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," defines the manner in which its ",(0,s.jsx)(r,{term:"subexpression",children:(0,s.jsx)("i",{children:"subexpressions"})})," are treated\u2014which are ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"forms"})}),", which are special syntax, ",(0,s.jsx)(n.em,{children:"etc."})]}),"\n",(0,s.jsxs)(n.p,{children:["Some ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operators"})})," create new lexical or dynamic ",(0,s.jsx)(r,{term:"environment",children:(0,s.jsx)("i",{children:"environments"})})," for use during the ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of ",(0,s.jsx)(r,{term:"subform",children:(0,s.jsx)("i",{children:"subforms"})})," of the ",(0,s.jsx)(r,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})}),". For example, ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})})," creates a new ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," that is the same as the one in force at the point of evaluation of the ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})})," ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," with the addition of a ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of the ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})})," name to an ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," from the ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The set of ",(0,s.jsx)(n.em,{children:"special operator names"})," is fixed in Common Lisp; no way is provided for the user to define a ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," . Figure 3\u20132 lists all of the Common Lisp ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," that have definitions as ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operators"})}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"block let* return-from\ncatch load-time-value setq\neval-when locally symbol-macrolet flet macrolet tagbody\nfunction multiple-value-call the\ngo multiple-value-prog1 throw\nif progn unwind-protect labels progv\nlet quote\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20132. Common Lisp Special Operators"})})]})}function H(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(X,{...e})}):X(e)}function W(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function _(e){const n={code:"code",em:"em",p:"p",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||U("DictionaryLink",!0),r||U("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," names a ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),", its associated ",(0,s.jsx)(r,{styled:!0,term:"macro function",children:(0,s.jsx)("i",{children:"macro function"})})," is applied to the entire ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," and the result of that application is used in place of the original ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Specifically, a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," names a ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," in a given ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," if ",(0,s.jsx)(i,{term:"macro-function",children:(0,s.jsx)("b",{children:"macro-function"})})," is ",(0,s.jsx)(r,{term:"true",children:(0,s.jsx)("i",{children:"true"})})," of the ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," and that ",(0,s.jsx)(r,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})}),". The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," returned by ",(0,s.jsx)(i,{term:"macro-function",children:(0,s.jsx)("b",{children:"macro-function"})})," is a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," of two arguments, called the expansion function. The expansion function is invoked by calling the ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})})," with the expansion function as its first argument, the entire ",(0,s.jsx)(r,{styled:!0,term:"macro form",children:(0,s.jsx)("i",{children:"macro form"})})," as its"]}),"\n",(0,s.jsxs)(n.p,{children:["second argument, and an ",(0,s.jsx)(r,{styled:!0,term:"environment object",children:(0,s.jsx)("i",{children:"environment object"})})," (corresponding to the current ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})}),") as its third argument. The ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})}),", in turn, calls the expansion function with the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," as its first argument and the ",(0,s.jsx)(r,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," as its second argument. The ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," of the expansion function, which is passed through by the ",(0,s.jsx)(r,{styled:!0,term:"macroexpand hook",children:(0,s.jsx)("i",{children:"macroexpand hook"})}),", is a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),". The returned ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is ",(0,s.jsx)(n.em,{children:"evaluated"})," in place of the original ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences are undefined if a ",(0,s.jsx)(r,{styled:!0,term:"macro function",children:(0,s.jsx)("i",{children:"macro function"})})," destructively modifies any part of its ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," argument."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"macro name",children:(0,s.jsx)("i",{children:"macro name"})})," is not a ",(0,s.jsx)(r,{styled:!0,term:"function designator",children:(0,s.jsx)("i",{children:"function designator"})})," , and cannot be used as the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," argument to ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})})," such as ",(0,s.jsx)(i,{term:"apply",children:(0,s.jsx)("b",{children:"apply"})}),", ",(0,s.jsx)(i,{term:"funcall",children:(0,s.jsx)("b",{children:"funcall"})}),", or ",(0,s.jsx)(i,{term:"map",children:(0,s.jsx)("b",{children:"map"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})})," is free to implement a Common Lisp ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," as a ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})}),". An ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})})," is free to implement any ",(0,s.jsx)(n.em,{children:"macro operator"})," as a ",(0,s.jsx)(r,{styled:!0,term:"special operator",children:(0,s.jsx)("i",{children:"special operator"})})," , but only if an equivalent definition of the ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macro"})})," is also provided."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20133 lists some ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," that are applicable to ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macros"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"*macroexpand-hook*"})," ",(0,s.jsx)(n.code,{children:"macro-function"})," ",(0,s.jsx)(n.code,{children:"macroexpand-1"})," ",(0,s.jsx)(n.code,{children:"defmacro"})," ",(0,s.jsx)(n.code,{children:"macroexpand"})," ",(0,s.jsx)(n.code,{children:"macrolet"})]}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20133. Defined names applicable to macros"})})]})}function P(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}function U(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function J(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||Q("DictionaryLink",!0),r||Q("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," is a ",(0,s.jsx)(r,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," naming a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),", the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," represents a ",(0,s.jsx)(n.em,{children:"function form"}),", and the ",(0,s.jsx)(r,{term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of the list contains the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"forms"})})," which when evaluated will supply the arguments passed to the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.em,{children:"function name"})," is not defined, an error of ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{term:"undefined-function",children:(0,s.jsx)("b",{children:"undefined-function"})})," should be signaled at run time; see Section 3.2.2.3 (Semantic Constraints)."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"function form"})," is evaluated as follows:"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"subform",children:(0,s.jsx)("i",{children:"subforms"})})," in the ",(0,s.jsx)(r,{term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of the original ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," are evaluated in left-to-right order in the current lexical and dynamic ",(0,s.jsx)(r,{term:"environment",children:(0,s.jsx)("i",{children:"environments"})}),". The ",(0,s.jsx)(n.em,{children:"primary value"})," of each such ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," becomes an ",(0,s.jsx)(r,{term:"argument",children:(0,s.jsx)("i",{children:"argument"})})," to the named ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),"; any additional ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," returned by the ",(0,s.jsx)(r,{term:"subform",children:(0,s.jsx)("i",{children:"subforms"})})," are discarded."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"functional value"})," of the ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," is retrieved from the ",(0,s.jsx)(n.em,{children:"lexical environment"}),", and that ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," is invoked with the indicated arguments."]}),"\n",(0,s.jsxs)(n.p,{children:["Although the order of ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"})," themselves is strictly left-to-right, it is not specified whether the definition of the ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operator"})})," in a ",(0,s.jsx)(n.em,{children:"function form"})," is looked up before the ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"}),", after the ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of the ",(0,s.jsx)(n.em,{children:"argument subforms"}),", or between the ",(0,s.jsx)(r,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of any two ",(0,s.jsx)(n.em,{children:"argument subforms"})," if there is more than one such ",(0,s.jsx)(n.em,{children:"argument subform"}),". For example, the following might return 23 or 24."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun foo (x) (+ x 3))\n\n(defun bar () (setf (symbol-function \u2019foo) #\u2019(lambda (x) (+ x 4))))\n\n(foo (progn (bar) 20))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(r,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function name"})})," can be ",(0,s.jsx)(n.em,{children:"established"})," in one of several ways. A ",(0,s.jsx)(n.em,{children:"bind ing"})," for a ",(0,s.jsx)(r,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function name"})})," in the ",(0,s.jsx)(r,{styled:!0,term:"global environment",children:(0,s.jsx)("i",{children:"global environment"})})," can be ",(0,s.jsx)(n.em,{children:"established"})," by ",(0,s.jsx)(i,{term:"defun",children:(0,s.jsx)("b",{children:"defun"})}),", ",(0,s.jsx)(i,{term:"setf",children:(0,s.jsx)("b",{children:"setf"})})," of ",(0,s.jsx)(i,{term:"fdefinition",children:(0,s.jsx)("b",{children:"fdefinition"})}),", ",(0,s.jsx)(i,{term:"setf",children:(0,s.jsx)("b",{children:"setf"})})," of ",(0,s.jsx)(i,{term:"symbol-function",children:(0,s.jsx)("b",{children:"symbol-function"})}),", ",(0,s.jsx)(i,{term:"ensure-generic-function",children:(0,s.jsx)("b",{children:"ensure-generic-function"})}),", ",(0,s.jsx)(i,{term:"defmethod",children:(0,s.jsx)("b",{children:"defmethod"})})," (implicitly, due to ",(0,s.jsx)(i,{term:"ensure-generic-function",children:(0,s.jsx)("b",{children:"ensure-generic-function"})}),"), or ",(0,s.jsx)(i,{term:"defgeneric",children:(0,s.jsx)("b",{children:"defgeneric"})}),". A ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for a ",(0,s.jsx)(r,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function name"})})," in the ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," can be ",(0,s.jsx)(n.em,{children:"established"})," by ",(0,s.jsx)(i,{term:"flet",children:(0,s.jsx)("b",{children:"flet"})})," or ",(0,s.jsx)(i,{term:"labels",children:(0,s.jsx)("b",{children:"labels"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20134 lists some ",(0,s.jsx)(r,{styled:!0,term:"defined name",children:(0,s.jsx)("i",{children:"defined names"})})," that are applicable to ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"apply fdefinition mapcan"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"call-arguments-limit flet mapcar"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"complement fmakunbound mapcon"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"constantly funcall mapl"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"defgeneric function maplist"})," "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.strong,{children:"defmethod functionp multiple-value-call defun labels reduce"})," "]}),(0,s.jsx)("p",{children:(0,s.jsx)(n.strong,{children:"fboundp map symbol-function"})}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20134. Some function-related defined names"})})]})}function K(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(J,{...e})}):J(e)}function Q(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Y(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||$("DictionaryLink",!0),r||$("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"lambda form",children:(0,s.jsx)("i",{children:"lambda form"})})," is similar to a ",(0,s.jsx)(r,{styled:!0,term:"function form",children:(0,s.jsx)("i",{children:"function form"})}),", except that the ",(0,s.jsx)(r,{styled:!0,term:"function name",children:(0,s.jsx)("i",{children:"function name"})})," is replaced by a ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"lambda form",children:(0,s.jsx)("i",{children:"lambda form"})})," is equivalent to using ",(0,s.jsx)(n.em,{children:"funcall"})," of a ",(0,s.jsx)(r,{styled:!0,term:"lexical closure",children:(0,s.jsx)("i",{children:"lexical closure"})})," of the ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," on the given ",(0,s.jsx)(r,{term:"argument",children:(0,s.jsx)("i",{children:"arguments"})}),". (In practice, some compilers are more likely to produce inline code for a ",(0,s.jsx)(r,{styled:!0,term:"lambda form",children:(0,s.jsx)("i",{children:"lambda form"})})," than for an arbitrary named function that has been declared ",(0,s.jsx)(i,{term:"inline",children:(0,s.jsx)("b",{children:"inline"})}),"; however, such a difference is not semantic.)"]}),"\n",(0,s.jsx)(n.p,{children:"For further information, see Section 3.1.3 (Lambda Expressions)."})]})}function Z(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Y,{...e})}):Y(e)}function $(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ee(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(i,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," that is neither a ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," nor a ",(0,s.jsx)(i,{term:"cons",children:(0,s.jsx)("i",{children:"cons"})})," is defined to be a ",(0,s.jsxs)(n.em,{children:["self-evaluating object",(0,s.jsx)(i,{term:"t",children:(0,s.jsx)("i",{children:". "})}),"Evaluating"]})," such an ",(0,s.jsx)(n.em,{children:"object yields"})," the ",(0,s.jsx)(n.em,{children:"same object"})," as a result."]}),"\n",(0,s.jsxs)(n.p,{children:["Certain specific ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," and ",(0,s.jsx)(n.em,{children:"conses"})," might also happen to be \u201cself-evaluating\u201d but only as a special case of a more general set of rules for the ",(0,s.jsx)(i,{term:"evaluation",children:(0,s.jsx)("i",{children:"evaluation"})})," of ",(0,s.jsx)(i,{term:"symbol",children:(0,s.jsx)("i",{children:"symbols"})})," and ",(0,s.jsx)(n.em,{children:"conses"}),"; such ",(0,s.jsx)(i,{term:"object",children:(0,s.jsx)("i",{children:"objects"})})," are not considered to be ",(0,s.jsx)(i,{styled:!0,term:"self-evaluating object",children:(0,s.jsx)("i",{children:"self-evaluating objects"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The consequences are undefined if ",(0,s.jsx)(n.em,{children:"literal objects"})," (including ",(0,s.jsx)(i,{styled:!0,term:"self-evaluating object",children:(0,s.jsx)("i",{children:"self-evaluating objects"})}),") are destructively modified."]})]})}function ne(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ee,{...e})}):ee(e)}function ie(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Numbers"}),", ",(0,s.jsx)(n.em,{children:"pathnames"}),", and ",(0,s.jsx)(n.em,{children:"arrays"})," are examples of ",(0,s.jsx)(n.em,{children:"self-evaluating objects"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:'3 \u2192 3 \n#c(2/3 5/8) \u2192 #C(2/3 5/8) \n#p"S:[BILL]OTHELLO.TXT" \u2192 #P"S:[BILL]OTHELLO.TXT" \n#(a b c) \u2192 #(A B C) \n"fred smith" \u2192 "fred smith" \n'})})]})}function re(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ie,{...e})}):ie(e)}function se(e){const n={em:"em",p:"p",...(0,t.R)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In a ",(0,s.jsx)(i,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),", the body is evaluated in a lexical ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})})," that is formed by adding the ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of each ",(0,s.jsx)(i,{term:"parameter",children:(0,s.jsx)("i",{children:"parameter"})})," in the ",(0,s.jsx)(i,{styled:!0,term:"lambda list",children:(0,s.jsx)("i",{children:"lambda list"})})," with the corresponding ",(0,s.jsx)(i,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," from the ",(0,s.jsx)(i,{term:"argument",children:(0,s.jsx)("i",{children:"arguments"})})," to the current lexical ",(0,s.jsx)(i,{term:"environment",children:(0,s.jsx)("i",{children:"environment"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For further discussion of how ",(0,s.jsx)(i,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," are ",(0,s.jsx)(n.em,{children:"established"})," based on the ",(0,s.jsx)(i,{styled:!0,term:"lambda list",children:(0,s.jsx)("i",{children:"lambda list"})}),", see Section 3.4 (Lambda Lists)."]}),"\n",(0,s.jsxs)(n.p,{children:["The body of a ",(0,s.jsx)(i,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," is an ",(0,s.jsx)(i,{styled:!0,term:"implicit progn",children:(0,s.jsx)("i",{children:"implicit progn"})}),"; the ",(0,s.jsx)(i,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," it returns are returned by the ",(0,s.jsx)(i,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),"."]})]})}function te(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(se,{...e})}):se(e)}function le(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||de("DictionaryLink",!0),r||de("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(r,{styled:!0,term:"lexical closure",children:(0,s.jsx)("i",{children:"lexical closure"})})," is a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," that can refer to and alter the values of ",(0,s.jsx)(n.em,{children:"lexical bindings established"})," by ",(0,s.jsx)(n.em,{children:"binding forms"})," that textually include the function definition."]}),"\n",(0,s.jsxs)(n.p,{children:["Consider this code, where x is not declared ",(0,s.jsx)(i,{term:"special",children:(0,s.jsx)("b",{children:"special"})}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun two-funs (x) \n  (list (function (lambda () x)) \n        (function (lambda (y) (setq x y))))) \n(setq funs (two-funs 6)) \n(funcall (car funs)) \u2192 6 \n(funcall (cadr funs) 43) \u2192 43 \n(funcall (car funs)) \u2192 43 \n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("b",{children:"function"})})," ",(0,s.jsx)(r,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})})," coerces a ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," into a ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," in which the ",(0,s.jsx)(r,{styled:!0,term:"lexical environment",children:(0,s.jsx)("i",{children:"lexical environment"})})," in effect when the ",(0,s.jsx)(r,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special form"})})," is evaluated is captured along with the ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The function two-funs returns a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of two ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})}),", each of which refers to the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of the variable x created on entry to the function two-funs when it was called. This variable has the value 6 initially, but ",(0,s.jsx)(i,{term:"setq",children:(0,s.jsx)("b",{children:"setq"})})," can alter this ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})}),". The ",(0,s.jsx)(r,{styled:!0,term:"lexical closure",children:(0,s.jsx)("i",{children:"lexical closure"})})," created for the first ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," does not \u201csnapshot\u201d the ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," 6 for x when the ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," is created; rather it captures the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of x. The second ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," can be used to alter the ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"value"})})," in the same (captured) ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," (to 43, in the example), and this altered variable binding then affects the value returned by the first ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In situations where a ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," of a ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," over the same set of ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," may be produced more than once, the various resulting ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closures"})})," may or may not be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})}),", at the discretion of the ",(0,s.jsx)(r,{term:"implementation",children:(0,s.jsx)("i",{children:"implementation"})}),". That is, two ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})})," that are behaviorally indistinguishable might or might not be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})}),". Two ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"functions"})})," that are behaviorally distinguishable are ",(0,s.jsx)(r,{term:"distinct",children:(0,s.jsx)("i",{children:"distinct"})}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(let ((x 5) (funs \u2019()))\n  (dotimes (j 10)\n    (push #\u2019(lambda (z)\n              (if (null z) (setq x 0) (+ x z)))\n            funs))\n  funs)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The result of the above ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," is a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ten ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closures"})}),". Each requires only the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of x. It is the same ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," in each case, but the ten ",(0,s.jsx)(n.em,{children:"closure objects"})," might or might not be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})}),". On the other hand, the result of the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(let ((funs \u2019()))\n  (dotimes (j 10)\n    (let ((x 5))\n      (push (function (lambda (z)\n              (if (null z) (setq x 0) (+ x z))))\n            funs)))\n  funs)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["is also a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ten ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closures"})}),". However, in this case no two of the ",(0,s.jsx)(n.em,{children:"closure objects"})," can be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})})," because each ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," is closed over a distinct ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of x, and these ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," can be behaviorally distinguished because of the use of ",(0,s.jsx)(i,{term:"setq",children:(0,s.jsx)("b",{children:"setq"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The result of the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(let ((funs \u2019()))\n  (dotimes (j 10)\n    (let ((x 5))\n      (push (function (lambda (z) (+ x z)))\n            funs)))\n  funs)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["is a ",(0,s.jsx)(r,{term:"list",children:(0,s.jsx)("i",{children:"list"})})," of ten ",(0,s.jsx)(n.em,{children:"closure objects"})," that might or might not be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})}),". A different ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of x is involved for each ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})}),", but the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"bindings"})})," cannot be distinguished because their values are the ",(0,s.jsx)(r,{term:"same",children:(0,s.jsx)("i",{children:"same"})})," and immutable (there being no occurrence of ",(0,s.jsx)(i,{term:"setq",children:(0,s.jsx)("b",{children:"setq"})})," on x). A compiler could internally transform the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," to"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(let ((funs \u2019()))\n  (dotimes (j 10)\n    (push (function (lambda (z) (+ 5 z)))\n          funs))\n  funs)  \n"})}),"\n",(0,s.jsxs)(n.p,{children:["where the ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closures"})})," may be ",(0,s.jsx)(r,{term:"identical",children:(0,s.jsx)("i",{children:"identical"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It is possible that a ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," does not close over any variable bindings. In the code fragment ",(0,s.jsx)(n.code,{children:"(mapcar (function (lambda (x) (+ x 2))) y)"})]}),"\n",(0,s.jsxs)(n.p,{children:["the function ",(0,s.jsx)(n.code,{children:"(lambda (x) (+ x 2))"})," contains no references to any outside object. In this case, the same ",(0,s.jsx)(r,{term:"closure",children:(0,s.jsx)("i",{children:"closure"})})," might be returned for all evaluations of the ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("b",{children:"function"})})," ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),"."]})]})}function ce(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(le,{...e})}):le(e)}function de(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function oe(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||he("DictionaryLink",!0),r||he("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If two ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"forms"})})," that ",(0,s.jsx)(n.em,{children:"establish lexical bindings"})," with the same ",(0,s.jsx)(n.em,{children:"name N"})," are textually nested, then references to ",(0,s.jsx)(n.em,{children:"N"})," within the inner ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," refer to the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," established by the inner ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),"; the inner ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for ",(0,s.jsx)(n.em,{children:"N shadows"})," the outer ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," for ",(0,s.jsx)(n.em,{children:"N"}),". Outside the inner ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," but inside the outer one, references to ",(0,s.jsx)(n.em,{children:"N"})," refer to the ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," established by the outer ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun test (x z)\n  (let ((z (\\* x 2)))\n    (print z))\n  z)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"binding",children:(0,s.jsx)("i",{children:"binding"})})," of the variable z by ",(0,s.jsx)(i,{term:"let",children:(0,s.jsx)("b",{children:"let"})})," shadows the ",(0,s.jsx)(r,{term:"parameter",children:(0,s.jsx)("i",{children:"parameter"})})," binding for the function test. The reference to the variable z in the ",(0,s.jsx)(i,{term:"print",children:(0,s.jsx)("b",{children:"print"})})," ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," refers to the ",(0,s.jsx)(i,{term:"let",children:(0,s.jsx)("b",{children:"let"})})," binding. The reference to z at the end of the function test refers to the ",(0,s.jsx)(r,{term:"parameter",children:(0,s.jsx)("i",{children:"parameter"})})," named z."]}),"\n",(0,s.jsxs)(n.p,{children:["Constructs that are lexically scoped act as if new names were generated for each ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"object"})})," on each execution. Therefore, dynamic shadowing cannot occur. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun contorted-example (f g x)\n  (if (= x 0)\n      (funcall f)\n      (block here\n        (+ 5 (contorted-example g\n                                #\u2019(lambda () (return-from here 4))\n                                (- x 1))))))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Consider the call ",(0,s.jsx)(n.code,{children:"(contorted-example nil nil 2)"}),". This produces ",(0,s.jsx)(n.code,{children:"4"}),". During the course of execution, there are three calls to ",(0,s.jsx)(n.code,{children:"contorted-example"}),", interleaved with two ",(0,s.jsx)(n.code,{children:"blocks"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(contorted-example nil nil 2)\n(block here<sub>1</sub> ...)\n(contorted-example nil #\u2019(lambda () (return-from here<sub>1</sub> 4)) 1)\n(block here<sub>2</sub> ...)\n(contorted-example #\u2019(lambda () (return-from here<sub>1</sub> 4))\n                   #\u2019(lambda () (return-from here<sub>2</sub> 4))\n                   \\0)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"(funcall f)"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"f"})," \u2192 ",(0,s.jsx)(n.code,{children:"#\u2019(lambda () (return-from here<sub>1</sub> 4))"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(return-from here<sub>1</sub> 4)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At the time the ",(0,s.jsx)(n.code,{children:"funcall"})," is executed there are two ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})})," ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit points"})})," outstanding, each apparently named ",(0,s.jsx)(n.code,{children:"here"}),". The ",(0,s.jsx)(i,{term:"return-from",children:(0,s.jsx)("b",{children:"return-from"})})," ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," executed as a result of the ",(0,s.jsx)(n.code,{children:"funcall"})," operation refers to the outer outstanding ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," (",(0,s.jsx)(n.code,{children:"here<sub>1</sub>"}),"), not the inner one (",(0,s.jsx)(n.code,{children:"here<sub>2</sub>"}),"). It refers to that ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," textually visible at the point of execution of ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("b",{children:"function"})})," (",(0,s.jsx)(n.code,{children:"here"})," abbreviated by the ",(0,s.jsx)(n.code,{children:"#\u2019"})," syntax) that resulted in creation of the ",(0,s.jsx)(n.em,{children:"function object"})," actually invoked by ",(0,s.jsx)(i,{term:"funcall",children:(0,s.jsx)("b",{children:"funcall"})}),".\nIf, in this example, one were to change the ",(0,s.jsx)(n.code,{children:"(funcall f)"})," to ",(0,s.jsx)(n.code,{children:"(funcall g)"}),", then the value of the call ",(0,s.jsx)(n.code,{children:"(contorted-example nil nil 2)"})," would be ",(0,s.jsx)(n.code,{children:"9"}),". The value would change because ",(0,s.jsx)(i,{term:"funcall",children:(0,s.jsx)("b",{children:"funcall"})})," would cause the execution of ",(0,s.jsx)(n.code,{children:"(return-from here<sub>2</sub> 4)"}),", thereby causing a return from the inner ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," (",(0,s.jsx)(n.code,{children:"here<sub>2</sub>"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["When that occurs, the value ",(0,s.jsx)(n.code,{children:"4"})," is returned from the middle invocation of ",(0,s.jsx)(n.code,{children:"contorted-example"}),", ",(0,s.jsx)(n.code,{children:"5"})," is added to that to get ",(0,s.jsx)(n.code,{children:"9"}),", and that value is returned from the outer block and the outermost call to ",(0,s.jsx)(n.code,{children:"contorted-example"}),". The point is that the choice of ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," returned from has nothing to do with its being innermost or outermost; rather, it depends on the lexical environment that is packaged up with a ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})})," when ",(0,s.jsx)(i,{term:"function",children:(0,s.jsx)("b",{children:"function"})})," is executed."]})]})}function ae(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(oe,{...e})}):oe(e)}function he(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function me(e){const n={code:"code",em:"em",p:"p",pre:"pre",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||je("DictionaryLink",!0),r||je("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Contorted-example works only because the ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," named by f is invoked during the ",(0,s.jsx)(r,{term:"extent",children:(0,s.jsx)("i",{children:"extent"})})," of the ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})}),". Once the flow of execution has left the block, the ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," is ",(0,s.jsx)(n.em,{children:"disestablished"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun invalid-example ()\n  (let ((y (block here #\u2019(lambda (z) (return-from here z)))))\n    (if (numberp y) y (funcall y 5))))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["One might expect the call ",(0,s.jsx)(n.code,{children:"(invalid-example)"})," to produce ",(0,s.jsx)(n.code,{children:"5"})," by the following incorrect reasoning: ",(0,s.jsx)(i,{term:"let",children:(0,s.jsx)("b",{children:"let"})})," binds ",(0,s.jsx)(n.code,{children:"y"})," to the value of ",(0,s.jsx)(i,{term:"block",children:(0,s.jsx)("b",{children:"block"})}),"; this value is a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," resulting from the ",(0,s.jsx)(r,{styled:!0,term:"lambda expression",children:(0,s.jsx)("i",{children:"lambda expression"})}),". Because ",(0,s.jsx)(n.code,{children:"y"})," is not a number, it is invoked on the value ",(0,s.jsx)(n.code,{children:"5"}),". The ",(0,s.jsx)(i,{term:"return-from",children:(0,s.jsx)("b",{children:"return-from"})})," should then return this value from the ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," named here, thereby exiting from the block again and giving ",(0,s.jsx)(n.code,{children:"y"})," the value ",(0,s.jsx)(n.code,{children:"5"})," which, being a number, is then returned as the value of the call to ",(0,s.jsx)(n.code,{children:"invalid-example"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The argument fails only because ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit points"})})," have ",(0,s.jsx)(r,{styled:!0,term:"dynamic extent",children:(0,s.jsx)("i",{children:"dynamic extent"})}),". The argument is correct up to the execution of ",(0,s.jsx)(i,{term:"return-from",children:(0,s.jsx)("b",{children:"return-from"})}),". The execution of ",(0,s.jsx)(i,{term:"return-from",children:(0,s.jsx)("b",{children:"return-from"})})," should signal an error of ",(0,s.jsx)(r,{term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{term:"control-error",children:(0,s.jsx)("b",{children:"control-error"})}),", however, not because it cannot refer to the ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})}),", but because it does correctly refer to an ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," and that ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," has been ",(0,s.jsx)(n.em,{children:"disestablished"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A reference by name to a dynamic ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit point"})})," binding such as a ",(0,s.jsx)(r,{styled:!0,term:"catch tag",children:(0,s.jsx)("i",{children:"catch tag"})})," refers to the most recently ",(0,s.jsx)(n.em,{children:"established binding"})," of that name that has not been ",(0,s.jsx)(n.em,{children:"disestablished"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun fun1 (x)\n  (catch \u2019trap (+ 3 (fun2 x))))\n\n(defun fun2 (y)\n  (catch \u2019trap (* 5 (fun3 y))))\n\n(defun fun3 (z)\n  (throw \u2019trap z))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Consider the call ",(0,s.jsx)(n.code,{children:"(fun1 7)"}),". The result is ",(0,s.jsx)(n.code,{children:"10"}),". At the time the ",(0,s.jsx)(i,{term:"throw",children:(0,s.jsx)("b",{children:"throw"})})," is executed, there are two outstanding catchers with the name ",(0,s.jsx)(n.code,{children:"trap"}),": one established within procedure ",(0,s.jsx)(n.code,{children:"fun1"}),", and the other within procedure ",(0,s.jsx)(n.code,{children:"fun2"}),". The latter is the more recent, and so the value ",(0,s.jsx)(n.code,{children:"7"})," is returned from ",(0,s.jsx)(i,{term:"catch",children:(0,s.jsx)("b",{children:"catch"})})," in ",(0,s.jsx)(n.code,{children:"fun2"}),". Viewed from within ",(0,s.jsx)(n.code,{children:"fun3"}),", the ",(0,s.jsx)(i,{term:"catch",children:(0,s.jsx)("b",{children:"catch"})})," in ",(0,s.jsx)(n.code,{children:"fun2"})," shadows the one in ",(0,s.jsx)(n.code,{children:"fun1"}),". Had ",(0,s.jsx)(n.code,{children:"fun2"})," been defined as"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(defun fun2 (y)\n  (catch \u2019snare (* 5 (fun3 y))))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["then the two ",(0,s.jsx)(r,{styled:!0,term:"exit point",children:(0,s.jsx)("i",{children:"exit points"})})," would have different ",(0,s.jsx)(r,{term:"name",children:(0,s.jsx)("i",{children:"names"})}),", and therefore the one in ",(0,s.jsx)(n.code,{children:"fun1"})," would not be shadowed. The result would then have been ",(0,s.jsx)(n.code,{children:"7"}),"."]})]})}function xe(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(me,{...e})}):me(e)}function je(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ue(e){const n={code:"code",em:"em",p:"p",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:r}=n;return i||fe("DictionaryLink",!0),r||fe("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Ordinarily the result of calling a ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," is a single ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"object"})}),". Sometimes, however, it is convenient for a function to compute several ",(0,s.jsx)(r,{term:"object",children:(0,s.jsx)("i",{children:"objects"})})," and return them."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to receive other than exactly one value from a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),", one of several ",(0,s.jsx)(r,{styled:!0,term:"special form",children:(0,s.jsx)("i",{children:"special forms"})})," or ",(0,s.jsx)(r,{term:"macro",children:(0,s.jsx)("i",{children:"macros"})})," must be used to request those values. If a ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," produces ",(0,s.jsx)(r,{styled:!0,term:"multiple values",children:(0,s.jsx)("i",{children:"multiple values"})})," which were not requested in this way, then the first value is given to the caller and all others are discarded; if the ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})})," produces zero values, then the caller receives ",(0,s.jsx)(i,{term:"nil",children:(0,s.jsx)("b",{children:"nil"})})," as a value."]}),"\n",(0,s.jsxs)(n.p,{children:["Figure 3\u20135 lists some ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operators"})})," for receiving ",(0,s.jsx)(r,{styled:!0,term:"multiple values",children:(0,s.jsx)("i",{children:"multiple values"})}),(0,s.jsx)("sub",{children:"2"}),". These ",(0,s.jsx)(r,{term:"operator",children:(0,s.jsx)("i",{children:"operators"})})," can be used to specify one or more ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"forms"})})," to ",(0,s.jsx)(r,{term:"evaluate",children:(0,s.jsx)("i",{children:"evaluate"})})," and where to put the ",(0,s.jsx)(r,{term:"value",children:(0,s.jsx)("i",{children:"values"})})," returned by those ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"forms"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.code,{children:"multiple-value-bind"})," ",(0,s.jsx)(n.code,{children:"multiple-value-prog1"})," ",(0,s.jsx)(n.code,{children:"return-from"})," ",(0,s.jsx)(n.code,{children:"multiple-value-call"})," ",(0,s.jsx)(n.code,{children:"multiple-value-setq"})," ",(0,s.jsx)(n.code,{children:"throw"})]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.code,{children:"multiple-value-list"})," ",(0,s.jsx)(n.code,{children:"return"})]}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 3\u20135. Some operators applicable to receiving multiple values"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(r,{term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(i,{term:"values",children:(0,s.jsx)("b",{children:"values"})})," can produce ",(0,s.jsx)(r,{styled:!0,term:"multiple values",children:(0,s.jsx)("i",{children:"multiple values"})}),(0,s.jsx)("sub",{children:"2"}),". ",(0,s.jsx)(n.code,{children:"(values)"})," returns zero values; ",(0,s.jsx)(n.code,{children:'(values <GlossaryTerm  term={"form"}><i>form</i></GlossaryTerm>)'})," returns the ",(0,s.jsx)(r,{styled:!0,term:"primary value",children:(0,s.jsx)("i",{children:"primary value"})})," returned by ",(0,s.jsx)(r,{term:"form",children:(0,s.jsx)("i",{children:"form"})}),"; ",(0,s.jsx)(n.code,{children:"(values *form1 form2*)"})," returns two values, the ",(0,s.jsx)(r,{styled:!0,term:"primary value",children:(0,s.jsx)("i",{children:"primary value"})})," of ",(0,s.jsx)(n.em,{children:"form1"})," and the ",(0,s.jsx)(r,{styled:!0,term:"primary value",children:(0,s.jsx)("i",{children:"primary value"})})," of ",(0,s.jsx)(n.em,{children:"form2"}),"; and so on."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(i,{term:"multiple-values-limit",children:(0,s.jsx)("b",{children:"multiple-values-limit"})})," and ",(0,s.jsx)(i,{term:"values-list",children:(0,s.jsx)("b",{children:"values-list"})}),"."]})]})}function pe(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(ue,{...e})}):ue(e)}function fe(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const be={title:"3.1 Evaluation"},ye="3.1 Evaluation",ve={},ge=[{value:"3.1.1 Introduction to Environments",id:"311-introduction-to-environments",level:2},{value:"3.1.1.1 The Global Environment",id:"3111-the-global-environment",level:3},{value:"3.1.1.2 Dynamic Environments",id:"3112-dynamic-environments",level:3},{value:"3.1.1.3 Lexical Environments",id:"3113-lexical-environments",level:3},{value:"3.1.1.3.1 The Null Lexical Environment",id:"31131-the-null-lexical-environment",level:4},{value:"3.1.1.4 Environment Objects",id:"3114-environment-objects",level:3},{value:"3.1.2 The Evaluation Model",id:"312-the-evaluation-model",level:2},{value:"3.1.2.1 Form Evaluation",id:"3121-form-evaluation",level:3},{value:"3.1.2.1.1 Symbols as Forms",id:"31211-symbols-as-forms",level:4},{value:"3.1.2.1.1.1 Lexical Variables",id:"312111-lexical-variables",level:5},{value:"3.1.2.1.1.2 Dynamic Variables",id:"312112-dynamic-variables",level:5},{value:"3.1.2.1.1.3 Constant Variables",id:"312113-constant-variables",level:5},{value:"3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables",id:"312114-symbols-naming-both-lexical-and-dynamic-variables",level:5},{value:"3.1.2.1.2 Conses as Forms",id:"31212-conses-as-forms",level:4},{value:"3.1.2.1.2.1 Special Forms",id:"312121-special-forms",level:5},{value:"3.1.2.1.2.2 Macro Forms",id:"312122-macro-forms",level:5},{value:"3.1.2.1.2.3 Function Forms",id:"312123-function-forms",level:5},{value:"3.1.2.1.2.4 Lambda Forms",id:"312124-lambda-forms",level:5},{value:"3.1.2.1.3 Self",id:"31213-self",level:4},{value:"3.1.2.1.3.1 Examples of Self",id:"312131-examples-of-self",level:5},{value:"3.1.3 Lambda Expressions",id:"313-lambda-expressions",level:2},{value:"3.1.4 Closures and Lexical Binding",id:"314-closures-and-lexical-binding",level:2},{value:"3.1.5 Shadowing",id:"315-shadowing",level:2},{value:"3.1.6 Extent",id:"316-extent",level:2},{value:"3.1.7 Return Values",id:"317-return-values",level:2}];function we(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"31-evaluation",children:"3.1 Evaluation"})}),"\n","\n",(0,s.jsx)(c,{}),"\n",(0,s.jsx)(n.h2,{id:"311-introduction-to-environments",children:"3.1.1 Introduction to Environments"}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(n.h3,{id:"3111-the-global-environment",children:"3.1.1.1 The Global Environment"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(n.h3,{id:"3112-dynamic-environments",children:"3.1.1.2 Dynamic Environments"}),"\n","\n",(0,s.jsx)(j,{}),"\n",(0,s.jsx)(n.h3,{id:"3113-lexical-environments",children:"3.1.1.3 Lexical Environments"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(n.h4,{id:"31131-the-null-lexical-environment",children:"3.1.1.3.1 The Null Lexical Environment"}),"\n","\n",(0,s.jsx)(b,{}),"\n",(0,s.jsx)(n.h3,{id:"3114-environment-objects",children:"3.1.1.4 Environment Objects"}),"\n","\n",(0,s.jsx)(v,{}),"\n",(0,s.jsx)(n.h2,{id:"312-the-evaluation-model",children:"3.1.2 The Evaluation Model"}),"\n","\n",(0,s.jsx)(T,{}),"\n",(0,s.jsx)(n.h3,{id:"3121-form-evaluation",children:"3.1.2.1 Form Evaluation"}),"\n","\n",(0,s.jsx)(E,{}),"\n",(0,s.jsx)(n.h4,{id:"31211-symbols-as-forms",children:"3.1.2.1.1 Symbols as Forms"}),"\n","\n",(0,s.jsx)(F,{}),"\n",(0,s.jsx)(n.h5,{id:"312111-lexical-variables",children:"3.1.2.1.1.1 Lexical Variables"}),"\n","\n",(0,s.jsx)(A,{}),"\n",(0,s.jsx)(n.h5,{id:"312112-dynamic-variables",children:"3.1.2.1.1.2 Dynamic Variables"}),"\n","\n",(0,s.jsx)(C,{}),"\n",(0,s.jsx)(n.h5,{id:"312113-constant-variables",children:"3.1.2.1.1.3 Constant Variables"}),"\n","\n",(0,s.jsx)(q,{}),"\n",(0,s.jsx)(n.h5,{id:"312114-symbols-naming-both-lexical-and-dynamic-variables",children:"3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables"}),"\n","\n",(0,s.jsx)(O,{}),"\n",(0,s.jsx)(n.h4,{id:"31212-conses-as-forms",children:"3.1.2.1.2 Conses as Forms"}),"\n","\n",(0,s.jsx)(M,{}),"\n",(0,s.jsx)(n.h5,{id:"312121-special-forms",children:"3.1.2.1.2.1 Special Forms"}),"\n","\n",(0,s.jsx)(H,{}),"\n",(0,s.jsx)(n.h5,{id:"312122-macro-forms",children:"3.1.2.1.2.2 Macro Forms"}),"\n","\n",(0,s.jsx)(P,{}),"\n",(0,s.jsx)(n.h5,{id:"312123-function-forms",children:"3.1.2.1.2.3 Function Forms"}),"\n","\n",(0,s.jsx)(K,{}),"\n",(0,s.jsx)(n.h5,{id:"312124-lambda-forms",children:"3.1.2.1.2.4 Lambda Forms"}),"\n","\n",(0,s.jsx)(Z,{}),"\n",(0,s.jsx)(n.h4,{id:"31213-self",children:"3.1.2.1.3 Self"}),"\n","\n",(0,s.jsx)(ne,{}),"\n",(0,s.jsx)(n.h5,{id:"312131-examples-of-self",children:"3.1.2.1.3.1 Examples of Self"}),"\n","\n",(0,s.jsx)(re,{}),"\n",(0,s.jsx)(n.h2,{id:"313-lambda-expressions",children:"3.1.3 Lambda Expressions"}),"\n","\n",(0,s.jsx)(te,{}),"\n",(0,s.jsx)(n.h2,{id:"314-closures-and-lexical-binding",children:"3.1.4 Closures and Lexical Binding"}),"\n","\n",(0,s.jsx)(ce,{}),"\n",(0,s.jsx)(n.h2,{id:"315-shadowing",children:"3.1.5 Shadowing"}),"\n","\n",(0,s.jsx)(ae,{}),"\n",(0,s.jsx)(n.h2,{id:"316-extent",children:"3.1.6 Extent"}),"\n","\n",(0,s.jsx)(xe,{}),"\n",(0,s.jsx)(n.h2,{id:"317-return-values",children:"3.1.7 Return Values"}),"\n","\n",(0,s.jsx)(pe,{})]})}function Te(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(we,{...e})}):we(e)}}}]);