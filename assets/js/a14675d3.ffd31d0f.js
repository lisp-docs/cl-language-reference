"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[97490],{93915:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>re,contentTitle:()=>ne,default:()=>ce,frontMatter:()=>ee,metadata:()=>ie,toc:()=>se});var r=i(85893),s=i(11151);function t(e){return(0,r.jsx)(r.Fragment,{})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t()}function l(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||d("DictionaryLink",!0),t||d("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," establishes a mapping from names to ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),". At any given time, one ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is current. The ",(0,r.jsx)(t,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," is the one that is the ",(0,r.jsx)(t,{term:"value",children:(0,r.jsx)("i",{children:"value"})})," of ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("b",{children:"*package*"})}),". When using the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," , it is possible to refer to ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," in ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," other than the current one through the use of ",(0,r.jsx)(n.em,{children:"package prefixes"})," in the printed representation of the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Figure 11\u20131 lists some ",(0,r.jsx)(t,{styled:!0,term:"defined name",children:(0,r.jsx)("i",{children:"defined names"})})," that are applicable to ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),". Where an ",(0,r.jsx)(t,{term:"operator",children:(0,r.jsx)("i",{children:"operator"})})," takes an argument that is either a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," or a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),", an argument of ",(0,r.jsx)(i,{term:"nil",children:(0,r.jsx)("b",{children:"nil"})})," is treated as an empty ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),". Any ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," argument may be either a ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),", a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),", or a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". If a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is supplied, its name will be used as the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," name."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"*modules* import provide *package* in-package rename-package defpackage intern require do-all-symbols list-all-packages shadow do-external-symbols make-package shadowing-import do-symbols package-name unexport export package-nicknames unintern find-all-symbols package-shadowing-symbols unuse-package find-package package-use-list use-package find-symbol package-used-by-list"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 11\u20131. Some Defined Names related to Packages"})})]})}function a(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function o(e){const n={p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||m("DictionaryLink",!0),t||m("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," has a ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," (a ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),") and perhaps some ",(0,r.jsx)(t,{term:"nickname",children:(0,r.jsx)("i",{children:"nicknames"})})," (also ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})}),"). These are assigned when the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is created and can be changed later."]}),"\n",(0,r.jsxs)(n.p,{children:["There is a single namespace for ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),". The ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(i,{term:"find-package",children:(0,r.jsx)("b",{children:"find-package"})})," translates a package ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," or ",(0,r.jsx)(t,{term:"nickname",children:(0,r.jsx)("i",{children:"nickname"})})," into the associated ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". The ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(i,{term:"package-name",children:(0,r.jsx)("b",{children:"package-name"})})," returns the ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," of a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". The ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(i,{term:"package-nicknames",children:(0,r.jsx)("b",{children:"package-nicknames"})})," returns a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of all ",(0,r.jsx)(t,{term:"nickname",children:(0,r.jsx)("i",{children:"nicknames"})})," for a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". ",(0,r.jsx)(i,{term:"rename-package",children:(0,r.jsx)("b",{children:"rename-package"})})]}),"\n",(0,r.jsxs)(n.p,{children:["removes a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"\u2019s current ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," and ",(0,r.jsx)(t,{term:"nickname",children:(0,r.jsx)("i",{children:"nicknames"})})," and replaces them with new ones specified by the caller."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function x(e){return(0,r.jsx)(r.Fragment,{})}function j(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x()}function p(e){const n={p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The mappings in a ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," are divided into two classes, external and internal. The ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," targeted by these different mappings are called ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," and ",(0,r.jsx)(i,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbols"})})," of the ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". Within a ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", a name refers to one ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," or to none; if it does refer to a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),", then it is either external or internal in that ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", but not both. ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"External symbols"})})," are part of the package\u2019s public interface to other ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),". ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"Symbols"})})," become ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," of a given ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," if they have been ",(0,r.jsx)(i,{term:"exported",children:(0,r.jsx)("i",{children:"exported"})})," from that ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," has the same ",(0,r.jsx)(i,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," no matter what ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," it is ",(0,r.jsx)(i,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," in, but it might be an ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of some ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," and an ",(0,r.jsx)(i,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbol"})})," of others."]})]})}function g(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}function y(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||f("DictionaryLink",!0),t||f("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"Packages"})})," can be built up in layers. From one point of view, a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is a single collection of mappings from ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"strings"})})," into ",(0,r.jsx)(t,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbols"})})," and ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})}),". However, some of these mappings might be established within the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," itself, while other mappings are inherited from other ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," via ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),". A ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is said to be ",(0,r.jsx)(t,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," in a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," if the mapping is in the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," itself and is not inherited from somewhere else."]}),"\n",(0,r.jsxs)(n.p,{children:["There is no way to inherit the ",(0,r.jsx)(t,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbols"})})," of another ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"; to refer to an ",(0,r.jsx)(t,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbol"})})," using the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," , a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," containing the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," must be made to be the ",(0,r.jsx)(t,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})}),", a ",(0,r.jsx)(t,{styled:!0,term:"package prefix",children:(0,r.jsx)("i",{children:"package prefix"})})," must be used, or the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," must be ",(0,r.jsx)(n.em,{children:"imported"})," into the ",(0,r.jsx)(t,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})}),"."]})]})}function b(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}function f(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function k(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||w("DictionaryLink",!0),t||w("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," becomes ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," if that is its ",(0,r.jsx)(t,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," when it is created, or if it is ",(0,r.jsx)(n.em,{children:"imported"})," into that ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", or by inheritance via ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", it can be referred to when using the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," without a ",(0,r.jsx)(t,{styled:!0,term:"package prefix",children:(0,r.jsx)("i",{children:"package prefix"})})," when that ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is the ",(0,r.jsx)(t,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})}),", regardless of whether it is ",(0,r.jsx)(t,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," or inherited."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"Symbols"})})," from one ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," can be made ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in another ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," in two ways."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 Any individual ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," can be added to a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," by use of ",(0,r.jsx)(i,{term:"import",children:(0,r.jsx)("b",{children:"import"})}),". After the call to ",(0,r.jsx)(i,{term:"import",children:(0,r.jsx)("b",{children:"import"})})," the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(t,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," in the importing ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". The status of the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," in the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," it came from (if any) is unchanged, and the ",(0,r.jsx)(t,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," for this ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is unchanged. Once ",(0,r.jsx)(n.em,{children:"imported"}),", a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(t,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," in the importing ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," and can be removed only by calling ",(0,r.jsx)(i,{term:"unintern",children:(0,r.jsx)("b",{children:"unintern"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(n.em,{children:"shadowed"})," ",(0,r.jsx)("sub",{children:"3"})," by another ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," in some ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," if the first ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," would be ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," by inheritance if not for the presence of the second ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),". See ",(0,r.jsx)(i,{term:"shadowing-import",children:(0,r.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 The second mechanism for making ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," from one ",(0,r.jsx)(n.em,{children:"package accessible"})," in another is provided by ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),". All of the ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," of the used ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," are inherited"]}),"\n",(0,r.jsxs)(n.p,{children:["by the using ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". The ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(i,{term:"unuse-package",children:(0,r.jsx)("b",{children:"unuse-package"})})," undoes the effects of a previous ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(k,{...e})}):k(e)}function w(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function v(e){const n={p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is to be located in a given ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," the following occurs:"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 The ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," and ",(0,r.jsx)(i,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbols"})})," of the ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," are searched for the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 The ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," of the used ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," are searched in some unspecified order. The order does not matter; see the rules for handling name conflicts listed below."]})]})}function O(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(v,{...e})}):v(e)}function M(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||S("DictionaryLink",!0),t||S("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Within one ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", any particular name can refer to at most one ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),". A name conflict is said to occur when there would be more than one candidate ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),". Any time a name conflict is about to occur, a ",(0,r.jsx)(n.em,{children:"correctable error"})," is signaled."]}),"\n",(0,r.jsx)(n.p,{children:"The following rules apply to name conflicts:"}),"\n",(0,r.jsx)(n.p,{children:"\u2013 Name conflicts are detected when they become possible, that is, when the package structure is altered. Name conflicts are not checked during every name lookup."}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 If the ",(0,r.jsx)(n.em,{children:"same symbol"})," is ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," to a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," through more than one path, there is no name conflict. A ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," cannot conflict with itself. Name conflicts occur only between ",(0,r.jsx)(n.em,{children:"distinct symbols"})," with the same name (under ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("b",{children:"string="})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 Every ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," has a list of shadowing ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),". A shadowing ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," takes precedence over any other ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," of the same name that would otherwise be ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in the ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". A name conflict involving a shadowing symbol is always resolved in favor of the shadowing ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),", without signaling an error (except for one exception involving ",(0,r.jsx)(i,{term:"import",children:(0,r.jsx)("b",{children:"import"})}),"). See ",(0,r.jsx)(i,{term:"shadow",children:(0,r.jsx)("b",{children:"shadow"})})," and ",(0,r.jsx)(i,{term:"shadowing-import",children:(0,r.jsx)("b",{children:"shadowing-import"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 The functions ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),", ",(0,r.jsx)(i,{term:"import",children:(0,r.jsx)("b",{children:"import"})}),", and ",(0,r.jsx)(i,{term:"export",children:(0,r.jsx)("b",{children:"export"})})," check for name conflicts."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 ",(0,r.jsx)(i,{term:"shadow",children:(0,r.jsx)("b",{children:"shadow"})})," and ",(0,r.jsx)(i,{term:"shadowing-import",children:(0,r.jsx)("b",{children:"shadowing-import"})})," never signal a name-conflict error."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 ",(0,r.jsx)(i,{term:"unuse-package",children:(0,r.jsx)("b",{children:"unuse-package"})})," and ",(0,r.jsx)(i,{term:"unexport",children:(0,r.jsx)("b",{children:"unexport"})})," do not need to do any name-conflict checking. ",(0,r.jsx)(i,{term:"unintern",children:(0,r.jsx)("b",{children:"unintern"})})," does name-conflict checking only when a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," being ",(0,r.jsx)(t,{term:"uninterned",children:(0,r.jsx)("i",{children:"uninterned"})})," is a ",(0,r.jsx)(t,{styled:!0,term:"shadowing symbol",children:(0,r.jsx)("i",{children:"shadowing symbol"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 Giving a shadowing symbol to ",(0,r.jsx)(i,{term:"unintern",children:(0,r.jsx)("b",{children:"unintern"})})," can uncover a name conflict that had previously been resolved by the shadowing."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 Package functions signal name-conflict errors of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"package-error",children:(0,r.jsx)("b",{children:"package-error"})})," before making any change to the package structure. When multiple changes are to be made, it is permissible for the implementation to process each change separately. For example, when ",(0,r.jsx)(i,{term:"export",children:(0,r.jsx)("b",{children:"export"})})," is"]}),"\n",(0,r.jsxs)(n.p,{children:["given a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),", aborting from a name conflict caused by the second ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," in the ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," might still export the first ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," in the ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})}),". However, a name-conflict error caused by ",(0,r.jsx)(i,{term:"export",children:(0,r.jsx)("b",{children:"export"})})," of a single ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," will be signaled before that ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,r.jsx)(t,{term:"accessibility",children:(0,r.jsx)("i",{children:"accessibility"})})," in any ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is changed."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 Continuing from a name-conflict error must offer the user a chance to resolve the name conflict in favor of either of the candidates. The ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," structure should be altered to reflect the resolution of the name conflict, via ",(0,r.jsx)(i,{term:"shadowing-import",children:(0,r.jsx)("b",{children:"shadowing-import"})}),", ",(0,r.jsx)(i,{term:"unintern",children:(0,r.jsx)("b",{children:"unintern"})}),", or ",(0,r.jsx)(i,{term:"unexport",children:(0,r.jsx)("b",{children:"unexport"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})})," between a ",(0,r.jsx)(n.em,{children:"symbol present"})," in the using ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," and an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the used ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is resolved in favor of the first ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," by making it a shadowing ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),", or in favor of the second ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," by uninterning the first ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," from the using ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 A name conflict in ",(0,r.jsx)(i,{term:"export",children:(0,r.jsx)("b",{children:"export"})})," or ",(0,r.jsx)(i,{term:"unintern",children:(0,r.jsx)("b",{children:"unintern"})})," due to a ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"\u2019s inheriting two ",(0,r.jsx)(n.em,{children:"distinct symbols"})," with the ",(0,r.jsx)(n.em,{children:"same name"})," (under ",(0,r.jsx)(i,{term:"string",children:(0,r.jsx)("b",{children:"string="})}),") from two other ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," can be resolved in favor of either ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," by importing it into the using ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," and making it a ",(0,r.jsx)(t,{styled:!0,term:"shadowing symbol",children:(0,r.jsx)("i",{children:"shadowing symbol"})}),", just as with ",(0,r.jsx)(i,{term:"use-package",children:(0,r.jsx)("b",{children:"use-package"})}),"."]})]})}function T(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(M,{...e})}):M(e)}function S(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function P(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["This section describes the ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," that are available in every ",(0,r.jsx)(i,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementation"})}),". A summary of the ",(0,r.jsx)(i,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," and ",(0,r.jsx)(i,{term:"nickname",children:(0,r.jsx)("i",{children:"nicknames"})})," of those ",(0,r.jsx)(n.em,{children:"standardized packages"})," is given in Figure 11\u20132."]}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)(n.strong,{children:"Name Nicknames"}),"|"]}),"\n",(0,r.jsx)(n.p,{children:"| :- |"}),"\n",(0,r.jsxs)(n.p,{children:["|",(0,r.jsx)("p",{children:"COMMON-LISP CL "}),(0,r.jsx)("p",{children:"COMMON-LISP-USER CL-USER "}),(0,r.jsxs)("p",{children:["KEYWORD ",(0,r.jsx)(n.em,{children:"none"})]}),"|"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Figure 11\u20132. Standardized Package Names"})})]})}function L(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(P,{...e})}):P(e)}function C(e){const n={p:"p",strong:"strong",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||N("DictionaryLink",!0),t||N("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," contains the primitives of the Common Lisp system as defined by this specification. Its ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," include all of the ",(0,r.jsx)(t,{styled:!0,term:"defined name",children:(0,r.jsx)("i",{children:"defined names"})})," (except for ",(0,r.jsx)(t,{styled:!0,term:"defined name",children:(0,r.jsx)("i",{children:"defined names"})})," in the KEYWORD ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),") that are present in the Common Lisp system, such as ",(0,r.jsx)(i,{term:"car",children:(0,r.jsx)("b",{children:"car"})}),", ",(0,r.jsx)(i,{term:"cdr",children:(0,r.jsx)("b",{children:"cdr"})}),", ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("b",{children:"*package*"})}),", etc. The COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," has the ",(0,r.jsx)(t,{term:"nickname",children:(0,r.jsx)("i",{children:"nickname"})})," CL."]}),"\n",(0,r.jsxs)(n.p,{children:["The COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," has as ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," those symbols enumerated in the figures in Section 1.9 (Symbols in the COMMON-LISP Package), and no others. These ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," are ",(0,r.jsx)(t,{term:"present",children:(0,r.jsx)("i",{children:"present"})})," in the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," but their ",(0,r.jsx)(t,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," need not be the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, the symbol HELP cannot be an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," because it is not mentioned in Section 1.9 (Symbols in the COMMON-LISP Package). In contrast, the ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"variable"})," must be an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," even though it has no definition because it is listed in that section (to support its use as a valid second ",(0,r.jsx)(t,{term:"argument",children:(0,r.jsx)("i",{children:"argument"})})," to the ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n.strong,{children:"documentation"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["The COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," can have additional ",(0,r.jsx)(t,{styled:!0,term:"internal symbol",children:(0,r.jsx)("i",{children:"internal symbols"})}),"."]})]})}function E(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(C,{...e})}):C(e)}function N(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function I(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||G("DictionaryLink",!0),t||G("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In a ",(0,r.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementation"})}),", an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," can have a ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})}),", ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," definition, a ",(0,r.jsx)(t,{styled:!0,term:"global variable",children:(0,r.jsx)("i",{children:"global variable"})})," definition (or other status as a ",(0,r.jsx)(t,{styled:!0,term:"dynamic variable",children:(0,r.jsx)("i",{children:"dynamic variable"})})," due to a ",(0,r.jsx)(i,{term:"special",children:(0,r.jsx)("b",{children:"special"})})," ",(0,r.jsx)(t,{term:"proclamation",children:(0,r.jsx)("i",{children:"proclamation"})}),"), or a ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," definition only if explicitly permitted in this standard. For example, ",(0,r.jsx)(i,{term:"fboundp",children:(0,r.jsx)("b",{children:"fboundp"})})," ",(0,r.jsx)(n.em,{children:"yields false"})," for any ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," that is not the ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," of a ",(0,r.jsx)(n.em,{children:"standardized function"}),", ",(0,r.jsx)(t,{styled:!0,term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," or ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," , and ",(0,r.jsx)(i,{term:"boundp",children:(0,r.jsx)("b",{children:"boundp"})})," returns ",(0,r.jsx)(t,{term:"false",children:(0,r.jsx)("i",{children:"false"})})," for any ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," that is not the ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," of a ",(0,r.jsx)(n.em,{children:"standardized global variable"}),". It also follows that ",(0,r.jsx)(t,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming programs"})})," can use ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," as the ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," of local ",(0,r.jsx)(t,{styled:!0,term:"lexical variable",children:(0,r.jsx)("i",{children:"lexical variables"})})," with confidence that those ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," have not been ",(0,r.jsx)(n.em,{children:"proclaimed"})," ",(0,r.jsx)(i,{term:"special",children:(0,r.jsx)("b",{children:"special"})})," by the ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," unless those ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," are ",(0,r.jsx)(t,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," of ",(0,r.jsx)(n.em,{children:"standardized global variables"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementation"})})," must not place any ",(0,r.jsx)(t,{term:"property",children:(0,r.jsx)("i",{children:"property"})})," on an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," using a ",(0,r.jsx)(t,{styled:!0,term:"property indicator",children:(0,r.jsx)("i",{children:"property indicator"})})," that is either an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of any ",(0,r.jsx)(n.em,{children:"standardized package"})," or a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," that is otherwise ",(0,r.jsx)(t,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in the COMMON-LISP-USER ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"."]})]})}function D(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(I,{...e})}):I(e)}function G(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function F(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||R("DictionaryLink",!0),t||R("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Except where explicitly allowed, the consequences are undefined if any of the following actions are performed on an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),":"]}),"\n",(0,r.jsxs)(n.p,{children:["1. ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"Binding"})})," or altering its value (lexically or dynamically). (Some exceptions are noted below.) 2. Defining, undefining, or ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})})," it as a ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})}),". (Some exceptions are noted below.)"]}),"\n",(0,r.jsxs)(n.p,{children:["3. Defining, undefining, or ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})})," it as a ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," or ",(0,r.jsx)(t,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),". (Some exceptions are noted below.)"]}),"\n",(0,r.jsxs)(n.p,{children:["4. Defining it as a ",(0,r.jsx)(t,{styled:!0,term:"type specifier",children:(0,r.jsx)("i",{children:"type specifier"})})," (via ",(0,r.jsx)(i,{term:"defstruct",children:(0,r.jsx)("b",{children:"defstruct"})}),", ",(0,r.jsx)(i,{term:"defclass",children:(0,r.jsx)("b",{children:"defclass"})}),", ",(0,r.jsx)(i,{term:"deftype",children:(0,r.jsx)("b",{children:"deftype"})}),", ",(0,r.jsx)(i,{term:"define-condition",children:(0,r.jsx)("b",{children:"define-condition"})}),"). 5. Defining it as a structure (via ",(0,r.jsx)(i,{term:"defstruct",children:(0,r.jsx)("b",{children:"defstruct"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["6. Defining it as a ",(0,r.jsx)(t,{term:"declaration",children:(0,r.jsx)("i",{children:"declaration"})})," with a ",(0,r.jsx)(i,{term:"declaration",children:(0,r.jsx)("b",{children:"declaration"})})," ",(0,r.jsx)(t,{term:"proclamation",children:(0,r.jsx)("i",{children:"proclamation"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["7. Defining it as a ",(0,r.jsx)(t,{styled:!0,term:"symbol macro",children:(0,r.jsx)("i",{children:"symbol macro"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["8. Altering its ",(0,r.jsx)(t,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["9. Tracing it (via ",(0,r.jsx)(i,{term:"trace",children:(0,r.jsx)("b",{children:"trace"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["10. Declaring or proclaiming it ",(0,r.jsx)(i,{term:"special",children:(0,r.jsx)("b",{children:"special"})})," (via ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})}),", ",(0,r.jsx)(i,{term:"declaim",children:(0,r.jsx)("b",{children:"declaim"})}),", or ",(0,r.jsx)(i,{term:"proclaim",children:(0,r.jsx)("b",{children:"proclaim"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["11. Declaring or proclaiming its ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("b",{children:"type"})})," or ",(0,r.jsx)(i,{term:"ftype",children:(0,r.jsx)("b",{children:"ftype"})})," (via ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})}),", ",(0,r.jsx)(i,{term:"declaim",children:(0,r.jsx)("b",{children:"declaim"})}),", or ",(0,r.jsx)(i,{term:"proclaim",children:(0,r.jsx)("b",{children:"proclaim"})}),"). (Some exceptions are noted below.)"]}),"\n",(0,r.jsxs)(n.p,{children:["12. Removing it from the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["13. Defining a ",(0,r.jsx)(t,{styled:!0,term:"setf expander",children:(0,r.jsx)("i",{children:"setf expander"})})," for it (via ",(0,r.jsx)(i,{term:"defsetf",children:(0,r.jsx)("b",{children:"defsetf"})})," or ",(0,r.jsx)(n.strong,{children:"define-setf-method"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["14. Defining, undefining, or binding its ",(0,r.jsx)(t,{styled:!0,term:"setf function name",children:(0,r.jsx)("i",{children:"setf function name"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["15. Defining it as a ",(0,r.jsx)(t,{styled:!0,term:"method combination",children:(0,r.jsx)("i",{children:"method combination"})})," type (via ",(0,r.jsx)(i,{term:"define-method-combination",children:(0,r.jsx)("b",{children:"define-method-combination"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["16. Using it as the class-name argument to ",(0,r.jsx)(i,{term:"setf",children:(0,r.jsx)("b",{children:"setf"})})," of ",(0,r.jsx)(i,{term:"find-class",children:(0,r.jsx)("b",{children:"find-class"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["17. Binding it as a ",(0,r.jsx)(t,{styled:!0,term:"catch tag",children:(0,r.jsx)("i",{children:"catch tag"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["18. Binding it as a ",(0,r.jsx)(n.em,{children:"restart name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["19. Defining a ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," for a ",(0,r.jsx)(n.em,{children:"standardized generic function"})," which is ",(0,r.jsx)(t,{term:"applicable",children:(0,r.jsx)("i",{children:"applicable"})})," when all of the ",(0,r.jsx)(t,{term:"argument",children:(0,r.jsx)("i",{children:"arguments"})})," are ",(0,r.jsx)(t,{styled:!0,term:"direct instance",children:(0,r.jsx)("i",{children:"direct instances"})})," of ",(0,r.jsx)(n.em,{children:"standardized classes"}),"."]})]})}function A(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(F,{...e})}):F(e)}function R(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function W(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||K("DictionaryLink",!0),t||K("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["If an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is not globally defined as a ",(0,r.jsx)(n.em,{children:"standardized dynamic variable"})," or ",(0,r.jsx)(t,{styled:!0,term:"constant variable",children:(0,r.jsx)("i",{children:"constant variable"})}),", it is allowed to lexically ",(0,r.jsx)(t,{term:"bind",children:(0,r.jsx)("i",{children:"bind"})})," it and to declare the ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("b",{children:"type"})})," of that ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})}),", and it is allowed to locally ",(0,r.jsx)(t,{term:"establish",children:(0,r.jsx)("i",{children:"establish"})})," it as a ",(0,r.jsx)(t,{styled:!0,term:"symbol macro",children:(0,r.jsx)("i",{children:"symbol macro"})})," (",(0,r.jsx)(n.em,{children:"e.g."}),", with ",(0,r.jsx)(i,{term:"symbol-macrolet",children:(0,r.jsx)("b",{children:"symbol-macrolet"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["Unless explicitly specified otherwise, if an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is globally defined as a ",(0,r.jsx)(n.em,{children:"standardized dynamic variable"}),", it is permitted to ",(0,r.jsx)(t,{term:"bind",children:(0,r.jsx)("i",{children:"bind"})})," or ",(0,r.jsx)(t,{term:"assign",children:(0,r.jsx)("i",{children:"assign"})})," that ",(0,r.jsx)(t,{styled:!0,term:"dynamic variable",children:(0,r.jsx)("i",{children:"dynamic variable"})})," provided that the \u201cValue Type\u201d constraints on the ",(0,r.jsx)(t,{styled:!0,term:"dynamic variable",children:(0,r.jsx)("i",{children:"dynamic variable"})})," are maintained, and that the new ",(0,r.jsx)(t,{term:"value",children:(0,r.jsx)("i",{children:"value"})})," of the ",(0,r.jsx)(t,{term:"variable",children:(0,r.jsx)("i",{children:"variable"})})," is consistent with the stated purpose of the ",(0,r.jsx)(t,{term:"variable",children:(0,r.jsx)("i",{children:"variable"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is not defined as a ",(0,r.jsx)(n.em,{children:"standardized function"}),", ",(0,r.jsx)(t,{styled:!0,term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,r.jsx)(t,{term:"bind",children:(0,r.jsx)("i",{children:"bind"})})," it as a ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," (",(0,r.jsx)(n.em,{children:"e.g."}),", with ",(0,r.jsx)(i,{term:"flet",children:(0,r.jsx)("b",{children:"flet"})}),"), to declare the ",(0,r.jsx)(i,{term:"ftype",children:(0,r.jsx)("b",{children:"ftype"})})," of that ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})}),", and (in ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementations"})})," which provide the ability to do so) to ",(0,r.jsx)(i,{term:"trace",children:(0,r.jsx)("b",{children:"trace"})})," that ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is not defined as a ",(0,r.jsx)(n.em,{children:"standardized function"}),", ",(0,r.jsx)(t,{styled:!0,term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,r.jsx)(t,{term:"bind",children:(0,r.jsx)("i",{children:"bind"})})," it as a ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," (",(0,r.jsx)(n.em,{children:"e.g."}),", with ",(0,r.jsx)(i,{term:"macrolet",children:(0,r.jsx)("b",{children:"macrolet"})}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["If an ",(0,r.jsx)(t,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," of the COMMON-LISP ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is not defined as a ",(0,r.jsx)(n.em,{children:"standardized function"}),", ",(0,r.jsx)(t,{styled:!0,term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," , it is allowed to lexically ",(0,r.jsx)(t,{term:"bind",children:(0,r.jsx)("i",{children:"bind"})})," its ",(0,r.jsx)(t,{styled:!0,term:"setf function name",children:(0,r.jsx)("i",{children:"setf function name"})})," as a ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})}),", and to declare the ",(0,r.jsx)(i,{term:"ftype",children:(0,r.jsx)("b",{children:"ftype"})})," of that ",(0,r.jsx)(t,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})}),"."]})]})}function z(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(W,{...e})}):W(e)}function K(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Y(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The COMMON-LISP-USER ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is the ",(0,r.jsx)(i,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," when a Common Lisp system starts up. This ",(0,r.jsx)(n.em,{children:"package uses"})," the COMMON-LISP ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),". The COMMON-LISP-USER ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," has the ",(0,r.jsx)(i,{term:"nickname",children:(0,r.jsx)("i",{children:"nickname"})})," CL-USER. The COMMON-LISP-USER ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," can have additional ",(0,r.jsx)(n.em,{children:"symbols interned"})," within it; it can ",(0,r.jsx)(i,{term:"use",children:(0,r.jsx)("i",{children:"use"})})," other ",(0,r.jsx)(n.em,{children:"implementation-defined packages"}),"."]})}function U(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Y,{...e})}):Y(e)}function _(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||B("DictionaryLink",!0),t||B("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The KEYWORD ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," contains ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),", called ",(0,r.jsx)(t,{term:"keyword",children:(0,r.jsx)("i",{children:"keywords"})}),(0,r.jsx)("sub",{children:"1"}),", that are typically used as special markers in ",(0,r.jsx)(t,{term:"program",children:(0,r.jsx)("i",{children:"programs"})})," and their associated data ",(0,r.jsx)(t,{term:"expression",children:(0,r.jsx)("i",{children:"expressions"})}),(0,r.jsx)("sub",{children:"1"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Symbol tokens"})," that start with a ",(0,r.jsx)(t,{styled:!0,term:"package marker",children:(0,r.jsx)("i",{children:"package marker"})})," are parsed by the ",(0,r.jsx)(n.em,{children:"Lisp reader"})," as ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," in the KEYWORD ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),"; see Section 2.3.4 (Symbols as Tokens). This makes it notationally convenient to use ",(0,r.jsx)(t,{term:"keyword",children:(0,r.jsx)("i",{children:"keywords"})})," when communicating between programs in different ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),". For example, the mechanism for passing ",(0,r.jsx)(t,{styled:!0,term:"keyword parameter",children:(0,r.jsx)("i",{children:"keyword parameters"})})," in a ",(0,r.jsx)(t,{term:"call",children:(0,r.jsx)("i",{children:"call"})})," uses ",(0,r.jsx)(t,{term:"keyword",children:(0,r.jsx)("i",{children:"keywords"})}),(0,r.jsx)("sub",{children:"1"})," to name the corresponding ",(0,r.jsx)(t,{term:"argument",children:(0,r.jsx)("i",{children:"arguments"})}),"; see Section 3.4.1 (Ordinary Lambda Lists)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"Symbols"})})," in the KEYWORD ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," are, by definition, of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"keyword",children:(0,r.jsx)("b",{children:"keyword"})}),"."]})]})}function q(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}function B(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function H(e){const n={p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(n.p,{children:["The KEYWORD ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is treated differently than other ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," in that special actions are taken when a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(i,{term:"interned",children:(0,r.jsx)("i",{children:"interned"})})," in it. In particular, when a ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(i,{term:"interned",children:(0,r.jsx)("i",{children:"interned"})})," in the KEYWORD ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", it is automatically made to be an ",(0,r.jsx)(i,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," and is automatically made to be a ",(0,r.jsx)(i,{styled:!0,term:"constant variable",children:(0,r.jsx)("i",{children:"constant variable"})})," with itself as a ",(0,r.jsx)(i,{term:"value",children:(0,r.jsx)("i",{children:"value"})}),"."]})}function V(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(H,{...e})}):H(e)}function Z(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{GlossaryTerm:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["It is generally best to confine the use of ",(0,r.jsx)(i,{term:"keyword",children:(0,r.jsx)("i",{children:"keywords"})})," to situations in which there are a finitely enumerable set of names to be selected between. For example, if there were two states of a light switch, they might be called ",":on"," and ",":off","."]}),"\n",(0,r.jsxs)(n.p,{children:["In situations where the set of names is not finitely enumerable (",(0,r.jsx)(n.em,{children:"i.e."}),", where name conflicts might arise) it is frequently best to use ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," in some ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," other than KEYWORD so that conflicts will be naturally avoided. For example, it is generally not wise for a ",(0,r.jsx)(i,{term:"program",children:(0,r.jsx)("i",{children:"program"})})," to use a ",(0,r.jsx)(i,{term:"keyword",children:(0,r.jsx)("i",{children:"keyword"})})," ",(0,r.jsx)("sub",{children:"1"})," as a ",(0,r.jsx)(i,{styled:!0,term:"property indicator",children:(0,r.jsx)("i",{children:"property indicator"})})," , since if there were ever another ",(0,r.jsx)(i,{term:"program",children:(0,r.jsx)("i",{children:"program"})})," that did the same thing, each would clobber the other\u2019s data."]})]})}function J(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Z,{...e})}):Z(e)}function Q(e){const n={em:"em",p:"p",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||$("DictionaryLink",!0),t||$("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Other, ",(0,r.jsx)(n.em,{children:"implementation-defined packages"})," might be present in the initial Common Lisp environment."]}),"\n",(0,r.jsxs)(n.p,{children:["It is recommended, but not required, that the documentation for a ",(0,r.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementation"})})," contain a full list of all ",(0,r.jsx)(t,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," names initially present in that ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," but not specified in this specification. (See also the ",(0,r.jsx)(t,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(i,{term:"list-all-packages",children:(0,r.jsx)("b",{children:"list-all-packages"})}),".)"]})]})}function X(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Q,{...e})}):Q(e)}function $(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const ee={title:"11.1 Package Concepts"},ne="11.1 Package Concepts",ie={id:"chap-11/bb-b-package-concepts",title:"11.1 Package Concepts",description:"11.1.1 Introduction to Packages",source:"@site/docs/chap-11/bb-b-package-concepts.md",sourceDirName:"chap-11",slug:"/chap-11/bb-b-package-concepts",permalink:"/cl-language-reference/chap-11/bb-b-package-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-11/bb-b-package-concepts.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"11.1 Package Concepts"},sidebar:"tutorialSidebar",previous:{title:"unbound-variable",permalink:"/cl-language-reference/chap-10/ba-c-dictionary/unbound-variable_condition-type"},next:{title:"11.2 Packages Dictionary",permalink:"/cl-language-reference/category/112-packages-dictionary"}},re={},se=[{value:"11.1.1 Introduction to Packages",id:"1111-introduction-to-packages",level:2},{value:"11.1.1.1 Package Names and Nicknames",id:"11111-package-names-and-nicknames",level:3},{value:"11.1.1.2 Symbols in a Package",id:"11112-symbols-in-a-package",level:3},{value:"11.1.1.2.1 Internal and External Symbols",id:"111121-internal-and-external-symbols",level:4},{value:"11.1.1.2.2 Package Inheritance",id:"111122-package-inheritance",level:4},{value:"11.1.1.2.3 Accessibility of Symbols in a Package",id:"111123-accessibility-of-symbols-in-a-package",level:4},{value:"11.1.1.2.4 Locating a Symbol in a Package",id:"111124-locating-a-symbol-in-a-package",level:4},{value:"11.1.1.2.5 Prevention of Name Conflicts in Packages",id:"111125-prevention-of-name-conflicts-in-packages",level:4},{value:"11.1.2 Standardized Packages",id:"1112-standardized-packages",level:2},{value:"11.1.2.1 The COMMON",id:"11121-the-common",level:3},{value:"11.1.2.1.1 Constraints on the COMMON",id:"111211-constraints-on-the-common",level:4},{value:"11.1.2.1.2 Constraints on the COMMON",id:"111212-constraints-on-the-common",level:4},{value:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON",id:"1112121-some-exceptions-to-constraints-on-the-common",level:5},{value:"11.1.2.2 The COMMON",id:"11122-the-common",level:3},{value:"11.1.2.3 The KEYWORD Package",id:"11123-the-keyword-package",level:3},{value:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package",id:"111231-interning-a-symbol-in-the-keyword-package",level:4},{value:"11.1.2.3.2 Notes about The KEYWORD Package",id:"111232-notes-about-the-keyword-package",level:4},{value:"11.1.2.4 Implementation",id:"11124-implementation",level:3}];function te(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"111-package-concepts",children:"11.1 Package Concepts"}),"\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h2,{id:"1111-introduction-to-packages",children:"11.1.1 Introduction to Packages"}),"\n","\n",(0,r.jsx)(a,{}),"\n",(0,r.jsx)(n.h3,{id:"11111-package-names-and-nicknames",children:"11.1.1.1 Package Names and Nicknames"}),"\n","\n",(0,r.jsx)(h,{}),"\n",(0,r.jsx)(n.h3,{id:"11112-symbols-in-a-package",children:"11.1.1.2 Symbols in a Package"}),"\n","\n",(0,r.jsx)(j,{}),"\n",(0,r.jsx)(n.h4,{id:"111121-internal-and-external-symbols",children:"11.1.1.2.1 Internal and External Symbols"}),"\n","\n",(0,r.jsx)(g,{}),"\n",(0,r.jsx)(n.h4,{id:"111122-package-inheritance",children:"11.1.1.2.2 Package Inheritance"}),"\n","\n",(0,r.jsx)(b,{}),"\n",(0,r.jsx)(n.h4,{id:"111123-accessibility-of-symbols-in-a-package",children:"11.1.1.2.3 Accessibility of Symbols in a Package"}),"\n","\n",(0,r.jsx)(u,{}),"\n",(0,r.jsx)(n.h4,{id:"111124-locating-a-symbol-in-a-package",children:"11.1.1.2.4 Locating a Symbol in a Package"}),"\n","\n",(0,r.jsx)(O,{}),"\n",(0,r.jsx)(n.h4,{id:"111125-prevention-of-name-conflicts-in-packages",children:"11.1.1.2.5 Prevention of Name Conflicts in Packages"}),"\n","\n",(0,r.jsx)(T,{}),"\n",(0,r.jsx)(n.h2,{id:"1112-standardized-packages",children:"11.1.2 Standardized Packages"}),"\n","\n",(0,r.jsx)(L,{}),"\n",(0,r.jsx)(n.h3,{id:"11121-the-common",children:"11.1.2.1 The COMMON"}),"\n","\n",(0,r.jsx)(E,{}),"\n",(0,r.jsx)(n.h4,{id:"111211-constraints-on-the-common",children:"11.1.2.1.1 Constraints on the COMMON"}),"\n","\n",(0,r.jsx)(D,{}),"\n",(0,r.jsx)(n.h4,{id:"111212-constraints-on-the-common",children:"11.1.2.1.2 Constraints on the COMMON"}),"\n","\n",(0,r.jsx)(A,{}),"\n",(0,r.jsx)(n.h5,{id:"1112121-some-exceptions-to-constraints-on-the-common",children:"11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON"}),"\n","\n",(0,r.jsx)(z,{}),"\n",(0,r.jsx)(n.h3,{id:"11122-the-common",children:"11.1.2.2 The COMMON"}),"\n","\n",(0,r.jsx)(U,{}),"\n",(0,r.jsx)(n.h3,{id:"11123-the-keyword-package",children:"11.1.2.3 The KEYWORD Package"}),"\n","\n",(0,r.jsx)(q,{}),"\n",(0,r.jsx)(n.h4,{id:"111231-interning-a-symbol-in-the-keyword-package",children:"11.1.2.3.1 Interning a Symbol in the KEYWORD Package"}),"\n","\n",(0,r.jsx)(V,{}),"\n",(0,r.jsx)(n.h4,{id:"111232-notes-about-the-keyword-package",children:"11.1.2.3.2 Notes about The KEYWORD Package"}),"\n","\n",(0,r.jsx)(J,{}),"\n",(0,r.jsx)(n.h3,{id:"11124-implementation",children:"11.1.2.4 Implementation"}),"\n","\n","\n",(0,r.jsx)(X,{})]})}function ce(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(te,{...e})}):te(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>c});var r=i(67294);const s={},t=r.createContext(s);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);