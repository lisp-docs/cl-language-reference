"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[76372],{9982:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var i=n(85893),s=n(11151);const t={title:"M",sidebar_position:109},c=void 0,l={id:"chap-26/m",title:"M",description:"M",source:"@site/docs/chap-26/m.md",sourceDirName:"chap-26",slug:"/chap-26/m",permalink:"/cl-language-reference/chap-26/m",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-26/m.md",tags:[],version:"current",lastUpdatedBy:"daninus14",sidebarPosition:109,frontMatter:{title:"M",sidebar_position:109},sidebar:"tutorialSidebar",previous:{title:"L",permalink:"/cl-language-reference/chap-26/l"},next:{title:"N",permalink:"/cl-language-reference/chap-26/n"}},d={},o=[];function h(e){const r={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||m("DictionaryLink",!0),t||m("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"M"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. a ",(0,i.jsx)(t,{styled:!0,term:"macro form",children:(0,i.jsx)("i",{children:"macro form"})})," 2. a ",(0,i.jsx)(t,{styled:!0,term:"macro function",children:(0,i.jsx)("i",{children:"macro function"})}),". 3. a ",(0,i.jsx)(t,{styled:!0,term:"macro name",children:(0,i.jsx)("i",{children:"macro name"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro character"})," ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{term:"character",children:(0,i.jsx)("i",{children:"character"})})," which, when encountered by the ",(0,i.jsx)(r.em,{children:"Lisp reader"})," in its main dispatch loop, introduces a ",(0,i.jsx)(t,{styled:!0,term:"reader macro",children:(0,i.jsx)("i",{children:"reader macro"})}),(0,i.jsx)("sub",{children:"1"}),". (",(0,i.jsx)(t,{styled:!0,term:"macro character",children:(0,i.jsx)("i",{children:"Macro characters"})})," have nothing to do with ",(0,i.jsx)(t,{term:"macro",children:(0,i.jsx)("i",{children:"macros"})}),".)"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro expansion"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. the process of translating a ",(0,i.jsx)(t,{styled:!0,term:"macro form",children:(0,i.jsx)("i",{children:"macro form"})})," into another ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),". 2. the ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," resulting from this process."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro form"})," ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," that stands for another ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," (",(0,i.jsx)(r.em,{children:"e.g."}),", for the purposes of"]}),"\n",(0,i.jsxs)(r.p,{children:["abstraction, information hiding, or syntactic convenience); that is, either a ",(0,i.jsx)(t,{styled:!0,term:"compound form",children:(0,i.jsx)("i",{children:"compound form"})})," whose first element is a ",(0,i.jsx)(t,{styled:!0,term:"macro name",children:(0,i.jsx)("i",{children:"macro name"})}),", or a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," that is a ",(0,i.jsx)(t,{term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," that names a ",(0,i.jsx)(t,{styled:!0,term:"symbol macro",children:(0,i.jsx)("i",{children:"symbol macro"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro function"})," ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{term:"function",children:(0,i.jsx)("i",{children:"function"})})," of two arguments, a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," and an ",(0,i.jsx)(t,{term:"environment",children:(0,i.jsx)("i",{children:"environment"})}),", that implements ",(0,i.jsx)(t,{styled:!0,term:"macro expansion",children:(0,i.jsx)("i",{children:"macro expansion"})})," by producing a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," to be evaluated in place of the original argument ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro lambda list"})," ",(0,i.jsx)(r.em,{children:"n."})," an ",(0,i.jsx)(t,{styled:!0,term:"extended lambda list",children:(0,i.jsx)("i",{children:"extended lambda list"})})," used in ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"forms"})})," that ",(0,i.jsx)(r.em,{children:"establish macro"})," definitions, such as ",(0,i.jsx)(n,{term:"defmacro",children:(0,i.jsx)("b",{children:"defmacro"})})," and ",(0,i.jsx)(n,{term:"macrolet",children:(0,i.jsx)("b",{children:"macrolet"})}),". See Section 3.4.4 (Macro Lambda Lists)."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macro name"})," ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{term:"name",children:(0,i.jsx)("i",{children:"name"})})," for which ",(0,i.jsx)(n,{term:"macro-function",children:(0,i.jsx)("b",{children:"macro-function"})})," returns ",(0,i.jsx)(t,{term:"true",children:(0,i.jsx)("i",{children:"true"})})," and which when used as the first element of a ",(0,i.jsx)(t,{styled:!0,term:"compound form",children:(0,i.jsx)("i",{children:"compound form"})})," identifies that ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," as a ",(0,i.jsx)(t,{styled:!0,term:"macro form",children:(0,i.jsx)("i",{children:"macro form"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"macroexpand hook"})," ",(0,i.jsx)(r.em,{children:"n."})," the ",(0,i.jsx)(t,{term:"function",children:(0,i.jsx)("i",{children:"function"})})," that is the ",(0,i.jsx)(t,{term:"value",children:(0,i.jsx)("i",{children:"value"})})," of ",(0,i.jsx)(r.strong,{children:"*macroexpand-hook*"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"mapping"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. a type of iteration in which a ",(0,i.jsx)(t,{term:"function",children:(0,i.jsx)("i",{children:"function"})})," is successively applied to ",(0,i.jsx)(t,{term:"object",children:(0,i.jsx)("i",{children:"objects"})})," taken from corresponding entries in collections such as ",(0,i.jsx)(r.em,{children:"sequences"})," or ",(0,i.jsx)(t,{styled:!0,term:"hash table",children:(0,i.jsx)("i",{children:"hash tables"})}),". 2. ",(0,i.jsx)(r.em,{children:"Math."})," a relation between two sets in which each element of the first set (the \u201cdomain\u201d) is assigned one element of the second set (the \u201crange\u201d)."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"metaclass"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. a ",(0,i.jsx)(t,{term:"class",children:(0,i.jsx)("i",{children:"class"})})," whose instances are ",(0,i.jsx)(r.em,{children:"classes"}),". 2. (of an ",(0,i.jsx)(t,{term:"object",children:(0,i.jsx)("i",{children:"object"})}),") the ",(0,i.jsx)(t,{term:"class",children:(0,i.jsx)("i",{children:"class"})})," of the ",(0,i.jsx)(t,{term:"class",children:(0,i.jsx)("i",{children:"class"})})," of the ",(0,i.jsx)(t,{term:"object",children:(0,i.jsx)("i",{children:"object"})}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Metaobject Protocol"})," ",(0,i.jsx)(r.em,{children:"n."})," one of many possible descriptions of how a ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," might implement various aspects of the object system. This description is beyond the scope of this document, and no ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," is required to adhere to it except as noted explicitly in this specification. Nevertheless, its existence helps to establish normative practice, and implementors with no reason to diverge from it are encouraged to consider making their ",(0,i.jsx)(t,{term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," adhere to it where possible. It is described in detail in ",(0,i.jsx)(r.em,{children:"The Art of the Metaobject Protocol"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(n,{term:"method",children:(0,i.jsx)("b",{children:"method"})})," ",(0,i.jsx)(r.em,{children:"n."})," an ",(0,i.jsx)(t,{term:"object",children:(0,i.jsx)("i",{children:"object"})})," that is part of a ",(0,i.jsx)(t,{styled:!0,term:"generic function",children:(0,i.jsx)("i",{children:"generic function"})})," and which provides information about how that ",(0,i.jsx)(t,{styled:!0,term:"generic function",children:(0,i.jsx)("i",{children:"generic function"})})," should behave when its ",(0,i.jsx)(t,{term:"argument",children:(0,i.jsx)("i",{children:"arguments"})})," are ",(0,i.jsx)(t,{term:"object",children:(0,i.jsx)("i",{children:"objects"})})," of certain ",(0,i.jsx)(r.em,{children:"classes"})," or with certain identities."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"method combination"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. generally, the composition of a set of ",(0,i.jsx)(t,{term:"method",children:(0,i.jsx)("i",{children:"methods"})})," to produce an ",(0,i.jsx)(t,{styled:!0,term:"effective method",children:(0,i.jsx)("i",{children:"effective method"})})," for a ",(0,i.jsx)(t,{styled:!0,term:"generic function",children:(0,i.jsx)("i",{children:"generic function"})}),". 2. an object of ",(0,i.jsx)(t,{term:"type",children:(0,i.jsx)("i",{children:"type"})})," ",(0,i.jsx)(n,{term:"method-combination",children:(0,i.jsx)("b",{children:"method-combination"})}),", which represents the details of how the ",(0,i.jsx)(t,{styled:!0,term:"method combination",children:(0,i.jsx)("i",{children:"method combination"})}),(0,i.jsx)("sub",{children:"1"})," for one or more specific ",(0,i.jsx)(t,{styled:!0,term:"generic function",children:(0,i.jsx)("i",{children:"generic functions"})})," is to be performed."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"method-defining form"})," ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{term:"form",children:(0,i.jsx)("i",{children:"form"})})," that defines a ",(0,i.jsx)(t,{term:"method",children:(0,i.jsx)("i",{children:"method"})})," for a ",(0,i.jsx)(t,{styled:!0,term:"generic function",children:(0,i.jsx)("i",{children:"generic function"})}),", whether explicitly or implicitly. See Section 7.6.1 (Introduction to Generic Functions)."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"method-defining operator"})," ",(0,i.jsx)(r.em,{children:"n."})," an ",(0,i.jsx)(t,{term:"operator",children:(0,i.jsx)("i",{children:"operator"})})," corresponding to a ",(0,i.jsx)(t,{styled:!0,term:"method-defining form",children:(0,i.jsx)("i",{children:"method-defining form"})}),". See Figure 7\u20131."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"minimal compilation"})," ",(0,i.jsx)(r.em,{children:"n."})," actions the ",(0,i.jsx)(t,{term:"compiler",children:(0,i.jsx)("i",{children:"compiler"})})," must take at compile time. See Section 3.2.2 (Compilation Semantics)."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"modified lambda list"})," ",(0,i.jsx)(r.em,{children:"n."})," a list resembling an ",(0,i.jsx)(t,{styled:!0,term:"ordinary lambda list",children:(0,i.jsx)("i",{children:"ordinary lambda list"})})," in form and"]}),"\n",(0,i.jsx)(r.p,{children:"purpose, but which deviates in syntax or functionality from the definition of an"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(t,{styled:!0,term:"ordinary lambda list",children:(0,i.jsx)("i",{children:"ordinary lambda list"})}),". See ",(0,i.jsx)(t,{styled:!0,term:"ordinary lambda list",children:(0,i.jsx)("i",{children:"ordinary lambda list"})}),". \u201c",(0,i.jsx)(n,{term:"deftype",children:(0,i.jsx)("b",{children:"deftype"})})," uses a modified lambda list.\u201d"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"most recent"})," ",(0,i.jsx)(r.em,{children:"adj."})," innermost; that is, having been ",(0,i.jsx)(r.em,{children:"established"})," (and not yet"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.em,{children:"disestablished"}),") more recently than any other of its kind."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"multiple escape"})," ",(0,i.jsx)(r.em,{children:"n."}),", ",(0,i.jsx)(r.em,{children:"adj."})," 1. ",(0,i.jsx)(r.em,{children:"n."})," the ",(0,i.jsx)(t,{styled:!0,term:"syntax type",children:(0,i.jsx)("i",{children:"syntax type"})})," of a ",(0,i.jsx)(t,{term:"character",children:(0,i.jsx)("i",{children:"character"})})," that is used in pairs to indicate that the enclosed ",(0,i.jsx)(t,{term:"character",children:(0,i.jsx)("i",{children:"characters"})})," are to be treated as ",(0,i.jsx)(t,{term:"alphabetic",children:(0,i.jsx)("i",{children:"alphabetic"})}),(0,i.jsx)("sub",{children:"2"})," ",(0,i.jsx)(t,{term:"character",children:(0,i.jsx)("i",{children:"characters"})})," with their ",(0,i.jsx)(t,{term:"case",children:(0,i.jsx)("i",{children:"case"})})," preserved. For details, see Section 2.1.4.5 (Multiple Escape Characters). 2. ",(0,i.jsx)(r.em,{children:"adj."})," (of a ",(0,i.jsx)(t,{term:"character",children:(0,i.jsx)("i",{children:"character"})})," ) having the ",(0,i.jsx)(r.em,{children:"multiple escape syntax type"}),". 3. ",(0,i.jsx)(r.em,{children:"n."})," a ",(0,i.jsx)(t,{styled:!0,term:"multiple escape",children:(0,i.jsx)("i",{children:"multiple escape"})}),(0,i.jsx)("sub",{children:"2"})," ",(0,i.jsx)(t,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"character"})})," . (In the ",(0,i.jsx)(t,{styled:!0,term:"standard readtable",children:(0,i.jsx)("i",{children:"standard readtable"})}),", ",(0,i.jsx)(t,{styled:!0,term:"vertical-bar",children:(0,i.jsx)("i",{children:"vertical-bar"})})," is a ",(0,i.jsx)(r.em,{children:"multiple escape character"})," .)"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"multiple values"})," ",(0,i.jsx)(r.em,{children:"n."})," 1. more than one ",(0,i.jsx)(t,{term:"value",children:(0,i.jsx)("i",{children:"value"})}),". \u201cThe function ",(0,i.jsx)(n,{term:"truncate",children:(0,i.jsx)("b",{children:"truncate"})})," returns multiple values.\u201d 2. a variable number of ",(0,i.jsx)(t,{term:"value",children:(0,i.jsx)("i",{children:"values"})}),", possibly including zero or one. \u201cThe function ",(0,i.jsx)(n,{term:"values",children:(0,i.jsx)("b",{children:"values"})})," returns multiple values.\u201d 3. a fixed number of values other than one. \u201cThe macro ",(0,i.jsx)(n,{term:"multiple-value-bind",children:(0,i.jsx)("b",{children:"multiple-value-bind"})})," is among the few operators in Common Lisp which can detect and manipulate multiple values.\u201d"]})]})}function a(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function m(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,r,n)=>{n.d(r,{Z:()=>l,a:()=>c});var i=n(67294);const s={},t=i.createContext(s);function c(e){const r=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);