"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[33890],{40849:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>Q,contentTitle:()=>H,default:()=>U,frontMatter:()=>M,metadata:()=>V,toc:()=>T});var s=i(85893),n=i(11151);function o(e){return(0,s.jsx)(s.Fragment,{})}function r(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o()}function c(e){const t={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Figure 18\u20131 lists some ",(0,s.jsx)(t.em,{children:"defined names"})," that are applicable to ",(0,s.jsx)(t.em,{children:"hash tables"}),". The following rules apply to ",(0,s.jsx)(t.em,{children:"hash tables"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2013 A ",(0,s.jsx)(t.em,{children:"hash table"})," can only associate one value with a given key. If an attempt is made to add a second value for a given key, the second value will replace the first. Thus, adding a value to a ",(0,s.jsx)(t.em,{children:"hash table"})," is a destructive operation; the ",(0,s.jsx)(t.em,{children:"hash table"})," is modified."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2013 There are four kinds of ",(0,s.jsx)(t.em,{children:"hash tables"}),": those whose keys are compared with ",(0,s.jsx)(i,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})}),", those whose keys are compared with ",(0,s.jsx)(i,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),", those whose keys are compared with ",(0,s.jsx)(i,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),", and those whose keys are compared with ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2013 ",(0,s.jsx)(t.em,{children:"Hash tables"})," are created by ",(0,s.jsx)(i,{styled:!0,term:"make-hash-table",children:(0,s.jsx)("b",{children:"make-hash-table"})}),". ",(0,s.jsx)(i,{styled:!0,term:"gethash",children:(0,s.jsx)("b",{children:"gethash"})})," is used to look up a key and find the associated value. New entries are added to ",(0,s.jsx)(t.em,{children:"hash tables"})," using ",(0,s.jsx)(i,{styled:!0,term:"setf",children:(0,s.jsx)("b",{children:"setf"})})," with ",(0,s.jsx)(i,{styled:!0,term:"gethash",children:(0,s.jsx)("b",{children:"gethash"})}),". ",(0,s.jsx)(i,{styled:!0,term:"remhash",children:(0,s.jsx)("b",{children:"remhash"})})," is used to remove an entry. For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lisp",children:"(setq a (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32536573>\n(setf (gethash \u2019color a) \u2019brown) \u2192 BROWN\n(setf (gethash \u2019name a) \u2019fred) \u2192 FRED\n(gethash \u2019color a) \u2192 BROWN, *true*\n(gethash \u2019name a) \u2192 FRED, *true*\n(gethash \u2019pointy a) \u2192 NIL, *false*\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this example, the symbols color and name are being used as keys, and the symbols brown and fred are being used as the associated values. The ",(0,s.jsx)(t.em,{children:"hash table"})," has two items in it, one of which associates from color to brown, and the other of which associates from name to fred."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2013 A key or a value may be any ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2013 The existence of an entry in the ",(0,s.jsx)(t.em,{children:"hash table"})," can be determined from the ",(0,s.jsx)(t.em,{children:"secondary value"})," returned by ",(0,s.jsx)(i,{styled:!0,term:"gethash",children:(0,s.jsx)("b",{children:"gethash"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(t.strong,{children:"clrhash hash-table-p remhash gethash make-hash-table sxhash"})," "]}),"\n",(0,s.jsx)("p",{children:(0,s.jsx)(t.strong,{children:"hash-table-count maphash"})}),"|"]}),"\n",(0,s.jsx)(t.p,{children:"| :- |"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Figure 18\u20131. Hash-table defined names"})}),"\n",(0,s.jsx)(t.p,{children:"Hash"})]})}function l(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function a(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["The function supplied as the ",":test"," argument to ",(0,s.jsx)(i,{styled:!0,term:"make-hash-table",children:(0,s.jsx)("b",{children:"make-hash-table"})})," specifies the \u2018equivalence test\u2019 for the ",(0,s.jsx)(t.em,{children:"hash table"})," it creates."]}),"\n",(0,s.jsxs)(t.p,{children:["An ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," is \u2018visibly modified\u2019 with regard to an equivalence test if there exists some set of ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," (or potential ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})}),") which are equivalent to the ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," before the modification but are no longer equivalent afterwards."]}),"\n",(0,s.jsxs)(t.p,{children:["If an ",(0,s.jsx)(t.em,{children:"object O"}),(0,s.jsx)("sub",{children:"1"})," is used as a key in a ",(0,s.jsx)(t.em,{children:"hash table H"})," and is then visibly modified with regard to the equivalence test of ",(0,s.jsx)(t.em,{children:"H"}),", then the consequences are unspecified if ",(0,s.jsx)(t.em,{children:"O"}),(0,s.jsx)("sub",{children:"1"}),", or any ",(0,s.jsx)(t.em,{children:"object O"}),(0,s.jsx)("sub",{children:"2"})," equivalent to ",(0,s.jsx)(t.em,{children:"O"}),(0,s.jsx)("sub",{children:"1"})," under the equivalence test (either before or after the modification), is used as a key in further operations on ",(0,s.jsx)(t.em,{children:"H"}),". The consequences of using ",(0,s.jsx)(t.em,{children:"O"}),(0,s.jsx)("sub",{children:"1"})," as a key are unspecified even if ",(0,s.jsx)(t.em,{children:"O"}),(0,s.jsx)("sub",{children:"1"})," is visibly"]}),"\n",(0,s.jsx)(t.p,{children:"modified and then later modified again in such a way as to undo the visible modification."}),"\n",(0,s.jsxs)(t.p,{children:["Following are specifications of the modifications which are visible to the equivalence tests which must be supported by ",(0,s.jsx)(t.em,{children:"hash tables"}),". The modifications are described in terms of modification of components, and are defined recursively. Visible modifications of components of the ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," are visible modifications of the ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}function d(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["No ",(0,s.jsx)(t.em,{children:"standardized function"})," is provided that is capable of visibly modifying an ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," with regard to ",(0,s.jsx)(i,{styled:!0,term:"eq",children:(0,s.jsx)("b",{children:"eq"})})," or ",(0,s.jsx)(i,{styled:!0,term:"eql",children:(0,s.jsx)("b",{children:"eql"})}),"."]})}function p(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function j(e){const t={p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["As a consequence of the behavior for ",(0,s.jsx)(i,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),", the rules for visible modification of ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modification of Objects with respect to EQ and EQL)."]})}function m(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}function x(e){const t={p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["Any visible change to the ",(0,s.jsx)(i,{styled:!0,term:"car",children:(0,s.jsx)("i",{children:"car"})})," or the ",(0,s.jsx)(i,{styled:!0,term:"cdr",children:(0,s.jsx)("i",{children:"cdr"})})," of a ",(0,s.jsx)(i,{styled:!0,term:"cons",children:(0,s.jsx)("i",{children:"cons"})})," is considered a visible modification with regard to ",(0,s.jsx)(i,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"."]})}function f(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}function b(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["For a ",(0,s.jsx)(i,{styled:!0,term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," of ",(0,s.jsx)(i,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{styled:!0,term:"bit-vector",children:(0,s.jsx)("b",{children:"bit-vector"})})," or of ",(0,s.jsx)(i,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(i,{styled:!0,term:"string",children:(0,s.jsx)("b",{children:"string"})}),", any visible change to an ",(0,s.jsx)(t.em,{children:"active element"})," of the ",(0,s.jsx)(i,{styled:!0,term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," , or to the ",(0,s.jsx)(i,{styled:!0,term:"length",children:(0,s.jsx)("i",{children:"length"})})," of the ",(0,s.jsx)(i,{styled:!0,term:"vector",children:(0,s.jsx)("i",{children:"vector"})})," (if it is ",(0,s.jsx)(t.em,{children:"actually adjustable"})," or has a ",(0,s.jsx)(t.em,{children:"fill pointer"})," ) is considered a visible modification with regard to ",(0,s.jsx)(i,{styled:!0,term:"equal",children:(0,s.jsx)("b",{children:"equal"})}),"."]})}function u(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}function y(e){const t={p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["As a consequence of the behavior for ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),", the rules for visible modification of ",(0,s.jsx)(i,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modification of Objects with respect to EQUAL)."]})}function v(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function g(e){const t={p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["Any visible change to a ",(0,s.jsx)(i,{styled:!0,term:"slot",children:(0,s.jsx)("i",{children:"slot"})})," of a ",(0,s.jsx)(i,{styled:!0,term:"structure",children:(0,s.jsx)("i",{children:"structure"})})," is considered a visible modification with regard to ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),"."]})}function w(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}function k(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(t.p,{children:["In an ",(0,s.jsx)(i,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"array"})}),", any visible change to an ",(0,s.jsx)(t.em,{children:"active element"}),", to the ",(0,s.jsx)(t.em,{children:"fill pointer"})," (if the ",(0,s.jsx)(i,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"array"})})," can and does have one), or to the ",(0,s.jsx)(i,{styled:!0,term:"dimension",children:(0,s.jsx)("i",{children:"dimensions"})})," (if the ",(0,s.jsx)(i,{styled:!0,term:"array",children:(0,s.jsx)("i",{children:"array"})})," is ",(0,s.jsx)(t.em,{children:"actually adjustable"}),") is considered a visible modification with regard to ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),"."]})}function q(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}function E(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In a ",(0,s.jsx)(t.em,{children:"hash table"}),", any visible change to the count of entries in the ",(0,s.jsx)(t.em,{children:"hash table"}),", to the keys, or to the values associated with the keys is considered a visible modification with regard to ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Note that the visibility of modifications to the keys depends on the equivalence test of the ",(0,s.jsx)(t.em,{children:"hash table"}),", not on the specification of ",(0,s.jsx)(i,{styled:!0,term:"equalp",children:(0,s.jsx)("b",{children:"equalp"})}),"."]})]})}function L(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(E,{...e})}):E(e)}function C(e){const t={em:"em",p:"p",...(0,n.a)(),...e.components},{ClLinks:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(i,{styled:!0,term:"implementation",children:(0,s.jsx)("i",{children:"Implementations"})})," that extend the language by providing additional mutator functions (or additional behavior for existing mutator functions) must document how the use of these extensions interacts with equivalence tests and ",(0,s.jsx)(t.em,{children:"hash table"})," searches."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(i,{styled:!0,term:"implementation",children:(0,s.jsx)("i",{children:"Implementations"})})," that extend the language by defining additional acceptable equivalence tests for ",(0,s.jsx)(t.em,{children:"hash tables"})," (allowing additional values for the ",":test"," argument to ",(0,s.jsx)(i,{styled:!0,term:"make-hash-table",children:(0,s.jsx)("b",{children:"make-hash-table"})}),") must document the visible components of these tests."]}),"\n",(0,s.jsx)(t.p,{children:"Hash"})]})}function A(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}const M={title:"18.1 Hash Table Concepts"},H="18.1 Hash Table Concepts",V={id:"chap-18/bi-b-hash-table-concepts",title:"18.1 Hash Table Concepts",description:"18.1.1 Hash",source:"@site/docs/chap-18/bi-b-hash-table-concepts.md",sourceDirName:"chap-18",slug:"/chap-18/bi-b-hash-table-concepts",permalink:"/cl-language-reference/chap-18/bi-b-hash-table-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-18/bi-b-hash-table-concepts.md",tags:[],version:"current",frontMatter:{title:"18.1 Hash Table Concepts"},sidebar:"tutorialSidebar",previous:{title:"18. Hash Tables",permalink:"/cl-language-reference/category/18-hash-tables"},next:{title:"18.2 Hash Tables Dictionary",permalink:"/cl-language-reference/category/182-hash-tables-dictionary"}},Q={},T=[{value:"18.1.1 Hash",id:"1811-hash",level:2},{value:"18.1.2 Modifying Hash Table Keys",id:"1812-modifying-hash-table-keys",level:2},{value:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL",id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",level:3},{value:"18.1.2.2 Visible Modification of Objects with respect to EQUAL",id:"18122-visible-modification-of-objects-with-respect-to-equal",level:3},{value:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL",id:"181221-visible-modification-of-conses-with-respect-to-equal",level:4},{value:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL",id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",level:4},{value:"18.1.2.3 Visible Modification of Objects with respect to EQUALP",id:"18123-visible-modification-of-objects-with-respect-to-equalp",level:3},{value:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP",id:"181231-visible-modification-of-structures-with-respect-to-equalp",level:4},{value:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP",id:"181232-visible-modification-of-arrays-with-respect-to-equalp",level:4},{value:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP",id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",level:4},{value:"18.1.2.4 Visible Modifications by Language Extensions",id:"18124-visible-modifications-by-language-extensions",level:3}];function O(e){const t={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"181-hash-table-concepts",children:"18.1 Hash Table Concepts"}),"\n","\n",(0,s.jsx)(r,{}),"\n",(0,s.jsx)(t.h2,{id:"1811-hash",children:"18.1.1 Hash"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(t.h2,{id:"1812-modifying-hash-table-keys",children:"18.1.2 Modifying Hash Table Keys"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(t.h3,{id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"}),"\n","\n",(0,s.jsx)(p,{}),"\n",(0,s.jsx)(t.h3,{id:"18122-visible-modification-of-objects-with-respect-to-equal",children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"}),"\n","\n",(0,s.jsx)(m,{}),"\n",(0,s.jsx)(t.h4,{id:"181221-visible-modification-of-conses-with-respect-to-equal",children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"}),"\n","\n",(0,s.jsx)(f,{}),"\n",(0,s.jsx)(t.h4,{id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"}),"\n","\n",(0,s.jsx)(u,{}),"\n",(0,s.jsx)(t.h3,{id:"18123-visible-modification-of-objects-with-respect-to-equalp",children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"}),"\n","\n",(0,s.jsx)(v,{}),"\n",(0,s.jsx)(t.h4,{id:"181231-visible-modification-of-structures-with-respect-to-equalp",children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"}),"\n","\n",(0,s.jsx)(w,{}),"\n",(0,s.jsx)(t.h4,{id:"181232-visible-modification-of-arrays-with-respect-to-equalp",children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"}),"\n","\n",(0,s.jsx)(q,{}),"\n",(0,s.jsx)(t.h4,{id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"}),"\n","\n",(0,s.jsx)(L,{}),"\n",(0,s.jsx)(t.h3,{id:"18124-visible-modifications-by-language-extensions",children:"18.1.2.4 Visible Modifications by Language Extensions"}),"\n","\n","\n",(0,s.jsx)(A,{})]})}function U(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>c,a:()=>r});var s=i(67294);const n={},o=s.createContext(n);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);