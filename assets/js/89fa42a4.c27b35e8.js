"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[40718],{38548:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>x,frontMatter:()=>c,metadata:()=>h,toc:()=>l});var r=i(85893),s=i(11151);function t(e){const n={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"defmethod"})," ",(0,r.jsx)(n.em,{children:"Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"defmethod"})," ",(0,r.jsx)(n.em,{children:"function-name {method-qualifier}"}),"* ",(0,r.jsx)(n.em,{children:"specialized-lambda-list"})]}),"\n",(0,r.jsxs)(n.p,{children:["[[ ",(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"| documentation"})," ]] ",(0,r.jsx)(n.em,{children:"{form}"}),"*"]}),"\n",(0,r.jsx)(n.p,{children:"\u2192 new-method"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"function-name"}),"::= ",(0,r.jsx)(n.em,{children:"{symbol |"})," (setf ",(0,r.jsx)(n.em,{children:"symbol"}),")",(0,r.jsx)(n.em,{children:"}"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-qualifier"}),"::= ",(0,r.jsx)(n.em,{children:"non-list"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"specialized-lambda-list"}),"::= (",(0,r.jsx)(n.em,{children:"{var |"})," (",(0,r.jsx)(n.em,{children:"var parameter-specializer-name"}),")",(0,r.jsx)(n.em,{children:"}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:["[&optional ",(0,r.jsx)(n.em,{children:"{var |"})," (var [",(0,r.jsx)(n.em,{children:"initform"})," [",(0,r.jsx)(n.em,{children:"supplied-p-parameter"}),"] ])",(0,r.jsx)(n.em,{children:"}"}),"*]"]}),"\n",(0,r.jsxs)(n.p,{children:["[&rest ",(0,r.jsx)(n.em,{children:"var"}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:["[&key*{var |* (",(0,r.jsx)(n.em,{children:"{var |"})," (",(0,r.jsx)(n.em,{children:"keywordvar"}),")",(0,r.jsx)(n.em,{children:"}"})," [",(0,r.jsx)(n.em,{children:"initform"})," [",(0,r.jsx)(n.em,{children:"supplied-p-parameter"}),"] ])",(0,r.jsx)(n.em,{children:"}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:["[",(0,r.jsx)(n.strong,{children:"&allow-other-keys"}),"] ]"]}),"\n",(0,r.jsxs)(n.p,{children:["[&aux ",(0,r.jsx)(n.em,{children:"{var |"})," (",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"initform"}),"] )",(0,r.jsx)(n.em,{children:"}"}),"*] )"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"parameter-specializer-name"}),"::= ",(0,r.jsx)(n.em,{children:"symbol |"})," (eql ",(0,r.jsx)(n.em,{children:"eql-specializer-form"}),")"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,r.jsx)(n.strong,{children:"declare"})," ",(0,r.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"documentation"}),"\u2014a ",(0,r.jsx)(n.em,{children:"string"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var"}),"\u2014a ",(0,r.jsx)(n.em,{children:"variable name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"eql-specializer-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Initform"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Supplied-p-parameter"}),"\u2014variable name."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"new-method"}),"\u2014the new ",(0,r.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["The macro ",(0,r.jsx)(n.strong,{children:"defmethod"})," defines a ",(0,r.jsx)(n.em,{children:"method"})," on a ",(0,r.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If (fboundp ",(0,r.jsx)(n.em,{children:"function-name"}),") is ",(0,r.jsx)(n.strong,{children:"nil"}),", a ",(0,r.jsx)(n.em,{children:"generic function"})," is created with default values for the argument precedence order (each argument is more specific than the arguments to its right in the argument list), for the generic function class (the ",(0,r.jsx)(n.em,{children:"class"})," ",(0,r.jsx)(n.strong,{children:"standard-generic-function"}),"), for the method class (the ",(0,r.jsx)(n.em,{children:"class"})," ",(0,r.jsx)(n.strong,{children:"standard-method"}),"), and for the method combination type (the standard method combination"]}),"\n",(0,r.jsxs)(n.p,{children:["type). The ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"generic function"})," is congruent with the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"method"})," being defined; if the ",(0,r.jsx)(n.strong,{children:"defmethod"})," form mentions keyword arguments, the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"generic function"})," will mention &key (but no keyword arguments). If ",(0,r.jsx)(n.em,{children:"function-name"})," names an ",(0,r.jsx)(n.em,{children:"ordinary function"}),", a ",(0,r.jsx)(n.em,{children:"macro"}),", or a ",(0,r.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.em,{children:"generic function"})," is currently named by ",(0,r.jsx)(n.em,{children:"function-name"}),", the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"method"})," must be congruent with the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"generic function"}),". If this condition does not hold, an error is signaled. For a definition of congruence in this context, see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.em,{children:"method-qualifier"})," argument is an ",(0,r.jsx)(n.em,{children:"object"})," that is used by method combination to identify the given ",(0,r.jsx)(n.em,{children:"method"}),". The method combination type might further restrict what a method ",(0,r.jsx)(n.em,{children:"qualifier"})," can be. The standard method combination type allows for ",(0,r.jsx)(n.em,{children:"unqualified methods"})," and ",(0,r.jsx)(n.em,{children:"methods"})," whose sole"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"defmethod"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"qualifier"})," is one of the keywords ",":before",", ",":after",", or ",":around","."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"specialized-lambda-list"})," argument is like an ordinary ",(0,r.jsx)(n.em,{children:"lambda list"})," except that the ",(0,r.jsx)(n.em,{children:"names"})," of required parameters can be replaced by specialized parameters. A specialized parameter is a list of the form (",(0,r.jsx)(n.em,{children:"var parameter-specializer-name"}),"). Only required parameters can be specialized. If ",(0,r.jsx)(n.em,{children:"parameter-specializer-name"})," is a ",(0,r.jsx)(n.em,{children:"symbol"})," it names a ",(0,r.jsx)(n.em,{children:"class"}),"; if it is a ",(0,r.jsx)(n.em,{children:"list"}),", it is of the form (eql ",(0,r.jsx)(n.em,{children:"eql-specializer-form"}),"). The parameter specializer name (eql ",(0,r.jsx)(n.em,{children:"eql-specializer-form"}),") indicates that the corresponding argument must be ",(0,r.jsx)(n.strong,{children:"eql"})," to the ",(0,r.jsx)(n.em,{children:"object"})," that is the value of ",(0,r.jsx)(n.em,{children:"eql-specializer-form"})," for the ",(0,r.jsx)(n.em,{children:"method"})," to be applicable. The ",(0,r.jsx)(n.em,{children:"eql-specializer-form"})," is evaluated at the time that the expansion of the ",(0,r.jsx)(n.strong,{children:"defmethod"})," macro is evaluated. If no ",(0,r.jsx)(n.em,{children:"parameter specializer name"})," is specified for a given required parameter, the ",(0,r.jsx)(n.em,{children:"parameter specializer"})," defaults to the ",(0,r.jsx)(n.em,{children:"class"})," ",(0,r.jsx)(n.strong,{children:"t"}),". For further discussion, see Section 7.6.2 (Introduction to Methods)."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"form"})," arguments specify the method body. The body of the ",(0,r.jsx)(n.em,{children:"method"})," is enclosed in an ",(0,r.jsx)(n.em,{children:"implicit block"}),". If ",(0,r.jsx)(n.em,{children:"function-name"})," is a ",(0,r.jsx)(n.em,{children:"symbol"}),", this block bears the same ",(0,r.jsx)(n.em,{children:"name"})," as the ",(0,r.jsx)(n.em,{children:"generic function"}),". If ",(0,r.jsx)(n.em,{children:"function-name"})," is a ",(0,r.jsx)(n.em,{children:"list"})," of the form (setf ",(0,r.jsx)(n.em,{children:"symbol"}),"), the ",(0,r.jsx)(n.em,{children:"name"})," of the block is ",(0,r.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"class"})," of the ",(0,r.jsx)(n.em,{children:"method object"})," that is created is that given by the method class option of the ",(0,r.jsx)(n.em,{children:"generic function"})," on which the ",(0,r.jsx)(n.em,{children:"method"})," is defined."]}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.em,{children:"generic function"})," already has a ",(0,r.jsx)(n.em,{children:"method"})," that agrees with the ",(0,r.jsx)(n.em,{children:"method"})," being defined on ",(0,r.jsx)(n.em,{children:"parameter specializers"})," and ",(0,r.jsx)(n.em,{children:"qualifiers"}),", ",(0,r.jsx)(n.strong,{children:"defmethod"})," replaces the existing ",(0,r.jsx)(n.em,{children:"method"})," with the one now being defined. For a definition of agreement in this context. see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers)."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"parameter specializers"})," are derived from the ",(0,r.jsx)(n.em,{children:"parameter specializer names"})," as described in Section 7.6.2 (Introduction to Methods)."]}),"\n",(0,r.jsxs)(n.p,{children:["The expansion of the ",(0,r.jsx)(n.strong,{children:"defmethod"})," macro \u201crefers to\u201d each specialized parameter (see the description of ",(0,r.jsx)(n.strong,{children:"ignore"})," within the description of ",(0,r.jsx)(n.strong,{children:"declare"}),"). This includes parameters that have an explicit ",(0,r.jsx)(n.em,{children:"parameter specializer name"})," of ",(0,r.jsx)(n.strong,{children:"t"}),". This means that a compiler warning does not occur if the body of the ",(0,r.jsx)(n.em,{children:"method"})," does not refer to a specialized parameter, while a warning might occur if the body of the ",(0,r.jsx)(n.em,{children:"method"})," does not refer to an unspecialized parameter. For this reason, a parameter that specializes on ",(0,r.jsx)(n.strong,{children:"t"})," is not quite synonymous with an unspecialized parameter in this context."]}),"\n",(0,r.jsxs)(n.p,{children:["Declarations at the head of the method body that apply to the method\u2019s ",(0,r.jsx)(n.em,{children:"lambda variables"})," are treated as ",(0,r.jsx)(n.em,{children:"bound declarations"})," whose ",(0,r.jsx)(n.em,{children:"scope"})," is the same as the corresponding ",(0,r.jsx)(n.em,{children:"bindings"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Declarations at the head of the method body that apply to the functional bindings of ",(0,r.jsx)(n.strong,{children:"call-next-method"})," or ",(0,r.jsx)(n.strong,{children:"next-method-p"})," apply to references to those functions within the method body ",(0,r.jsx)(n.em,{children:"forms"}),". Any outer ",(0,r.jsx)(n.em,{children:"bindings"})," of the ",(0,r.jsx)(n.em,{children:"function names"})," ",(0,r.jsx)(n.strong,{children:"call-next-method"})," and ",(0,r.jsx)(n.strong,{children:"next-method-p"}),", and declarations associated with such ",(0,r.jsx)(n.em,{children:"bindings"})," are ",(0,r.jsx)(n.em,{children:"shadowed"})," ",(0,r.jsx)("sub",{children:"2"})," within the method body ",(0,r.jsx)(n.em,{children:"forms"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"scope"})," of ",(0,r.jsx)(n.em,{children:"free declarations"})," at the head of the method body is the entire method body, which includes any implicit local function definitions but excludes ",(0,r.jsx)(n.em,{children:"initialization forms"})," for the ",(0,r.jsx)(n.em,{children:"lambda variables"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"defmethod"})," is not required to perform any compile-time side effects. In particular, the ",(0,r.jsx)(n.em,{children:"methods"})]}),"\n",(0,r.jsxs)(n.p,{children:["are not installed for invocation during compilation. An ",(0,r.jsx)(n.em,{children:"implementation"})," may choose to store information about the ",(0,r.jsx)(n.em,{children:"generic function"})," for the purposes of compile-time error-checking (such as checking the number of arguments on calls, or noting that a definition for the function name has been seen)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Documentation"})," is attached as a ",(0,r.jsx)(n.em,{children:"documentation string"})," to the ",(0,r.jsx)(n.em,{children:"method object"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,r.jsxs)(n.p,{children:["The definition of the referenced ",(0,r.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"function-name"})," names an ",(0,r.jsx)(n.em,{children:"ordinary function"}),", a ",(0,r.jsx)(n.em,{children:"macro"}),", or a ",(0,r.jsx)(n.em,{children:"special operator"})," , an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.em,{children:"generic function"})," is currently named by ",(0,r.jsx)(n.em,{children:"function-name"}),", the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"method"})," must be congruent with the ",(0,r.jsx)(n.em,{children:"lambda list"})," of the ",(0,r.jsx)(n.em,{children:"generic function"}),", or an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"error"})," is signaled."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"defgeneric"}),", ",(0,r.jsx)(n.strong,{children:"documentation"}),", Section 7.6.2 (Introduction to Methods), Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function), Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)"]})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}const c={title:"defmethod"},o="defmethod",h={id:"chap-7/h-h-dictionary/defmethod_macro",title:"defmethod",description:"Expanded Reference: defmethod",source:"@site/docs/chap-7/h-h-dictionary/defmethod_macro.md",sourceDirName:"chap-7/h-h-dictionary",slug:"/chap-7/h-h-dictionary/defmethod_macro",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/defmethod_macro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-7/h-h-dictionary/defmethod_macro.md",tags:[],version:"current",frontMatter:{title:"defmethod"},sidebar:"tutorialSidebar",previous:{title:"define-method-combination",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/define-method-combination_macro"},next:{title:"ensure-generic-function",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/ensure-generic-function_function"}},a={},l=[{value:"Expanded Reference: defmethod",id:"expanded-reference-defmethod",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"defmethod",children:"defmethod"}),"\n","\n","\n",(0,r.jsx)(d,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-defmethod",children:"Expanded Reference: defmethod"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(defmethod )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>d});var r=i(67294);const s={},t=r.createContext(s);function d(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);