"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[7679],{28453:(e,n,s)=>{s.d(n,{R:()=>h,x:()=>c});var i=s(96540);const r={},t=i.createContext(r);function h(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:h(e.components),i.createElement(t.Provider,{value:n},e.children)}},94387:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>j,frontMatter:()=>l,metadata:()=>i,toc:()=>x});const i=JSON.parse('{"id":"chap-18/bi-c-dictionary/sxhash_function","title":"sxhash","description":"Expanded Reference: sxhash","source":"@site/docs/chap-18/bi-c-dictionary/sxhash_function.md","sourceDirName":"chap-18/bi-c-dictionary","slug":"/chap-18/bi-c-dictionary/sxhash_function","permalink":"/cl-language-reference/chap-18/bi-c-dictionary/sxhash_function","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-18/bi-c-dictionary/sxhash_function.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"sxhash"},"sidebar":"tutorialSidebar","previous":{"title":"remhash","permalink":"/cl-language-reference/chap-18/bi-c-dictionary/remhash_function"},"next":{"title":"with-hash-table-iterator","permalink":"/cl-language-reference/chap-18/bi-c-dictionary/with-hash-table-iterator_macro"}}');var r=s(74848),t=s(28453);function h(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components},{DictionaryLink:s,GlossaryTerm:i}=n;return s||a("DictionaryLink",!0),i||a("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"sxhash"})," ",(0,r.jsx)(i,{term:"function",children:(0,r.jsx)("i",{children:"Function"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})})," ",(0,r.jsx)(n.em,{children:"object \u2192 hash-code"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),"\u2014an ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"hash-code"}),"\u2014a non-negative ",(0,r.jsx)(i,{term:"fixnum",children:(0,r.jsx)("i",{children:"fixnum"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})})," returns a hash code for ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The manner in which the hash code is computed is ",(0,r.jsx)(i,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})}),", but subject to certain constraints:"]}),"\n",(0,r.jsxs)(n.p,{children:["1. (equal ",(0,r.jsx)(n.em,{children:"x y"}),") implies (= (sxhash ",(0,r.jsx)(n.em,{children:"x"}),") (sxhash ",(0,r.jsx)(n.em,{children:"y"}),"))."]}),"\n",(0,r.jsxs)(n.p,{children:["2. For any two ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"objects"})}),", ",(0,r.jsx)(n.em,{children:"x"})," and ",(0,r.jsx)(n.em,{children:"y"}),", both of which are ",(0,r.jsx)(i,{styled:!0,term:"bit vector",children:(0,r.jsx)("i",{children:"bit vectors"})}),", ",(0,r.jsx)(i,{styled:!0,term:"character",children:(0,r.jsx)("i",{children:"characters"})}),", ",(0,r.jsx)(n.em,{children:"conses"}),", ",(0,r.jsx)(i,{styled:!0,term:"number",children:(0,r.jsx)("i",{children:"numbers"})}),", ",(0,r.jsx)(i,{styled:!0,term:"pathname",children:(0,r.jsx)("i",{children:"pathnames"})}),", ",(0,r.jsx)(i,{styled:!0,term:"string",children:(0,r.jsx)("i",{children:"strings"})}),", or ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})}),", and which are ",(0,r.jsx)(i,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," , (sxhash ",(0,r.jsx)(n.em,{children:"x"}),") and (sxhash ",(0,r.jsx)(n.em,{children:"y"}),") ",(0,r.jsx)(i,{term:"yield",children:(0,r.jsx)("i",{children:"yield"})})," the same mathematical value even if ",(0,r.jsx)(n.em,{children:"x"})," and ",(0,r.jsx)(n.em,{children:"y"})," exist in different ",(0,r.jsx)(n.em,{children:"Lisp images"})," of the same ",(0,r.jsx)(i,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),". See Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,r.jsxs)(n.p,{children:["3. The ",(0,r.jsx)(n.em,{children:"hash-code"})," for an ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," is always the ",(0,r.jsx)(i,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," within a single ",(0,r.jsx)(i,{term:"session",children:(0,r.jsx)("i",{children:"session"})})," provided that the ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," is not visibly modified with regard to the equivalence test ",(0,r.jsx)(s,{term:"equal",children:(0,r.jsx)("b",{children:"equal"})}),". See Section 18.1.2 (Modifying Hash Table Keys)."]}),"\n",(0,r.jsx)(n.p,{children:"Hash"}),"\n",(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})}),"\n",(0,r.jsxs)(n.p,{children:["4. The ",(0,r.jsx)(n.em,{children:"hash-code"})," is intended for hashing. This places no verifiable constraint on a ",(0,r.jsx)(i,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementation"})}),", but the intent is that an ",(0,r.jsx)(i,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," should make a good-faith effort to produce ",(0,r.jsx)(n.em,{children:"hash-codes"})," that are well distributed within the range of non-negative ",(0,r.jsx)(i,{term:"fixnum",children:(0,r.jsx)("i",{children:"fixnums"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["5. Computation of the ",(0,r.jsx)(n.em,{children:"hash-code"})," must terminate, even if the ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," contains circularities."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:'(= (sxhash (list \u2019list "ab")) (sxhash (list \u2019list "ab"))) \u2192 true \n(= (sxhash "a") (sxhash (make-string 1 :initial-element #\\a))) \u2192 true \n(let ((r (make-random-state))) \n  (= (sxhash r) (sxhash (make-random-state r)))) \n\u2192 implementation-dependent \n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(i,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["Many common hashing needs are satisfied by ",(0,r.jsx)(s,{term:"make-hash-table",children:(0,r.jsx)("b",{children:"make-hash-table"})})," and the related functions on ",(0,r.jsx)(i,{styled:!0,term:"hash table",children:(0,r.jsx)("i",{children:"hash tables"})}),". ",(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})})," is intended for use where the pre-defined abstractions are insufficient. Its main intent is to allow the user a convenient means of implementing more complicated hashing paradigms than are provided through ",(0,r.jsx)(i,{styled:!0,term:"hash table",children:(0,r.jsx)("i",{children:"hash tables"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The hash codes returned by ",(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})})," are not necessarily related to any hashing strategy used by any other ",(0,r.jsx)(i,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," in Common Lisp."]}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," of ",(0,r.jsx)(i,{term:"type",children:(0,r.jsx)("i",{children:"types"})})," that ",(0,r.jsx)(s,{term:"equal",children:(0,r.jsx)("b",{children:"equal"})})," compares with ",(0,r.jsx)(s,{term:"eq",children:(0,r.jsx)("b",{children:"eq"})}),", item 3 requires that the ",(0,r.jsx)(n.em,{children:"hash-code"})," be based on some immutable quality of the identity of the object. Another legitimate implementation technique would be to have ",(0,r.jsx)(s,{term:"sxhash",children:(0,r.jsx)("b",{children:"sxhash"})})," assign (and cache) a random hash code for these ",(0,r.jsx)(i,{term:"object",children:(0,r.jsx)("i",{children:"objects"})}),", since there is no requirement that ",(0,r.jsx)(i,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," but non-",(0,r.jsx)(s,{term:"eq",children:(0,r.jsx)("b",{children:"eq"})})," objects have the same hash code."]}),"\n",(0,r.jsxs)(n.p,{children:["Although ",(0,r.jsx)(i,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," is defined for ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," in terms of both the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,r.jsx)(i,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," and the ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," in which the ",(0,r.jsx)(i,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," is ",(0,r.jsx)(i,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})}),", item 3 disallows using ",(0,r.jsx)(i,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," information to compute the hash code, since changes to the package status of a symbol are not visible to ",(0,r.jsx)(n.em,{children:"equal"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function a(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const l={title:"sxhash"},d="sxhash",o={},x=[{value:"Expanded Reference: sxhash",id:"expanded-reference-sxhash",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sxhash",children:"sxhash"})}),"\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-sxhash",children:"Expanded Reference: sxhash"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(sxhash )\n"})})]})}function j(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}}}]);