"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[13115],{12247:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>je,contentTitle:()=>he,default:()=>fe,frontMatter:()=>ae,metadata:()=>me,toc:()=>xe});var r=n(85893),t=n(11151);function s(e){return(0,r.jsx)(r.Fragment,{})}function l(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(s,{...e})}):s()}function c(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||d("DictionaryLink",!0),s||d("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"The following terminology is used in this section."}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," is a utility that translates code into an ",(0,r.jsx)(s,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," form that might be represented or executed efficiently. The term ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," refers to both of the ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"functions"})})," ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," and ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})})," refers to ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," representing compiled programs, such as ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," constructed by ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," or by ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})})," when ",(0,r.jsx)(i.em,{children:"loading"})," a ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"implicit compilation",children:(0,r.jsx)("i",{children:"implicit compilation"})})," refers to ",(0,r.jsx)(s,{term:"compilation",children:(0,r.jsx)("i",{children:"compilation"})})," performed during ",(0,r.jsx)(s,{term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(i.em,{children:"literal object"})," refers to a quoted ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," or a ",(0,r.jsx)(s,{styled:!0,term:"self-evaluating object",children:(0,r.jsx)("i",{children:"self-evaluating object"})})," or an ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," that is a substructure of such an ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),". A ",(0,r.jsx)(s,{styled:!0,term:"constant variable",children:(0,r.jsx)("i",{children:"constant variable"})})," is not itself a ",(0,r.jsx)(i.em,{children:"literal object"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{term:"coalesce",children:(0,r.jsx)("i",{children:"coalesce"})})," is defined as follows. Suppose A and B are two ",(0,r.jsx)(i.em,{children:"literal constants"})," in the ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})}),", and that A\u2019 and B\u2019 are the corresponding ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})}),". If A\u2019 and B\u2019 are ",(0,r.jsx)(n,{term:"eql",children:(0,r.jsx)("b",{children:"eql"})})," but A and B are not ",(0,r.jsx)(n,{term:"eql",children:(0,r.jsx)("b",{children:"eql"})}),", then it is said that A and B have been coalesced by the compiler."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"minimal compilation",children:(0,r.jsx)("i",{children:"minimal compilation"})})," refers to actions the compiler must take at ",(0,r.jsx)(s,{styled:!0,term:"compile time",children:(0,r.jsx)("i",{children:"compile time"})}),". These actions are specified in Section 3.2.2 (Compilation Semantics)."]}),"\n",(0,r.jsxs)(i.p,{children:["The verb ",(0,r.jsx)(s,{term:"process",children:(0,r.jsx)("i",{children:"process"})})," refers to performing ",(0,r.jsx)(s,{styled:!0,term:"minimal compilation",children:(0,r.jsx)("i",{children:"minimal compilation"})}),", determining the time of evaluation for a ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),", and possibly ",(0,r.jsx)(i.em,{children:"evaluating"})," that ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," (if required)."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"further compilation",children:(0,r.jsx)("i",{children:"further compilation"})})," refers to ",(0,r.jsx)(s,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," compilation beyond ",(0,r.jsx)(s,{styled:!0,term:"minimal compilation",children:(0,r.jsx)("i",{children:"minimal compilation"})}),". That is, ",(0,r.jsx)(i.em,{children:"processing"})," does not imply complete compilation. Block compilation and generation of machine-specific instructions are examples of further compilation. Further compilation is permitted to take place at ",(0,r.jsx)(s,{styled:!0,term:"run time",children:(0,r.jsx)("i",{children:"run time"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Four different ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environments"})})," relevant to compilation are distinguished: the ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})}),", the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})}),", the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})}),", and the ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})})," is the ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," of the ",(0,r.jsx)(i.em,{children:"Lisp image"})," from which the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," was invoked."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," is maintained by the compiler and is used to hold definitions and declarations to be used internally by the compiler. Only those parts of a definition needed for correct compilation are saved. The ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," is used as the ",(0,r.jsx)(i.em,{children:"environment argument"})," to macro expanders called by the compiler. It is unspecified whether a definition available in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," can be used in an ",(0,r.jsx)(s,{term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})})," initiated in the ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})})," or ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," is a ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})})," in which macro expanders and code specified by ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," to be evaluated are evaluated. All evaluations initiated by the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})]}),"\n",(0,r.jsxs)(i.p,{children:["take place in the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})})," is the ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," in which the program being compiled will be executed."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," inherits from the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})}),", and the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," and ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," might be ",(0,r.jsx)(s,{term:"identical",children:(0,r.jsx)("i",{children:"identical"})}),". The ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," inherits from the ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})}),", and the ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})})," and ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," might be ",(0,r.jsx)(s,{term:"identical",children:(0,r.jsx)("i",{children:"identical"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"compile time",children:(0,r.jsx)("i",{children:"compile time"})})," refers to the duration of time that the compiler is processing ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})}),". At ",(0,r.jsx)(s,{styled:!0,term:"compile time",children:(0,r.jsx)("i",{children:"compile time"})}),", only the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," and the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," are available."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(i.em,{children:"compile-time definition"})," refers to a definition in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})}),". For example, when compiling a file, the definition of a function might be retained in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," if it is declared ",(0,r.jsx)(n,{term:"inline",children:(0,r.jsx)("b",{children:"inline"})}),". This definition might not be available in the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"run time",children:(0,r.jsx)("i",{children:"run time"})})," refers to the duration of time that the loader is loading compiled code or compiled code is being executed. At run time, only the ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})})," is available."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"run-time definition",children:(0,r.jsx)("i",{children:"run-time definition"})})," refers to a definition in the ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The term ",(0,r.jsx)(s,{styled:!0,term:"run-time compiler",children:(0,r.jsx)("i",{children:"run-time compiler"})})," refers to the ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," or ",(0,r.jsx)(s,{styled:!0,term:"implicit compilation",children:(0,r.jsx)("i",{children:"implicit compilation"})}),", for which the compilation and run-time ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environments"})})," are maintained in the same ",(0,r.jsx)(i.em,{children:"Lisp image"}),". Note that when the ",(0,r.jsx)(s,{styled:!0,term:"run-time compiler",children:(0,r.jsx)("i",{children:"run-time compiler"})})," is used, the ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})})," and ",(0,r.jsx)(s,{styled:!0,term:"startup environment",children:(0,r.jsx)("i",{children:"startup environment"})})," are the same."]})]})}function o(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}function d(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function a(e){const i={p:"p",...(0,t.a)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(i.p,{children:["Conceptually, compilation is a process that traverses code, performs certain kinds of syntactic and semantic analyses using information (such as proclamations and ",(0,r.jsx)(n,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," definitions) present in the ",(0,r.jsx)(n,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})}),", and produces equivalent, possibly more efficient code."]})}function h(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}function m(e){const i={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||x("DictionaryLink",!0),s||x("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," can be defined for a ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," that also names a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," or ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),". That is, it is possible for a ",(0,r.jsx)(s,{styled:!0,term:"function name",children:(0,r.jsx)("i",{children:"function name"})})," to name both a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," and a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(s,{styled:!0,term:"function name",children:(0,r.jsx)("i",{children:"function name"})})," names a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," if ",(0,r.jsx)(n,{term:"compiler-macro-function",children:(0,r.jsx)("b",{children:"compiler-macro-function"})})," is ",(0,r.jsx)(s,{term:"true",children:(0,r.jsx)("i",{children:"true"})})," of the ",(0,r.jsx)(s,{styled:!0,term:"function name",children:(0,r.jsx)("i",{children:"function name"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"lexical environment",children:(0,r.jsx)("i",{children:"lexical environment"})})," in which it appears. Creating a ",(0,r.jsx)(s,{styled:!0,term:"lexical binding",children:(0,r.jsx)("i",{children:"lexical binding"})})," for the ",(0,r.jsx)(s,{styled:!0,term:"function name",children:(0,r.jsx)("i",{children:"function name"})})," not only creates a new local ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," or ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," definition, but also ",(0,r.jsx)(s,{term:"shadow",children:(0,r.jsx)("i",{children:"shadows"})}),(0,r.jsx)("sub",{children:"2"})," the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," returned by ",(0,r.jsx)(n,{term:"compiler-macro-function",children:(0,r.jsx)("b",{children:"compiler-macro-function"})})," is a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," of two arguments, called the expansion function. To expand a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),", the expansion function is invoked by calling the ",(0,r.jsx)(s,{styled:!0,term:"macroexpand hook",children:(0,r.jsx)("i",{children:"macroexpand hook"})})," with the expansion function as its first argument, the entire compiler macro ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," as its second argument, and the current compilation ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," (or with the current lexical ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),", if the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," is being processed by something other than ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),") as its third"]}),"\n",(0,r.jsxs)(i.p,{children:["argument. The ",(0,r.jsx)(s,{styled:!0,term:"macroexpand hook",children:(0,r.jsx)("i",{children:"macroexpand hook"})}),", in turn, calls the expansion function with the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," as its first argument and the ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," as its second argument. The return value from the expansion function, which is passed through by the ",(0,r.jsx)(s,{styled:!0,term:"macroexpand hook",children:(0,r.jsx)("i",{children:"macroexpand hook"})}),", might either be the ",(0,r.jsx)(i.em,{children:"same form"}),", or else a form that can, at the discretion of the ",(0,r.jsx)(s,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," doing the expansion, be used in place of the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["|",(0,r.jsx)(i.strong,{children:"*macroexpand-hook* compiler-macro-function define-compiler-macro"}),"|"]}),"\n",(0,r.jsx)(i.p,{children:"| :- |"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Figure 3\u20136. Defined names applicable to compiler macros"})})]})}function j(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}function x(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function p(e){const i={p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||u("DictionaryLink",!0),s||u("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["The purpose of the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," facility is to permit selective source code transformations as optimization advice to the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," . When a ",(0,r.jsx)(s,{styled:!0,term:"compound form",children:(0,r.jsx)("i",{children:"compound form"})})," is being processed (as by the compiler), if the ",(0,r.jsx)(s,{term:"operator",children:(0,r.jsx)("i",{children:"operator"})})," names a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," then the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})})," may be"]}),"\n",(0,r.jsxs)(i.p,{children:["invoked on the form, and the resulting expansion recursively processed in preference to performing the usual processing on the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," according to its normal interpretation as a ",(0,r.jsx)(s,{styled:!0,term:"function form",children:(0,r.jsx)("i",{children:"function form"})})," or ",(0,r.jsx)(s,{styled:!0,term:"macro form",children:(0,r.jsx)("i",{children:"macro form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})}),", like a ",(0,r.jsx)(s,{styled:!0,term:"macro function",children:(0,r.jsx)("i",{children:"macro function"})}),", is a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," of two ",(0,r.jsx)(s,{term:"argument",children:(0,r.jsx)("i",{children:"arguments"})}),": the entire call ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," and the ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),". Unlike an ordinary ",(0,r.jsx)(s,{styled:!0,term:"macro function",children:(0,r.jsx)("i",{children:"macro function"})}),", a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})})," can decline to provide an expansion merely by returning a value that is the ",(0,r.jsx)(s,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," as the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),". The consequences are undefined if a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})})," destructively modifies any part of its ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," argument."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," passed to the compiler macro function can either be a ",(0,r.jsx)(s,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," whose ",(0,r.jsx)(s,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," is the function name, or a ",(0,r.jsx)(s,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," whose ",(0,r.jsx)(s,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," is ",(0,r.jsx)(n,{term:"funcall",children:(0,r.jsx)("b",{children:"funcall"})})," and whose ",(0,r.jsx)(s,{term:"cadr",children:(0,r.jsx)("i",{children:"cadr"})})," is a list (function ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})}),"); note that this affects destructuring of the form argument by the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})}),". ",(0,r.jsx)(n,{term:"define-compiler-macro",children:(0,r.jsx)("b",{children:"define-compiler-macro"})})," arranges for destructuring of arguments to be performed correctly for both possible formats."]}),"\n",(0,r.jsxs)(i.p,{children:["When ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," chooses to expand a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," that is a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro form",children:(0,r.jsx)("i",{children:"compiler macro form"})}),", the expansion is also treated as a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," for the purposes of ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," processing; see Section 3.2.3.1 (Processing of Top Level Forms)."]})]})}function f(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}function u(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function y(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||g("DictionaryLink",!0),s||g("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"Compiler macros"})})," may be defined for ",(0,r.jsx)(s,{styled:!0,term:"function name",children:(0,r.jsx)("i",{children:"function names"})})," that name ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," as well as ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"functions"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"Compiler macro"})})," definitions are strictly global. There is no provision for defining local ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," in the way that ",(0,r.jsx)(n,{term:"macrolet",children:(0,r.jsx)("b",{children:"macrolet"})})," defines local ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})}),". Lexical bindings of a function name shadow any compiler macro definition associated with the name as well as its global ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," or ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," definition."]}),"\n",(0,r.jsxs)(i.p,{children:["Note that the presence of a compiler macro definition does not affect the values returned by functions that access ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," definitions (",(0,r.jsx)(i.em,{children:"e.g."}),", ",(0,r.jsx)(n,{term:"fboundp",children:(0,r.jsx)("b",{children:"fboundp"})}),") or ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," definitions (",(0,r.jsx)(i.em,{children:"e.g."}),", ",(0,r.jsx)(n,{term:"macroexpand",children:(0,r.jsx)("b",{children:"macroexpand"})}),")."]}),"\n",(0,r.jsxs)(i.p,{children:["Compiler macros are global, and the function ",(0,r.jsx)(n,{term:"compiler-macro-function",children:(0,r.jsx)("b",{children:"compiler-macro-function"})})," is sufficient to resolve their interaction with other lexical and global definitions."]})]})}function b(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}function g(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function v(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||k("DictionaryLink",!0),s||k("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["The presence of a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," definition for a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," or ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," indicates that it is desirable for the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," to use the expansion of the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," instead of the original ",(0,r.jsx)(s,{styled:!0,term:"function form",children:(0,r.jsx)("i",{children:"function form"})})," or ",(0,r.jsx)(s,{styled:!0,term:"macro form",children:(0,r.jsx)("i",{children:"macro form"})}),". However, no language processor (compiler, evaluator, or other code walker) is ever required to actually invoke ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro functions"})}),", or to make use of the resulting expansion if it does invoke a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro function",children:(0,r.jsx)("i",{children:"compiler macro function"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["When the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," encounters a ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," during processing that represents a call to a ",(0,r.jsx)(i.em,{children:"compiler macro name"})," (that is not declared ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})}),"), the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," might expand the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),", and might use the expansion in place of the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["When ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," encounters a ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," during processing that represents a call to a ",(0,r.jsx)(i.em,{children:"compiler macro name"})," (that is not declared ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})}),"), ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," might expand the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})}),", and might use the expansion in place of the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["There are two situations in which a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," definition must not be applied by any language processor:"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," The global function name binding associated with the compiler macro is shadowed by a lexical binding of the function name."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," The function name has been declared or proclaimed ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})})," and the call form appears within the scope of the declaration."]}),"\n",(0,r.jsxs)(i.p,{children:["It is unspecified whether ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," are expanded or used in any other situations."]})]})}function w(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(v,{...e})}):v(e)}function k(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function T(e){const i={p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||E("DictionaryLink",!0),s||E("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Although it is technically permissible, as described above, for ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," to treat ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," in the same situations as ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," might, this is not necessarily a good idea in ",(0,r.jsx)(s,{styled:!0,term:"interpreted implementation",children:(0,r.jsx)("i",{children:"interpreted implementations"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"Compiler macros"})})," exist for the purpose of trading compile-time speed for run-time speed. Programmers who write ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," tend to assume that the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," can take more time than normal ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"functions"})})," and ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," in order to produce code which is especially optimal for use at run time. Since ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," in an ",(0,r.jsx)(s,{styled:!0,term:"interpreted implementation",children:(0,r.jsx)("i",{children:"interpreted implementation"})})," might perform semantic analysis of the same form multiple times, it might be inefficient in general for the ",(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," to choose to call ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macros"})})," on every such ",(0,r.jsx)(s,{term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Nevertheless, the decision about what to do in these situations is left to each ",(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),". Evaluation and"]})]})}function C(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(T,{...e})}):T(e)}function E(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function S(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||L("DictionaryLink",!0),s||L("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{styled:!0,term:"minimal compilation",children:(0,r.jsx)("i",{children:"Minimal compilation"})})," is defined as follows:"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," All ",(0,r.jsx)(s,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"compiler macro"})})," calls appearing in the ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," being compiled are expanded, if at all, at compile time; they will not be expanded at run time."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," All ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," and ",(0,r.jsx)(s,{styled:!0,term:"symbol macro",children:(0,r.jsx)("i",{children:"symbol macro"})})," calls appearing in the source code being compiled are expanded at compile time in such a way that they will not be expanded again at run time. ",(0,r.jsx)(n,{term:"macrolet",children:(0,r.jsx)("b",{children:"macrolet"})})," and ",(0,r.jsx)(n,{term:"symbol-macrolet",children:(0,r.jsx)("b",{children:"symbol-macrolet"})})," are effectively replaced by ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," corresponding to their bodies in which calls to ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," are replaced by their expansions."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," The first ",(0,r.jsx)(s,{term:"argument",children:(0,r.jsx)("i",{children:"argument"})})," in a ",(0,r.jsx)(n,{term:"load-time-value",children:(0,r.jsx)("b",{children:"load-time-value"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," in ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," processed by ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," is ",(0,r.jsx)(i.em,{children:"evaluated"})," at ",(0,r.jsx)(s,{styled:!0,term:"compile time",children:(0,r.jsx)("i",{children:"compile time"})}),"; in ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," processed by ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),", the compiler arranges for it to be ",(0,r.jsx)(i.em,{children:"evaluated"})," at ",(0,r.jsx)(s,{styled:!0,term:"load time",children:(0,r.jsx)("i",{children:"load time"})}),". In either case, the result of the ",(0,r.jsx)(s,{term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})})," is remembered and used later as the value of the ",(0,r.jsx)(n,{term:"load-time-value",children:(0,r.jsx)("b",{children:"load-time-value"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," at ",(0,r.jsx)(i.em,{children:"execution time"}),"."]})]})}function F(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}function L(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function q(e){const i={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||A("DictionaryLink",!0),s||A("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["All ",(0,r.jsx)(s,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming programs"})})," must obey the following constraints, which are designed to minimize the observable differences between compiled and interpreted programs:"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," Definitions of any referenced ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," must be present in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})}),". Any ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," that is a ",(0,r.jsx)(s,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," beginning with a ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," that does not name a ",(0,r.jsx)(s,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," or a ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," defined in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," is treated by the compiler as a function call."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," ",(0,r.jsx)(i.strong,{children:"Special"})," proclamations for ",(0,r.jsx)(s,{styled:!0,term:"dynamic variable",children:(0,r.jsx)("i",{children:"dynamic variables"})})," must be made in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})}),". Any ",(0,r.jsx)(s,{term:"binding",children:(0,r.jsx)("i",{children:"binding"})})," for which there is no ",(0,r.jsx)(n,{term:"special",children:(0,r.jsx)("b",{children:"special"})})," declaration or proclamation in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," is treated by the compiler as a ",(0,r.jsx)(s,{styled:!0,term:"lexical binding",children:(0,r.jsx)("i",{children:"lexical binding"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," The definition of a function that is defined and declared ",(0,r.jsx)(n,{term:"inline",children:(0,r.jsx)("b",{children:"inline"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," must be the same at run time."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," Within a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," named ",(0,r.jsx)(i.em,{children:"F"}),", the compiler may (but is not required to) assume that an apparent recursive call to a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," named ",(0,r.jsx)(i.em,{children:"F"})," refers to the same definition of ",(0,r.jsx)(i.em,{children:"F"}),", unless that function has been declared ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})}),". The consequences of redefining such a recursively defined ",(0,r.jsx)(i.em,{children:"function F"})," while it is executing are undefined."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," A call within a file to a named function that is defined in the same file refers to that function, unless that function has been declared ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})}),". The consequences are unspecified if functions are redefined individually at run time or multiply defined in the same file."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," The argument syntax and number of return values for all functions whose ",(0,r.jsx)(n,{term:"ftype",children:(0,r.jsx)("b",{children:"ftype"})})," is declared at compile time must remain the same at run time."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022 Constant variables"})," defined in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," must have a ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," value at run time. A reference to a ",(0,r.jsx)(s,{styled:!0,term:"constant variable",children:(0,r.jsx)("i",{children:"constant variable"})})," in ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," is equivalent to a reference to a ",(0,r.jsx)(i.em,{children:"literal object"})," that is the ",(0,r.jsx)(s,{term:"value",children:(0,r.jsx)("i",{children:"value"})})," of the ",(0,r.jsx)(s,{styled:!0,term:"constant variable",children:(0,r.jsx)("i",{children:"constant variable"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," Type definitions made with ",(0,r.jsx)(n,{term:"deftype",children:(0,r.jsx)("b",{children:"deftype"})})," or ",(0,r.jsx)(n,{term:"defstruct",children:(0,r.jsx)("b",{children:"defstruct"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," must retain the same definition at run time. Classes defined by ",(0,r.jsx)(n,{term:"defclass",children:(0,r.jsx)("b",{children:"defclass"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," must be defined at run time to have the same ",(0,r.jsx)(i.em,{children:"superclasses"})," and same ",(0,r.jsx)(s,{term:"metaclass",children:(0,r.jsx)("i",{children:"metaclass"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["This implies that ",(0,r.jsx)(s,{term:"subtype",children:(0,r.jsx)("i",{children:"subtype"})}),"/",(0,r.jsx)(s,{term:"supertype",children:(0,r.jsx)("i",{children:"supertype"})})," relationships of ",(0,r.jsx)(s,{styled:!0,term:"type specifier",children:(0,r.jsx)("i",{children:"type specifiers"})})," must not change between ",(0,r.jsx)(s,{styled:!0,term:"compile time",children:(0,r.jsx)("i",{children:"compile time"})})," and ",(0,r.jsx)(s,{styled:!0,term:"run time",children:(0,r.jsx)("i",{children:"run time"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," Type declarations present in the compilation ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," must accurately describe the corresponding values at run time; otherwise, the consequences are undefined. It is permissible for an unknown ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," to appear in a declaration at compile time, though a warning might be signaled in such a case."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," Except in the situations explicitly listed above, a ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," defined in the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," is permitted to have a different definition or a different ",(0,r.jsx)(s,{term:"signature",children:(0,r.jsx)("i",{children:"signature"})})," at run time, and the run-time definition prevails."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"Conforming programs"})})," should not be written using any additional assumptions about consistency between the run-time ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," and the startup, evaluation, and compilation ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environments"})}),"."]}),"\n",(0,r.jsx)(i.p,{children:"Except where noted, when a compile-time and a run-time definition are different, one of the following occurs at run time:"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," an error of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"error",children:(0,r.jsx)("b",{children:"error"})})," is signaled"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," the compile-time definition prevails"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"\u2022"})," the run-time definition prevails"]}),"\n",(0,r.jsxs)(i.p,{children:["If the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," processes a ",(0,r.jsx)(s,{styled:!0,term:"function form",children:(0,r.jsx)("i",{children:"function form"})})," whose ",(0,r.jsx)(s,{term:"operator",children:(0,r.jsx)("i",{children:"operator"})})," is not defined at compile time, no error is signaled at compile time."]})]})}function D(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(q,{...e})}):q(e)}function A(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function G(e){const i={p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||N("DictionaryLink",!0),s||N("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," performs compilation of ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," in a file following the rules specified in Section 3.2.2 (Compilation Semantics), and produces an output file that can be loaded by using ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Normally, the ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," appearing in a file compiled with ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," are evaluated only when the resulting compiled file is loaded, and not when the file is compiled. However, it is typically the case that some forms in the file need to be evaluated at compile time so the remainder of the file can be read and compiled correctly."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," ",(0,r.jsx)(s,{styled:!0,term:"special form",children:(0,r.jsx)("i",{children:"special form"})})," can be used to control whether a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," is evaluated at compile time, load time, or both. It is possible to specify any of three situations with ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})}),", denoted by the symbols ",":compile-toplevel",", ",":load-toplevel",", and ",":execute",". For top level ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," forms, ",":compile-toplevel"," specifies that the compiler must evaluate the body at compile time, and ",":load-toplevel"," specifies that the compiler must arrange to evaluate the body at load time. For non-top level ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," forms, ",":execute"," specifies that the body must be executed in the run-time ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The behavior of this ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," can be more precisely understood in terms of a model of how ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," processes forms in a file to be compiled. There are two processing modes, called \u201cnot-compile-time\u201d and \u201ccompile-time-too\u201d."]}),"\n",(0,r.jsxs)(i.p,{children:["Successive forms are read from the file by ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," and processed in not-compile-time mode; in this mode, ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," arranges for forms to be evaluated only at load time and not at compile time. When ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," is in compile-time-too mode, forms are evaluated both at compile time and load time."]})]})}function I(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(G,{...e})}):G(e)}function N(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function z(e){const i={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||P("DictionaryLink",!0),s||P("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Processing of ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," in the file compiler is defined as follows:"]}),"\n",(0,r.jsxs)(i.p,{children:["1. If the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," is a ",(0,r.jsx)(s,{styled:!0,term:"compiler macro form",children:(0,r.jsx)("i",{children:"compiler macro form"})})," (not disabled by a ",(0,r.jsx)(n,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})})," ",(0,r.jsx)(s,{term:"declaration",children:(0,r.jsx)("i",{children:"declaration"})}),"), the ",(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," might or might not choose to compute the ",(0,r.jsx)(s,{styled:!0,term:"compiler macro expansion",children:(0,r.jsx)("i",{children:"compiler macro expansion"})})," of the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," and, having performed the expansion, might or might not choose to process the result as a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in the same processing mode (compile-time-too or not-compile time). If it declines to obtain or use the expansion, it must process the original ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["2. If the form is a ",(0,r.jsx)(s,{styled:!0,term:"macro form",children:(0,r.jsx)("i",{children:"macro form"})}),", its ",(0,r.jsx)(s,{styled:!0,term:"macro expansion",children:(0,r.jsx)("i",{children:"macro expansion"})})," is computed and processed as a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in the same processing mode (compile-time-too or not-compile-time)."]}),"\n",(0,r.jsxs)(i.p,{children:["3. If the form is a ",(0,r.jsx)(n,{term:"progn",children:(0,r.jsx)("b",{children:"progn"})})," form, each of its body ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," is sequentially processed as a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in the same processing mode."]}),"\n",(0,r.jsxs)(i.p,{children:["4. If the form is a ",(0,r.jsx)(n,{term:"locally",children:(0,r.jsx)("b",{children:"locally"})}),", ",(0,r.jsx)(n,{term:"macrolet",children:(0,r.jsx)("b",{children:"macrolet"})}),", or ",(0,r.jsx)(n,{term:"symbol-macrolet",children:(0,r.jsx)("b",{children:"symbol-macrolet"})}),", ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," establishes the appropriate bindings and processes the body forms as ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," with those bindings in effect in the same processing mode. (Note that this implies that the lexical ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," in which ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," are processed is not necessarily the ",(0,r.jsx)(s,{styled:!0,term:"null lexical environment",children:(0,r.jsx)("i",{children:"null lexical environment"})}),".)"]}),"\n",(0,r.jsxs)(i.p,{children:["5. If the form is an ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," form, it is handled according to Figure 3\u20137."]}),"\n",(0,r.jsxs)(i.p,{children:["|",(0,r.jsx)(i.strong,{children:"CT LT E Mode Action New Mode"}),"|"]}),"\n",(0,r.jsx)(i.p,{children:"| :- |"}),"\n",(0,r.jsxs)(i.p,{children:["|",(0,r.jsx)("p",{children:"Yes Yes \u2014 \u2014 Process compile-time-too No Yes Yes CTT Process compile-time-too No Yes Yes NCT Process not-compile-time No Yes No \u2014 Process not-compile-time Yes No \u2014 \u2014 Evaluate \u2014 "}),(0,r.jsx)("p",{children:"No No Yes CTT Evaluate \u2014 No No Yes NCT Discard \u2014 No No No \u2014 Discard \u2014"}),"|"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Figure 3\u20137. EVAL-WHEN processing"})}),"\n",(0,r.jsxs)(i.p,{children:["Column ",(0,r.jsx)(i.strong,{children:"CT"})," indicates whether ",":compile-toplevel"," is specified. Column ",(0,r.jsx)(i.strong,{children:"LT"})," indicates whether ",":load-toplevel"," is specified. Column ",(0,r.jsx)(i.strong,{children:"E"})," indicates whether ",":execute"," is specified. Column ",(0,r.jsx)(i.strong,{children:"Mode"})," indicates the processing mode; a dash (\u2014) indicates that the processing mode is not relevant."]}),"\n",(0,r.jsxs)(i.p,{children:["The\n",(0,r.jsx)(i.strong,{children:"Action"}),"\ncolumn specifies one of three actions:"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Process:"})," process the body as ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," in the specified mode."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Evaluate:"})," evaluate the body in the dynamic execution context of the compiler, using the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," as the global environment and the ",(0,r.jsx)(s,{styled:!0,term:"lexical environment",children:(0,r.jsx)("i",{children:"lexical environment"})})," in which the ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," appears."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Discard:"})," ignore the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.strong,{children:"New Mode"})," column indicates the new processing mode. A dash (\u2014) indicates the compiler remains in its current mode."]}),"\n",(0,r.jsxs)(i.p,{children:["6. Otherwise, the form is a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," that is not one of the special cases. In compile time-too mode, the compiler first evaluates the form in the evaluation ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})})," and then minimally compiles it. In not-compile-time mode, the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," is simply minimally compiled. All ",(0,r.jsx)(s,{term:"subform",children:(0,r.jsx)("i",{children:"subforms"})})," are treated as ",(0,r.jsx)(s,{styled:!0,term:"non-top-level form",children:(0,r.jsx)("i",{children:"non-top-level forms"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Note that ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," are processed in the order in which they textually appear in the file and that each ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," read by the compiler is processed before the next is read. However, the order of processing (including macro expansion) of ",(0,r.jsx)(s,{term:"subform",children:(0,r.jsx)("i",{children:"subforms"})})," that are not ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})})," and the order of further compilation is unspecified as long as Common Lisp"]}),"\n",(0,r.jsx)(i.p,{children:"semantics are preserved."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," forms cause compile-time evaluation only at top level. Both ",":compile-toplevel"," and ",":load-toplevel"," situation specifications are ignored for ",(0,r.jsx)(s,{styled:!0,term:"non-top-level form",children:(0,r.jsx)("i",{children:"non-top-level forms"})}),". For ",(0,r.jsx)(i.em,{children:"non-top-level"})]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})}),", an ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," specifying the ",":execute"," situation is treated as an ",(0,r.jsx)(s,{styled:!0,term:"implicit progn",children:(0,r.jsx)("i",{children:"implicit progn"})})," including the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," in the body of the ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"; otherwise, the ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," in the body are ignored."]})]})}function M(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(z,{...e})}):z(e)}function P(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function O(e){const i={p:"p",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||B("DictionaryLink",!0),s||B("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Defining ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," (such as ",(0,r.jsx)(n,{term:"defmacro",children:(0,r.jsx)("b",{children:"defmacro"})})," or ",(0,r.jsx)(n,{term:"defvar",children:(0,r.jsx)("b",{children:"defvar"})}),") appearing within a file being processed by ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," normally have compile-time side effects which affect how subsequent ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," in the same ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})})," are compiled. A convenient model for explaining how these side effects happen is that the defining macro expands into one or more ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"forms"})}),", and that the calls which cause the compile-time side effects to happen appear in the body of an (eval-when (",":compile-toplevel",") ...) ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsx)(i.p,{children:"The compile-time side effects may cause information about the definition to be stored differently than if the defining macro had been processed in the \u2018normal\u2019 way (either interpretively or by loading the compiled file)."}),"\n",(0,r.jsxs)(i.p,{children:["In particular, the information stored by the defining ",(0,r.jsx)(s,{term:"macro",children:(0,r.jsx)("i",{children:"macros"})})," at compile time might or might not be available to the interpreter (either during or after compilation), or during subsequent calls to the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," . For example, the following code is nonportable because it assumes that the ",(0,r.jsx)(s,{term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," stores the macro definition of foo where it is available to the interpreter:"]}),"\n",(0,r.jsx)(i.p,{children:"(defmacro foo (x) \u2018(car ,x))"}),"\n",(0,r.jsxs)(i.p,{children:["(eval-when (",":execute"," ",":compile-toplevel"," ",":load-toplevel",")"]}),"\n",(0,r.jsx)(i.p,{children:"(print (foo \u2019(a b c))))"}),"\n",(0,r.jsxs)(i.p,{children:["A portable way to do the same thing would be to include the macro definition inside the ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),", as in:"]}),"\n",(0,r.jsxs)(i.p,{children:["(eval-when (",":execute"," ",":compile-toplevel"," ",":load-toplevel",")"]}),"\n",(0,r.jsx)(i.p,{children:"(defmacro foo (x) \u2018(car ,x))"}),"\n",(0,r.jsx)(i.p,{children:"(print (foo \u2019(a b c))))"}),"\n",(0,r.jsxs)(i.p,{children:["Figure 3\u20138 lists macros that make definitions available both in the compilation and run-time ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environments"})}),". It is not specified whether definitions made available in the ",(0,r.jsx)(s,{styled:!0,term:"compilation environment",children:(0,r.jsx)("i",{children:"compilation environment"})})," are available in the evaluation ",(0,r.jsx)(s,{term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),", nor is it specified whether they are available in subsequent compilation units or subsequent invocations of the compiler. As with ",(0,r.jsx)(n,{term:"eval-when",children:(0,r.jsx)("b",{children:"eval-when"})}),", these compile-time side effects happen only when the defining macros appear at top level."]}),"\n",(0,r.jsxs)(i.p,{children:["|",(0,r.jsx)(i.strong,{children:"declaim define-modify-macro defsetf defclass define-setf-expander defstruct defconstant defmacro deftype define-compiler-macro defpackage defvar define-condition defparameter"}),"|"]}),"\n",(0,r.jsx)(i.p,{children:"| :- |"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Figure 3\u20138. Defining Macros That Affect the Compile-Time Environment"})})]})}function W(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(O,{...e})}):O(e)}function B(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function Y(e){const i={p:"p",...(0,t.a)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Except where explicitly stated otherwise, no ",(0,r.jsx)(n,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})})," defined in the Common Lisp standard produces an expansion that could cause any of the ",(0,r.jsx)(n,{term:"subform",children:(0,r.jsx)("i",{children:"subforms"})})," of the ",(0,r.jsx)(n,{styled:!0,term:"macro form",children:(0,r.jsx)("i",{children:"macro form"})})," to be treated as ",(0,r.jsx)(n,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level forms"})}),". If an ",(0,r.jsx)(n,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," also provides a ",(0,r.jsx)(n,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," definition of a Common Lisp ",(0,r.jsx)(n,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", the ",(0,r.jsx)(n,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," definition must be semantically equivalent in this respect."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{styled:!0,term:"compiler macro",children:(0,r.jsx)("i",{children:"Compiler macro"})})," expansions must also have the same top level evaluation semantics as the ",(0,r.jsx)(n,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," which they replace. This is of concern both to ",(0,r.jsx)(n,{styled:!0,term:"conforming implementation",children:(0,r.jsx)("i",{children:"conforming implementations"})})," and to ",(0,r.jsx)(n,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming programs"})}),"."]})]})}function H(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(Y,{...e})}):Y(e)}function U(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||K("DictionaryLink",!0),s||K("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["The functions ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," and ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," are required to ensure that ",(0,r.jsx)(i.em,{children:"literal objects"})," referenced within the resulting interpreted or compiled code objects are the ",(0,r.jsx)(s,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," as the corresponding ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})}),". ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),", on the other hand, must produce a ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," that, when loaded with ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})}),", constructs the ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," defined by the ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," and produces references to them."]}),"\n",(0,r.jsxs)(i.p,{children:["In the case of ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),", ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," constructed by ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})})," of the ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," cannot be spoken of as being the ",(0,r.jsx)(s,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," as the ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," constructed at compile time, because the ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," may be loaded into a different ",(0,r.jsx)(i.em,{children:"Lisp image"})," than the one in which it was compiled. This section defines the concept of ",(0,r.jsx)(s,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," which relates ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"evaluation environment",children:(0,r.jsx)("i",{children:"evaluation environment"})})," to the corresponding ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in"]}),"\n",(0,r.jsxs)(i.p,{children:["the ",(0,r.jsx)(s,{styled:!0,term:"run-time environment",children:(0,r.jsx)("i",{children:"run-time environment"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The constraints on ",(0,r.jsx)(i.em,{children:"literal objects"})," described in this section apply only to ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),"; ",(0,r.jsx)(n,{term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," and ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," do not copy or coalesce constants."]})]})}function _(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(U,{...e})}):U(e)}function K(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function R(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["The fact that the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," represents ",(0,r.jsx)(i.em,{children:"literal objects"})," externally in a ",(0,r.jsx)(n,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," and must later reconstruct suitable equivalents of those ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," when that ",(0,r.jsx)(n,{term:"file",children:(0,r.jsx)("i",{children:"file"})})," is loaded imposes a need for constraints on the nature of the ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," that can be used as ",(0,r.jsx)(i.em,{children:"literal objects"})," in ",(0,r.jsx)(n,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," to be processed by the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["An ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," that can be used as a ",(0,r.jsx)(i.em,{children:"literal object"})," in ",(0,r.jsx)(n,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," to be processed by the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," is called an ",(0,r.jsx)(n,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable object"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["We define that two ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," are ",(0,r.jsx)(n,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if they satisfy a two-place conceptual equivalence predicate (defined below), which is independent of the ",(0,r.jsx)(i.em,{children:"Lisp image"})," so that the two ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in different ",(0,r.jsx)(i.em,{children:"Lisp images"})," can be understood to be equivalent under this predicate. Further, by inspecting the definition of this conceptual predicate, the programmer can anticipate what aspects of an ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," are reliably preserved by ",(0,r.jsx)(i.em,{children:"file compilation"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," must cooperate with the ",(0,r.jsx)(n,{term:"loader",children:(0,r.jsx)("i",{children:"loader"})})," in order to assure that in each case where an ",(0,r.jsx)(n,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable object"})})," is processed as a ",(0,r.jsx)(i.em,{children:"literal object"}),", the ",(0,r.jsx)(n,{term:"loader",children:(0,r.jsx)("i",{children:"loader"})})," will construct a ",(0,r.jsx)(i.em,{children:"similar object"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The set of ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," that are ",(0,r.jsx)(n,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable objects"})})," are those for which the new conceptual term \u201c",(0,r.jsx)(n,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})}),"\u201d is defined, such that when a ",(0,r.jsx)(n,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," is ",(0,r.jsx)(i.em,{children:"loaded"}),", an ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," can be constructed which"]}),"\n",(0,r.jsxs)(i.p,{children:["can be shown to be ",(0,r.jsx)(n,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the original ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," which existed at the time the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," was operating."]})]})}function V(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(R,{...e})}):R(e)}function Z(e){return(0,r.jsx)(r.Fragment,{})}function J(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(Z,{...e})}):Z()}function Q(e){const i={p:"p",...(0,t.a)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(i.p,{children:["Of the ",(0,r.jsx)(n,{term:"type",children:(0,r.jsx)("i",{children:"types"})})," over which ",(0,r.jsx)(n,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," is defined, some are treated as aggregate objects. For these types, ",(0,r.jsx)(n,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," is defined recursively. We say that an ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," of these types has certain \u201cbasic qualities\u201d and to satisfy the ",(0,r.jsx)(n,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," relationship, the values of the corresponding qualities of the two ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," must also be similar."]})}function X(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(Q,{...e})}):Q(e)}function $(e){const i={em:"em",p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||ie("DictionaryLink",!0),s||ie("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"objects S"})," (in ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})}),") and ",(0,r.jsx)(i.em,{children:"C"})," (in ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})}),") are defined to be ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if and only if they are both of one of the ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"types"})})," listed here (or defined by the ",(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),") and they both satisfy all additional requirements of ",(0,r.jsx)(s,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," indicated for that ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})}),"."]}),"\n",(0,r.jsx)(n,{term:"number",children:(0,r.jsx)("b",{children:"number"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"numbers S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if they are of the same ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," and represent the same mathematical value."]}),"\n",(0,r.jsx)(n,{term:"character",children:(0,r.jsx)("b",{children:"character"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"simple characters S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if they have ",(0,r.jsx)(i.em,{children:"similar code attributes"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"Implementations"})})," providing additional, ",(0,r.jsx)(i.em,{children:"implementation-defined attributes"})," must define whether and how ",(0,r.jsx)(i.em,{children:"non-simple characters"})," can be regarded as ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsx)(n,{term:"symbol",children:(0,r.jsx)("b",{children:"symbol"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"apparently uninterned symbols S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if their ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(s,{term:"interned",children:(0,r.jsx)("i",{children:"interned"})})," symbols ",(0,r.jsx)(i.em,{children:"S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if their ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," , and if either ",(0,r.jsx)(i.em,{children:"S"})," is accessible in the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," at compile time and ",(0,r.jsx)(i.em,{children:"C"})," is accessible in the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," at load time, or ",(0,r.jsx)(i.em,{children:"C"})," is accessible in the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," that is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," of ",(0,r.jsx)(i.em,{children:"S"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["(Note that ",(0,r.jsx)(s,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," of ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," is dependent on neither the ",(0,r.jsx)(s,{styled:!0,term:"current readtable",children:(0,r.jsx)("i",{children:"current readtable"})})," nor how the ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n,{term:"read",children:(0,r.jsx)("b",{children:"read"})})," would parse the ",(0,r.jsx)(s,{term:"character",children:(0,r.jsx)("i",{children:"characters"})})," in the ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," of the ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),".)"]}),"\n",(0,r.jsx)(n,{term:"package",children:(0,r.jsx)("b",{children:"package"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"packages S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if their ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"names"})})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["Note that although a ",(0,r.jsx)(i.em,{children:"package object"})," is an ",(0,r.jsx)(s,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable object"})}),", the programmer is responsible for ensuring that the corresponding ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," is already in existence when code"]}),"\n",(0,r.jsxs)(i.p,{children:["referencing it as a ",(0,r.jsx)(i.em,{children:"literal object"})," is ",(0,r.jsx)(i.em,{children:"loaded"}),". The ",(0,r.jsx)(s,{term:"loader",children:(0,r.jsx)("i",{children:"loader"})})," finds the corresponding ",(0,r.jsx)(i.em,{children:"package object"})," as if by calling ",(0,r.jsx)(n,{term:"find-package",children:(0,r.jsx)("b",{children:"find-package"})})," with that ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," as an ",(0,r.jsx)(s,{term:"argument",children:(0,r.jsx)("i",{children:"argument"})}),". An error is signaled by the ",(0,r.jsx)(s,{term:"loader",children:(0,r.jsx)("i",{children:"loader"})})," if no ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," exists at load time."]}),"\n",(0,r.jsx)(n,{term:"random-state",children:(0,r.jsx)("b",{children:"random-state"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"random states S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if ",(0,r.jsx)(i.em,{children:"S"})," would always produce the same sequence of pseudo-random numbers as a ",(0,r.jsx)(s,{term:"copy",children:(0,r.jsx)("i",{children:"copy"})}),(0,r.jsx)("sub",{children:"5"})," of ",(0,r.jsx)(i.em,{children:"C"})," when given as the ",(0,r.jsx)(i.em,{children:"random-state argument"})," to the ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n,{term:"random",children:(0,r.jsx)("b",{children:"random"})}),", assuming equivalent ",(0,r.jsx)(i.em,{children:"limit arguments"})," in each case."]}),"\n",(0,r.jsxs)(i.p,{children:["(Note that since ",(0,r.jsx)(i.em,{children:"C"})," has been processed by the ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," , it cannot be used directly as an ",(0,r.jsx)(s,{term:"argument",children:(0,r.jsx)("i",{children:"argument"})})," to ",(0,r.jsx)(n,{term:"random",children:(0,r.jsx)("b",{children:"random"})})," because ",(0,r.jsx)(n,{term:"random",children:(0,r.jsx)("b",{children:"random"})})," would perform a side effect.)"]}),"\n",(0,r.jsx)(n,{term:"cons",children:(0,r.jsx)("b",{children:"cons"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"conses"}),", ",(0,r.jsx)(i.em,{children:"S"})," and ",(0,r.jsx)(i.em,{children:"C"}),", are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if the ",(0,r.jsx)(s,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," ",(0,r.jsx)("sub",{children:"2"})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{term:"car",children:(0,r.jsx)("i",{children:"car"})})," ",(0,r.jsx)("sub",{children:"2"})," of ",(0,r.jsx)(i.em,{children:"C"}),", and the ",(0,r.jsx)(s,{term:"cdr",children:(0,r.jsx)("i",{children:"cdr"})})," ",(0,r.jsx)("sub",{children:"2"})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{term:"cdr",children:(0,r.jsx)("i",{children:"cdr"})})," ",(0,r.jsx)("sub",{children:"2"})," of ",(0,r.jsx)(i.em,{children:"C"}),"."]}),"\n",(0,r.jsx)(n,{term:"array",children:(0,r.jsx)("b",{children:"array"})}),"\n",(0,r.jsxs)(i.p,{children:["Two one-dimensional ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"arrays"})}),", ",(0,r.jsx)(i.em,{children:"S"})," and ",(0,r.jsx)(i.em,{children:"C"}),", are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if the ",(0,r.jsx)(s,{term:"length",children:(0,r.jsx)("i",{children:"length"})})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{term:"length",children:(0,r.jsx)("i",{children:"length"})})," of ",(0,r.jsx)(i.em,{children:"C"}),", the ",(0,r.jsx)(s,{styled:!0,term:"actual array element type",children:(0,r.jsx)("i",{children:"actual array element type"})})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{styled:!0,term:"actual array element type",children:(0,r.jsx)("i",{children:"actual array element type"})})," of ",(0,r.jsx)(i.em,{children:"C"}),", and each ",(0,r.jsx)(i.em,{children:"active element"})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the corresponding ",(0,r.jsx)(s,{term:"element",children:(0,r.jsx)("i",{children:"element"})})," of ",(0,r.jsx)(i.em,{children:"C"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"arrays"})})," of ",(0,r.jsx)(s,{term:"rank",children:(0,r.jsx)("i",{children:"rank"})})," other than one, ",(0,r.jsx)(i.em,{children:"S"})," and ",(0,r.jsx)(i.em,{children:"C"}),", are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if the ",(0,r.jsx)(s,{term:"rank",children:(0,r.jsx)("i",{children:"rank"})})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{term:"rank",children:(0,r.jsx)("i",{children:"rank"})})," of ",(0,r.jsx)(i.em,{children:"C"}),", each ",(0,r.jsx)(s,{term:"dimension",children:(0,r.jsx)("i",{children:"dimension"})}),(0,r.jsx)("sub",{children:"1"})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the corresponding ",(0,r.jsx)(s,{term:"dimension",children:(0,r.jsx)("i",{children:"dimension"})}),(0,r.jsx)("sub",{children:"1"})," of ",(0,r.jsx)(i.em,{children:"C"}),", the ",(0,r.jsx)(s,{styled:!0,term:"actual array element type",children:(0,r.jsx)("i",{children:"actual array element type"})})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the ",(0,r.jsx)(s,{styled:!0,term:"actual array element type",children:(0,r.jsx)("i",{children:"actual array element type"})})," of ",(0,r.jsx)(i.em,{children:"C"}),", and each ",(0,r.jsx)(s,{term:"element",children:(0,r.jsx)("i",{children:"element"})})," of ",(0,r.jsx)(i.em,{children:"S"})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to the corresponding ",(0,r.jsx)(s,{term:"element",children:(0,r.jsx)("i",{children:"element"})})," of ",(0,r.jsx)(i.em,{children:"C"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["In addition, if ",(0,r.jsx)(i.em,{children:"S"})," is a ",(0,r.jsx)(s,{styled:!0,term:"simple array",children:(0,r.jsx)("i",{children:"simple array"})}),", then ",(0,r.jsx)(i.em,{children:"C"})," must also be a ",(0,r.jsx)(s,{styled:!0,term:"simple array",children:(0,r.jsx)("i",{children:"simple array"})}),". If ",(0,r.jsx)(i.em,{children:"S"})," is a ",(0,r.jsx)(s,{styled:!0,term:"displaced array",children:(0,r.jsx)("i",{children:"displaced array"})}),", has a ",(0,r.jsx)(s,{styled:!0,term:"fill pointer",children:(0,r.jsx)("i",{children:"fill pointer"})})," , or is ",(0,r.jsx)(s,{styled:!0,term:"actually adjustable",children:(0,r.jsx)("i",{children:"actually adjustable"})}),", ",(0,r.jsx)(i.em,{children:"C"})," is permitted to lack any or all of these qualities."]}),"\n",(0,r.jsx)(n,{term:"hash-table",children:(0,r.jsx)("b",{children:"hash-table"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"hash tables S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if they meet the following three requirements: 1. They both have the same test (",(0,r.jsx)(i.em,{children:"e.g."}),", they are both ",(0,r.jsx)(n,{term:"eql",children:(0,r.jsx)("b",{children:"eql"})})," ",(0,r.jsx)(s,{styled:!0,term:"hash table",children:(0,r.jsx)("i",{children:"hash tables"})}),")."]}),"\n",(0,r.jsxs)(i.p,{children:["2. There is a unique one-to-one correspondence between the keys of the two ",(0,r.jsx)(s,{styled:!0,term:"hash table",children:(0,r.jsx)("i",{children:"hash tables"})}),", such that the corresponding keys are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["3. For all keys, the values associated with two corresponding keys are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["If there is more than one possible one-to-one correspondence between the keys of ",(0,r.jsx)(i.em,{children:"S"})," and ",(0,r.jsx)(i.em,{children:"C"}),", the consequences are unspecified. A ",(0,r.jsx)(s,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," cannot use a table such as ",(0,r.jsx)(i.em,{children:"S"})," as an ",(0,r.jsx)(i.em,{children:"externalizable constant"}),"."]}),"\n",(0,r.jsx)(n,{term:"pathname",children:(0,r.jsx)("b",{children:"pathname"})}),"\n",(0,r.jsxs)(i.p,{children:["Two ",(0,r.jsx)(i.em,{children:"pathnames S"})," and ",(0,r.jsx)(i.em,{children:"C"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," if all corresponding ",(0,r.jsx)(i.em,{children:"pathname components"})," are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ."]}),"\n",(0,r.jsx)(n,{term:"function",children:(0,r.jsx)("b",{children:"function"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"Functions"})})," are not ",(0,r.jsx)(s,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable objects"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})})," and ",(0,r.jsx)(n,{term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})})]}),"\n",(0,r.jsxs)(i.p,{children:["A general-purpose concept of ",(0,r.jsx)(s,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," does not exist for ",(0,r.jsx)(s,{term:"structure",children:(0,r.jsx)("i",{children:"structures"})})," and ",(0,r.jsx)(s,{styled:!0,term:"standard object",children:(0,r.jsx)("i",{children:"standard objects"})}),". However, a ",(0,r.jsx)(s,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"conforming program"})})," is permitted to define a ",(0,r.jsx)(n,{term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," ",(0,r.jsx)(s,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," for any ",(0,r.jsx)(i.em,{children:"class K"})," defined by that ",(0,r.jsx)(s,{term:"program",children:(0,r.jsx)("i",{children:"program"})})," that is a ",(0,r.jsx)(s,{term:"subclass",children:(0,r.jsx)("i",{children:"subclass"})})," of either ",(0,r.jsx)(n,{term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})})," or ",(0,r.jsx)(n,{term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})}),". The effect of such a ",(0,r.jsx)(s,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," is to define that an ",(0,r.jsx)(i.em,{children:"object S"})," of ",(0,r.jsx)(i.em,{children:"type K"})," in ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," is ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," to an ",(0,r.jsx)(i.em,{children:"object C"})," of ",(0,r.jsx)(i.em,{children:"type K"})," in ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})})," if ",(0,r.jsx)(i.em,{children:"C"})," was constructed from ",(0,r.jsx)(s,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," produced by calling ",(0,r.jsx)(n,{term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," on ",(0,r.jsx)(i.em,{children:"S"}),"."]})]})}function ee(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)($,{...e})}):$(e)}function ie(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ne(e){const i={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components},{GlossaryTerm:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["Some ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})}),", such as ",(0,r.jsx)(n,{term:"stream",children:(0,r.jsx)("i",{children:"streams"})}),", ",(0,r.jsx)(i.strong,{children:"readtables"}),", and ",(0,r.jsx)(i.strong,{children:"methods"})," are not ",(0,r.jsx)(n,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable objects"})})," under the definition of similarity given above. That is, such ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," may not portably appear as ",(0,r.jsx)(i.em,{children:"literal objects"})," in ",(0,r.jsx)(n,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," to be processed by the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," ."]}),"\n",(0,r.jsxs)(i.p,{children:["An ",(0,r.jsx)(n,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," is permitted to extend the rules of similarity, so that other kinds of ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," are ",(0,r.jsx)(n,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable objects"})})," for that ",(0,r.jsx)(n,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["If for some kind of ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})}),", ",(0,r.jsx)(n,{term:"similarity",children:(0,r.jsx)("i",{children:"similarity"})})," is neither defined by this specification nor by the ",(0,r.jsx)(n,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})}),", then the ",(0,r.jsx)(n,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," must signal an error upon encountering such an ",(0,r.jsx)(n,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," as a ",(0,r.jsx)(i.em,{children:"literal constant"}),"."]})]})}function re(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(ne,{...e})}):ne(e)}function te(e){const i={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||le("DictionaryLink",!0),s||le("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:["If two ",(0,r.jsx)(i.em,{children:"literal objects"})," appearing in the source code for a single file processed with the ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," are the ",(0,r.jsx)(s,{term:"identical",children:(0,r.jsx)("i",{children:"identical"})}),", the corresponding ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"objects"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})})," must also be the ",(0,r.jsx)(s,{term:"identical",children:(0,r.jsx)("i",{children:"identical"})}),". With the exception of ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," and ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),", any two ",(0,r.jsx)(i.em,{children:"literal objects"})," in ",(0,r.jsx)(s,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," being processed by the ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," may be ",(0,r.jsx)(i.em,{children:"coalesced"})," if and only if they are ",(0,r.jsx)(s,{term:"similar",children:(0,r.jsx)("i",{children:"similar"})})," ; if they are either both ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," or both ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"packages"})}),", they may only be ",(0,r.jsx)(i.em,{children:"coalesced"})," if and only if they are ",(0,r.jsx)(s,{term:"identical",children:(0,r.jsx)("i",{children:"identical"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"Objects"})})," containing circular references can be ",(0,r.jsx)(s,{styled:!0,term:"externalizable object",children:(0,r.jsx)("i",{children:"externalizable objects"})}),". The ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," is required to preserve ",(0,r.jsx)(n,{term:"eql",children:(0,r.jsx)("b",{children:"eql"})}),"ness of substructures within a ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})}),". Preserving ",(0,r.jsx)(n,{term:"eql",children:(0,r.jsx)("b",{children:"eql"})}),"ness means that subobjects that are the ",(0,r.jsx)(s,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"source code",children:(0,r.jsx)("i",{children:"source code"})})," must be the ",(0,r.jsx)(s,{term:"same",children:(0,r.jsx)("i",{children:"same"})})," in the corresponding ",(0,r.jsx)(s,{styled:!0,term:"compiled code",children:(0,r.jsx)("i",{children:"compiled code"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["In addition, the following are constraints on the handling of ",(0,r.jsx)(i.em,{children:"literal objects"})," by the ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," :"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"array",children:(0,r.jsx)("b",{children:"array:"})})," If an ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the source code is a ",(0,r.jsx)(s,{styled:!0,term:"simple array",children:(0,r.jsx)("i",{children:"simple array"})}),", then the corresponding ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the compiled code will also be a ",(0,r.jsx)(s,{styled:!0,term:"simple array",children:(0,r.jsx)("i",{children:"simple array"})}),". If an ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the source code is displaced, has a ",(0,r.jsx)(s,{styled:!0,term:"fill pointer",children:(0,r.jsx)("i",{children:"fill pointer"})})," , or is ",(0,r.jsx)(s,{styled:!0,term:"actually adjustable",children:(0,r.jsx)("i",{children:"actually adjustable"})}),", the corresponding ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the compiled code might lack any or all of these qualities. If an ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the source code has a fill pointer, then the corresponding ",(0,r.jsx)(s,{term:"array",children:(0,r.jsx)("i",{children:"array"})})," in the compiled code might be only the size implied by the fill pointer."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"packages:"})," The loader is required to find the corresponding ",(0,r.jsx)(i.em,{children:"package object"})," as if by calling ",(0,r.jsx)(n,{term:"find-package",children:(0,r.jsx)("b",{children:"find-package"})})," with the package name as an argument. An error of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"package-error",children:(0,r.jsx)("b",{children:"package-error"})})," is signaled if no ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," of that name exists at load time."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"random-state",children:(0,r.jsx)("b",{children:"random-state:"})})," A constant ",(0,r.jsx)(s,{styled:!0,term:"random state",children:(0,r.jsx)("i",{children:"random state"})})," object cannot be used as the state argument to the ",(0,r.jsx)(s,{term:"function",children:(0,r.jsx)("i",{children:"function"})})," ",(0,r.jsx)(n,{term:"random",children:(0,r.jsx)("b",{children:"random"})})," because ",(0,r.jsx)(n,{term:"random",children:(0,r.jsx)("b",{children:"random"})})," modifies this data structure."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"structure, standard-object:"})," ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"Objects"})})," of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})})," and ",(0,r.jsx)(n,{term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})})," may appear in compiled constants if there is an appropriate ",(0,r.jsx)(n,{term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," method defined for that ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," calls ",(0,r.jsx)(n,{term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," on any ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," that is referenced as a ",(0,r.jsx)(i.em,{children:"literal object"})," if the ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," is a ",(0,r.jsx)(s,{styled:!0,term:"generalized instance",children:(0,r.jsx)("i",{children:"generalized instance"})})," of ",(0,r.jsx)(n,{term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})}),", ",(0,r.jsx)(n,{term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})}),", ",(0,r.jsx)(n,{term:"condition",children:(0,r.jsx)("b",{children:"condition"})}),", or any of a (possibly empty) ",(0,r.jsx)(s,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," set of other ",(0,r.jsx)(i.em,{children:"classes"}),". The ",(0,r.jsx)(s,{styled:!0,term:"file compiler",children:(0,r.jsx)("i",{children:"file compiler"})})," only calls ",(0,r.jsx)(n,{term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," once for any given ",(0,r.jsx)(s,{term:"object",children:(0,r.jsx)("i",{children:"object"})})," within a single ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"symbol",children:(0,r.jsx)("b",{children:"symbol:"})})," In order to guarantee that ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled files"})})," can be ",(0,r.jsx)(i.em,{children:"loaded"})," correctly, users must ensure that the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"packages"})})," referenced in those ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"files"})})," are defined consistently at compile time and load time. ",(0,r.jsx)(s,{styled:!0,term:"conforming program",children:(0,r.jsx)("i",{children:"Conforming programs"})})," must satisfy the following requirements:"]}),"\n",(0,r.jsxs)(i.p,{children:["1. The ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," when a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in the ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})})," is processed by ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," must be the same as the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," when the ",(0,r.jsx)(s,{term:"code",children:(0,r.jsx)("i",{children:"code"})})," corresponding to that ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in the ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," is executed by ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})}),". In particular:"]}),"\n",(0,r.jsxs)(i.p,{children:["a. Any ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," in a ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})})," that alters the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," must change it to"]}),"\n",(0,r.jsxs)(i.p,{children:["a ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," of the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," both at compile time and at load time."]}),"\n",(0,r.jsxs)(i.p,{children:["b. If the first ",(0,r.jsx)(i.em,{children:"non-atomic top level form"})," in the ",(0,r.jsx)(s,{term:"file",children:(0,r.jsx)("i",{children:"file"})})," is not an ",(0,r.jsx)(n,{term:"in-package",children:(0,r.jsx)("b",{children:"in-package"})})," ",(0,r.jsx)(s,{term:"form",children:(0,r.jsx)("i",{children:"form"})}),","]}),"\n",(0,r.jsxs)(i.p,{children:["then the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," at the time ",(0,r.jsx)(n,{term:"load",children:(0,r.jsx)("b",{children:"load"})})," is called must be a ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," with"]}),"\n",(0,r.jsxs)(i.p,{children:["the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," as the package that was the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," at the time"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," was called."]}),"\n",(0,r.jsxs)(i.p,{children:["2. For all ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," appearing lexically within a ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," that were ",(0,r.jsx)(s,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," that was the ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," during processing of that ",(0,r.jsx)(s,{styled:!0,term:"top level form",children:(0,r.jsx)("i",{children:"top level form"})})," at compile time, but whose ",(0,r.jsx)(s,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," was another ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})}),", at load time there must be a ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," with the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," that is ",(0,r.jsx)(s,{term:"accessible",children:(0,r.jsx)("i",{children:"accessible"})})," in both the load-time ",(0,r.jsx)(s,{styled:!0,term:"current package",children:(0,r.jsx)("i",{children:"current package"})})," and in the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," with the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," as the compile-time ",(0,r.jsx)(s,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["3. For all ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," represented in the ",(0,r.jsx)(s,{styled:!0,term:"compiled file",children:(0,r.jsx)("i",{children:"compiled file"})})," that were ",(0,r.jsx)(s,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbols"})})," in their ",(0,r.jsx)(s,{styled:!0,term:"home package",children:(0,r.jsx)("i",{children:"home package"})})," at compile time, there must be a ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," with the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," that is an ",(0,r.jsx)(s,{styled:!0,term:"external symbol",children:(0,r.jsx)("i",{children:"external symbol"})})," in the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," with the same ",(0,r.jsx)(s,{term:"name",children:(0,r.jsx)("i",{children:"name"})})," at load time."]}),"\n",(0,r.jsxs)(i.p,{children:["If any of these conditions do not hold, the ",(0,r.jsx)(s,{term:"package",children:(0,r.jsx)("i",{children:"package"})})," in which the ",(0,r.jsx)(s,{term:"loader",children:(0,r.jsx)("i",{children:"loader"})})," looks for the affected ",(0,r.jsx)(s,{term:"symbol",children:(0,r.jsx)("i",{children:"symbols"})})," is unspecified. ",(0,r.jsx)(s,{term:"implementation",children:(0,r.jsx)("i",{children:"Implementations"})})," are permitted to signal an error or to define this behavior."]})]})}function se(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(te,{...e})}):te(e)}function le(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function ce(e){const i={p:"p",...(0,t.a)(),...e.components},{DictionaryLink:n,GlossaryTerm:s}=i;return n||de("DictionaryLink",!0),s||de("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(i.p,{children:[(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," and ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," are permitted to signal errors and warnings, including errors due to compile-time processing of (eval-when (",":compile-toplevel",") ...) forms, macro expansion, and conditions signaled by the compiler itself."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(s,{term:"condition",children:(0,r.jsx)("i",{children:"Conditions"})})," of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"error",children:(0,r.jsx)("b",{children:"error"})})," might be signaled by the compiler in situations where the compilation cannot proceed without intervention."]}),"\n",(0,r.jsxs)(i.p,{children:["In addition to situations for which the standard specifies that ",(0,r.jsx)(s,{term:"condition",children:(0,r.jsx)("i",{children:"conditions"})})," of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"warning",children:(0,r.jsx)("b",{children:"warning"})})," must or might be signaled, warnings might be signaled in situations where the compiler can determine that the consequences are undefined or that a run-time error will be signaled. Examples of this situation are as follows: violating type declarations, altering or assigning the value of a constant defined with ",(0,r.jsx)(n,{term:"defconstant",children:(0,r.jsx)("b",{children:"defconstant"})}),", calling built-in Lisp functions with a wrong number of arguments or malformed keyword argument lists, and using unrecognized declaration specifiers."]}),"\n",(0,r.jsxs)(i.p,{children:["The compiler is permitted to issue warnings about matters of programming style as conditions of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"style-warning",children:(0,r.jsx)("b",{children:"style-warning"})}),". Examples of this situation are as follows: redefining a function using a different argument list, calling a function with a wrong number of arguments, not declaring ",(0,r.jsx)(n,{term:"ignore",children:(0,r.jsx)("b",{children:"ignore"})})," of a local variable that is not referenced, and referencing a variable declared ",(0,r.jsx)(n,{term:"ignore",children:(0,r.jsx)("b",{children:"ignore"})}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["Both ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," and ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," are permitted (but not required) to ",(0,r.jsx)(s,{term:"establish",children:(0,r.jsx)("i",{children:"establish"})})," a ",(0,r.jsx)(s,{term:"handler",children:(0,r.jsx)("i",{children:"handler"})})," for ",(0,r.jsx)(s,{term:"condition",children:(0,r.jsx)("i",{children:"conditions"})})," of ",(0,r.jsx)(s,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(n,{term:"error",children:(0,r.jsx)("b",{children:"error"})}),". For example, they might signal a warning, and restart compilation from some ",(0,r.jsx)(s,{term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," point in order to let the compilation proceed without manual intervention."]}),"\n",(0,r.jsxs)(i.p,{children:["Both ",(0,r.jsx)(n,{term:"compile",children:(0,r.jsx)("b",{children:"compile"})})," and ",(0,r.jsx)(n,{term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})})," return three values, the second two indicating whether the source code being compiled contained errors and whether style warnings were issued."]}),"\n",(0,r.jsxs)(i.p,{children:["Some warnings might be deferred until the end of compilation. See ",(0,r.jsx)(n,{term:"with-compilation-unit",children:(0,r.jsx)("b",{children:"with-compilation-unit"})}),"."]})]})}function oe(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(ce,{...e})}):ce(e)}function de(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const ae={title:"3.2 Compilation"},he="3.2 Compilation",me={id:"chap-3/d-c-compilation",title:"3.2 Compilation",description:"3.2.1 Compiler Terminology",source:"@site/docs/chap-3/d-c-compilation.md",sourceDirName:"chap-3",slug:"/chap-3/d-c-compilation",permalink:"/cl-language-reference/chap-3/d-c-compilation",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-c-compilation.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"3.2 Compilation"},sidebar:"tutorialSidebar",previous:{title:"3.1 Evaluation",permalink:"/cl-language-reference/chap-3/d-b-evaluation"},next:{title:"3.3 Declarations",permalink:"/cl-language-reference/chap-3/d-d-declarations"}},je={},xe=[{value:"3.2.1 Compiler Terminology",id:"321-compiler-terminology",level:2},{value:"3.2.2 Compilation Semantics",id:"322-compilation-semantics",level:2},{value:"3.2.2.1 Compiler Macros",id:"3221-compiler-macros",level:3},{value:"3.2.2.1.1 Purpose of Compiler Macros",id:"32211-purpose-of-compiler-macros",level:4},{value:"3.2.2.1.2 Naming of Compiler Macros",id:"32212-naming-of-compiler-macros",level:4},{value:"3.2.2.1.3 When Compiler Macros Are Used",id:"32213-when-compiler-macros-are-used",level:4},{value:"3.2.2.1.3.1 Notes about the Implementation of Compiler Macros",id:"322131-notes-about-the-implementation-of-compiler-macros",level:5},{value:"3.2.2.2 Minimal Compilation",id:"3222-minimal-compilation",level:3},{value:"3.2.2.3 Semantic Constraints",id:"3223-semantic-constraints",level:3},{value:"3.2.3 File Compilation",id:"323-file-compilation",level:2},{value:"3.2.3.1 Processing of Top Level Forms",id:"3231-processing-of-top-level-forms",level:3},{value:"3.2.3.1.1 Processing of Defining Macros",id:"32311-processing-of-defining-macros",level:4},{value:"3.2.3.1.2 Constraints on Macros and Compiler Macros",id:"32312-constraints-on-macros-and-compiler-macros",level:4},{value:"3.2.4 Literal Objects in Compiled Files",id:"324-literal-objects-in-compiled-files",level:2},{value:"3.2.4.1 Externalizable Objects",id:"3241-externalizable-objects",level:3},{value:"3.2.4.2 Similarity of Literal Objects",id:"3242-similarity-of-literal-objects",level:3},{value:"3.2.4.2.1 Similarity of Aggregate Objects",id:"32421-similarity-of-aggregate-objects",level:4},{value:"3.2.4.2.2 Definition of Similarity",id:"32422-definition-of-similarity",level:4},{value:"3.2.4.3 Extensions to Similarity Rules",id:"3243-extensions-to-similarity-rules",level:3},{value:"3.2.4.4 Additional Constraints on Externalizable Objects",id:"3244-additional-constraints-on-externalizable-objects",level:3},{value:"3.2.5 Exceptional Situations in the Compiler",id:"325-exceptional-situations-in-the-compiler",level:2}];function pe(e){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h1,{id:"32-compilation",children:"3.2 Compilation"}),"\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(i.h2,{id:"321-compiler-terminology",children:"3.2.1 Compiler Terminology"}),"\n","\n",(0,r.jsx)(o,{}),"\n",(0,r.jsx)(i.h2,{id:"322-compilation-semantics",children:"3.2.2 Compilation Semantics"}),"\n","\n",(0,r.jsx)(h,{}),"\n",(0,r.jsx)(i.h3,{id:"3221-compiler-macros",children:"3.2.2.1 Compiler Macros"}),"\n","\n",(0,r.jsx)(j,{}),"\n",(0,r.jsx)(i.h4,{id:"32211-purpose-of-compiler-macros",children:"3.2.2.1.1 Purpose of Compiler Macros"}),"\n","\n",(0,r.jsx)(f,{}),"\n",(0,r.jsx)(i.h4,{id:"32212-naming-of-compiler-macros",children:"3.2.2.1.2 Naming of Compiler Macros"}),"\n","\n",(0,r.jsx)(b,{}),"\n",(0,r.jsx)(i.h4,{id:"32213-when-compiler-macros-are-used",children:"3.2.2.1.3 When Compiler Macros Are Used"}),"\n","\n",(0,r.jsx)(w,{}),"\n",(0,r.jsx)(i.h5,{id:"322131-notes-about-the-implementation-of-compiler-macros",children:"3.2.2.1.3.1 Notes about the Implementation of Compiler Macros"}),"\n","\n",(0,r.jsx)(C,{}),"\n",(0,r.jsx)(i.h3,{id:"3222-minimal-compilation",children:"3.2.2.2 Minimal Compilation"}),"\n","\n",(0,r.jsx)(F,{}),"\n",(0,r.jsx)(i.h3,{id:"3223-semantic-constraints",children:"3.2.2.3 Semantic Constraints"}),"\n","\n",(0,r.jsx)(D,{}),"\n",(0,r.jsx)(i.h2,{id:"323-file-compilation",children:"3.2.3 File Compilation"}),"\n","\n",(0,r.jsx)(I,{}),"\n",(0,r.jsx)(i.h3,{id:"3231-processing-of-top-level-forms",children:"3.2.3.1 Processing of Top Level Forms"}),"\n","\n",(0,r.jsx)(M,{}),"\n",(0,r.jsx)(i.h4,{id:"32311-processing-of-defining-macros",children:"3.2.3.1.1 Processing of Defining Macros"}),"\n","\n",(0,r.jsx)(W,{}),"\n",(0,r.jsx)(i.h4,{id:"32312-constraints-on-macros-and-compiler-macros",children:"3.2.3.1.2 Constraints on Macros and Compiler Macros"}),"\n","\n",(0,r.jsx)(H,{}),"\n",(0,r.jsx)(i.h2,{id:"324-literal-objects-in-compiled-files",children:"3.2.4 Literal Objects in Compiled Files"}),"\n","\n",(0,r.jsx)(_,{}),"\n",(0,r.jsx)(i.h3,{id:"3241-externalizable-objects",children:"3.2.4.1 Externalizable Objects"}),"\n","\n",(0,r.jsx)(V,{}),"\n",(0,r.jsx)(i.h3,{id:"3242-similarity-of-literal-objects",children:"3.2.4.2 Similarity of Literal Objects"}),"\n","\n",(0,r.jsx)(J,{}),"\n",(0,r.jsx)(i.h4,{id:"32421-similarity-of-aggregate-objects",children:"3.2.4.2.1 Similarity of Aggregate Objects"}),"\n","\n",(0,r.jsx)(X,{}),"\n",(0,r.jsx)(i.h4,{id:"32422-definition-of-similarity",children:"3.2.4.2.2 Definition of Similarity"}),"\n","\n",(0,r.jsx)(ee,{}),"\n",(0,r.jsx)(i.h3,{id:"3243-extensions-to-similarity-rules",children:"3.2.4.3 Extensions to Similarity Rules"}),"\n","\n",(0,r.jsx)(re,{}),"\n",(0,r.jsx)(i.h3,{id:"3244-additional-constraints-on-externalizable-objects",children:"3.2.4.4 Additional Constraints on Externalizable Objects"}),"\n","\n",(0,r.jsx)(se,{}),"\n",(0,r.jsx)(i.h2,{id:"325-exceptional-situations-in-the-compiler",children:"3.2.5 Exceptional Situations in the Compiler"}),"\n","\n","\n",(0,r.jsx)(oe,{})]})}function fe(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(pe,{...e})}):pe(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>c,a:()=>l});var r=n(67294);const t={},s=r.createContext(t);function l(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);