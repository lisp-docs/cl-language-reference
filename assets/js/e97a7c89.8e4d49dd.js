"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[6466],{4867:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>pn,contentTitle:()=>dn,default:()=>un,frontMatter:()=>an,metadata:()=>xn,toc:()=>mn});var r=s(5893),i=s(1151);function t(e){return(0,r.jsx)(r.Fragment,{})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t()}function o(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"macro"})," performs iteration."]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}function h(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"forms"})," are partitioned into two categories: simple ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"forms"})," and extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"forms"}),"."]})}function a(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}function d(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A simple ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is one that has a body containing only ",(0,r.jsx)(n.em,{children:"compound forms"}),". Each ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"evaluated"})," in turn from left to right. When the last ",(0,r.jsx)(n.em,{children:"form"})," has been ",(0,r.jsx)(n.em,{children:"evaluated"}),", then the first ",(0,r.jsx)(n.em,{children:"form"})," is evaluated again, and so on, in a never-ending cycle. A simple ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," establishes an ",(0,r.jsx)(n.em,{children:"implicit block"})," named"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"nil"}),". The execution of a simple ",(0,r.jsx)(n.strong,{children:"loop"})," can be terminated by explicitly transfering control to the ",(0,r.jsx)(n.em,{children:"implicit block"})," (using ",(0,r.jsx)(n.strong,{children:"return"})," or ",(0,r.jsx)(n.strong,{children:"return-from"}),") or to some ",(0,r.jsx)(n.em,{children:"exit point"})," outside of the ",(0,r.jsx)(n.em,{children:"block"})," (",(0,r.jsx)(n.em,{children:"e.g."}),", using ",(0,r.jsx)(n.strong,{children:"throw"}),", ",(0,r.jsx)(n.strong,{children:"go"}),", or ",(0,r.jsx)(n.strong,{children:"return-from"}),")."]})]})}function x(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function p(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["An extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is one that has a body containing ",(0,r.jsx)(n.em,{children:"atomic expressions"}),". When the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"macro"})," processes such a ",(0,r.jsx)(n.em,{children:"form"}),", it invokes a facility that is commonly called \u201cthe Loop Facility.\u201d"]}),"\n",(0,r.jsxs)(n.p,{children:["The Loop Facility provides standardized access to mechanisms commonly used in iterations through Loop schemas, which are introduced by ",(0,r.jsx)(n.em,{children:"loop keywords"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The body of an extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is divided into ",(0,r.jsx)(n.strong,{children:"loop"})," clauses, each which is in turn made up of ",(0,r.jsx)(n.em,{children:"loop keywords"})," and ",(0,r.jsx)(n.em,{children:"forms"}),"."]})]})}function m(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}function j(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Loop keywords"})," are not true ",(0,r.jsx)(n.em,{children:"keywords"}),"<sub>1</sub>; they are special ",(0,r.jsx)(n.em,{children:"symbols"}),", recognized by ",(0,r.jsx)(n.em,{children:"name"})," rather than ",(0,r.jsx)(n.em,{children:"object"})," identity, that are meaningful only to the ",(0,r.jsx)(n.strong,{children:"loop"})," facility. A ",(0,r.jsx)(n.em,{children:"loop keyword"})," is a ",(0,r.jsx)(n.em,{children:"symbol"})," but is recognized by its ",(0,r.jsx)(n.em,{children:"name"})," (not its identity), regardless of the ",(0,r.jsx)(n.em,{children:"packages"})," in which it is ",(0,r.jsx)(n.em,{children:"accessible"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In general, ",(0,r.jsx)(n.em,{children:"loop keywords"})," are not ",(0,r.jsx)(n.em,{children:"external symbols"})," of the COMMON-LISP ",(0,r.jsx)(n.em,{children:"package"}),", except in the coincidental situation that a ",(0,r.jsx)(n.em,{children:"symbol"})," with the same name as a ",(0,r.jsx)(n.em,{children:"loop keyword"})," was needed for some other purpose in Common Lisp. For example, there is a ",(0,r.jsx)(n.em,{children:"symbol"})," in the COMMON-LISP ",(0,r.jsx)(n.em,{children:"package"})," whose ",(0,r.jsx)(n.em,{children:"name"}),' is "UNLESS" but not one whose ',(0,r.jsx)(n.em,{children:"name"}),' is "UNTIL".']}),"\n",(0,r.jsxs)(n.p,{children:["If no ",(0,r.jsx)(n.em,{children:"loop keywords"})," are supplied in a ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),", the Loop Facility executes the loop body repeatedly; see Section 6.1.1.1.1 (Simple Loop)."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u20131"})]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}function f(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The syntactic parts of an extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," are called clauses; the rules for parsing are determined by that clause\u2019s keyword. The following example shows a ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," with six clauses:"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to (compute-top-value) ; first clause"}),"\n",(0,r.jsx)(n.p,{children:"while (not (unacceptable i)) ; second clause"}),"\n",(0,r.jsx)(n.p,{children:"collect (square i) ; third clause"}),"\n",(0,r.jsx)(n.p,{children:'do (format t "Working on ~D now" i) ; fourth clause'}),"\n",(0,r.jsx)(n.p,{children:"when (evenp i) ; fifth clause"}),"\n",(0,r.jsx)(n.p,{children:'do (format t "~D is a non-odd number" i)'}),"\n",(0,r.jsx)(n.p,{children:'finally (format t "About to exit!")) ; sixth clause'}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.em,{children:"loop keyword"})," introduces either a compound loop clause or a simple loop clause that can consist of a ",(0,r.jsx)(n.em,{children:"loop keyword"})," followed by a single ",(0,r.jsx)(n.em,{children:"form"}),". The number of ",(0,r.jsx)(n.em,{children:"forms"})," in a clause is determined by the ",(0,r.jsx)(n.em,{children:"loop keyword"})," that begins the clause and by the auxiliary keywords in the clause. The keywords do, doing, initially, and finally are the only loop keywords that can take any number of ",(0,r.jsx)(n.em,{children:"forms"})," and group them as an ",(0,r.jsx)(n.em,{children:"implicit progn"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Loop clauses can contain auxiliary keywords, which are sometimes called prepositions. For example, the first clause in the code above includes the prepositions from and to, which mark the value from which stepping begins and the value at which stepping ends."}),"\n",(0,r.jsxs)(n.p,{children:["For detailed information about ",(0,r.jsx)(n.strong,{children:"loop"})," syntax, see the ",(0,r.jsx)(n.em,{children:"macro"})," ",(0,r.jsx)(n.strong,{children:"loop"}),"."]})]})}function g(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}function b(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"macro form"})," expands into a ",(0,r.jsx)(n.em,{children:"form"})," containing one or more binding forms (that ",(0,r.jsx)(n.em,{children:"establish bindings"})," of loop variables) and a ",(0,r.jsx)(n.strong,{children:"block"})," and a ",(0,r.jsx)(n.strong,{children:"tagbody"})," (that express a looping control structure). The variables established in ",(0,r.jsx)(n.strong,{children:"loop"})," are bound as if by ",(0,r.jsx)(n.strong,{children:"let"})," or ",(0,r.jsx)(n.strong,{children:"lambda"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Implementations can interleave the setting of initial values with the ",(0,r.jsx)(n.em,{children:"bindings"}),". However, the assignment of the initial values is always calculated in the order specified by the user. A variable is thus sometimes bound to a meaningless value of the correct ",(0,r.jsx)(n.em,{children:"type"}),", and then later in the prologue it is set to the true initial value by using ",(0,r.jsx)(n.strong,{children:"setq"}),". One implication of this interleaving is that it is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether the ",(0,r.jsx)(n.em,{children:"lexical environment"})," in which the initial value ",(0,r.jsx)(n.em,{children:"forms"})," (variously called the ",(0,r.jsx)(n.em,{children:"form1"}),", ",(0,r.jsx)(n.em,{children:"form2"}),", ",(0,r.jsx)(n.em,{children:"form3"}),", ",(0,r.jsx)(n.em,{children:"step-fun"}),", ",(0,r.jsx)(n.em,{children:"vector"}),", ",(0,r.jsx)(n.em,{children:"hash-table"}),", and ",(0,r.jsx)(n.em,{children:"package"}),") in any ",(0,r.jsx)(n.em,{children:"for-as-subclause"}),", except ",(0,r.jsx)(n.em,{children:"for-as-equals-then"}),", are ",(0,r.jsx)(n.em,{children:"evaluated"})," includes only the loop variables preceding that ",(0,r.jsx)(n.em,{children:"form"})," or includes more or all of the loop variables; the ",(0,r.jsx)(n.em,{children:"form1"})," and ",(0,r.jsx)(n.em,{children:"form2"})," in a ",(0,r.jsx)(n.em,{children:"for-as-equals-then"})," form includes the ",(0,r.jsx)(n.em,{children:"lexical environment"})," of all the loop variables."]}),"\n",(0,r.jsxs)(n.p,{children:["After the ",(0,r.jsx)(n.em,{children:"form"})," is expanded, it consists of three basic parts in the ",(0,r.jsx)(n.strong,{children:"tagbody"}),": the loop prologue, the loop body, and the loop epilogue."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Loop prologue"})}),"\n",(0,r.jsxs)(n.p,{children:["The loop prologue contains ",(0,r.jsx)(n.em,{children:"forms"})," that are executed before iteration begins, such as any automatic variable initializations prescribed by the ",(0,r.jsx)(n.em,{children:"variable"})," clauses, along with any"]}),"\n",(0,r.jsx)(n.p,{children:"initially clauses in the order they appear in the source."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Loop body"})}),"\n",(0,r.jsxs)(n.p,{children:["The loop body contains those ",(0,r.jsx)(n.em,{children:"forms"})," that are executed during iteration, including application-specific calculations, termination tests, and variable ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub>."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Loop epilogue"})}),"\n",(0,r.jsxs)(n.p,{children:["The loop epilogue contains ",(0,r.jsx)(n.em,{children:"forms"})," that are executed after iteration terminates, such as finally clauses, if any, along with any implicit return value from an ",(0,r.jsx)(n.em,{children:"accumulation"})," clause or an ",(0,r.jsx)(n.em,{children:"termination-test"})," clause."]}),"\n",(0,r.jsxs)(n.p,{children:["Some clauses from the source ",(0,r.jsx)(n.em,{children:"form"})," contribute code only to the loop prologue; these clauses must come before other clauses that are in the main body of the ",(0,r.jsx)(n.strong,{children:"loop"})," form. Others contribute code only to the loop epilogue. All other clauses contribute to the final translated ",(0,r.jsx)(n.em,{children:"form"})," in the same order given in the original source ",(0,r.jsx)(n.em,{children:"form"})," of the ",(0,r.jsx)(n.strong,{children:"loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Expansion of the ",(0,r.jsx)(n.strong,{children:"loop"})," macro produces an ",(0,r.jsx)(n.em,{children:"implicit block"})," named ",(0,r.jsx)(n.strong,{children:"nil"})," unless named is supplied. Thus, ",(0,r.jsx)(n.strong,{children:"return-from"})," (and sometimes ",(0,r.jsx)(n.strong,{children:"return"}),") can be used to return values from ",(0,r.jsx)(n.strong,{children:"loop"})," or to exit ",(0,r.jsx)(n.strong,{children:"loop"}),"."]})]})}function v(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}function y(e){const n={p:"p",...(0,i.a)(),...e.components};return(0,r.jsx)(n.p,{children:"Loop clauses fall into one of the following categories:"})}function w(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}function T(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The for and as constructs provide iteration control clauses that establish a variable to be initialized. for and as clauses can be combined with the loop keyword and to get ",(0,r.jsx)(n.em,{children:"parallel"})," initialization and ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub>. Otherwise, the initialization and ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> are ",(0,r.jsx)(n.em,{children:"sequential"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The with construct is similar to a single ",(0,r.jsx)(n.strong,{children:"let"})," clause. with clauses can be combined using the ",(0,r.jsx)(n.em,{children:"loop keyword"})," and to get ",(0,r.jsx)(n.em,{children:"parallel"})," initialization."]}),"\n",(0,r.jsx)(n.p,{children:"For more information, see Section 6.1.2 (Variable Initialization and Stepping Clauses)."})]})}function k(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(T,{...e})}):T(e)}function I(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The collect (or collecting) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause and adds the value of that ",(0,r.jsx)(n.em,{children:"form"})," to the end of a ",(0,r.jsx)(n.em,{children:"list"})," of values. By default, the ",(0,r.jsx)(n.em,{children:"list"})," of values is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["The append (or appending) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause and appends the value of that ",(0,r.jsx)(n.em,{children:"form"})," to the end of a ",(0,r.jsx)(n.em,{children:"list"})," of values. By default, the ",(0,r.jsx)(n.em,{children:"list"})," of values is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["The nconc (or nconcing) construct is similar to the append construct, but its ",(0,r.jsx)(n.em,{children:"list"})," values are concatenated as if by the function nconc. By default, the ",(0,r.jsx)(n.em,{children:"list"})," of values is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u20133"})]}),"\n",(0,r.jsxs)(n.p,{children:["The sum (or summing) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause that must evaluate to a ",(0,r.jsx)(n.em,{children:"number"})," and accumulates the sum of all these ",(0,r.jsx)(n.em,{children:"numbers"}),". By default, the cumulative sum is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["The count (or counting) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause and counts the number of times that the ",(0,r.jsx)(n.em,{children:"form"})," evaluates to ",(0,r.jsx)(n.em,{children:"true"}),". By default, the count is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["The minimize (or minimizing) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause and determines the minimum value obtained by evaluating that ",(0,r.jsx)(n.em,{children:"form"}),". By default, the minimum value is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsxs)(n.p,{children:["The maximize (or maximizing) construct takes one ",(0,r.jsx)(n.em,{children:"form"})," in its clause and determines the maximum value obtained by evaluating that ",(0,r.jsx)(n.em,{children:"form"}),". By default, the maximum value is returned when the ",(0,r.jsx)(n.strong,{children:"loop"})," finishes."]}),"\n",(0,r.jsx)(n.p,{children:"For more information, see Section 6.1.3 (Value Accumulation Clauses)."})]})}function E(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(I,{...e})}):I(e)}function A(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The for and as constructs provide a termination test that is determined by the iteration control clause."}),"\n",(0,r.jsx)(n.p,{children:"The repeat construct causes termination after a specified number of iterations. (It uses an internal variable to keep track of the number of iterations.)"}),"\n",(0,r.jsxs)(n.p,{children:["The while construct takes one ",(0,r.jsx)(n.em,{children:"form"}),", a ",(0,r.jsx)(n.em,{children:"test"}),", and terminates the iteration if the ",(0,r.jsx)(n.em,{children:"test"})," evaluates to ",(0,r.jsx)(n.em,{children:"false"}),". A while clause is equivalent to the expression (if (not ",(0,r.jsx)(n.em,{children:"test"}),") (loop-finish))."]}),"\n",(0,r.jsxs)(n.p,{children:["The until construct is the inverse of while; it terminates the iteration if the ",(0,r.jsx)(n.em,{children:"test"})," evaluates to any ",(0,r.jsx)(n.em,{children:"non-nil"})," value. An until clause is equivalent to the expression (if ",(0,r.jsx)(n.em,{children:"test"})," (loop-finish))."]}),"\n",(0,r.jsxs)(n.p,{children:["The always construct takes one ",(0,r.jsx)(n.em,{children:"form"})," and terminates the ",(0,r.jsx)(n.strong,{children:"loop"})," if the ",(0,r.jsx)(n.em,{children:"form"})," ever evaluates to ",(0,r.jsx)(n.em,{children:"false"}),"; in this case, the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," returns ",(0,r.jsx)(n.strong,{children:"nil"}),". Otherwise, it provides a default return value of ",(0,r.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The never construct takes one ",(0,r.jsx)(n.em,{children:"form"})," and terminates the ",(0,r.jsx)(n.strong,{children:"loop"})," if the ",(0,r.jsx)(n.em,{children:"form"})," ever evaluates to ",(0,r.jsx)(n.em,{children:"true"}),"; in this case, the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," returns ",(0,r.jsx)(n.strong,{children:"nil"}),". Otherwise, it provides a default return value of ",(0,r.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The thereis construct takes one ",(0,r.jsx)(n.em,{children:"form"})," and terminates the ",(0,r.jsx)(n.strong,{children:"loop"})," if the ",(0,r.jsx)(n.em,{children:"form"})," ever evaluates to a ",(0,r.jsx)(n.em,{children:"non-nil object"}),"; in this case, the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," returns that ",(0,r.jsx)(n.em,{children:"object"}),". Otherwise, it provides a default return value of ",(0,r.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If multiple termination test clauses are specified, the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," terminates if any are satisfied. For more information, see Section 6.1.4 (Termination Test Clauses)."]})]})}function L(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(A,{...e})}):A(e)}function S(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The do (or doing) construct evaluates all ",(0,r.jsx)(n.em,{children:"forms"})," in its clause."]}),"\n",(0,r.jsxs)(n.p,{children:["The return construct takes one ",(0,r.jsx)(n.em,{children:"form"}),". Any ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"form"})," are immediately returned by the ",(0,r.jsx)(n.strong,{children:"loop"})," form. It is equivalent to the clause do (return-from ",(0,r.jsx)(n.em,{children:"block-name value"}),"), where ",(0,r.jsx)(n.em,{children:"block-name"})," is the name specified in a named clause, or ",(0,r.jsx)(n.strong,{children:"nil"})," if there is no named clause."]}),"\n",(0,r.jsx)(n.p,{children:"For more information, see Section 6.1.5 (Unconditional Execution Clauses)."})]})}function F(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(S,{...e})}):S(e)}function N(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The if and when constructs take one ",(0,r.jsx)(n.em,{children:"form"})," as a test and a clause that is executed when the test ",(0,r.jsx)(n.em,{children:"yields true"}),". The clause can be a value accumulation, unconditional, or another conditional clause; it can also be any combination of such clauses connected by the ",(0,r.jsx)(n.strong,{children:"loop"})," and keyword."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," unless construct is similar to the ",(0,r.jsx)(n.strong,{children:"loop"})," when construct except that it complements the test result."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," else construct provides an optional component of if, when, and unless clauses that is executed when an if or when test ",(0,r.jsx)(n.em,{children:"yields false"})," or when an unless test ",(0,r.jsx)(n.em,{children:"yields true"}),". The component is one of the clauses described under if."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," end construct provides an optional component to mark the end of a conditional clause. For more information, see Section 6.1.6 (Conditional Execution Clauses)."]})]})}function z(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(N,{...e})}):N(e)}function C(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," named construct gives a name for the ",(0,r.jsx)(n.em,{children:"block"})," of the loop."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," initially construct causes its ",(0,r.jsx)(n.em,{children:"forms"})," to be evaluated in the loop prologue, which precedes all ",(0,r.jsx)(n.strong,{children:"loop"})," code except for initial settings supplied by the constructs with, for, or as."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop"})," finally construct causes its ",(0,r.jsx)(n.em,{children:"forms"})," to be evaluated in the loop epilogue after normal iteration terminates."]}),"\n",(0,r.jsx)(n.p,{children:"For more information, see Section 6.1.7 (Miscellaneous Clauses)."})]})}function q(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(C,{...e})}):C(e)}function O(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["With the exceptions listed below, clauses are executed in the loop body in the order in which they appear in the source. Execution is repeated until a clause terminates the ",(0,r.jsx)(n.strong,{children:"loop"})," or until a ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"go"}),", or ",(0,r.jsx)(n.strong,{children:"throw"})," form is encountered which transfers control to a point outside of the loop. The following actions are exceptions to the linear order of execution:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," All variables are initialized first, regardless of where the establishing clauses appear in the source. The order of initialization follows the order of these clauses."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u20135"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The code for any initially clauses is collected into one ",(0,r.jsx)(n.strong,{children:"progn"})," in the order in which the clauses appear in the source. The collected code is executed once in the loop prologue after any implicit variable initializations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The code for any finally clauses is collected into one ",(0,r.jsx)(n.strong,{children:"progn"})," in the order in which the clauses appear in the source. The collected code is executed once in the loop epilogue before any implicit values from the accumulation clauses are returned. Explicit returns anywhere in the source, however, will exit the ",(0,r.jsx)(n.strong,{children:"loop"})," without executing the epilogue code."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A with clause introduces a variable ",(0,r.jsx)(n.em,{children:"binding"})," and an optional initial value. The initial values are calculated in the order in which the with clauses occur."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," Iteration control clauses implicitly perform the following actions:"]}),"\n",(0,r.jsx)(n.p,{children:"\u2013 initialize variables;"}),"\n",(0,r.jsxs)(n.p,{children:["\u2013 ",(0,r.jsx)(n.em,{children:"step"})," variables, generally between each execution of the loop body;"]}),"\n",(0,r.jsx)(n.p,{children:"\u2013 perform termination tests, generally just before the execution of the loop body."})]})}function D(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(O,{...e})}):O(e)}function P(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"d-type-spec"})," argument is used for destructuring. If the ",(0,r.jsx)(n.em,{children:"d-type-spec"})," argument consists solely of the ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"fixnum"}),", ",(0,r.jsx)(n.strong,{children:"float"}),", ",(0,r.jsx)(n.strong,{children:"t"}),", or ",(0,r.jsx)(n.strong,{children:"nil"}),", the of-type keyword is optional. The of-type construct is optional in these cases to provide backwards compatibility; thus, the following two expressions are the same:"]}),"\n",(0,r.jsx)(n.p,{children:";;; This expression uses the old syntax for type specifiers."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i fixnum upfrom 3 ...)"}),"\n",(0,r.jsx)(n.p,{children:";;; This expression uses the new syntax for type specifiers."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i of-type fixnum upfrom 3 ...)"}),"\n",(0,r.jsx)(n.p,{children:";; Declare X and Y to be of type VECTOR and FIXNUM respectively."}),"\n",(0,r.jsx)(n.p,{children:"(loop for (x y) of-type (vector fixnum)"}),"\n",(0,r.jsx)(n.p,{children:"in l do ...)"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"type specifier"})," for a destructuring pattern is a ",(0,r.jsx)(n.em,{children:"tree"})," of ",(0,r.jsx)(n.em,{children:"type specifiers"})," with the same shape as the ",(0,r.jsx)(n.em,{children:"tree"})," of ",(0,r.jsx)(n.em,{children:"variable names"}),", with the following exceptions:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," When aligning the ",(0,r.jsx)(n.em,{children:"trees"}),", an ",(0,r.jsx)(n.em,{children:"atom"})," in the ",(0,r.jsx)(n.em,{children:"tree"})," of ",(0,r.jsx)(n.em,{children:"type specifiers"})," that matches a ",(0,r.jsx)(n.em,{children:"cons"})," in the variable tree declares the same ",(0,r.jsx)(n.em,{children:"type"})," for each variable in the subtree rooted at the ",(0,r.jsx)(n.em,{children:"cons"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," A ",(0,r.jsx)(n.em,{children:"cons"})," in the ",(0,r.jsx)(n.em,{children:"tree"})," of ",(0,r.jsx)(n.em,{children:"type specifiers"})," that matches an ",(0,r.jsx)(n.em,{children:"atom"})," in the ",(0,r.jsx)(n.em,{children:"tree"})," of ",(0,r.jsx)(n.em,{children:"variable names"})," is a ",(0,r.jsx)(n.em,{children:"compound type specifer"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:["Destructuring allows ",(0,r.jsx)(n.em,{children:"binding"})," of a set of variables to a corresponding set of values anywhere that a value can normally be bound to a single variable. During ",(0,r.jsx)(n.strong,{children:"loop"})," expansion, each variable in the"]}),"\n",(0,r.jsxs)(n.p,{children:["variable list is matched with the values in the values list. If there are more variables in the variable list than there are values in the values list, the remaining variables are given a value of ",(0,r.jsx)(n.strong,{children:"nil"}),". If there are more values than variables listed, the extra values are discarded."]}),"\n",(0,r.jsxs)(n.p,{children:["To assign values from a list to the variables a, b, and c, the for clause could be used to bind the variable numlist to the ",(0,r.jsx)(n.em,{children:"car"})," of the supplied ",(0,r.jsx)(n.em,{children:"form"}),", and then another for clause could be used to bind the variables a, b, and c ",(0,r.jsx)(n.em,{children:"sequentially"}),"."]}),"\n",(0,r.jsx)(n.p,{children:";; Collect values by using FOR constructs."}),"\n",(0,r.jsx)(n.p,{children:"(loop for numlist in \u2019((1 2 4.0) (5 6 8.3) (8 9 10.4))"}),"\n",(0,r.jsx)(n.p,{children:"for a of-type integer = (first numlist)"}),"\n",(0,r.jsx)(n.p,{children:"and b of-type integer = (second numlist)"}),"\n",(0,r.jsx)(n.p,{children:"and c of-type float = (third numlist)"}),"\n",(0,r.jsx)(n.p,{children:"collect (list c b a))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((4.0 2 1) (8.3 6 5) (10.4 9 8))"]}),"\n",(0,r.jsxs)(n.p,{children:["Destructuring makes this process easier by allowing the variables to be bound in each loop iteration. ",(0,r.jsx)(n.em,{children:"Types"})," can be declared by using a list of ",(0,r.jsx)(n.em,{children:"type-spec"})," arguments. If all the ",(0,r.jsx)(n.em,{children:"types"})," are the same, a shorthand destructuring syntax can be used, as the second example illustrates."]}),"\n",(0,r.jsx)(n.p,{children:";; Destructuring simplifies the process."}),"\n",(0,r.jsx)(n.p,{children:"(loop for (a b c) of-type (integer integer float) in"}),"\n",(0,r.jsx)(n.p,{children:"\u2019((1 2 4.0) (5 6 8.3) (8 9 10.4))"}),"\n",(0,r.jsx)(n.p,{children:"collect (list c b a))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((4.0 2 1) (8.3 6 5) (10.4 9 8))"]}),"\n",(0,r.jsx)(n.p,{children:";; If all the types are the same, this way is even simpler."}),"\n",(0,r.jsx)(n.p,{children:"(loop for (a b c) of-type float in"}),"\n",(0,r.jsx)(n.p,{children:"\u2019((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))"}),"\n",(0,r.jsx)(n.p,{children:"collect (list c b a))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))"]}),"\n",(0,r.jsxs)(n.p,{children:["If destructuring is used to declare or initialize a number of groups of variables into ",(0,r.jsx)(n.em,{children:"types"}),", the ",(0,r.jsx)(n.em,{children:"loop keyword"})," and can be used to simplify the process further. ;; Initialize and declare variables in parallel by using the AND construct."]}),"\n",(0,r.jsx)(n.p,{children:"(loop with (a b) of-type float = \u2019(1.0 2.0)"}),"\n",(0,r.jsx)(n.p,{children:"and (c d) of-type integer = \u2019(3 4)"}),"\n",(0,r.jsx)(n.p,{children:"and (e f)"}),"\n",(0,r.jsx)(n.p,{children:"return (list a b c d e f))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1.0 2.0 3 4 NIL NIL)"]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.strong,{children:"nil"})," is used in a destructuring list, no variable is provided for its place."]}),"\n",(0,r.jsx)(n.p,{children:"(loop for (a nil b) = \u2019(1 2 3)"}),"\n",(0,r.jsx)(n.p,{children:"do (return (list a b)))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3)"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u20137"})]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.em,{children:"dotted lists"})," can specify destructuring."]}),"\n",(0,r.jsx)(n.p,{children:"(loop for (x . y) = \u2019(1 . 2)"}),"\n",(0,r.jsx)(n.p,{children:"do (return y))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 2"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in"}),"\n",(0,r.jsx)(n.p,{children:"\u2019(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))"}),"\n",(0,r.jsx)(n.p,{children:"collect (list a b c d))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((1.2 2.4 3 4) (3.4 4.6 5 6))"]}),"\n",(0,r.jsxs)(n.p,{children:["An error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"program-error"})," is signaled (at macro expansion time) if the same variable is bound twice in any variable-binding clause of a single ",(0,r.jsx)(n.strong,{children:"loop"})," expression. Such variables include local variables, iteration control variables, and variables found by destructuring."]})]})}function M(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(P,{...e})}):P(e)}function U(e){const n={p:"p",...(0,i.a)(),...e.components};return(0,r.jsx)(n.p,{children:"See Section 3.6 (Traversal Rules and Side Effects)."})}function W(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(U,{...e})}):U(e)}function R(e){return(0,r.jsx)(r.Fragment,{})}function B(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(R,{...e})}):R()}function H(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Iteration control clauses allow direction of ",(0,r.jsx)(n.strong,{children:"loop"})," iteration. The ",(0,r.jsx)(n.em,{children:"loop keywords"})," for and as designate iteration control clauses. Iteration control clauses differ with respect to the specification of termination tests and to the initialization and ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> of loop variables. Iteration clauses by themselves do not cause the Loop Facility to return values, but they can be used in conjunction with value-accumulation clauses to return values."]}),"\n",(0,r.jsxs)(n.p,{children:["All variables are initialized in the loop prologue. A ",(0,r.jsx)(n.em,{children:"variable binding"})," has ",(0,r.jsx)(n.em,{children:"lexical scope"})," unless it is proclaimed ",(0,r.jsx)(n.strong,{children:"special"}),"; thus, by default, the variable can be ",(0,r.jsx)(n.em,{children:"accessed"})," only by ",(0,r.jsx)(n.em,{children:"forms"})," that lie textually within the ",(0,r.jsx)(n.strong,{children:"loop"}),". Stepping assignments are made in the loop body before any other ",(0,r.jsx)(n.em,{children:"forms"})," are evaluated in the body."]}),"\n",(0,r.jsxs)(n.p,{children:["The variable argument in iteration control clauses can be a destructuring list. A destructuring list is a ",(0,r.jsx)(n.em,{children:"tree"})," whose ",(0,r.jsx)(n.em,{children:"non-nil atoms"})," are ",(0,r.jsx)(n.em,{children:"variable names"}),". See Section 6.1.1.7 (Destructuring)."]}),"\n",(0,r.jsxs)(n.p,{children:["The iteration control clauses for, as, and repeat must precede any other loop clauses, except initially, with, and named, since they establish variable ",(0,r.jsx)(n.em,{children:"bindings"}),". When iteration control clauses are used in a ",(0,r.jsx)(n.strong,{children:"loop"}),", the corresponding termination tests in the loop body are evaluated before any other loop body code is executed."]}),"\n",(0,r.jsxs)(n.p,{children:["If multiple iteration clauses are used to control iteration, variable initialization and ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> occur ",(0,r.jsx)(n.em,{children:"sequentially"})," by default. The and construct can be used to connect two or more iteration clauses when ",(0,r.jsx)(n.em,{children:"sequential binding"})," and ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> are not necessary. The iteration behavior of clauses joined by and is analogous to the behavior of the macro ",(0,r.jsx)(n.strong,{children:"do"})," with respect to ",(0,r.jsx)(n.strong,{children:"do*"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The for and as clauses iterate by using one or more local loop variables that are initialized to some value and that can be modified or ",(0,r.jsx)(n.em,{children:"stepped"})," <sub>1</sub> after each iteration. For these clauses, iteration terminates when a local variable reaches some supplied value or when some other loop clause terminates iteration. At each iteration, variables can be ",(0,r.jsx)(n.em,{children:"stepped"})," <sub>1</sub> by an increment or a decrement or can be assigned a new value by the evaluation of a ",(0,r.jsx)(n.em,{children:"form"}),"). Destructuring can be used to assign values to variables during iteration."]}),"\n",(0,r.jsxs)(n.p,{children:["The for and as keywords are synonyms; they can be used interchangeably. There are seven syntactic formats for these constructs. In each syntactic format, the ",(0,r.jsx)(n.em,{children:"type"})," of ",(0,r.jsx)(n.em,{children:"var"})," can be supplied by the optional ",(0,r.jsx)(n.em,{children:"type-spec"})," argument. If ",(0,r.jsx)(n.em,{children:"var"})," is a destructuring list, the ",(0,r.jsx)(n.em,{children:"type"})," supplied by the ",(0,r.jsx)(n.em,{children:"type-spec"})," argument must appropriately match the elements of the list. By convention, for introduces new iterations and as introduces iterations that depend on a previous iteration specification."]})]})}function V(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(H,{...e})}):H(e)}function K(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-arithmetic"})," subclause, the for or as construct iterates from the value supplied by ",(0,r.jsx)(n.em,{children:"form1"})," to the value supplied by ",(0,r.jsx)(n.em,{children:"form2"})," in increments or decrements denoted by ",(0,r.jsx)(n.em,{children:"form3"}),". Each expression is evaluated only once and must evaluate to a ",(0,r.jsx)(n.em,{children:"number"})," . The variable ",(0,r.jsx)(n.em,{children:"var"})," is bound to the value of ",(0,r.jsx)(n.em,{children:"form1"})," in the first iteration and is ",(0,r.jsx)(n.em,{children:"stepped"})," <sub>1</sub> by the value of ",(0,r.jsx)(n.em,{children:"form3"})," in each succeeding iteration, or by 1 if ",(0,r.jsx)(n.em,{children:"form3"})," is not provided. The following ",(0,r.jsx)(n.em,{children:"loop keywords"})," serve as valid prepositions within this syntax. At least one of the prepositions must be used; and at most one from each line may be used in a single subclause."]}),"\n",(0,r.jsx)(n.p,{children:"from | downfrom | upfrom"}),"\n",(0,r.jsx)(n.p,{children:"to | downto | upto | below | above"}),"\n",(0,r.jsx)(n.p,{children:"by"}),"\n",(0,r.jsx)(n.p,{children:"The prepositional phrases in each subclause may appear in any order. For example, either \u201cfrom x by y\u201d or \u201cby y from x\u201d is permitted. However, because left-to-right order of evaluation is preserved, the effects will be different in the case of side effects. Consider:"}),"\n",(0,r.jsx)(n.p,{children:"(let ((x 1)) (loop for i from x by (incf x) to 10 collect i))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3 5 7 9)"]}),"\n",(0,r.jsx)(n.p,{children:"(let ((x 1)) (loop for i by (incf x) from x to 10 collect i))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (2 4 6 8 10)"]}),"\n",(0,r.jsx)(n.p,{children:"The descriptions of the prepositions follow:"}),"\n",(0,r.jsx)(n.p,{children:"from"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," from specifies the value from which ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> begins, as supplied by ",(0,r.jsx)(n.em,{children:"form1"}),". ",(0,r.jsx)(n.em,{children:"Stepping"}),"<sub>1</sub> is incremental by default. If decremental ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> is desired, the preposition downto or above must be used with ",(0,r.jsx)(n.em,{children:"form2"}),". For incremental ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub>, the default from value is 0."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u20139"})]}),"\n",(0,r.jsx)(n.p,{children:"downfrom, upfrom"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," downfrom indicates that the variable ",(0,r.jsx)(n.em,{children:"var"})," is decreased in decrements supplied by ",(0,r.jsx)(n.em,{children:"form3"}),"; the ",(0,r.jsx)(n.em,{children:"loop keyword"})," upfrom indicates that ",(0,r.jsx)(n.em,{children:"var"})," is increased in increments supplied by ",(0,r.jsx)(n.em,{children:"form3"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"to"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," to marks the end value for ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> supplied in ",(0,r.jsx)(n.em,{children:"form2"}),". ",(0,r.jsx)(n.em,{children:"Stepping"}),"<sub>1</sub> is incremental by default. If decremental ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub> is desired, the preposition downfrom must be used with ",(0,r.jsx)(n.em,{children:"form1"}),", or else the preposition downto or above should be used instead of to with ",(0,r.jsx)(n.em,{children:"form2"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"downto, upto"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," downto specifies decremental ",(0,r.jsx)(n.em,{children:"stepping"}),"; the ",(0,r.jsx)(n.em,{children:"loop keyword"})," upto specifies incremental ",(0,r.jsx)(n.em,{children:"stepping"}),". In both cases, the amount of change on each step is specified by ",(0,r.jsx)(n.em,{children:"form3"}),", and the ",(0,r.jsx)(n.strong,{children:"loop"})," terminates when the variable ",(0,r.jsx)(n.em,{children:"var"})," passes the value of ",(0,r.jsx)(n.em,{children:"form2"}),". Since there is no default for ",(0,r.jsx)(n.em,{children:"form1"})," in decremental ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub>, a ",(0,r.jsx)(n.em,{children:"form1"})," value must be supplied (using from or downfrom) when downto is supplied."]}),"\n",(0,r.jsx)(n.p,{children:"below, above"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keywords"})," below and above are analogous to upto and downto respectively. These keywords stop iteration just before the value of the variable ",(0,r.jsx)(n.em,{children:"var"})," reaches the value supplied by ",(0,r.jsx)(n.em,{children:"form2"}),"; the end value of ",(0,r.jsx)(n.em,{children:"form2"})," is not included. Since there is no default for ",(0,r.jsx)(n.em,{children:"form1"})," in decremental ",(0,r.jsx)(n.em,{children:"stepping"}),"<sub>1</sub>, a ",(0,r.jsx)(n.em,{children:"form1"})," value must be supplied (using from or downfrom) when above is supplied."]}),"\n",(0,r.jsx)(n.p,{children:"by"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," by marks the increment or decrement supplied by ",(0,r.jsx)(n.em,{children:"form3"}),". The value of ",(0,r.jsx)(n.em,{children:"form3"})," can be any positive ",(0,r.jsx)(n.em,{children:"number"})," . The default value is 1."]}),"\n",(0,r.jsxs)(n.p,{children:["In an iteration control clause, the for or as construct causes termination when the supplied limit is reached. That is, iteration continues until the value ",(0,r.jsx)(n.em,{children:"var"})," is stepped to the exclusive or inclusive limit supplied by ",(0,r.jsx)(n.em,{children:"form2"}),". The range is exclusive if ",(0,r.jsx)(n.em,{children:"form3"})," increases or decreases ",(0,r.jsx)(n.em,{children:"var"})," to the value of ",(0,r.jsx)(n.em,{children:"form2"})," without reaching that value; the loop keywords below and above provide exclusive limits. An"]}),"\n",(0,r.jsxs)(n.p,{children:["inclusive limit allows ",(0,r.jsx)(n.em,{children:"var"})," to attain the value of ",(0,r.jsx)(n.em,{children:"form2"}),"; to, downto, and upto provide inclusive limits."]})]})}function X(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(K,{...e})}):K(e)}function G(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Print some numbers."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to 3"}),"\n",(0,r.jsx)(n.p,{children:"do (print i))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; Print every third number."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 10 downto 1 by 3"}),"\n",(0,r.jsx)(n.p,{children:"do (print i))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 10"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 7"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 4"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; Step incrementally from the default starting value."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i below 3"}),"\n",(0,r.jsx)(n.p,{children:"do (print i))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 0"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function Z(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(G,{...e})}):G(e)}function Y(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-in-list"})," subclause, the for or as construct iterates over the contents of a ",(0,r.jsx)(n.em,{children:"list"}),". It checks for the end of the ",(0,r.jsx)(n.em,{children:"list"})," as if by using ",(0,r.jsx)(n.strong,{children:"endp"}),". The variable ",(0,r.jsx)(n.em,{children:"var"})," is bound to the successive elements of the ",(0,r.jsx)(n.em,{children:"list"})," in ",(0,r.jsx)(n.em,{children:"form1"})," before each iteration. At the end of each iteration, the function ",(0,r.jsx)(n.em,{children:"step-fun"})," is applied to the ",(0,r.jsx)(n.em,{children:"list"}),"; the default value for ",(0,r.jsx)(n.em,{children:"step-fun"})," is ",(0,r.jsx)(n.strong,{children:"cdr"}),". The ",(0,r.jsx)(n.em,{children:"loop keywords"})," in and by serve as valid prepositions in this syntax. The for or as construct causes termination when the end of the ",(0,r.jsx)(n.em,{children:"list"})," is reached."]})}function _(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Y,{...e})}):Y(e)}function J(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Print every item in a list."}),"\n",(0,r.jsx)(n.p,{children:"(loop for item in \u2019(1 2 3) do (print item))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; Print every other item in a list."}),"\n",(0,r.jsx)(n.p,{children:"(loop for item in \u2019(1 2 3 4 5) by #\u2019cddr"}),"\n",(0,r.jsx)(n.p,{children:"do (print item))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 5"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201311"})]}),"\n",(0,r.jsx)(n.p,{children:";; Destructure a list, and sum the x values using fixnum arithmetic."}),"\n",(0,r.jsx)(n.p,{children:"(loop for (item . x) of-type (t . fixnum) in \u2019((A . 1) (B . 2) (C . 3))"}),"\n",(0,r.jsx)(n.p,{children:"unless (eq item \u2019B) sum x)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 4"]})]})}function Q(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(J,{...e})}):J(e)}function $(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-on-list"})," subclause, the for or as construct iterates over a ",(0,r.jsx)(n.em,{children:"list"}),". It checks for the end of the ",(0,r.jsx)(n.em,{children:"list"})," as if by using ",(0,r.jsx)(n.strong,{children:"atom"}),". The variable ",(0,r.jsx)(n.em,{children:"var"})," is bound to the successive tails of the ",(0,r.jsx)(n.em,{children:"list"})," in ",(0,r.jsx)(n.em,{children:"form1"}),". At the end of each iteration, the function ",(0,r.jsx)(n.em,{children:"step-fun"})," is applied to the ",(0,r.jsx)(n.em,{children:"list"}),"; the default value for ",(0,r.jsx)(n.em,{children:"step-fun"})," is ",(0,r.jsx)(n.strong,{children:"cdr"}),". The ",(0,r.jsx)(n.em,{children:"loop keywords"})," on and by serve as valid prepositions in this syntax. The for or as construct causes termination when the end of the ",(0,r.jsx)(n.em,{children:"list"})," is reached."]})}function ee(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Collect successive tails of a list."}),"\n",(0,r.jsx)(n.p,{children:"(loop for sublist on \u2019(a b c d)"}),"\n",(0,r.jsx)(n.p,{children:"collect sublist)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((A B C D) (B C D) (C D) (D))"]}),"\n",(0,r.jsx)(n.p,{children:";; Print a list by using destructuring with the loop keyword ON."}),"\n",(0,r.jsx)(n.p,{children:"(loop for (item) on \u2019(1 2 3)"}),"\n",(0,r.jsx)(n.p,{children:"do (print item))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function se(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ne,{...e})}):ne(e)}function re(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-equals-then"})," subclause the for or as construct initializes the variable ",(0,r.jsx)(n.em,{children:"var"})," by setting it to the result of evaluating ",(0,r.jsx)(n.em,{children:"form1"})," on the first iteration, then setting it to the result of evaluating ",(0,r.jsx)(n.em,{children:"form2"})," on the second and subsequent iterations. If ",(0,r.jsx)(n.em,{children:"form2"})," is omitted, the construct uses ",(0,r.jsx)(n.em,{children:"form1"})," on the second and subsequent iterations. The ",(0,r.jsx)(n.em,{children:"loop keywords"})," = and then serve as valid prepositions in this syntax. This construct does not provide any termination tests."]})}function ie(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(re,{...e})}):re(e)}function te(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Collect some numbers."}),"\n",(0,r.jsx)(n.p,{children:"(loop for item = 1 then (+ item 10)"}),"\n",(0,r.jsx)(n.p,{children:"for iteration from 1 to 5"}),"\n",(0,r.jsx)(n.p,{children:"collect item)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 11 21 31 41)"]})]})}function le(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(te,{...e})}):te(e)}function oe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-across"})," subclause the for or as construct binds the variable ",(0,r.jsx)(n.em,{children:"var"})," to the value of each element in the array ",(0,r.jsx)(n.em,{children:"vector"}),". The ",(0,r.jsx)(n.em,{children:"loop keyword"})," across marks the array ",(0,r.jsx)(n.em,{children:"vector"}),"; across is used as a preposition in this syntax. Iteration stops when there are no more elements in the supplied ",(0,r.jsx)(n.em,{children:"array"})]}),"\n",(0,r.jsxs)(n.p,{children:["that can be referenced. Some implementations might recognize a ",(0,r.jsx)(n.strong,{children:"the"})," special form in the ",(0,r.jsx)(n.em,{children:"vector"})," form to produce more efficient code."]})]})}function ce(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(oe,{...e})}):oe(e)}function he(e){const n={p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop for char across (the simple-string (find-message channel))"}),"\n",(0,r.jsx)(n.p,{children:"do (write-char char stream))"})]})}function ae(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(he,{...e})}):he(e)}function de(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-hash"})," subclause the for or as construct iterates over the elements, keys, and values of a ",(0,r.jsx)(n.em,{children:"hash-table"}),". In this syntax, a compound preposition is used to designate access to a ",(0,r.jsx)(n.em,{children:"hash table"}),". The variable ",(0,r.jsx)(n.em,{children:"var"})," takes on the value of each hash key or hash value in the supplied ",(0,r.jsx)(n.em,{children:"hash-table"}),". The following ",(0,r.jsx)(n.em,{children:"loop keywords"})," serve as valid prepositions within this syntax:"]}),"\n",(0,r.jsx)(n.p,{children:"being"}),"\n",(0,r.jsx)(n.p,{children:"The keyword being introduces either the Loop schema hash-key or hash-value."}),"\n",(0,r.jsx)(n.p,{children:"each, the"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," each follows the ",(0,r.jsx)(n.em,{children:"loop keyword"})," being when hash-key or hash-value is used. The ",(0,r.jsx)(n.em,{children:"loop keyword"})," the is used with hash-keys and hash-values only for ease of reading. This agreement isn\u2019t required."]}),"\n",(0,r.jsx)(n.p,{children:"hash-key, hash-keys"}),"\n",(0,r.jsxs)(n.p,{children:["These ",(0,r.jsx)(n.em,{children:"loop keywords"})," access each key entry of the ",(0,r.jsx)(n.em,{children:"hash table"}),". If the name hash-value is supplied in a using construct with one of these Loop schemas, the iteration can optionally access the keyed value. The order in which the keys are accessed is undefined; empty slots in the ",(0,r.jsx)(n.em,{children:"hash table"})," are ignored."]}),"\n",(0,r.jsx)(n.p,{children:"hash-value, hash-values"}),"\n",(0,r.jsxs)(n.p,{children:["These ",(0,r.jsx)(n.em,{children:"loop keywords"})," access each value entry of a ",(0,r.jsx)(n.em,{children:"hash table"}),". If the name hash-key is supplied in a using construct with one of these Loop schemas, the iteration can optionally access the key that corresponds to the value. The order in which the keys are accessed is undefined; empty slots in the ",(0,r.jsx)(n.em,{children:"hash table"})," are ignored."]}),"\n",(0,r.jsx)(n.p,{children:"using"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," using introduces the optional key or the keyed value to be accessed. It allows access to the hash key if iteration is over the hash values, and the hash value if iteration is over the hash keys."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201313"})]}),"\n",(0,r.jsx)(n.p,{children:"in, of"}),"\n",(0,r.jsxs)(n.p,{children:["These loop prepositions introduce ",(0,r.jsx)(n.em,{children:"hash-table"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In effect"}),"\n",(0,r.jsxs)(n.p,{children:["being ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["each ",(0,r.jsx)(n.em,{children:"|"})," the"]}),"} {",(0,r.jsxs)(n.em,{children:["hash-value ",(0,r.jsx)(n.em,{children:"|"})," hash-values ",(0,r.jsx)(n.em,{children:"|"})," hash-key ",(0,r.jsx)(n.em,{children:"|"})," hash-keys"]}),"} {",(0,r.jsxs)(n.em,{children:["in ",(0,r.jsx)(n.em,{children:"|"})," of"]}),"}"]})]}),"\n",(0,r.jsx)(n.p,{children:"is a compound preposition."}),"\n",(0,r.jsxs)(n.p,{children:["Iteration stops when there are no more hash keys or hash values to be referenced in the supplied ",(0,r.jsx)(n.em,{children:"hash-table"}),"."]})]})}function xe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(de,{...e})}):de(e)}function pe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"for-as-package"})," subclause the for or as construct iterates over the ",(0,r.jsx)(n.em,{children:"symbols"})," in a ",(0,r.jsx)(n.em,{children:"package"}),". In this syntax, a compound preposition is used to designate access to a ",(0,r.jsx)(n.em,{children:"package"}),". The variable ",(0,r.jsx)(n.em,{children:"var"})," takes on the value of each ",(0,r.jsx)(n.em,{children:"symbol"})," in the supplied ",(0,r.jsx)(n.em,{children:"package"}),". The following ",(0,r.jsx)(n.em,{children:"loop keywords"})," serve as valid prepositions within this syntax:"]}),"\n",(0,r.jsx)(n.p,{children:"being"}),"\n",(0,r.jsx)(n.p,{children:"The keyword being introduces either the Loop schema symbol, present-symbol, or external-symbol."}),"\n",(0,r.jsx)(n.p,{children:"each, the"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," each follows the ",(0,r.jsx)(n.em,{children:"loop keyword"})," being when symbol, present-symbol, or external-symbol is used. The ",(0,r.jsx)(n.em,{children:"loop keyword"})," the is used with symbols, present-symbols, and external-symbols only for ease of reading. This agreement isn\u2019t required."]}),"\n",(0,r.jsx)(n.p,{children:"present-symbol, present-symbols"}),"\n",(0,r.jsxs)(n.p,{children:["These Loop schemas iterate over the ",(0,r.jsx)(n.em,{children:"symbols"})," that are ",(0,r.jsx)(n.em,{children:"present"})," in a ",(0,r.jsx)(n.em,{children:"package"}),". The ",(0,r.jsx)(n.em,{children:"package"})," to be iterated over is supplied in the same way that ",(0,r.jsx)(n.em,{children:"package"})," arguments to ",(0,r.jsx)(n.strong,{children:"find-package"})," are supplied. If the ",(0,r.jsx)(n.em,{children:"package"})," for the iteration is not supplied, the ",(0,r.jsx)(n.em,{children:"current package"})," is used. If a ",(0,r.jsx)(n.em,{children:"package"})," that does not exist is supplied, an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"package-error"})," is signaled."]}),"\n",(0,r.jsx)(n.p,{children:"symbol, symbols"}),"\n",(0,r.jsxs)(n.p,{children:["These Loop schemas iterate over ",(0,r.jsx)(n.em,{children:"symbols"})," that are ",(0,r.jsx)(n.em,{children:"accessible"})," in a given ",(0,r.jsx)(n.em,{children:"package"}),". The ",(0,r.jsx)(n.em,{children:"package"})," to be iterated over is supplied in the same way that ",(0,r.jsx)(n.em,{children:"package"})," arguments to ",(0,r.jsx)(n.strong,{children:"find-package"})," are supplied. If the ",(0,r.jsx)(n.em,{children:"package"})," for the iteration is not supplied, the ",(0,r.jsx)(n.em,{children:"current package"})," is used. If a ",(0,r.jsx)(n.em,{children:"package"})," that does not exist is supplied, an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"package-error"})," is signaled."]}),"\n",(0,r.jsx)(n.p,{children:"external-symbol, external-symbols"}),"\n",(0,r.jsxs)(n.p,{children:["These Loop schemas iterate over the ",(0,r.jsx)(n.em,{children:"external symbols"})," of a ",(0,r.jsx)(n.em,{children:"package"}),". The ",(0,r.jsx)(n.em,{children:"package"})," to be iterated over is supplied in the same way that ",(0,r.jsx)(n.em,{children:"package"})," arguments to ",(0,r.jsx)(n.strong,{children:"find-package"})," are"]}),"\n",(0,r.jsxs)(n.p,{children:["supplied. If the ",(0,r.jsx)(n.em,{children:"package"})," for the iteration is not supplied, the ",(0,r.jsx)(n.em,{children:"current package"})," is used. If a ",(0,r.jsx)(n.em,{children:"package"})," that does not exist is supplied, an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"package-error"})," is signaled."]}),"\n",(0,r.jsx)(n.p,{children:"in, of"}),"\n",(0,r.jsxs)(n.p,{children:["These loop prepositions introduce ",(0,r.jsx)(n.em,{children:"package"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In effect"}),"\n",(0,r.jsxs)(n.p,{children:["being ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["each ",(0,r.jsx)(n.em,{children:"|"})," the"]}),"} {",(0,r.jsxs)(n.em,{children:["symbol ",(0,r.jsx)(n.em,{children:"|"})," symbols ",(0,r.jsx)(n.em,{children:"|"})," present-symbol ",(0,r.jsx)(n.em,{children:"|"})," present-symbols ",(0,r.jsx)(n.em,{children:"|"})," external-symbol ",(0,r.jsx)(n.em,{children:"|"})," external-symbols"]}),"} {",(0,r.jsxs)(n.em,{children:["in ",(0,r.jsx)(n.em,{children:"|"})," of"]}),"}"]})]}),"\n",(0,r.jsx)(n.p,{children:"is a compound preposition."}),"\n",(0,r.jsxs)(n.p,{children:["Iteration stops when there are no more ",(0,r.jsx)(n.em,{children:"symbols"})," to be referenced in the supplied ",(0,r.jsx)(n.em,{children:"package"}),"."]})]})}function me(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(pe,{...e})}):pe(e)}function je(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:'(let ((*package* (make-package "TEST-PACKAGE-1")))'}),"\n",(0,r.jsx)(n.p,{children:";; For effect, intern some symbols"}),"\n",(0,r.jsx)(n.p,{children:'(read-from-string "(THIS IS A TEST)")'}),"\n",(0,r.jsx)(n.p,{children:'(export (intern "THIS"))'}),"\n",(0,r.jsx)(n.p,{children:"(loop for x being each present-symbol of *package*"}),"\n",(0,r.jsx)(n.p,{children:"do (print x)))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 A"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 TEST"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 THIS"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 IS"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function ue(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(je,{...e})}):je(e)}function fe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When a ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is executed, the local variables are bound and are initialized to some value. These local variables exist until ",(0,r.jsx)(n.strong,{children:"loop"})," iteration terminates, at which point they cease to exist. Implicit variables are also established by iteration control clauses and the into preposition of accumulation clauses."]}),"\n",(0,r.jsxs)(n.p,{children:["The with construct initializes variables that are local to a loop. The variables are initialized one time only. If the optional ",(0,r.jsx)(n.em,{children:"type-spec"})," argument is supplied for the variable ",(0,r.jsx)(n.em,{children:"var"}),", but there is no related expression to be evaluated, ",(0,r.jsx)(n.em,{children:"var"})," is initialized to an appropriate default value for its ",(0,r.jsx)(n.em,{children:"type"}),". For example, for the types ",(0,r.jsx)(n.strong,{children:"t"}),", ",(0,r.jsx)(n.strong,{children:"number"}),", and ",(0,r.jsx)(n.strong,{children:"float"}),", the default values are ",(0,r.jsx)(n.strong,{children:"nil"}),", 0, and 0.0 respectively. The consequences are undefined if a ",(0,r.jsx)(n.em,{children:"type-spec"})," argument is supplied for ",(0,r.jsx)(n.em,{children:"var"})," if the related expression returns a value that is not of the supplied ",(0,r.jsx)(n.em,{children:"type"}),". By default, the with construct initializes variables ",(0,r.jsx)(n.em,{children:"sequentially"}),"; that is, one variable is assigned a value before the next expression is evaluated. However, by using the ",(0,r.jsx)(n.em,{children:"loop keyword"})," and to join several with clauses, initializations can be forced to"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201315"})]}),"\n",(0,r.jsxs)(n.p,{children:["occur in ",(0,r.jsx)(n.em,{children:"parallel"}),"; that is, all of the supplied ",(0,r.jsx)(n.em,{children:"forms"})," are evaluated, and the results are bound to the respective variables simultaneously."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Sequential binding"})," is used when it is desireable for the initialization of some variables to depend on the values of previously bound variables. For example, suppose the variables a, b, and c are to be bound in sequence:"]}),"\n",(0,r.jsx)(n.p,{children:"(loop with a = 1"}),"\n",(0,r.jsx)(n.p,{children:"with b = (+ a 2)"}),"\n",(0,r.jsx)(n.p,{children:"with c = (+ b 3)"}),"\n",(0,r.jsx)(n.p,{children:"return (list a b c))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3 6)"]}),"\n",(0,r.jsxs)(n.p,{children:["The execution of the above ",(0,r.jsx)(n.strong,{children:"loop"})," is equivalent to the execution of the following code:"]}),"\n",(0,r.jsx)(n.p,{children:"(block nil"}),"\n",(0,r.jsx)(n.p,{children:"(let* ((a 1)"}),"\n",(0,r.jsx)(n.p,{children:"(b (+ a 2))"}),"\n",(0,r.jsx)(n.p,{children:"(c (+ b 3)))"}),"\n",(0,r.jsx)(n.p,{children:"(tagbody"}),"\n",(0,r.jsx)(n.p,{children:"(next-loop (return (list a b c))"}),"\n",(0,r.jsx)(n.p,{children:"(go next-loop)"}),"\n",(0,r.jsx)(n.p,{children:"end-loop))))"}),"\n",(0,r.jsxs)(n.p,{children:["If the values of previously bound variables are not needed for the initialization of other local variables, an and clause can be used to specify that the bindings are to occur in ",(0,r.jsx)(n.em,{children:"parallel"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"(loop with a = 1"}),"\n",(0,r.jsx)(n.p,{children:"and b = 2"}),"\n",(0,r.jsx)(n.p,{children:"and c = 3"}),"\n",(0,r.jsx)(n.p,{children:"return (list a b c))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 2 3)"]}),"\n",(0,r.jsx)(n.p,{children:"The execution of the above loop is equivalent to the execution of the following code:"}),"\n",(0,r.jsx)(n.p,{children:"(block nil"}),"\n",(0,r.jsx)(n.p,{children:"(let ((a 1)"}),"\n",(0,r.jsx)(n.p,{children:"(b 2)"}),"\n",(0,r.jsx)(n.p,{children:"(c 3))"}),"\n",(0,r.jsx)(n.p,{children:"(tagbody"}),"\n",(0,r.jsx)(n.p,{children:"(next-loop (return (list a b c))"}),"\n",(0,r.jsx)(n.p,{children:"(go next-loop)"}),"\n",(0,r.jsx)(n.p,{children:"end-loop))))"})]})}function ge(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(fe,{...e})}):fe(e)}function be(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; These bindings occur in sequence."}),"\n",(0,r.jsx)(n.p,{children:"(loop with a = 1"}),"\n",(0,r.jsx)(n.p,{children:"with b = (+ a 2)"}),"\n",(0,r.jsx)(n.p,{children:"with c = (+ b 3)"}),"\n",(0,r.jsx)(n.p,{children:"return (list a b c))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3 6)"]}),"\n",(0,r.jsx)(n.p,{children:";; These bindings occur in parallel."}),"\n",(0,r.jsx)(n.p,{children:"(setq a 5 b 10)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 10"]}),"\n",(0,r.jsx)(n.p,{children:"(loop with a = 1"}),"\n",(0,r.jsx)(n.p,{children:"and b = (+ a 2)"}),"\n",(0,r.jsx)(n.p,{children:"and c = (+ b 3)"}),"\n",(0,r.jsx)(n.p,{children:"return (list a b c))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 7 13)"]}),"\n",(0,r.jsx)(n.p,{children:";; This example shows a shorthand way to declare local variables"}),"\n",(0,r.jsx)(n.p,{children:";; that are of different types."}),"\n",(0,r.jsx)(n.p,{children:"(loop with (a b c) of-type (float integer float)"}),"\n",(0,r.jsx)(n.p,{children:'return (format nil "~A ~A ~A" a b c))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' "0.0 0 0.0"']}),"\n",(0,r.jsx)(n.p,{children:";; This example shows a shorthand way to declare local variables"}),"\n",(0,r.jsx)(n.p,{children:";; that are the same type."}),"\n",(0,r.jsx)(n.p,{children:"(loop with (a b c) of-type float"}),"\n",(0,r.jsx)(n.p,{children:'return (format nil "~A ~A ~A" a b c))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' "0.0 0.0 0.0"']})]})}function ve(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(be,{...e})}):be(e)}function ye(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The constructs collect, collecting, append, appending, nconc, nconcing, count, counting, maximize, maximizing, minimize, minimizing, sum, and summing, allow values to be accumulated in a ",(0,r.jsx)(n.strong,{children:"loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The constructs collect, collecting, append, appending, nconc, and nconcing, designate clauses that accumulate values in ",(0,r.jsx)(n.em,{children:"lists"})," and return them. The constructs count, counting, maximize, maximizing, minimize, minimizing, sum, and summing designate clauses that accumulate and return numerical values."]}),"\n",(0,r.jsxs)(n.p,{children:["During each iteration, the constructs collect and collecting collect the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," into a ",(0,r.jsx)(n.em,{children:"list"}),". When iteration terminates, the ",(0,r.jsx)(n.em,{children:"list"})," is returned. The argument ",(0,r.jsx)(n.em,{children:"var"})," is set to the ",(0,r.jsx)(n.em,{children:"list"})," of collected values; if ",(0,r.jsx)(n.em,{children:"var"})," is supplied, the ",(0,r.jsx)(n.strong,{children:"loop"})," does not return the final ",(0,r.jsx)(n.em,{children:"list"})," automatically. If ",(0,r.jsx)(n.em,{children:"var"})," is not supplied, it is equivalent to supplying an internal name for ",(0,r.jsx)(n.em,{children:"var"})," and returning its value in a finally clause. The ",(0,r.jsx)(n.em,{children:"var"})," argument is bound as if by the construct with. No mechanism is provided for declaring the ",(0,r.jsx)(n.em,{children:"type"})," of ",(0,r.jsx)(n.em,{children:"var"}),"; it must be of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"list"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The constructs append, appending, nconc, and nconcing are similar to collect except that the values of the supplied ",(0,r.jsx)(n.em,{children:"form"})," must be ",(0,r.jsx)(n.em,{children:"lists"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201317"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The append keyword causes its ",(0,r.jsx)(n.em,{children:"list"})," values to be concatenated into a single ",(0,r.jsx)(n.em,{children:"list"}),", as if they were arguments to the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"append"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The nconc keyword causes its ",(0,r.jsx)(n.em,{children:"list"})," values to be concatenated into a single ",(0,r.jsx)(n.em,{children:"list"}),", as if they were arguments to the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"nconc"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The argument ",(0,r.jsx)(n.em,{children:"var"})," is set to the ",(0,r.jsx)(n.em,{children:"list"})," of concatenated values; if ",(0,r.jsx)(n.em,{children:"var"})," is supplied, ",(0,r.jsx)(n.strong,{children:"loop"})," does not return the final ",(0,r.jsx)(n.em,{children:"list"})," automatically. The ",(0,r.jsx)(n.em,{children:"var"})," argument is bound as if by the construct with. A ",(0,r.jsx)(n.em,{children:"type"})," cannot be supplied for ",(0,r.jsx)(n.em,{children:"var"}),"; it must be of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"list"}),". The construct nconc destructively modifies its argument ",(0,r.jsx)(n.em,{children:"lists"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The count construct counts the number of times that the supplied ",(0,r.jsx)(n.em,{children:"form"})," returns ",(0,r.jsx)(n.em,{children:"true"}),". The argument ",(0,r.jsx)(n.em,{children:"var"})," accumulates the number of occurrences; if ",(0,r.jsx)(n.em,{children:"var"})," is supplied, ",(0,r.jsx)(n.strong,{children:"loop"})," does not return the final count automatically. The ",(0,r.jsx)(n.em,{children:"var"})," argument is bound as if by the construct with to a zero of the appropriate type. Subsequent values (including any necessary coercions) are computed as if by the function ",(0,r.jsx)(n.strong,{children:"1+"}),". If into ",(0,r.jsx)(n.em,{children:"var"})," is used, a ",(0,r.jsx)(n.em,{children:"type"})," can be supplied for ",(0,r.jsx)(n.em,{children:"var"})," with the ",(0,r.jsx)(n.em,{children:"type-spec"})," argument; the consequences are unspecified if a nonnumeric ",(0,r.jsx)(n.em,{children:"type"})," is supplied. If there is no into variable, the optional ",(0,r.jsx)(n.em,{children:"type-spec"})," argument applies to the internal variable that is keeping the count. The default ",(0,r.jsx)(n.em,{children:"type"})," is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"; but it must be a ",(0,r.jsx)(n.em,{children:"supertype"})," of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"fixnum"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The maximize and minimize constructs compare the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," obtained during the first iteration with values obtained in successive iterations. The maximum (for maximize) or minimum (for minimize) value encountered is determined (as if by the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"max"})," for maximize and as if by the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"min"})," for minimize) and returned. If the maximize or minimize clause is never executed, the accumulated value is unspecified. The argument ",(0,r.jsx)(n.em,{children:"var"})," accumulates the maximum or minimum value; if ",(0,r.jsx)(n.em,{children:"var"})," is supplied, ",(0,r.jsx)(n.strong,{children:"loop"})," does not return the maximum or minimum automatically. The ",(0,r.jsx)(n.em,{children:"var"})," argument is bound as if by the construct with. If into ",(0,r.jsx)(n.em,{children:"var"})," is used, a ",(0,r.jsx)(n.em,{children:"type"})," can be supplied for ",(0,r.jsx)(n.em,{children:"var"})," with the ",(0,r.jsx)(n.em,{children:"type-spec"})," argument; the consequences are unspecified if a nonnumeric ",(0,r.jsx)(n.em,{children:"type"})," is supplied. If there is no into variable, the optional ",(0,r.jsx)(n.em,{children:"type-spec"})," argument applies to the internal variable that is keeping the maximum or minimum value. The default ",(0,r.jsx)(n.em,{children:"type"})," is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"; but it must be a ",(0,r.jsx)(n.em,{children:"supertype"})," of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"real"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The sum construct forms a cumulative sum of the successive ",(0,r.jsx)(n.em,{children:"primary values"})," of the supplied ",(0,r.jsx)(n.em,{children:"form"})," at each iteration. The argument ",(0,r.jsx)(n.em,{children:"var"})," is used to accumulate the sum; if ",(0,r.jsx)(n.em,{children:"var"})," is supplied, ",(0,r.jsx)(n.strong,{children:"loop"})," does not return the final sum automatically. The ",(0,r.jsx)(n.em,{children:"var"})," argument is bound as if by the construct with to a zero of the appropriate type. Subsequent values (including any necessary coercions) are computed as if by the ",(0,r.jsx)(n.em,{children:"function"})," ",(0,r.jsx)(n.strong,{children:"+"}),". If into ",(0,r.jsx)(n.em,{children:"var"})," is used, a ",(0,r.jsx)(n.em,{children:"type"})," can be supplied for ",(0,r.jsx)(n.em,{children:"var"})," with the ",(0,r.jsx)(n.em,{children:"type-spec"})," argument; the consequences are unspecified if a nonnumeric ",(0,r.jsx)(n.em,{children:"type"})," is supplied. If there is no into variable, the optional ",(0,r.jsx)(n.em,{children:"type-spec"})," argument applies to the internal variable that is keeping the sum. The default ",(0,r.jsx)(n.em,{children:"type"})," is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"; but it must be a ",(0,r.jsx)(n.em,{children:"supertype"})," of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"number"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If into is used, the construct does not provide a default return value; however, the variable is available for use in any finally clause."}),"\n",(0,r.jsxs)(n.p,{children:["Certain kinds of accumulation clauses can be combined in a ",(0,r.jsx)(n.strong,{children:"loop"})," if their destination is the same (the result of ",(0,r.jsx)(n.strong,{children:"loop"})," or an into ",(0,r.jsx)(n.em,{children:"var"}),") because they are considered to accumulate conceptually compatible quantities. In particular, any elements of following sets of accumulation clauses can be"]}),"\n",(0,r.jsxs)(n.p,{children:["mixed with other elements of the same set for the same destination in a ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),": ",(0,r.jsx)(n.em,{children:"\u2022"})," collect, append, nconc"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," sum, count"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," maximize, minimize"]}),"\n",(0,r.jsx)(n.p,{children:";; Collect every name and the kids in one list by using"}),"\n",(0,r.jsx)(n.p,{children:";; COLLECT and APPEND."}),"\n",(0,r.jsx)(n.p,{children:"(loop for name in \u2019(fred sue alice joe june)"}),"\n",(0,r.jsx)(n.p,{children:"for kids in \u2019((bob ken) () () (kris sunshine) ())"}),"\n",(0,r.jsx)(n.p,{children:"collect name"}),"\n",(0,r.jsx)(n.p,{children:"append kids)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)"]}),"\n",(0,r.jsxs)(n.p,{children:["Any two clauses that do not accumulate the same ",(0,r.jsx)(n.em,{children:"type"})," of ",(0,r.jsx)(n.em,{children:"object"})," can coexist in a ",(0,r.jsx)(n.strong,{children:"loop"})," only if each clause accumulates its values into a different ",(0,r.jsx)(n.em,{children:"variable"}),"."]})]})}function we(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ye,{...e})}):ye(e)}function Te(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Collect all the symbols in a list."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(bird 3 4 turtle (1 . 4) horse cat)"}),"\n",(0,r.jsx)(n.p,{children:"when (symbolp i) collect i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (BIRD TURTLE HORSE CAT)"]}),"\n",(0,r.jsx)(n.p,{children:";; Collect and return odd numbers."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"if (oddp i) collect i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3 5 7 9)"]}),"\n",(0,r.jsx)(n.p,{children:";; Collect items into local variable, but don\u2019t return them."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(a b c d) by #\u2019cddr"}),"\n",(0,r.jsx)(n.p,{children:"collect i into my-list"}),"\n",(0,r.jsx)(n.p,{children:"finally (print my-list))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 (A C)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function ke(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Te,{...e})}):Te(e)}function Ie(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Use APPEND to concatenate some sublists."}),"\n",(0,r.jsx)(n.p,{children:"(loop for x in \u2019((a) (b) ((c)))"}),"\n",(0,r.jsx)(n.p,{children:"append x)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (A B (C))"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201319"})]}),"\n",(0,r.jsx)(n.p,{children:";; NCONC some sublists together. Note that only lists made by the ;; call to LIST are modified."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i upfrom 0"}),"\n",(0,r.jsx)(n.p,{children:"as x in \u2019(a b (c))"}),"\n",(0,r.jsx)(n.p,{children:"nconc (if (evenp i) (list x) nil))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (A (C))"]})]})}function Ee(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ie,{...e})}):Ie(e)}function Ae(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop for i in \u2019(a b nil c nil d e)"}),"\n",(0,r.jsx)(n.p,{children:"count i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 5"]})]})}function Le(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ae,{...e})}):Ae(e)}function Se(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop for i in \u2019(2 1 5 3 4)"}),"\n",(0,r.jsx)(n.p,{children:"maximize i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 5"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(2 1 5 3 4)"}),"\n",(0,r.jsx)(n.p,{children:"minimize i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 1"]}),"\n",(0,r.jsx)(n.p,{children:";; In this example, FIXNUM applies to the internal variable that holds ;; the maximum value."}),"\n",(0,r.jsx)(n.p,{children:"(setq series \u2019(1.2 4.3 5.7))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1.2 4.3 5.7)"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for v in series"}),"\n",(0,r.jsx)(n.p,{children:"maximize (round v) of-type fixnum)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 6"]}),"\n",(0,r.jsx)(n.p,{children:";; In this example, FIXNUM applies to the variable RESULT."}),"\n",(0,r.jsx)(n.p,{children:"(loop for v of-type float in series"}),"\n",(0,r.jsx)(n.p,{children:"minimize (round v) into result of-type fixnum"}),"\n",(0,r.jsx)(n.p,{children:"finally (return result))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 1"]})]})}function Fe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Se,{...e})}):Se(e)}function Ne(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop for i of-type fixnum in \u2019(1 2 3 4 5)"}),"\n",(0,r.jsx)(n.p,{children:"sum i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 15"]}),"\n",(0,r.jsx)(n.p,{children:"(setq series \u2019(1.2 4.3 5.7))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1.2 4.3 5.7)"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for v in series"}),"\n",(0,r.jsx)(n.p,{children:"sum (* 2.0 v))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 22.4"]})]})}function ze(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ne,{...e})}):Ne(e)}function Ce(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The repeat construct causes iteration to terminate after a specified number of times. The loop body executes ",(0,r.jsx)(n.em,{children:"n"})," times, where ",(0,r.jsx)(n.em,{children:"n"})," is the value of the expression ",(0,r.jsx)(n.em,{children:"form"}),". The ",(0,r.jsx)(n.em,{children:"form"})," argument is evaluated one time in the loop prologue. If the expression evaluates to 0 or to a negative ",(0,r.jsx)(n.em,{children:"number"})," , the loop body is not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:["The constructs always, never, thereis, while, until, and the macro ",(0,r.jsx)(n.strong,{children:"loop-finish"})," allow conditional termination of iteration within a ",(0,r.jsx)(n.strong,{children:"loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The constructs always, never, and thereis provide specific values to be returned when a ",(0,r.jsx)(n.strong,{children:"loop"})," terminates. Using always, never, or thereis in a loop with value accumulation clauses that are not into causes an error of ",(0,r.jsx)(n.em,{children:"type"})," ",(0,r.jsx)(n.strong,{children:"program-error"})," to be signaled (at macro expansion time). Since always, never, and thereis use the ",(0,r.jsx)(n.strong,{children:"return-from"})," ",(0,r.jsx)(n.em,{children:"special operator"})," to terminate iteration, any finally clause that is supplied is not evaluated when exit occurs due to any of these constructs. In all other respects these constructs behave like the while and until constructs."]}),"\n",(0,r.jsxs)(n.p,{children:["The always construct takes one ",(0,r.jsx)(n.em,{children:"form"})," and terminates the ",(0,r.jsx)(n.strong,{children:"loop"})," if the ",(0,r.jsx)(n.em,{children:"form"})," ever evaluates to ",(0,r.jsx)(n.strong,{children:"nil"}),"; in this case, it returns ",(0,r.jsx)(n.strong,{children:"nil"}),". Otherwise, it provides a default return value of ",(0,r.jsx)(n.strong,{children:"t"}),". If the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is never ",(0,r.jsx)(n.strong,{children:"nil"}),", some other construct can terminate the iteration."]}),"\n",(0,r.jsxs)(n.p,{children:["The never construct terminates iteration the first time that the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"non-nil"}),"; the ",(0,r.jsx)(n.strong,{children:"loop"})," returns ",(0,r.jsx)(n.strong,{children:"nil"}),". If the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is always ",(0,r.jsx)(n.strong,{children:"nil"}),", some other construct can terminate the iteration. Unless some other clause contributes a return value, the default value returned is ",(0,r.jsx)(n.strong,{children:"t"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The thereis construct terminates iteration the first time that the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"non-nil"}),"; the ",(0,r.jsx)(n.strong,{children:"loop"})," returns the value of the supplied ",(0,r.jsx)(n.em,{children:"form"}),". If the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is always ",(0,r.jsx)(n.strong,{children:"nil"}),", some other construct can terminate the iteration. Unless some other clause contributes a return value, the default value returned is ",(0,r.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"There are two differences between the thereis and until constructs:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The until construct does not return a value or ",(0,r.jsx)(n.strong,{children:"nil"})," based on the value of the supplied ",(0,r.jsx)(n.em,{children:"form"}),". Iteration ",(0,r.jsx)(n.strong,{children:"6\u201321"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The until construct executes any finally clause. Since thereis uses the ",(0,r.jsx)(n.strong,{children:"return-from"})," ",(0,r.jsx)(n.em,{children:"special operator"})," to terminate iteration, any finally clause that is supplied is not evaluated when exit occurs due to thereis."]}),"\n",(0,r.jsxs)(n.p,{children:["The while construct allows iteration to continue until the supplied ",(0,r.jsx)(n.em,{children:"form"})," evaluates to ",(0,r.jsx)(n.em,{children:"false"}),". The supplied ",(0,r.jsx)(n.em,{children:"form"})," is reevaluated at the location of the while clause."]}),"\n",(0,r.jsxs)(n.p,{children:["The until construct is equivalent to while (not ",(0,r.jsx)(n.em,{children:"form"}),")",(0,r.jsx)(n.em,{children:". . ."})," . If the value of the supplied ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"non-nil"}),", iteration terminates."]}),"\n",(0,r.jsx)(n.p,{children:"Termination-test control constructs can be used anywhere within the loop body. The termination tests are used in the order in which they appear. If an until or while clause causes termination, any clauses that precede it in the source are still evaluated. If the until and while constructs cause termination, control is passed to the loop epilogue, where any finally clauses will be executed."}),"\n",(0,r.jsx)(n.p,{children:"There are two differences between the never and until constructs:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The until construct does not return ",(0,r.jsx)(n.strong,{children:"t"})," or ",(0,r.jsx)(n.strong,{children:"nil"})," based on the value of the supplied ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The until construct does not bypass any finally clauses. Since never uses the ",(0,r.jsx)(n.strong,{children:"return-from"})," ",(0,r.jsx)(n.em,{children:"special operator"})," to terminate iteration, any finally clause that is supplied is not evaluated when exit occurs due to never."]}),"\n",(0,r.jsxs)(n.p,{children:["In most cases it is not necessary to use ",(0,r.jsx)(n.strong,{children:"loop-finish"})," because other loop control clauses terminate the ",(0,r.jsx)(n.strong,{children:"loop"}),". The macro ",(0,r.jsx)(n.strong,{children:"loop-finish"})," is used to provide a normal exit from a nested conditional inside a ",(0,r.jsx)(n.strong,{children:"loop"}),". Since ",(0,r.jsx)(n.strong,{children:"loop-finish"})," transfers control to the loop epilogue, using ",(0,r.jsx)(n.strong,{children:"loop-finish"})," within a finally expression can cause infinite looping."]})]})}function qe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ce,{...e})}):Ce(e)}function Oe(e){const n={del:"del",em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop repeat 3"}),"\n",(0,r.jsxs)(n.p,{children:['do (format t "',(0,r.jsx)(n.del,{children:"&What I say three times is true."}),'%"))']}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 What I say three times is true."}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 What I say three times is true."}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 What I say three times is true."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:"(loop repeat -15"}),"\n",(0,r.jsx)(n.p,{children:'do (format t "What you see is what you expect~%"))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function De(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Oe,{...e})}):Oe(e)}function Pe(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Make sure I is always less than 11 (two ways)."}),"\n",(0,r.jsx)(n.p,{children:";; The FOR construct terminates these loops."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 0 to 10"}),"\n",(0,r.jsx)(n.p,{children:"always (< i 11))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 0 to 10"}),"\n",(0,r.jsx)(n.p,{children:"never (> i 11))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsx)(n.p,{children:";; If I exceeds 10 return I; otherwise, return NIL."}),"\n",(0,r.jsx)(n.p,{children:";; The THEREIS construct terminates this loop."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 0"}),"\n",(0,r.jsx)(n.p,{children:"thereis (when (> i 10) i) )"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 11"]}),"\n",(0,r.jsx)(n.p,{children:";;; The FINALLY clause is not evaluated in these examples."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 0 to 10"}),"\n",(0,r.jsx)(n.p,{children:"always (< i 9)"}),"\n",(0,r.jsx)(n.p,{children:'finally (print "you won\u2019t see this"))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:"(loop never t"}),"\n",(0,r.jsx)(n.p,{children:'finally (print "you won\u2019t see this"))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:'(loop thereis "Here is my value"'}),"\n",(0,r.jsx)(n.p,{children:'finally (print "you won\u2019t see this"))'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' "Here is my value"']}),"\n",(0,r.jsx)(n.p,{children:";; The FOR construct terminates this loop, so the FINALLY clause"}),"\n",(0,r.jsx)(n.p,{children:";; is evaluated."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"thereis (> i 11)"}),"\n",(0,r.jsx)(n.p,{children:"finally (prin1 \u2019got-here))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 GOT-HERE"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; If this code could be used to find a counterexample to Fermat\u2019s"}),"\n",(0,r.jsx)(n.p,{children:";; last theorem, it would still not return the value of the"}),"\n",(0,r.jsx)(n.p,{children:";; counterexample because all of the THEREIS clauses in this example"}),"\n",(0,r.jsx)(n.p,{children:";; only return T. But if Fermat is right, that won\u2019t matter"}),"\n",(0,r.jsx)(n.p,{children:";; because this won\u2019t terminate."}),"\n",(0,r.jsx)(n.p,{children:"(loop for z upfrom 2"}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201323"})]}),"\n",(0,r.jsx)(n.p,{children:"thereis"}),"\n",(0,r.jsx)(n.p,{children:"(loop for n upfrom 3 below (log z 2)"}),"\n",(0,r.jsx)(n.p,{children:"thereis"}),"\n",(0,r.jsx)(n.p,{children:"(loop for x below z"}),"\n",(0,r.jsx)(n.p,{children:"thereis"}),"\n",(0,r.jsx)(n.p,{children:"(loop for y below z"}),"\n",(0,r.jsx)(n.p,{children:"thereis (= (+ (expt x n) (expt y n))"}),"\n",(0,r.jsx)(n.p,{children:"(expt z n))))))"})]})}function Me(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Pe,{...e})}):Pe(e)}function Ue(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(loop while (hungry-p) do (eat))"}),"\n",(0,r.jsx)(n.p,{children:";; UNTIL NOT is equivalent to WHILE."}),"\n",(0,r.jsx)(n.p,{children:"(loop until (not (hungry-p)) do (eat))"}),"\n",(0,r.jsx)(n.p,{children:";; Collect the length and the items of STACK."}),"\n",(0,r.jsx)(n.p,{children:"(let ((stack \u2019(a b c d e f)))"}),"\n",(0,r.jsx)(n.p,{children:"(loop for item = (length stack) then (pop stack)"}),"\n",(0,r.jsx)(n.p,{children:"collect item"}),"\n",(0,r.jsx)(n.p,{children:"while stack))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (6 A B C D E F)"]}),"\n",(0,r.jsx)(n.p,{children:";; Use WHILE to terminate a loop that otherwise wouldn\u2019t terminate."}),"\n",(0,r.jsx)(n.p,{children:";; Note that WHILE occurs after the WHEN."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i fixnum from 3"}),"\n",(0,r.jsx)(n.p,{children:"when (oddp i) collect i"}),"\n",(0,r.jsx)(n.p,{children:"while (< i 5))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (3 5)"]})]})}function We(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ue,{...e})}):Ue(e)}function Re(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The do and doing constructs evaluate the supplied ",(0,r.jsx)(n.em,{children:"forms"})," wherever they occur in the expanded form of ",(0,r.jsx)(n.strong,{children:"loop"}),". The ",(0,r.jsx)(n.em,{children:"form"})," argument can be any ",(0,r.jsx)(n.em,{children:"compound form"}),". Each ",(0,r.jsx)(n.em,{children:"form"})," is evaluated in every iteration. Because every loop clause must begin with a ",(0,r.jsx)(n.em,{children:"loop keyword"}),", the keyword do is used when no control action other than execution is required."]}),"\n",(0,r.jsxs)(n.p,{children:["The return construct takes one ",(0,r.jsx)(n.em,{children:"form"}),". Any ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"form"})," are immediately returned by the ",(0,r.jsx)(n.strong,{children:"loop"})," form. It is equivalent to the clause do (return-from ",(0,r.jsx)(n.em,{children:"block-name value"}),"), where ",(0,r.jsx)(n.em,{children:"block-name"})," is the name specified in a named clause, or ",(0,r.jsx)(n.strong,{children:"nil"})," if there is no named clause."]})]})}function Be(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Re,{...e})}):Re(e)}function He(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Print numbers and their squares."}),"\n",(0,r.jsx)(n.p,{children:";; The DO construct applies to multiple forms."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to 3"}),"\n",(0,r.jsx)(n.p,{children:"do (print i)"}),"\n",(0,r.jsx)(n.p,{children:"(print (* i i)))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 4"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 9"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function Ve(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(He,{...e})}):He(e)}function Ke(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The if, when, and unless constructs establish conditional control in a ",(0,r.jsx)(n.strong,{children:"loop"}),". If the test passes, the succeeding loop clause is executed. If the test does not pass, the succeeding clause is skipped, and program control moves to the clause that follows the ",(0,r.jsx)(n.em,{children:"loop keyword"})," else. If the test does not pass and no else clause is supplied, control is transferred to the clause or construct following the entire"]}),"\n",(0,r.jsx)(n.p,{children:"conditional clause."}),"\n",(0,r.jsx)(n.p,{children:"If conditional clauses are nested, each else is paired with the closest preceding conditional clause that has no associated else or end."}),"\n",(0,r.jsxs)(n.p,{children:["In the if and when clauses, which are synonymous, the test passes if the value of ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"true"}),". In the unless clause, the test passes if the value of ",(0,r.jsx)(n.em,{children:"form"})," is ",(0,r.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Clauses that follow the test expression can be grouped by using the ",(0,r.jsx)(n.em,{children:"loop keyword"})," and to produce a conditional block consisting of a compound clause."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"loop keyword"})," it can be used to refer to the result of the test expression in a clause. Use the ",(0,r.jsx)(n.em,{children:"loop keyword"})," it in place of the form in a return clause or an ",(0,r.jsx)(n.em,{children:"accumulation"})," clause that is inside a conditional execution clause. If multiple clauses are connected with and, the it construct must be in the first clause in the block."]}),"\n",(0,r.jsxs)(n.p,{children:["The optional ",(0,r.jsx)(n.em,{children:"loop keyword"})," end marks the end of the clause. If this keyword is not supplied, the next ",(0,r.jsx)(n.em,{children:"loop keyword"})," marks the end. The construct end can be used to distinguish the scoping of compound clauses."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201325"})]})]})}function Xe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ke,{...e})}):Ke(e)}function Ge(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Signal an exceptional condition."}),"\n",(0,r.jsx)(n.p,{children:"(loop for item in \u2019(1 2 3 a 4 5)"}),"\n",(0,r.jsx)(n.p,{children:"when (not (numberp item))"}),"\n",(0,r.jsx)(n.p,{children:'return (cerror "enter new value" "non-numeric value: ~s" item)) Error: non-numeric value: A'}),"\n",(0,r.jsx)(n.p,{children:";; The previous example is equivalent to the following one."}),"\n",(0,r.jsx)(n.p,{children:"(loop for item in \u2019(1 2 3 a 4 5)"}),"\n",(0,r.jsx)(n.p,{children:"when (not (numberp item))"}),"\n",(0,r.jsx)(n.p,{children:"do (return"}),"\n",(0,r.jsx)(n.p,{children:'(cerror "Enter new value" "non-numeric value: ~s" item)))'}),"\n",(0,r.jsx)(n.p,{children:"Error: non-numeric value: A"}),"\n",(0,r.jsx)(n.p,{children:";; This example parses a simple printed string representation from ;; BUFFER (which is itself a string) and returns the index of the ;; closing double-quote character."}),"\n",(0,r.jsx)(n.p,{children:'(let ((buffer ""a" "b""))'}),"\n",(0,r.jsx)(n.p,{children:'(loop initially (unless (char= (char buffer 0) #")'}),"\n",(0,r.jsx)(n.p,{children:"(loop-finish))"}),"\n",(0,r.jsx)(n.p,{children:'for i of-type fixnum from 1 below (length (the string buffer)) when (char= (char buffer i) #")'}),"\n",(0,r.jsx)(n.p,{children:"return i))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 2"]}),"\n",(0,r.jsx)(n.p,{children:";; The collected value is returned."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"when (> i 5)"}),"\n",(0,r.jsx)(n.p,{children:"collect i"}),"\n",(0,r.jsx)(n.p,{children:"finally (prin1 \u2019got-here))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 GOT-HERE"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (6 7 8 9 10)"]}),"\n",(0,r.jsx)(n.p,{children:";; Return both the count of collected numbers and the numbers. (loop for i from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"when (> i 5)"}),"\n",(0,r.jsx)(n.p,{children:"collect i into number-list"}),"\n",(0,r.jsx)(n.p,{children:"and count i into number-count"}),"\n",(0,r.jsx)(n.p,{children:"finally (return (values number-count number-list)))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 5, (6 7 8 9 10)"]})]})}function Ze(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ge,{...e})}):Ge(e)}function Ye(e){return(0,r.jsx)(r.Fragment,{})}function _e(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Ye,{...e})}):Ye()}function Je(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The named construct establishes a name for an ",(0,r.jsx)(n.em,{children:"implicit block"})," surrounding the entire ",(0,r.jsx)(n.strong,{children:"loop"})," so that the ",(0,r.jsx)(n.strong,{children:"return-from"})," ",(0,r.jsx)(n.em,{children:"special operator"})," can be used to return values from or to exit ",(0,r.jsx)(n.strong,{children:"loop"}),". Only one name per ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," can be assigned. If used, the named construct must be the first clause in the loop expression."]}),"\n",(0,r.jsxs)(n.p,{children:["The return construct takes one ",(0,r.jsx)(n.em,{children:"form"}),". Any ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"form"})," are immediately returned by the ",(0,r.jsx)(n.strong,{children:"loop"})," form. This construct is similar to the ",(0,r.jsx)(n.strong,{children:"return-from"})," ",(0,r.jsx)(n.em,{children:"special operator"})," and the ",(0,r.jsx)(n.strong,{children:"return"})," ",(0,r.jsx)(n.em,{children:"macro"}),". The return construct does not execute any finally clause that the ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is given."]})]})}function Qe(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Je,{...e})}):Je(e)}function $e(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Just name and return."}),"\n",(0,r.jsx)(n.p,{children:"(loop named max"}),"\n",(0,r.jsx)(n.p,{children:"for i from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"do (print i)"}),"\n",(0,r.jsx)(n.p,{children:"do (return-from max \u2019done))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," DONE"]})]})}function en(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)($e,{...e})}):$e(e)}function nn(e){const n={em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The initially and finally constructs evaluate forms that occur before and after the loop body."}),"\n",(0,r.jsxs)(n.p,{children:["The initially construct causes the supplied ",(0,r.jsx)(n.em,{children:"compound-forms"})," to be evaluated in the loop prologue, which precedes all loop code except for initial settings supplied by constructs with, for, or as. The code for any initially clauses is executed in the order in which the clauses appeared in the ",(0,r.jsx)(n.strong,{children:"loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The finally construct causes the supplied ",(0,r.jsx)(n.em,{children:"compound-forms"})," to be evaluated in the loop epilogue after normal iteration terminates. The code for any finally clauses is executed in the order in which the clauses appeared in the ",(0,r.jsx)(n.strong,{children:"loop"}),". The collected code is executed once in the loop epilogue before any implicit values are returned from the accumulation clauses. An explicit transfer of control (",(0,r.jsx)(n.em,{children:"e.g."}),", by ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"go"}),", or ",(0,r.jsx)(n.strong,{children:"throw"}),") from the loop body, however, will exit the ",(0,r.jsx)(n.strong,{children:"loop"})," without executing the epilogue code."]}),"\n",(0,r.jsxs)(n.p,{children:["Clauses such as return, always, never, and thereis can bypass the finally clause. ",(0,r.jsx)(n.strong,{children:"return"})," (or ",(0,r.jsx)(n.strong,{children:"return-from"}),", if the named option was supplied) can be used after finally to return values from a ",(0,r.jsx)(n.strong,{children:"loop"}),". Such an ",(0,r.jsx)(n.em,{children:"explicit return"})," inside the finally clause takes precedence over returning the accumulation from clauses supplied by such keywords as collect, nconc, append, sum, count, maximize, and minimize; the accumulation values for these preempted clauses are not returned by ",(0,r.jsx)(n.strong,{children:"loop"})," if ",(0,r.jsx)(n.strong,{children:"return"})," or ",(0,r.jsx)(n.strong,{children:"return-from"})," is used."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201327"})]})]})}function sn(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(nn,{...e})}):nn(e)}function rn(e){const n={em:"em",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(let ((i 0)) ; no loop keywords are used"}),"\n",(0,r.jsxs)(n.p,{children:["(loop (incf i) (if (= i 3) (return i)))) ",(0,r.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,r.jsx)(n.p,{children:"(let ((i 0)(j 0))"}),"\n",(0,r.jsx)(n.p,{children:"(tagbody"}),"\n",(0,r.jsx)(n.p,{children:"(loop (incf j 3) (incf i) (if (= i 3) (go exit)))"}),"\n",(0,r.jsx)(n.p,{children:"exit)"}),"\n",(0,r.jsxs)(n.p,{children:["j) ",(0,r.jsx)(n.em,{children:"\u2192"})," 9"]}),"\n",(0,r.jsx)(n.p,{children:"In the following example, the variable x is stepped before y is stepped; thus, the value of y reflects the updated value of x:"}),"\n",(0,r.jsx)(n.p,{children:"(loop for x from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"for y = nil then x"}),"\n",(0,r.jsx)(n.p,{children:"collect (list x y))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))"]}),"\n",(0,r.jsxs)(n.p,{children:["In this example, x and y are stepped in ",(0,r.jsx)(n.em,{children:"parallel"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"(loop for x from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"and y = nil then x"}),"\n",(0,r.jsx)(n.p,{children:"collect (list x y))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," ((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))"]})]})}function tn(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(rn,{...e})}):rn(e)}function ln(e){const n={del:"del",em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:";; Group conditional clauses."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 324 2345 323 2 4 235 252)"}),"\n",(0,r.jsx)(n.p,{children:"when (oddp i)"}),"\n",(0,r.jsx)(n.p,{children:"do (print i)"}),"\n",(0,r.jsx)(n.p,{children:"and collect i into odd-numbers"}),"\n",(0,r.jsx)(n.p,{children:"and do (terpri)"}),"\n",(0,r.jsx)(n.p,{children:"else ; I is even."}),"\n",(0,r.jsx)(n.p,{children:"collect i into even-numbers"}),"\n",(0,r.jsx)(n.p,{children:"finally"}),"\n",(0,r.jsx)(n.p,{children:"(return (values odd-numbers even-numbers)))"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2345"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 323"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 235"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 2345 323 235), (324 2 4 252)"]}),"\n",(0,r.jsx)(n.p,{children:";; Collect numbers larger than 3."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 2 3 4 5 6)"}),"\n",(0,r.jsx)(n.p,{children:"when (and (> i 3) i)"}),"\n",(0,r.jsx)(n.p,{children:"collect it) ; IT refers to (and (> i 3) i)."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (4 5 6)"]}),"\n",(0,r.jsx)(n.p,{children:";; Find a number in a list."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 2 3 4 5 6)"}),"\n",(0,r.jsx)(n.p,{children:"when (and (> i 3) i)"}),"\n",(0,r.jsx)(n.p,{children:"return it)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 4"]}),"\n",(0,r.jsx)(n.p,{children:";; The above example is similar to the following one."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 2 3 4 5 6)"}),"\n",(0,r.jsx)(n.p,{children:"thereis (and (> i 3) i))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 4"]}),"\n",(0,r.jsx)(n.p,{children:";; Nest conditional clauses."}),"\n",(0,r.jsx)(n.p,{children:"(let ((list \u2019(0 3.0 apple 4 5 9.8 orange banana)))"}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in list"}),"\n",(0,r.jsx)(n.p,{children:"when (numberp i)"}),"\n",(0,r.jsx)(n.p,{children:"when (floatp i)"}),"\n",(0,r.jsx)(n.p,{children:"collect i into float-numbers"}),"\n",(0,r.jsx)(n.p,{children:"else ; Not (floatp i)"}),"\n",(0,r.jsx)(n.p,{children:"collect i into other-numbers"}),"\n",(0,r.jsx)(n.p,{children:"else ; Not (numberp i)"}),"\n",(0,r.jsx)(n.p,{children:"when (symbolp i)"}),"\n",(0,r.jsx)(n.p,{children:"collect i into symbol-list"}),"\n",(0,r.jsx)(n.p,{children:"else ; Not (symbolp i)"}),"\n",(0,r.jsxs)(n.p,{children:['do (error "found a funny value in list ~S, value ',(0,r.jsx)(n.del,{children:"S"}),'%" list i)']}),"\n",(0,r.jsx)(n.p,{children:"finally (return (values float-numbers other-numbers symbol-list))))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)"]}),"\n",(0,r.jsx)(n.p,{children:";; Without the END preposition, the last AND would apply to the"}),"\n",(0,r.jsx)(n.p,{children:";; inner IF rather than the outer one."}),"\n",(0,r.jsx)(n.p,{children:"(loop for x from 0 to 3"}),"\n",(0,r.jsx)(n.p,{children:"do (print x)"}),"\n",(0,r.jsx)(n.p,{children:"if (zerop (mod x 2))"}),"\n",(0,r.jsx)(n.p,{children:'do (princ " a")'}),"\n",(0,r.jsx)(n.p,{children:"and if (zerop (floor x 2))"}),"\n",(0,r.jsx)(n.p,{children:'do (princ " b")'}),"\n",(0,r.jsx)(n.p,{children:"end"}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201329"})]}),"\n",(0,r.jsx)(n.p,{children:'and do (princ " c"))'}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 0 a b c"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 1"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 2 a c"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 3"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]})]})}function on(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ln,{...e})}):ln(e)}function cn(e){const n={del:"del",em:"em",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Types"})," can be supplied for loop variables. It is not necessary to supply a ",(0,r.jsx)(n.em,{children:"type"})," for any variable, but supplying the ",(0,r.jsx)(n.em,{children:"type"})," can ensure that the variable has a correctly typed initial value, and it can also enable compiler optimizations (depending on the ",(0,r.jsx)(n.em,{children:"implementation"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["The clause repeat ",(0,r.jsx)(n.em,{children:"n"})," ... is roughly equivalent to a clause such as"]}),"\n",(0,r.jsxs)(n.p,{children:["(loop for ",(0,r.jsx)(n.em,{children:"internal-variable"})," downfrom (- ",(0,r.jsx)(n.em,{children:"n"})," 1) to 0 ...)"]}),"\n",(0,r.jsxs)(n.p,{children:["but in some ",(0,r.jsx)(n.em,{children:"implementations"}),", the repeat construct might be more efficient."]}),"\n",(0,r.jsxs)(n.p,{children:["Within the executable parts of the loop clauses and around the entire ",(0,r.jsx)(n.strong,{children:"loop"})," form, variables can be bound by using ",(0,r.jsx)(n.strong,{children:"let"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Use caution when using a variable named IT (in any ",(0,r.jsx)(n.em,{children:"package"}),") in connection with ",(0,r.jsx)(n.strong,{children:"loop"}),", since it is a ",(0,r.jsx)(n.em,{children:"loop keyword"})," that can be used in place of a ",(0,r.jsx)(n.em,{children:"form"})," in certain contexts."]}),"\n",(0,r.jsxs)(n.p,{children:["There is no ",(0,r.jsx)(n.em,{children:"standardized"})," mechanism for users to add extensions to ",(0,r.jsx)(n.strong,{children:"loop"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do, do"}),(0,r.jsx)(n.em,{children:"\u2217 Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do"})," (",(0,r.jsx)(n.em,{children:"{var |"})," (",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"init-form"})," [",(0,r.jsx)(n.em,{children:"step-form"}),"]])",(0,r.jsx)(n.em,{children:"}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.em,{children:"end-test-form {result-form}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"{tag | statement}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do*"})," (",(0,r.jsx)(n.em,{children:"{var |"})," (",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"init-form"})," [",(0,r.jsx)(n.em,{children:"step-form"}),"]])",(0,r.jsx)(n.em,{children:"}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.em,{children:"end-test-form {result-form}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"{tag | statement}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var"}),"\u2014a ",(0,r.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"init-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"step-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"end-test-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result-forms"}),"\u2014an ",(0,r.jsx)(n.em,{children:"implicit progn"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,r.jsx)(n.strong,{children:"declare"})," ",(0,r.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"tag"}),"\u2014a ",(0,r.jsx)(n.em,{children:"go tag"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"statement"}),"\u2014a ",(0,r.jsx)(n.em,{children:"compound form"}),"; evaluated as described below."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"results"}),"\u2014if a ",(0,r.jsx)(n.strong,{children:"return"})," or ",(0,r.jsx)(n.strong,{children:"return-from"})," form is executed, the ",(0,r.jsx)(n.em,{children:"values"})," passed from that ",(0,r.jsx)(n.em,{children:"form"}),"; otherwise, the ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"result-forms"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do"})," iterates over a group of ",(0,r.jsx)(n.em,{children:"statements"})," while a test condition holds. ",(0,r.jsx)(n.strong,{children:"do"})," accepts an arbitrary number of iteration ",(0,r.jsx)(n.em,{children:"vars"})," which are bound within the iteration and stepped in parallel. An initial value may be supplied for each iteration variable by use of an ",(0,r.jsx)(n.em,{children:"init-form"}),". ",(0,r.jsx)(n.em,{children:"Step-forms"})," may be used to specify how the ",(0,r.jsx)(n.em,{children:"vars"})," should be updated on succeeding iterations through the loop. ",(0,r.jsx)(n.em,{children:"Step-forms"})," may be used both to generate successive values or to accumulate results. If the ",(0,r.jsx)(n.em,{children:"end-test-form"})," condition is met prior to an execution of the body, the iteration terminates. ",(0,r.jsx)(n.em,{children:"Tags"})," label ",(0,r.jsx)(n.em,{children:"statements"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do*"})," is exactly like ",(0,r.jsx)(n.strong,{children:"do"})," except that the ",(0,r.jsx)(n.em,{children:"bindings"})," and steppings of the ",(0,r.jsx)(n.em,{children:"vars"})," are performed sequentially rather than in parallel."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201331"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do, do"}),(0,r.jsx)(n.em,{children:"\u2217"})]}),"\n",(0,r.jsxs)(n.p,{children:["Before the first iteration, all the ",(0,r.jsx)(n.em,{children:"init-forms"})," are evaluated, and each ",(0,r.jsx)(n.em,{children:"var"})," is bound to the value of its respective ",(0,r.jsx)(n.em,{children:"init-form"}),", if supplied. This is a ",(0,r.jsx)(n.em,{children:"binding"}),", not an assignment; when the loop terminates, the old values of those variables will be restored. For ",(0,r.jsx)(n.strong,{children:"do"}),", all of the ",(0,r.jsx)(n.em,{children:"init-forms"})," are evaluated before"]}),"\n",(0,r.jsxs)(n.p,{children:["any ",(0,r.jsx)(n.em,{children:"var"})," is bound. The ",(0,r.jsx)(n.em,{children:"init-forms"})," can refer to the ",(0,r.jsx)(n.em,{children:"bindings"})," of the ",(0,r.jsx)(n.em,{children:"vars"})," visible before beginning execution of ",(0,r.jsx)(n.strong,{children:"do"}),". For ",(0,r.jsx)(n.strong,{children:"do*"}),", the first ",(0,r.jsx)(n.em,{children:"init-form"})," is evaluated, then the first ",(0,r.jsx)(n.em,{children:"var"})," is bound to that value, then the second ",(0,r.jsx)(n.em,{children:"init-form"})," is evaluated, then the second ",(0,r.jsx)(n.em,{children:"var"})," is bound, and so on; in general, the ",(0,r.jsx)(n.em,{children:"k"}),"th ",(0,r.jsx)(n.em,{children:"init-form"})," can refer to the new binding of the ",(0,r.jsx)(n.em,{children:"j"}),"th ",(0,r.jsx)(n.em,{children:"var"})," if ",(0,r.jsx)(n.em,{children:"j"})," < ",(0,r.jsx)(n.em,{children:"k"}),", and otherwise to the old binding of the ",(0,r.jsx)(n.em,{children:"j"}),"th ",(0,r.jsx)(n.em,{children:"var"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["At the beginning of each iteration, after processing the variables, the ",(0,r.jsx)(n.em,{children:"end-test-form"})," is evaluated. If the result is ",(0,r.jsx)(n.em,{children:"false"}),", execution proceeds with the body of the ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") form. If the result is ",(0,r.jsx)(n.em,{children:"true"}),", the ",(0,r.jsx)(n.em,{children:"result-forms"})," are evaluated in order as an ",(0,r.jsx)(n.em,{children:"implicit progn"}),", and then ",(0,r.jsx)(n.strong,{children:"do"})," or ",(0,r.jsx)(n.strong,{children:"do*"})," returns."]}),"\n",(0,r.jsxs)(n.p,{children:["At the beginning of each iteration other than the first, ",(0,r.jsx)(n.em,{children:"vars"})," are updated as follows. All the ",(0,r.jsx)(n.em,{children:"step-forms"}),", if supplied, are evaluated, from left to right, and the resulting values are assigned to the respective ",(0,r.jsx)(n.em,{children:"vars"}),". Any ",(0,r.jsx)(n.em,{children:"var"})," that has no associated ",(0,r.jsx)(n.em,{children:"step-form"})," is not assigned to. For ",(0,r.jsx)(n.strong,{children:"do"}),", all the ",(0,r.jsx)(n.em,{children:"step-forms"})," are evaluated before any ",(0,r.jsx)(n.em,{children:"var"})," is updated; the assignment of values to ",(0,r.jsx)(n.em,{children:"vars"})," is done in parallel, as if by ",(0,r.jsx)(n.strong,{children:"psetq"}),". Because all of the ",(0,r.jsx)(n.em,{children:"step-forms"})," are evaluated before any of the ",(0,r.jsx)(n.em,{children:"vars"})," are altered, a ",(0,r.jsx)(n.em,{children:"step-form"})," when evaluated always has access to the old values of all the ",(0,r.jsx)(n.em,{children:"vars"}),", even if other ",(0,r.jsx)(n.em,{children:"step-forms"})," precede it. For ",(0,r.jsx)(n.strong,{children:"do*"}),", the first ",(0,r.jsx)(n.em,{children:"step-form"})," is evaluated, then the value is assigned to the first ",(0,r.jsx)(n.em,{children:"var"}),", then the second ",(0,r.jsx)(n.em,{children:"step-form"})," is evaluated, then the value is assigned to the second ",(0,r.jsx)(n.em,{children:"var"}),", and so on; the assignment of values to variables is done sequentially, as if by ",(0,r.jsx)(n.strong,{children:"setq"}),". For either ",(0,r.jsx)(n.strong,{children:"do"})," or ",(0,r.jsx)(n.strong,{children:"do*"}),", after the ",(0,r.jsx)(n.em,{children:"vars"})," have been updated, the ",(0,r.jsx)(n.em,{children:"end-test-form"})," is evaluated as described above, and the iteration continues."]}),"\n",(0,r.jsxs)(n.p,{children:["The remainder of the ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") form constitutes an ",(0,r.jsx)(n.em,{children:"implicit tagbody"}),". ",(0,r.jsx)(n.em,{children:"Tags"})," may appear within the body of a ",(0,r.jsx)(n.strong,{children:"do"})," loop for use by ",(0,r.jsx)(n.strong,{children:"go"})," statements appearing in the body (but such ",(0,r.jsx)(n.strong,{children:"go"})," statements may not appear in the variable specifiers, the ",(0,r.jsx)(n.em,{children:"end-test-form"}),", or the ",(0,r.jsx)(n.em,{children:"result-forms"}),"). When the end of a ",(0,r.jsx)(n.strong,{children:"do"})," body is reached, the next iteration cycle (beginning with the evaluation of ",(0,r.jsx)(n.em,{children:"step-forms"}),") occurs."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"implicit block"})," named ",(0,r.jsx)(n.strong,{children:"nil"})," surrounds the entire ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") form. A ",(0,r.jsx)(n.strong,{children:"return"})," statement may be used at any point to exit the loop immediately."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Init-form"})," is an initial value for the ",(0,r.jsx)(n.em,{children:"var"})," with which it is associated. If ",(0,r.jsx)(n.em,{children:"init-form"})," is omitted, the initial value of ",(0,r.jsx)(n.em,{children:"var"})," is ",(0,r.jsx)(n.strong,{children:"nil"}),". If a ",(0,r.jsx)(n.em,{children:"declaration"})," is supplied for a ",(0,r.jsx)(n.em,{children:"var"}),", ",(0,r.jsx)(n.em,{children:"init-form"})," must be consistent with the ",(0,r.jsx)(n.em,{children:"declaration"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Declarations"})," can appear at the beginning of a ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") body. They apply to code in the ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") body, to the ",(0,r.jsx)(n.em,{children:"bindings"})," of the ",(0,r.jsx)(n.strong,{children:"do"})," (or ",(0,r.jsx)(n.strong,{children:"do*"}),") ",(0,r.jsx)(n.em,{children:"vars"}),", to the ",(0,r.jsx)(n.em,{children:"step-forms"}),", to the ",(0,r.jsx)(n.em,{children:"end-test-form"}),", and to the ",(0,r.jsx)(n.em,{children:"result-forms"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.p,{children:"(do ((temp-one 1 (1+ temp-one))"}),"\n",(0,r.jsx)(n.p,{children:"(temp-two 0 (1- temp-two)))"}),"\n",(0,r.jsxs)(n.p,{children:["((> (- temp-one temp-two) 5) temp-one)) ",(0,r.jsx)(n.em,{children:"\u2192"})," 4"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do, do"}),(0,r.jsx)(n.em,{children:"\u2217"})]}),"\n",(0,r.jsx)(n.p,{children:"(do ((temp-one 1 (1+ temp-one))"}),"\n",(0,r.jsx)(n.p,{children:"(temp-two 0 (1+ temp-one)))"}),"\n",(0,r.jsxs)(n.p,{children:["((= 3 temp-two) temp-one)) ",(0,r.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,r.jsx)(n.p,{children:"(do* ((temp-one 1 (1+ temp-one))"}),"\n",(0,r.jsx)(n.p,{children:"(temp-two 0 (1+ temp-one)))"}),"\n",(0,r.jsxs)(n.p,{children:["((= 3 temp-two) temp-one)) ",(0,r.jsx)(n.em,{children:"\u2192"})," 2"]}),"\n",(0,r.jsx)(n.p,{children:"(do ((j 0 (+ j 1)))"}),"\n",(0,r.jsx)(n.p,{children:"(nil) ;Do forever."}),"\n",(0,r.jsx)(n.p,{children:'(format t "~%Input ~D:" j)'}),"\n",(0,r.jsx)(n.p,{children:"(let ((item (read)))"}),"\n",(0,r.jsx)(n.p,{children:"(if (null item) (return) ;Process items until NIL seen."}),"\n",(0,r.jsx)(n.p,{children:'(format t "~&Output ~D: ~S" j item))))'}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 Input 0: banana"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 Output 0: BANANA"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 Input 1: (57 boxes)"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 Output 1: (57 BOXES)"}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 Input 2: NIL"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:"(setq a-vector (vector 1 nil 3 nil))"}),"\n",(0,r.jsx)(n.p,{children:"(do ((i 0 (+ i 1)) ;Sets every null element of a-vector to zero."}),"\n",(0,r.jsx)(n.p,{children:"(n (array-dimension a-vector 0)))"}),"\n",(0,r.jsx)(n.p,{children:"((= i n))"}),"\n",(0,r.jsx)(n.p,{children:"(when (null (aref a-vector i))"}),"\n",(0,r.jsxs)(n.p,{children:["(setf (aref a-vector i) 0))) ",(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsxs)(n.p,{children:["a-vector ",(0,r.jsx)(n.em,{children:"\u2192"})," #(1 0 3 0)"]}),"\n",(0,r.jsx)(n.p,{children:"(do ((x e (cdr x))"}),"\n",(0,r.jsx)(n.p,{children:"(oldx x x))"}),"\n",(0,r.jsx)(n.p,{children:"((null x))"}),"\n",(0,r.jsx)(n.p,{children:"body)"}),"\n",(0,r.jsxs)(n.p,{children:["is an example of parallel assignment to index variables. On the first iteration, the value of oldx is whatever value x had before the ",(0,r.jsx)(n.strong,{children:"do"})," was entered. On succeeding iterations, oldx contains the value that x had on the previous iteration."]}),"\n",(0,r.jsx)(n.p,{children:"(do ((x foo (cdr x))"}),"\n",(0,r.jsx)(n.p,{children:"(y bar (cdr y))"}),"\n",(0,r.jsx)(n.p,{children:"(z \u2019() (cons (f (car x) (car y)) z)))"}),"\n",(0,r.jsx)(n.p,{children:"((or (null x) (null y))"}),"\n",(0,r.jsx)(n.p,{children:"(nreverse z)))"}),"\n",(0,r.jsx)(n.p,{children:"does the same thing as (mapcar #\u2019f foo bar). The step computation for z is an example of the fact that variables are stepped in parallel. Also, the body of the loop is empty."}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201333"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do, do"}),(0,r.jsx)(n.em,{children:"\u2217"})]}),"\n",(0,r.jsx)(n.p,{children:"(defun list-reverse (list)"}),"\n",(0,r.jsx)(n.p,{children:"(do ((x list (cdr x))"}),"\n",(0,r.jsx)(n.p,{children:"(y \u2019() (cons (car x) y)))"}),"\n",(0,r.jsx)(n.p,{children:"((endp x) y)))"}),"\n",(0,r.jsxs)(n.p,{children:["As an example of nested iterations, consider a data structure that is a ",(0,r.jsx)(n.em,{children:"list"})," of ",(0,r.jsx)(n.em,{children:"conses"}),". The ",(0,r.jsx)(n.em,{children:"car"})," of each ",(0,r.jsx)(n.em,{children:"cons"})," is a ",(0,r.jsx)(n.em,{children:"list"})," of ",(0,r.jsx)(n.em,{children:"symbols"}),", and the ",(0,r.jsx)(n.em,{children:"cdr"})," of each ",(0,r.jsx)(n.em,{children:"cons"})," is a ",(0,r.jsx)(n.em,{children:"list"})," of equal length containing corresponding values. Such a data structure is similar to an association list, but is divided into \u201cframes\u201d; the overall structure resembles a rib-cage. A lookup function on such a data structure might be:"]}),"\n",(0,r.jsx)(n.p,{children:"(defun ribcage-lookup (sym ribcage)"}),"\n",(0,r.jsx)(n.p,{children:"(do ((r ribcage (cdr r)))"}),"\n",(0,r.jsx)(n.p,{children:"((null r) nil)"}),"\n",(0,r.jsx)(n.p,{children:"(do ((s (caar r) (cdr s))"}),"\n",(0,r.jsx)(n.p,{children:"(v (cdar r) (cdr v)))"}),"\n",(0,r.jsx)(n.p,{children:"((null s))"}),"\n",(0,r.jsx)(n.p,{children:"(when (eq (car s) sym)"}),"\n",(0,r.jsxs)(n.p,{children:["(return-from ribcage-lookup (car v)))))) ",(0,r.jsx)(n.em,{children:"\u2192"})," RIBCAGE-LOOKUP"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:["other iteration functions (",(0,r.jsx)(n.strong,{children:"dolist"}),", ",(0,r.jsx)(n.strong,{children:"dotimes"}),", and ",(0,r.jsx)(n.strong,{children:"loop"}),") and more primitive functionality (",(0,r.jsx)(n.strong,{children:"tagbody"}),", ",(0,r.jsx)(n.strong,{children:"go"}),", ",(0,r.jsx)(n.strong,{children:"block"}),", ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"let"}),", and ",(0,r.jsx)(n.strong,{children:"setq"}),")"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"end-test-form"})," is ",(0,r.jsx)(n.strong,{children:"nil"}),", the test will never succeed. This provides an idiom for \u201cdo forever\u201d: the body of the ",(0,r.jsx)(n.strong,{children:"do"})," or ",(0,r.jsx)(n.strong,{children:"do*"})," is executed repeatedly. The infinite loop can be terminated by the use of ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"return-from"}),", ",(0,r.jsx)(n.strong,{children:"go"})," to an outer level, or ",(0,r.jsx)(n.strong,{children:"throw"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"do"})," ",(0,r.jsx)(n.em,{children:"form"})," may be explained in terms of the more primitive ",(0,r.jsx)(n.em,{children:"forms"})," ",(0,r.jsx)(n.strong,{children:"block"}),", ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"let"}),", ",(0,r.jsx)(n.strong,{children:"loop"}),", ",(0,r.jsx)(n.strong,{children:"tagbody"}),", and ",(0,r.jsx)(n.strong,{children:"psetq"})," as follows:"]}),"\n",(0,r.jsx)(n.p,{children:"(block nil"}),"\n",(0,r.jsx)(n.p,{children:"(let ((var1 init1)"}),"\n",(0,r.jsx)(n.p,{children:"(var2 init2)"}),"\n",(0,r.jsx)(n.p,{children:"..."}),"\n",(0,r.jsx)(n.p,{children:"(varn initn))"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"declarations"})}),"\n",(0,r.jsx)(n.p,{children:"(loop (when end-test (return (progn . result)))"}),"\n",(0,r.jsx)(n.p,{children:"(tagbody . tagbody)"}),"\n",(0,r.jsx)(n.p,{children:"(psetq var1 step1"}),"\n",(0,r.jsx)(n.p,{children:"var2 step2"}),"\n",(0,r.jsx)(n.p,{children:"..."}),"\n",(0,r.jsx)(n.p,{children:"varn stepn))))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do*"})," is similar, except that ",(0,r.jsx)(n.strong,{children:"let*"})," and ",(0,r.jsx)(n.strong,{children:"setq"})," replace the ",(0,r.jsx)(n.strong,{children:"let"})," and ",(0,r.jsx)(n.strong,{children:"psetq"}),", respectively."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dotimes"})," ",(0,r.jsx)(n.em,{children:"Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dotimes"})," (",(0,r.jsx)(n.em,{children:"var count-form"})," [",(0,r.jsx)(n.em,{children:"result-form"}),"]) ",(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"{tag | statement}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var"}),"\u2014a ",(0,r.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"count-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,r.jsx)(n.strong,{children:"declare"})," ",(0,r.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"tag"}),"\u2014a ",(0,r.jsx)(n.em,{children:"go tag"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"statement"}),"\u2014a ",(0,r.jsx)(n.em,{children:"compound form"}),"; evaluated as described below."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"results"}),"\u2014if a ",(0,r.jsx)(n.strong,{children:"return"})," or ",(0,r.jsx)(n.strong,{children:"return-from"})," form is executed, the ",(0,r.jsx)(n.em,{children:"values"})," passed from that ",(0,r.jsx)(n.em,{children:"form"}),"; otherwise, the ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"result-form"})," or ",(0,r.jsx)(n.strong,{children:"nil"})," if there is no ",(0,r.jsx)(n.em,{children:"result-form"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dotimes"})," iterates over a series of ",(0,r.jsx)(n.em,{children:"integers"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dotimes"})," evaluates ",(0,r.jsx)(n.em,{children:"count-form"}),", which should produce an ",(0,r.jsx)(n.em,{children:"integer"})," . If ",(0,r.jsx)(n.em,{children:"count-form"})," is zero or negative, the body is not executed. ",(0,r.jsx)(n.strong,{children:"dotimes"})," then executes the body once for each ",(0,r.jsx)(n.em,{children:"integer"})," from 0 up to but not including the value of ",(0,r.jsx)(n.em,{children:"count-form"}),", in the order in which the ",(0,r.jsx)(n.em,{children:"tags"})," and ",(0,r.jsx)(n.em,{children:"statements"})," occur, with ",(0,r.jsx)(n.em,{children:"var"})]}),"\n",(0,r.jsxs)(n.p,{children:["bound to each ",(0,r.jsx)(n.em,{children:"integer"})," . Then ",(0,r.jsx)(n.em,{children:"result-form"})," is evaluated. At the time ",(0,r.jsx)(n.em,{children:"result-form"})," is processed, ",(0,r.jsx)(n.em,{children:"var"})," is bound to the number of times the body was executed. ",(0,r.jsx)(n.em,{children:"Tags"})," label ",(0,r.jsx)(n.em,{children:"statements"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"implicit block"})," named ",(0,r.jsx)(n.strong,{children:"nil"})," surrounds ",(0,r.jsx)(n.strong,{children:"dotimes"}),". ",(0,r.jsx)(n.strong,{children:"return"})," may be used to terminate the loop immediately without performing any further iterations, returning zero or more ",(0,r.jsx)(n.em,{children:"values"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The body of the loop is an ",(0,r.jsx)(n.em,{children:"implicit tagbody"}),"; it may contain tags to serve as the targets of ",(0,r.jsx)(n.strong,{children:"go"})," statements. Declarations may appear before the body of the loop."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"scope"})," of the binding of ",(0,r.jsx)(n.em,{children:"var"})," does not include the ",(0,r.jsx)(n.em,{children:"count-form"}),", but the ",(0,r.jsx)(n.em,{children:"result-form"})," is included."]}),"\n",(0,r.jsxs)(n.p,{children:["It is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,r.jsx)(n.strong,{children:"dotimes"})," ",(0,r.jsx)(n.em,{children:"establishes"})," a new ",(0,r.jsx)(n.em,{children:"binding"})," of ",(0,r.jsx)(n.em,{children:"var"})," on each iteration or whether it ",(0,r.jsx)(n.em,{children:"establishes"})," a binding for ",(0,r.jsx)(n.em,{children:"var"})," once at the beginning and then ",(0,r.jsx)(n.em,{children:"assigns"})," it on any subsequent iterations."]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201335"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["(dotimes (temp-one 10 temp-one)) ",(0,r.jsx)(n.em,{children:"\u2192"})," 10"]}),"\n",(0,r.jsxs)(n.p,{children:["(setq temp-two 0) ",(0,r.jsx)(n.em,{children:"\u2192"})," 0"]}),"\n",(0,r.jsxs)(n.p,{children:["(dotimes (temp-one 10 t) (incf temp-two)) ",(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsxs)(n.p,{children:["temp-two ",(0,r.jsx)(n.em,{children:"\u2192"})," 10"]}),"\n",(0,r.jsx)(n.p,{children:"Here is an example of the use of dotimes in processing strings:"}),"\n",(0,r.jsx)(n.p,{children:";;; True if the specified subsequence of the string is a"}),"\n",(0,r.jsx)(n.p,{children:";;; palindrome (reads the same forwards and backwards)."}),"\n",(0,r.jsx)(n.p,{children:"(defun palindromep (string &optional"}),"\n",(0,r.jsx)(n.p,{children:"(start 0)"}),"\n",(0,r.jsx)(n.p,{children:"(end (length string)))"}),"\n",(0,r.jsx)(n.p,{children:"(dotimes (k (floor (- end start) 2) t)"}),"\n",(0,r.jsx)(n.p,{children:"(unless (char-equal (char string (+ start k))"}),"\n",(0,r.jsx)(n.p,{children:"(char string (- end k 1)))"}),"\n",(0,r.jsx)(n.p,{children:"(return nil))))"}),"\n",(0,r.jsxs)(n.p,{children:['(palindromep "Able was I ere I saw Elba") ',(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsxs)(n.p,{children:['(palindromep "A man, a plan, a canal\u2013Panama!") ',(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:"(remove-if-not #\u2019alpha-char-p ;Remove punctuation."}),"\n",(0,r.jsx)(n.p,{children:'"A man, a plan, a canal\u2013Panama!")'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' "AmanaplanacanalPanama"']}),"\n",(0,r.jsx)(n.p,{children:"(palindromep"}),"\n",(0,r.jsx)(n.p,{children:"(remove-if-not #\u2019alpha-char-p"}),"\n",(0,r.jsxs)(n.p,{children:['"A man, a plan, a canal\u2013Panama!")) ',(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsx)(n.p,{children:"(palindromep"}),"\n",(0,r.jsx)(n.p,{children:"(remove-if-not"}),"\n",(0,r.jsx)(n.p,{children:"#\u2019alpha-char-p"}),"\n",(0,r.jsxs)(n.p,{children:['"Unremarkable was I ere I saw Elba Kramer, nu?")) ',(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsx)(n.p,{children:"(palindromep"}),"\n",(0,r.jsx)(n.p,{children:"(remove-if-not"}),"\n",(0,r.jsx)(n.p,{children:"#\u2019alpha-char-p"}),"\n",(0,r.jsx)(n.p,{children:'"A man, a plan, a cat, a ham, a yak,'}),"\n",(0,r.jsxs)(n.p,{children:['a yam, a hat, a canal\u2013Panama!")) ',(0,r.jsx)(n.em,{children:"\u2192"})," T"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do"}),", ",(0,r.jsx)(n.strong,{children:"dolist"}),", ",(0,r.jsx)(n.strong,{children:"tagbody"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"go"})," may be used within the body of ",(0,r.jsx)(n.strong,{children:"dotimes"})," to transfer control to a statement labeled by a ",(0,r.jsx)(n.em,{children:"tag"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"dolist"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dolist"})," ",(0,r.jsx)(n.em,{children:"Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dolist"})," (",(0,r.jsx)(n.em,{children:"var list-form"})," [",(0,r.jsx)(n.em,{children:"result-form"}),"]) ",(0,r.jsx)(n.em,{children:"{declaration}"}),"* ",(0,r.jsx)(n.em,{children:"{tag | statement}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var"}),"\u2014a ",(0,r.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"list-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"declaration"}),"\u2014a ",(0,r.jsx)(n.strong,{children:"declare"})," ",(0,r.jsx)(n.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"tag"}),"\u2014a ",(0,r.jsx)(n.em,{children:"go tag"}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"statement"}),"\u2014a ",(0,r.jsx)(n.em,{children:"compound form"}),"; evaluated as described below."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"results"}),"\u2014if a ",(0,r.jsx)(n.strong,{children:"return"})," or ",(0,r.jsx)(n.strong,{children:"return-from"})," form is executed, the ",(0,r.jsx)(n.em,{children:"values"})," passed from that ",(0,r.jsx)(n.em,{children:"form"}),"; otherwise, the ",(0,r.jsx)(n.em,{children:"values"})," returned by the ",(0,r.jsx)(n.em,{children:"result-form"})," or ",(0,r.jsx)(n.strong,{children:"nil"})," if there is no ",(0,r.jsx)(n.em,{children:"result-form"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dolist"})," iterates over the elements of a ",(0,r.jsx)(n.em,{children:"list"}),". The body of ",(0,r.jsx)(n.strong,{children:"dolist"})," is like a ",(0,r.jsx)(n.strong,{children:"tagbody"}),". It consists of a series of ",(0,r.jsx)(n.em,{children:"tags"})," and ",(0,r.jsx)(n.em,{children:"statements"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dolist"})," evaluates ",(0,r.jsx)(n.em,{children:"list-form"}),", which should produce a ",(0,r.jsx)(n.em,{children:"list"}),". It then executes the body once for each element in the ",(0,r.jsx)(n.em,{children:"list"}),", in the order in which the ",(0,r.jsx)(n.em,{children:"tags"})," and ",(0,r.jsx)(n.em,{children:"statements"})," occur, with ",(0,r.jsx)(n.em,{children:"var"})," bound to the element. Then ",(0,r.jsx)(n.em,{children:"result-form"})," is evaluated. ",(0,r.jsx)(n.em,{children:"tags"})," label ",(0,r.jsx)(n.em,{children:"statements"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["At the time ",(0,r.jsx)(n.em,{children:"result-form"})," is processed, ",(0,r.jsx)(n.em,{children:"var"})," is bound to ",(0,r.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"implicit block"})," named ",(0,r.jsx)(n.strong,{children:"nil"})," surrounds ",(0,r.jsx)(n.strong,{children:"dolist"}),". ",(0,r.jsx)(n.strong,{children:"return"})," may be used to terminate the loop immediately without performing any further iterations, returning zero or more ",(0,r.jsx)(n.em,{children:"values"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"scope"})," of the binding of ",(0,r.jsx)(n.em,{children:"var"})," does not include the ",(0,r.jsx)(n.em,{children:"list-form"}),", but the ",(0,r.jsx)(n.em,{children:"result-form"})," is included."]}),"\n",(0,r.jsxs)(n.p,{children:["It is ",(0,r.jsx)(n.em,{children:"implementation-dependent"})," whether ",(0,r.jsx)(n.strong,{children:"dolist"})," ",(0,r.jsx)(n.em,{children:"establishes"})," a new ",(0,r.jsx)(n.em,{children:"binding"})," of ",(0,r.jsx)(n.em,{children:"var"})," on each iteration or whether it ",(0,r.jsx)(n.em,{children:"establishes"})," a binding for ",(0,r.jsx)(n.em,{children:"var"})," once at the beginning and then ",(0,r.jsx)(n.em,{children:"assigns"})," it on any subsequent iterations."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsxs)(n.p,{children:["(setq temp-two \u2019()) ",(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsxs)(n.p,{children:["(dolist (temp-one \u2019(1 2 3 4) temp-two) (push temp-one temp-two)) ",(0,r.jsx)(n.em,{children:"\u2192"})," (4 3 2 1) (setq temp-two 0) ",(0,r.jsx)(n.em,{children:"\u2192"})," 0"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201337"})]}),"\n",(0,r.jsxs)(n.p,{children:["(dolist (temp-one \u2019(1 2 3 4)) (incf temp-two)) ",(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsxs)(n.p,{children:["temp-two ",(0,r.jsx)(n.em,{children:"\u2192"})," 4"]}),"\n",(0,r.jsx)(n.p,{children:'(dolist (x \u2019(a b c d)) (prin1 x) (princ " "))'}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 A B C D"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do"}),", ",(0,r.jsx)(n.strong,{children:"dotimes"}),", ",(0,r.jsx)(n.strong,{children:"tagbody"}),", Section 3.6 (Traversal Rules and Side Effects)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"go"})," may be used within the body of ",(0,r.jsx)(n.strong,{children:"dolist"})," to transfer control to a statement labeled by a ",(0,r.jsx)(n.em,{children:"tag"}),". ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:["The \u201csimple\u201d ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"{compound-form}"}),"* ",(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:["The \u201cextended\u201d ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),":"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop"})," [",(0,r.jsx)(n.em,{children:"\u2193name-clause"}),"] ",(0,r.jsx)(n.em,{children:"{\u2193variable-clause}"}),"* ",(0,r.jsx)(n.em,{children:"{\u2193main-clause}"}),"* ",(0,r.jsx)(n.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"name-clause::"}),"=named ",(0,r.jsx)(n.em,{children:"name"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"variable-clause::"}),"=",(0,r.jsx)(n.em,{children:"\u2193with-clause | \u2193initial-final | \u2193for-as-clause"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"with-clause::"}),"=with ",(0,r.jsx)(n.em,{children:"var1"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] [= ",(0,r.jsx)(n.em,{children:"form1"}),"] ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["and ",(0,r.jsx)(n.em,{children:"var2"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] [= ",(0,r.jsx)(n.em,{children:"form2"}),"]"]}),"}"]}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"main-clause::"}),"=",(0,r.jsx)(n.em,{children:"\u2193unconditional | \u2193accumulation | \u2193conditional | \u2193termination-test | \u2193initial-final initial-final::"}),"=initially ",(0,r.jsx)(n.em,{children:"{compound-form}"}),"<sup>+</sup>",(0,r.jsx)(n.em,{children:"|"})," finally ",(0,r.jsx)(n.em,{children:"{compound-form}"}),"<sup>+</sup>"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"unconditional::"}),"=",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["do ",(0,r.jsx)(n.em,{children:"|"})," doing"]}),"} {compound-form}"]}),"<sup>+</sup>",(0,r.jsx)(n.em,{children:"|"})," return ",(0,r.jsx)(n.em,{children:"{form |"})," it*}*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"accumulation::"}),"=",(0,r.jsx)(n.em,{children:"\u2193list-accumulation | \u2193numeric-accumulation"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"list-accumulation::"}),"=",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["collect ",(0,r.jsx)(n.em,{children:"|"})," collecting ",(0,r.jsx)(n.em,{children:"|"})," append ",(0,r.jsx)(n.em,{children:"|"})," appending ",(0,r.jsx)(n.em,{children:"|"})," nconc ",(0,r.jsx)(n.em,{children:"|"})," nconcing"]}),"} {form |"]})," it*}* [into ",(0,r.jsx)(n.em,{children:"simple-var"}),"]"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"loop"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"numeric-accumulation::"}),"=*{*count ",(0,r.jsx)(n.em,{children:"|"})," counting ",(0,r.jsx)(n.em,{children:"|"})," sum ",(0,r.jsx)(n.em,{children:"|"})," summing ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["maximize ",(0,r.jsx)(n.em,{children:"|"})," maximizing ",(0,r.jsx)(n.em,{children:"|"})," minimize ",(0,r.jsx)(n.em,{children:"|"})," minimizing*} {form |* it*}*"]}),"\n",(0,r.jsxs)(n.p,{children:["[into ",(0,r.jsx)(n.em,{children:"simple-var"}),"] [",(0,r.jsx)(n.em,{children:"type-spec"}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"conditional::"}),"=*{",(0,r.jsxs)(n.em,{children:["if ",(0,r.jsx)(n.em,{children:"|"})," when ",(0,r.jsx)(n.em,{children:"|"})," unless"]}),"} form \u2193selectable-clause {*and ",(0,r.jsx)(n.em,{children:"\u2193selectable-clause}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:["[else *\u2193selectable-clause {*and ",(0,r.jsx)(n.em,{children:"\u2193selectable-clause}"}),"*]"]}),"\n",(0,r.jsx)(n.p,{children:"[end]"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"selectable-clause::"}),"=",(0,r.jsx)(n.em,{children:"\u2193unconditional | \u2193accumulation | \u2193conditional"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"termination-test::"}),"=while ",(0,r.jsx)(n.em,{children:"form |"})," until ",(0,r.jsx)(n.em,{children:"form |"})," repeat ",(0,r.jsx)(n.em,{children:"form |"})," always ",(0,r.jsx)(n.em,{children:"form |"})," never ",(0,r.jsx)(n.em,{children:"form |"})," thereis ",(0,r.jsx)(n.em,{children:"form for-as-clause::"}),"=*{",(0,r.jsxs)(n.em,{children:["for ",(0,r.jsx)(n.em,{children:"|"})," as"]}),"} \u2193for-as-subclause {*and ",(0,r.jsx)(n.em,{children:"\u2193for-as-subclause}"}),"*"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-subclause::"}),"=",(0,r.jsx)(n.em,{children:"\u2193for-as-arithmetic | \u2193for-as-in-list | \u2193for-as-on-list | \u2193for-as-equals-then | \u2193for-as-across | \u2193for-as-hash | \u2193for-as-package"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-arithmetic::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] ",(0,r.jsx)(n.em,{children:"\u2193for-as-arithmetic-subclause"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-arithmetic-subclause::"}),"=",(0,r.jsx)(n.em,{children:"\u2193arithmetic-up | \u2193arithmetic-downto | \u2193arithmetic-downfrom arithmetic-up::"}),"=[[ ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["from ",(0,r.jsx)(n.em,{children:"|"})," upfrom"]}),"} form1 | {",(0,r.jsxs)(n.em,{children:["to ",(0,r.jsx)(n.em,{children:"|"})," upto ",(0,r.jsx)(n.em,{children:"|"})," below"]}),"} form2 |"]})," by ",(0,r.jsx)(n.em,{children:"form3"})," ]]<sup>+</sup>"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"arithmetic-downto::"}),"=[[ ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["from ",(0,r.jsx)(n.em,{children:"form1}"}),"<sup>1</sup>"]}),"| {{",(0,r.jsxs)(n.em,{children:["downto ",(0,r.jsx)(n.em,{children:"|"})," above"]}),"} form2}"]}),"<sup>1</sup>",(0,r.jsx)(n.em,{children:"|"})," by ",(0,r.jsx)(n.em,{children:"form3"})," ]]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"arithmetic-downfrom::"}),"=[[ ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["downfrom ",(0,r.jsx)(n.em,{children:"form1}"}),"<sup>1</sup>"]}),"| {",(0,r.jsxs)(n.em,{children:["to ",(0,r.jsx)(n.em,{children:"|"})," downto ",(0,r.jsx)(n.em,{children:"|"})," above"]}),"} form2 |"]})," by ",(0,r.jsx)(n.em,{children:"form3"})," ]] ",(0,r.jsx)(n.em,{children:"for-as-in-list::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] in ",(0,r.jsx)(n.em,{children:"form1"})," [by ",(0,r.jsx)(n.em,{children:"step-fun"}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-on-list::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] on ",(0,r.jsx)(n.em,{children:"form1"})," [by ",(0,r.jsx)(n.em,{children:"step-fun"}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-equals-then::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] = ",(0,r.jsx)(n.em,{children:"form1"})," [then ",(0,r.jsx)(n.em,{children:"form2"}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-across::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] across ",(0,r.jsx)(n.em,{children:"vector"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-hash::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] being ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["each ",(0,r.jsx)(n.em,{children:"|"})," the"]}),"}"]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["{{",(0,r.jsxs)(n.em,{children:["hash-key ",(0,r.jsx)(n.em,{children:"|"})," hash-keys"]}),"} {",(0,r.jsxs)(n.em,{children:["in ",(0,r.jsx)(n.em,{children:"|"})," of"]}),"} hash-table"]})}),"\n",(0,r.jsxs)(n.p,{children:["[using (hash-value ",(0,r.jsx)(n.em,{children:"other-var"}),")] ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["hash-value ",(0,r.jsx)(n.em,{children:"|"})," hash-values"]}),"} {",(0,r.jsxs)(n.em,{children:["in ",(0,r.jsx)(n.em,{children:"|"})," of"]}),"} hash-table"]})}),"\n",(0,r.jsxs)(n.p,{children:["[using (hash-key ",(0,r.jsx)(n.em,{children:"other-var"}),")]",(0,r.jsx)(n.em,{children:"}"})]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201339"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"loop"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"for-as-package::"}),"=",(0,r.jsx)(n.em,{children:"var"})," [",(0,r.jsx)(n.em,{children:"type-spec"}),"] being ",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["each ",(0,r.jsx)(n.em,{children:"|"})," the"]}),"}"]})]}),"\n",(0,r.jsxs)(n.p,{children:["*{*symbol ",(0,r.jsx)(n.em,{children:"|"})," symbols ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["present-symbol ",(0,r.jsx)(n.em,{children:"|"})," present-symbols ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["external-symbol ",(0,r.jsx)(n.em,{children:"|"})," external-symbols*}*"]}),"\n",(0,r.jsxs)(n.p,{children:["[",(0,r.jsxs)(n.em,{children:["{",(0,r.jsxs)(n.em,{children:["in ",(0,r.jsx)(n.em,{children:"|"})," of"]}),"} package"]}),"]"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"type-spec::"}),"=",(0,r.jsx)(n.em,{children:"\u2193simple-type-spec | \u2193destructured-type-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"simple-type-spec::"}),"=",(0,r.jsx)(n.strong,{children:"fixnum"})," ",(0,r.jsx)(n.em,{children:"|"})," ",(0,r.jsx)(n.strong,{children:"float"})," ",(0,r.jsx)(n.em,{children:"|"})," ",(0,r.jsx)(n.strong,{children:"t"})," ",(0,r.jsx)(n.em,{children:"|"})," ",(0,r.jsx)(n.strong,{children:"nil"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"destructured-type-spec::"}),"=of-type ",(0,r.jsx)(n.em,{children:"d-type-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"d-type-spec::"}),"=",(0,r.jsx)(n.em,{children:"type-specifier |"})," (",(0,r.jsx)(n.em,{children:"d-type-spec"})," . ",(0,r.jsx)(n.em,{children:"d-type-spec"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var::"}),"=",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var1::"}),"=",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"var2::"}),"=",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"other-var::"}),"=",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"d-var-spec::"}),"=",(0,r.jsx)(n.em,{children:"simple-var |"})," ",(0,r.jsx)(n.strong,{children:"nil"})," ",(0,r.jsx)(n.em,{children:"|"})," (",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"})," . ",(0,r.jsx)(n.em,{children:"\u2193d-var-spec"}),")"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"compound-form"}),"\u2014a ",(0,r.jsx)(n.em,{children:"compound form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"name"}),"\u2014a ",(0,r.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"simple-var"}),"\u2014a ",(0,r.jsx)(n.em,{children:"symbol"})," (a ",(0,r.jsx)(n.em,{children:"variable"})," name)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"form"}),", ",(0,r.jsx)(n.em,{children:"form1"}),", ",(0,r.jsx)(n.em,{children:"form2"}),", ",(0,r.jsx)(n.em,{children:"form3"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"step-fun"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"})," that evaluates to a ",(0,r.jsx)(n.em,{children:"function"})," of one ",(0,r.jsx)(n.em,{children:"argument"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"vector"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"})," that evaluates to a ",(0,r.jsx)(n.em,{children:"vector"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"hash-table"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"})," that evaluates to a ",(0,r.jsx)(n.em,{children:"hash table"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"package"}),"\u2014a ",(0,r.jsx)(n.em,{children:"form"})," that evaluates to a ",(0,r.jsx)(n.em,{children:"package designator"})," ."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"type-specifier"}),"\u2014a ",(0,r.jsx)(n.em,{children:"type specifier"})," . This might be either an ",(0,r.jsx)(n.em,{children:"atomic type specifier"})," or a ",(0,r.jsx)(n.em,{children:"compound type specifier"})," , which introduces some additional complications to proper parsing in the face of destructuring; for further information, see Section 6.1.1.7 (Destructuring)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"result"}),"\u2014an ",(0,r.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"loop"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"For details, see Section 6.1 (The LOOP Facility)."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.p,{children:";; An example of the simple form of LOOP."}),"\n",(0,r.jsx)(n.p,{children:"(defun sqrt-advisor ()"}),"\n",(0,r.jsx)(n.p,{children:'(loop (format t "~&Number: ")'}),"\n",(0,r.jsxs)(n.p,{children:["(let ((n (parse-integer (read-line) ",":junk-allowed"," t)))"]}),"\n",(0,r.jsx)(n.p,{children:"(when (not n) (return))"}),"\n",(0,r.jsxs)(n.p,{children:['(format t "~&The square root of ~D is ',(0,r.jsx)(n.del,{children:"D."}),'%" n (sqrt n)))))']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," SQRT-ADVISOR"]}),"\n",(0,r.jsx)(n.p,{children:"(sqrt-advisor)"}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: 5",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 The square root of 5 is 2.236068."}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: 4",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 The square root of 4 is 2."}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: done",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; An example of the extended form of LOOP."}),"\n",(0,r.jsx)(n.p,{children:"(defun square-advisor ()"}),"\n",(0,r.jsx)(n.p,{children:'(loop as n = (progn (format t "~&Number: ")'}),"\n",(0,r.jsxs)(n.p,{children:["(parse-integer (read-line) ",":junk-allowed"," t))"]}),"\n",(0,r.jsx)(n.p,{children:"while n"}),"\n",(0,r.jsxs)(n.p,{children:['do (format t "~&The square of ~D is ',(0,r.jsx)(n.del,{children:"D."}),'%" n (* n n))))']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," SQUARE-ADVISOR"]}),"\n",(0,r.jsx)(n.p,{children:"(square-advisor)"}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: 4",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 The square of 4 is 16."}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: 23",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsx)(n.p,{children:"\u25b7 The square of 23 is 529."}),"\n",(0,r.jsxs)(n.p,{children:["\u25b7 Number: done",(0,r.jsx)(n.em,{children:"\u2190-"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," NIL"]}),"\n",(0,r.jsx)(n.p,{children:";; Another example of the extended form of LOOP."}),"\n",(0,r.jsx)(n.p,{children:"(loop for n from 1 to 10"}),"\n",(0,r.jsx)(n.p,{children:"when (oddp n)"}),"\n",(0,r.jsx)(n.p,{children:"collect n)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," (1 3 5 7 9)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"do"}),", ",(0,r.jsx)(n.strong,{children:"dolist"}),", ",(0,r.jsx)(n.strong,{children:"dotimes"}),", ",(0,r.jsx)(n.strong,{children:"return"}),", ",(0,r.jsx)(n.strong,{children:"go"}),", ",(0,r.jsx)(n.strong,{children:"throw"}),", Section 6.1.1.7 (Destructuring)"]}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201341"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["Except that ",(0,r.jsx)(n.strong,{children:"loop-finish"})," cannot be used within a simple ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),", a simple ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," is related to an extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," in the following way:"]}),"\n",(0,r.jsxs)(n.p,{children:["(loop ",(0,r.jsx)(n.em,{children:"{compound-form}"}),"*) ",(0,r.jsx)(n.em,{children:"\u2261"})," (loop do ",(0,r.jsx)(n.em,{children:"{compound-form}"}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop-finish"})," ",(0,r.jsx)(n.em,{children:"Local Macro"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop-finish"})," ",(0,r.jsx)(n.em,{children:"hno argumentsi \u2192"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"loop-finish"})," ",(0,r.jsx)(n.em,{children:"macro"})," can be used lexically within an extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"})," to terminate that ",(0,r.jsx)(n.em,{children:"form"})," \u201cnormally.\u201d That is, it transfers control to the loop epilogue of the lexically innermost extended ",(0,r.jsx)(n.strong,{children:"loop"})," ",(0,r.jsx)(n.em,{children:"form"}),". This permits execution of any ",(0,r.jsx)(n.strong,{children:"finally"})," clause (for effect) and the return of any accumulated result."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.p,{children:";; Terminate the loop, but return the accumulated count."}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 2 3 stop-here 4 5 6)"}),"\n",(0,r.jsx)(n.p,{children:"when (symbolp i) do (loop-finish)"}),"\n",(0,r.jsx)(n.p,{children:"count i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,r.jsx)(n.p,{children:";; The preceding loop is equivalent to:"}),"\n",(0,r.jsx)(n.p,{children:"(loop for i in \u2019(1 2 3 stop-here 4 5 6)"}),"\n",(0,r.jsx)(n.p,{children:"until (symbolp i)"}),"\n",(0,r.jsx)(n.p,{children:"count i)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," 3"]}),"\n",(0,r.jsx)(n.p,{children:";; While LOOP-FINISH can be used can be used in a variety of"}),"\n",(0,r.jsx)(n.p,{children:";; situations it is really most needed in a situation where a need"}),"\n",(0,r.jsx)(n.p,{children:";; to exit is detected at other than the loop\u2019s \u2018top level\u2019"}),"\n",(0,r.jsx)(n.p,{children:";; (where UNTIL or WHEN often work just as well), or where some"}),"\n",(0,r.jsx)(n.p,{children:";; computation must occur between the point where a need to exit is"}),"\n",(0,r.jsx)(n.p,{children:";; detected and the point where the exit actually occurs. For example:"}),"\n",(0,r.jsx)(n.p,{children:"(defun tokenize-sentence (string)"}),"\n",(0,r.jsx)(n.p,{children:"(macrolet ((add-word (wvar svar)"}),"\n",(0,r.jsx)(n.p,{children:"\u2018(when ,wvar"}),"\n",(0,r.jsx)(n.p,{children:"(push (coerce (nreverse ,wvar) \u2019string) ,svar)"}),"\n",(0,r.jsx)(n.p,{children:"(setq ,wvar nil))))"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"loop-finish"})}),"\n",(0,r.jsx)(n.p,{children:"(loop with word = \u2019() and sentence = \u2019() and endpos = nil"}),"\n",(0,r.jsx)(n.p,{children:"for i below (length string)"}),"\n",(0,r.jsx)(n.p,{children:"do (let ((char (aref string i)))"}),"\n",(0,r.jsx)(n.p,{children:"(case char"}),"\n",(0,r.jsx)(n.p,{children:"(#\\Space (add-word word sentence))"}),"\n",(0,r.jsx)(n.p,{children:"(#. (setq endpos (1+ i)) (loop-finish))"}),"\n",(0,r.jsx)(n.p,{children:"(otherwise (push char word))))"}),"\n",(0,r.jsx)(n.p,{children:"finally (add-word word sentence)"}),"\n",(0,r.jsx)(n.p,{children:"(return (values (nreverse sentence) endpos)))))"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"})," TOKENIZE-SENTENCE"]}),"\n",(0,r.jsx)(n.p,{children:'(tokenize-sentence "this is a sentence. this is another sentence.")'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' ("this" "is" "a" "sentence"), 19']}),"\n",(0,r.jsx)(n.p,{children:'(tokenize-sentence "this is a sentence")'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2192"}),' ("this" "is" "a" "sentence"), NIL']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Side Effects:"})}),"\n",(0,r.jsx)(n.p,{children:"Transfers control."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["Whether or not ",(0,r.jsx)(n.strong,{children:"loop-finish"})," is ",(0,r.jsx)(n.em,{children:"fbound"})," in the ",(0,r.jsx)(n.em,{children:"global environment"})," is ",(0,r.jsx)(n.em,{children:"implementation-dependent"}),"; however, the restrictions on redefinition and ",(0,r.jsx)(n.em,{children:"shadowing"})," of ",(0,r.jsx)(n.strong,{children:"loop-finish"})," are the same as for ",(0,r.jsx)(n.em,{children:"symbols"})," in the COMMON-LISP ",(0,r.jsx)(n.em,{children:"package"})," which are ",(0,r.jsx)(n.em,{children:"fbound"})," in the ",(0,r.jsx)(n.em,{children:"global environment"}),". The consequences of attempting to use ",(0,r.jsx)(n.strong,{children:"loop-finish"})," outside of ",(0,r.jsx)(n.strong,{children:"loop"})," are undefined."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"loop"}),", Section 6.1 (The LOOP Facility)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["Iteration ",(0,r.jsx)(n.strong,{children:"6\u201343"})]})]})}function hn(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(cn,{...e})}):cn(e)}const an={title:"6.1 The LOOP Facility"},dn="6.1 The LOOP Facility",xn={id:"chap-6/g-b-the-loop-facility",title:"6.1 The LOOP Facility",description:"6.1.1 Overview of the Loop Facility",source:"@site/docs/chap-6/g-b-the-loop-facility.md",sourceDirName:"chap-6",slug:"/chap-6/g-b-the-loop-facility",permalink:"/cl-language-reference/docs/chap-6/g-b-the-loop-facility",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-6/g-b-the-loop-facility.md",tags:[],version:"current",frontMatter:{title:"6.1 The LOOP Facility"},sidebar:"tutorialSidebar",previous:{title:"6. Iteration",permalink:"/cl-language-reference/docs/category/6-iteration"},next:{title:"intro",permalink:"/cl-language-reference/docs/chap-6/intro"}},pn={},mn=[{value:"6.1.1 Overview of the Loop Facility",id:"611-overview-of-the-loop-facility",level:2},{value:"6.1.1.1 Simple vs Extended Loop",id:"6111-simple-vs-extended-loop",level:3},{value:"6.1.1.1.1 Simple Loop",id:"61111-simple-loop",level:4},{value:"6.1.1.1.2 Extended Loop",id:"61112-extended-loop",level:4},{value:"6.1.1.2 Loop Keywords",id:"6112-loop-keywords",level:3},{value:"6.1.1.3 Parsing Loop Clauses",id:"6113-parsing-loop-clauses",level:3},{value:"6.1.1.4 Expanding Loop Forms",id:"6114-expanding-loop-forms",level:3},{value:"6.1.1.5 Summary of Loop Clauses",id:"6115-summary-of-loop-clauses",level:3},{value:"6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses",id:"61151-summary-of-variable-initialization-and-stepping-clauses",level:4},{value:"6.1.1.5.2 Summary of Value Accumulation Clauses",id:"61152-summary-of-value-accumulation-clauses",level:4},{value:"6.1.1.5.3 Summary of Termination Test Clauses",id:"61153-summary-of-termination-test-clauses",level:4},{value:"6.1.1.5.4 Summary of Unconditional Execution Clauses",id:"61154-summary-of-unconditional-execution-clauses",level:4},{value:"6.1.1.5.5 Summary of Conditional Execution Clauses",id:"61155-summary-of-conditional-execution-clauses",level:4},{value:"6.1.1.5.6 Summary of Miscellaneous Clauses",id:"61156-summary-of-miscellaneous-clauses",level:4},{value:"6.1.1.6 Order of Execution",id:"6116-order-of-execution",level:3},{value:"6.1.1.7 Destructuring",id:"6117-destructuring",level:3},{value:"6.1.1.8 Restrictions on Side",id:"6118-restrictions-on-side",level:3},{value:"6.1.2 Variable Initialization and Stepping Clauses",id:"612-variable-initialization-and-stepping-clauses",level:2},{value:"6.1.2.1 Iteration Control",id:"6121-iteration-control",level:3},{value:"6.1.2.1.1 The for",id:"61211-the-for",level:4},{value:"6.1.2.1.1.1 Examples of for",id:"612111-examples-of-for",level:5},{value:"6.1.2.1.2 The for",id:"61212-the-for",level:4},{value:"6.1.2.1.2.1 Examples of for",id:"612121-examples-of-for",level:5},{value:"6.1.2.1.3 The for",id:"61213-the-for",level:4},{value:"6.1.2.1.3.1 Examples of for",id:"612131-examples-of-for",level:5},{value:"6.1.2.1.4 The for",id:"61214-the-for",level:4},{value:"6.1.2.1.4.1 Examples of for",id:"612141-examples-of-for",level:5},{value:"6.1.2.1.5 The for",id:"61215-the-for",level:4},{value:"6.1.2.1.5.1 Examples of for",id:"612151-examples-of-for",level:5},{value:"6.1.2.1.6 The for",id:"61216-the-for",level:4},{value:"6.1.2.1.7 The for",id:"61217-the-for",level:4},{value:"6.1.2.1.7.1 Examples of for",id:"612171-examples-of-for",level:5},{value:"6.1.2.2 Local Variable Initializations",id:"6122-local-variable-initializations",level:3},{value:"6.1.2.2.1 Examples of WITH clause",id:"61221-examples-of-with-clause",level:4},{value:"6.1.3 Value Accumulation Clauses",id:"613-value-accumulation-clauses",level:2},{value:"6.1.3.1 Examples of COLLECT clause",id:"6131-examples-of-collect-clause",level:3},{value:"6.1.3.2 Examples of APPEND and NCONC clauses",id:"6132-examples-of-append-and-nconc-clauses",level:3},{value:"6.1.3.3 Examples of COUNT clause",id:"6133-examples-of-count-clause",level:3},{value:"6.1.3.4 Examples of MAXIMIZE and MINIMIZE clauses",id:"6134-examples-of-maximize-and-minimize-clauses",level:3},{value:"6.1.3.5 Examples of SUM clause",id:"6135-examples-of-sum-clause",level:3},{value:"6.1.4 Termination Test Clauses",id:"614-termination-test-clauses",level:2},{value:"6.1.4.1 Examples of REPEAT clause",id:"6141-examples-of-repeat-clause",level:3},{value:"6.1.4.2 Examples of ALWAYS",id:"6142-examples-of-always",level:3},{value:"6.1.4.3 Examples of WHILE and UNTIL clauses",id:"6143-examples-of-while-and-until-clauses",level:3},{value:"6.1.5 Unconditional Execution Clauses",id:"615-unconditional-execution-clauses",level:2},{value:"6.1.5.1 Examples of unconditional execution",id:"6151-examples-of-unconditional-execution",level:3},{value:"6.1.6 Conditional Execution Clauses",id:"616-conditional-execution-clauses",level:2},{value:"6.1.6.1 Examples of WHEN clause",id:"6161-examples-of-when-clause",level:3},{value:"6.1.7 Miscellaneous Clauses",id:"617-miscellaneous-clauses",level:2},{value:"6.1.7.1 Control Transfer Clauses",id:"6171-control-transfer-clauses",level:3},{value:"6.1.7.1.1 Examples of NAMED clause",id:"61711-examples-of-named-clause",level:4},{value:"6.1.7.2 Initial and Final Execution",id:"6172-initial-and-final-execution",level:3},{value:"6.1.8 Examples of Miscellaneous Loop Features",id:"618-examples-of-miscellaneous-loop-features",level:2},{value:"6.1.8.1 Examples of clause grouping",id:"6181-examples-of-clause-grouping",level:3},{value:"6.1.9 Notes about Loop",id:"619-notes-about-loop",level:2}];function jn(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"61-the-loop-facility",children:"6.1 The LOOP Facility"}),"\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(n.h2,{id:"611-overview-of-the-loop-facility",children:"6.1.1 Overview of the Loop Facility"}),"\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h3,{id:"6111-simple-vs-extended-loop",children:"6.1.1.1 Simple vs Extended Loop"}),"\n","\n",(0,r.jsx)(a,{}),"\n",(0,r.jsx)(n.h4,{id:"61111-simple-loop",children:"6.1.1.1.1 Simple Loop"}),"\n","\n",(0,r.jsx)(x,{}),"\n",(0,r.jsx)(n.h4,{id:"61112-extended-loop",children:"6.1.1.1.2 Extended Loop"}),"\n","\n",(0,r.jsx)(m,{}),"\n",(0,r.jsx)(n.h3,{id:"6112-loop-keywords",children:"6.1.1.2 Loop Keywords"}),"\n","\n",(0,r.jsx)(u,{}),"\n",(0,r.jsx)(n.h3,{id:"6113-parsing-loop-clauses",children:"6.1.1.3 Parsing Loop Clauses"}),"\n","\n",(0,r.jsx)(g,{}),"\n",(0,r.jsx)(n.h3,{id:"6114-expanding-loop-forms",children:"6.1.1.4 Expanding Loop Forms"}),"\n","\n",(0,r.jsx)(v,{}),"\n",(0,r.jsx)(n.h3,{id:"6115-summary-of-loop-clauses",children:"6.1.1.5 Summary of Loop Clauses"}),"\n","\n",(0,r.jsx)(w,{}),"\n",(0,r.jsx)(n.h4,{id:"61151-summary-of-variable-initialization-and-stepping-clauses",children:"6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses"}),"\n","\n",(0,r.jsx)(k,{}),"\n",(0,r.jsx)(n.h4,{id:"61152-summary-of-value-accumulation-clauses",children:"6.1.1.5.2 Summary of Value Accumulation Clauses"}),"\n","\n",(0,r.jsx)(E,{}),"\n",(0,r.jsx)(n.h4,{id:"61153-summary-of-termination-test-clauses",children:"6.1.1.5.3 Summary of Termination Test Clauses"}),"\n","\n",(0,r.jsx)(L,{}),"\n",(0,r.jsx)(n.h4,{id:"61154-summary-of-unconditional-execution-clauses",children:"6.1.1.5.4 Summary of Unconditional Execution Clauses"}),"\n","\n",(0,r.jsx)(F,{}),"\n",(0,r.jsx)(n.h4,{id:"61155-summary-of-conditional-execution-clauses",children:"6.1.1.5.5 Summary of Conditional Execution Clauses"}),"\n","\n",(0,r.jsx)(z,{}),"\n",(0,r.jsx)(n.h4,{id:"61156-summary-of-miscellaneous-clauses",children:"6.1.1.5.6 Summary of Miscellaneous Clauses"}),"\n","\n",(0,r.jsx)(q,{}),"\n",(0,r.jsx)(n.h3,{id:"6116-order-of-execution",children:"6.1.1.6 Order of Execution"}),"\n","\n",(0,r.jsx)(D,{}),"\n",(0,r.jsx)(n.h3,{id:"6117-destructuring",children:"6.1.1.7 Destructuring"}),"\n","\n",(0,r.jsx)(M,{}),"\n",(0,r.jsx)(n.h3,{id:"6118-restrictions-on-side",children:"6.1.1.8 Restrictions on Side"}),"\n","\n",(0,r.jsx)(W,{}),"\n",(0,r.jsx)(n.h2,{id:"612-variable-initialization-and-stepping-clauses",children:"6.1.2 Variable Initialization and Stepping Clauses"}),"\n","\n",(0,r.jsx)(B,{}),"\n",(0,r.jsx)(n.h3,{id:"6121-iteration-control",children:"6.1.2.1 Iteration Control"}),"\n","\n",(0,r.jsx)(V,{}),"\n",(0,r.jsx)(n.h4,{id:"61211-the-for",children:"6.1.2.1.1 The for"}),"\n","\n",(0,r.jsx)(X,{}),"\n",(0,r.jsx)(n.h5,{id:"612111-examples-of-for",children:"6.1.2.1.1.1 Examples of for"}),"\n","\n",(0,r.jsx)(Z,{}),"\n",(0,r.jsx)(n.h4,{id:"61212-the-for",children:"6.1.2.1.2 The for"}),"\n","\n",(0,r.jsx)(_,{}),"\n",(0,r.jsx)(n.h5,{id:"612121-examples-of-for",children:"6.1.2.1.2.1 Examples of for"}),"\n","\n",(0,r.jsx)(Q,{}),"\n",(0,r.jsx)(n.h4,{id:"61213-the-for",children:"6.1.2.1.3 The for"}),"\n","\n",(0,r.jsx)(ee,{}),"\n",(0,r.jsx)(n.h5,{id:"612131-examples-of-for",children:"6.1.2.1.3.1 Examples of for"}),"\n","\n",(0,r.jsx)(se,{}),"\n",(0,r.jsx)(n.h4,{id:"61214-the-for",children:"6.1.2.1.4 The for"}),"\n","\n",(0,r.jsx)(ie,{}),"\n",(0,r.jsx)(n.h5,{id:"612141-examples-of-for",children:"6.1.2.1.4.1 Examples of for"}),"\n","\n",(0,r.jsx)(le,{}),"\n",(0,r.jsx)(n.h4,{id:"61215-the-for",children:"6.1.2.1.5 The for"}),"\n","\n",(0,r.jsx)(ce,{}),"\n",(0,r.jsx)(n.h5,{id:"612151-examples-of-for",children:"6.1.2.1.5.1 Examples of for"}),"\n","\n",(0,r.jsx)(ae,{}),"\n",(0,r.jsx)(n.h4,{id:"61216-the-for",children:"6.1.2.1.6 The for"}),"\n","\n",(0,r.jsx)(xe,{}),"\n",(0,r.jsx)(n.h4,{id:"61217-the-for",children:"6.1.2.1.7 The for"}),"\n","\n",(0,r.jsx)(me,{}),"\n",(0,r.jsx)(n.h5,{id:"612171-examples-of-for",children:"6.1.2.1.7.1 Examples of for"}),"\n","\n",(0,r.jsx)(ue,{}),"\n",(0,r.jsx)(n.h3,{id:"6122-local-variable-initializations",children:"6.1.2.2 Local Variable Initializations"}),"\n","\n",(0,r.jsx)(ge,{}),"\n",(0,r.jsx)(n.h4,{id:"61221-examples-of-with-clause",children:"6.1.2.2.1 Examples of WITH clause"}),"\n","\n",(0,r.jsx)(ve,{}),"\n",(0,r.jsx)(n.h2,{id:"613-value-accumulation-clauses",children:"6.1.3 Value Accumulation Clauses"}),"\n","\n",(0,r.jsx)(we,{}),"\n",(0,r.jsx)(n.h3,{id:"6131-examples-of-collect-clause",children:"6.1.3.1 Examples of COLLECT clause"}),"\n","\n",(0,r.jsx)(ke,{}),"\n",(0,r.jsx)(n.h3,{id:"6132-examples-of-append-and-nconc-clauses",children:"6.1.3.2 Examples of APPEND and NCONC clauses"}),"\n","\n",(0,r.jsx)(Ee,{}),"\n",(0,r.jsx)(n.h3,{id:"6133-examples-of-count-clause",children:"6.1.3.3 Examples of COUNT clause"}),"\n","\n",(0,r.jsx)(Le,{}),"\n",(0,r.jsx)(n.h3,{id:"6134-examples-of-maximize-and-minimize-clauses",children:"6.1.3.4 Examples of MAXIMIZE and MINIMIZE clauses"}),"\n","\n",(0,r.jsx)(Fe,{}),"\n",(0,r.jsx)(n.h3,{id:"6135-examples-of-sum-clause",children:"6.1.3.5 Examples of SUM clause"}),"\n","\n",(0,r.jsx)(ze,{}),"\n",(0,r.jsx)(n.h2,{id:"614-termination-test-clauses",children:"6.1.4 Termination Test Clauses"}),"\n","\n",(0,r.jsx)(qe,{}),"\n",(0,r.jsx)(n.h3,{id:"6141-examples-of-repeat-clause",children:"6.1.4.1 Examples of REPEAT clause"}),"\n","\n",(0,r.jsx)(De,{}),"\n",(0,r.jsx)(n.h3,{id:"6142-examples-of-always",children:"6.1.4.2 Examples of ALWAYS"}),"\n","\n",(0,r.jsx)(Me,{}),"\n",(0,r.jsx)(n.h3,{id:"6143-examples-of-while-and-until-clauses",children:"6.1.4.3 Examples of WHILE and UNTIL clauses"}),"\n","\n",(0,r.jsx)(We,{}),"\n",(0,r.jsx)(n.h2,{id:"615-unconditional-execution-clauses",children:"6.1.5 Unconditional Execution Clauses"}),"\n","\n",(0,r.jsx)(Be,{}),"\n",(0,r.jsx)(n.h3,{id:"6151-examples-of-unconditional-execution",children:"6.1.5.1 Examples of unconditional execution"}),"\n","\n",(0,r.jsx)(Ve,{}),"\n",(0,r.jsx)(n.h2,{id:"616-conditional-execution-clauses",children:"6.1.6 Conditional Execution Clauses"}),"\n","\n",(0,r.jsx)(Xe,{}),"\n",(0,r.jsx)(n.h3,{id:"6161-examples-of-when-clause",children:"6.1.6.1 Examples of WHEN clause"}),"\n","\n",(0,r.jsx)(Ze,{}),"\n",(0,r.jsx)(n.h2,{id:"617-miscellaneous-clauses",children:"6.1.7 Miscellaneous Clauses"}),"\n","\n",(0,r.jsx)(_e,{}),"\n",(0,r.jsx)(n.h3,{id:"6171-control-transfer-clauses",children:"6.1.7.1 Control Transfer Clauses"}),"\n","\n",(0,r.jsx)(Qe,{}),"\n",(0,r.jsx)(n.h4,{id:"61711-examples-of-named-clause",children:"6.1.7.1.1 Examples of NAMED clause"}),"\n","\n",(0,r.jsx)(en,{}),"\n",(0,r.jsx)(n.h3,{id:"6172-initial-and-final-execution",children:"6.1.7.2 Initial and Final Execution"}),"\n","\n",(0,r.jsx)(sn,{}),"\n",(0,r.jsx)(n.h2,{id:"618-examples-of-miscellaneous-loop-features",children:"6.1.8 Examples of Miscellaneous Loop Features"}),"\n","\n",(0,r.jsx)(tn,{}),"\n",(0,r.jsx)(n.h3,{id:"6181-examples-of-clause-grouping",children:"6.1.8.1 Examples of clause grouping"}),"\n","\n",(0,r.jsx)(on,{}),"\n",(0,r.jsx)(n.h2,{id:"619-notes-about-loop",children:"6.1.9 Notes about Loop"}),"\n","\n","\n",(0,r.jsx)(hn,{})]})}function un(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(jn,{...e})}):jn(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>l});var r=s(7294);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);