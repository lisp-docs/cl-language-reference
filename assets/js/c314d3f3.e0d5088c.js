"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[68928],{57928:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>h,default:()=>j,frontMatter:()=>l,metadata:()=>o,toc:()=>m});var r=i(85893),s=i(11151);function t(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components},{DictionaryLink:i,GlossaryTerm:t}=n;return i||d("DictionaryLink",!0),t||d("GlossaryTerm",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"defgeneric"})," ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"Macro"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," ",(0,r.jsx)(n.em,{children:"function-name gf-lambda-list"})," [[ ",(0,r.jsx)(n.em,{children:"\u2193option | {\u2193method-description}"}),"* ]]"]}),"\n",(0,r.jsx)(n.p,{children:"\u2192 new-generic"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"option::"}),"=(",":argument-precedence-order"," ",(0,r.jsx)(n.em,{children:"{parameter-name}"}),(0,r.jsx)("sup",{children:"+"}),") ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})})," ",(0,r.jsx)(n.em,{children:"{gf-declaration}"}),(0,r.jsx)("sup",{children:"+"}),") ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["(",":documentation"," ",(0,r.jsx)(n.em,{children:"gf-documentation"}),") ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["(",":method-combination"," ",(0,r.jsx)(n.em,{children:"method-combination {method-combination-argument}"}),"*) ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["(",":generic-function-class"," ",(0,r.jsx)(n.em,{children:"generic-function-class"}),") ",(0,r.jsx)(n.em,{children:"|"})]}),"\n",(0,r.jsxs)(n.p,{children:["(",":method-class"," ",(0,r.jsx)(n.em,{children:"method-class"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-description::"}),"=(",":method"," ",(0,r.jsx)(n.em,{children:"{method-qualifier}"}),"* ",(0,r.jsx)(n.em,{children:"specialized-lambda-list"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:["[[ ",(0,r.jsx)(t,{term:"declaration",children:(0,r.jsx)("i",{children:"{declaration}"})}),"* ",(0,r.jsx)(n.em,{children:"| documentation"})," ]] ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"{form}"})}),"*)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"function-name"}),"\u2014a ",(0,r.jsx)(n.em,{children:"function name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"generic-function-class"}),"\u2014a ",(0,r.jsx)(n.em,{children:"non-nil symbol"})," naming a ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"gf-declaration"}),"\u2014an ",(0,r.jsx)(i,{term:"optimize",children:(0,r.jsx)("b",{children:"optimize"})})," ",(0,r.jsx)(n.em,{children:"declaration specifier"})," ; other ",(0,r.jsx)(n.em,{children:"declaration specifiers"})," are not permitted. ",(0,r.jsx)(n.em,{children:"gf-documentation"}),"\u2014a ",(0,r.jsx)(t,{term:"string",children:(0,r.jsx)("i",{children:"string"})}),"; not evaluated."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"gf-lambda-list"}),"\u2014a ",(0,r.jsx)(n.em,{children:"generic function lambda list"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-class"}),"\u2014a ",(0,r.jsx)(n.em,{children:"non-nil symbol"})," naming a ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-combination-argument"}),"\u2014an ",(0,r.jsx)(t,{term:"object",children:(0,r.jsx)("i",{children:"object."})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-combination-name"}),"\u2014a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," naming a ",(0,r.jsx)(n.em,{children:"method combination type"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"method-qualifiers"}),", ",(0,r.jsx)(n.em,{children:"specialized-lambda-list"}),", ",(0,r.jsx)(t,{term:"declaration",children:(0,r.jsx)("i",{children:"declarations"})}),", ",(0,r.jsx)(n.em,{children:"documentation"}),", ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"forms"})}),"\u2014as per ",(0,r.jsx)(i,{term:"defmethod",children:(0,r.jsx)("b",{children:"defmethod"})}),". ",(0,r.jsx)(n.em,{children:"new-generic"}),"\u2014the ",(0,r.jsx)(n.em,{children:"generic function object"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"parameter-name"}),"\u2014a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})})," that names a ",(0,r.jsx)(n.em,{children:"required parameter"})," in the ",(0,r.jsx)(n.em,{children:"lambda-list"}),". (If the ",":argument-precedence-order"," option is specified, each ",(0,r.jsx)(n.em,{children:"required parameter"})," in the ",(0,r.jsx)(n.em,{children:"lambda-list"})," must be used exactly once as a ",(0,r.jsx)(n.em,{children:"parameter-name"}),".)"]}),"\n",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["The macro ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," is used to define a ",(0,r.jsx)(n.em,{children:"generic function"})," or to specify options and declarations that pertain to a ",(0,r.jsx)(n.em,{children:"generic function"})," as a whole."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"function-name"})," is a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," it must be of the form (setf ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"). If (fboundp ",(0,r.jsx)(n.em,{children:"function-name"}),") is ",(0,r.jsx)(t,{term:"false",children:(0,r.jsx)("i",{children:"false"})}),", a new ",(0,r.jsx)(n.em,{children:"generic function"})," is created. If (fdefinition ",(0,r.jsx)(n.em,{children:"function-name"}),") is a ",(0,r.jsx)(n.em,{children:"generic function"}),", that ",(0,r.jsx)(n.em,{children:"generic function"})," is modified. If ",(0,r.jsx)(n.em,{children:"function-name"})," names an ",(0,r.jsx)(n.em,{children:"ordinary function"}),", a ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or a ",(0,r.jsx)(n.em,{children:"special operator"})," , an error is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["The effect of the ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," macro is as if the following three steps were performed: first, ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," defined by previous ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"forms"})})," are removed; second, ",(0,r.jsx)(i,{term:"ensure-generic-function",children:(0,r.jsx)("b",{children:"ensure-generic-function"})})," is called; and finally, ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," specified by the current ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," are added to the ",(0,r.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.em,{children:"method-description"})," defines a ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," on the ",(0,r.jsx)(n.em,{children:"generic function"}),". The ",(0,r.jsx)(n.em,{children:"lambda list"})," of each ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," must be congruent with the ",(0,r.jsx)(n.em,{children:"lambda list"})," specified by the ",(0,r.jsx)(n.em,{children:"gf-lambda-list"})," option. If no ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," descriptions are specified and a ",(0,r.jsx)(n.em,{children:"generic function"})," of the same name does not already exist, a ",(0,r.jsx)(n.em,{children:"generic function"})," with no ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," is created."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"gf-lambda-list"})," argument of ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," specifies the shape of ",(0,r.jsx)(n.em,{children:"lambda lists"})," for the ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," on this ",(0,r.jsx)(n.em,{children:"generic function"}),". All ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," on the resulting ",(0,r.jsx)(n.em,{children:"generic function"})," must have ",(0,r.jsx)(n.em,{children:"lambda lists"})," that are congruent with this shape. If a ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," form is evaluated and some ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," for that ",(0,r.jsx)(n.em,{children:"generic function"})," have ",(0,r.jsx)(n.em,{children:"lambda lists"})," that are not congruent with that given in the ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," form, an error is signaled. For further details on method congruence, see Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"generic function"})," passes to the ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," all the argument values passed to it, and only those; default values are not supported. Note that optional and keyword arguments in method definitions, however, can have default initial value forms and can use supplied-p parameters."]}),"\n",(0,r.jsx)(n.p,{children:"The following options are provided. Except as otherwise noted, a given option may occur only once."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",":argument-precedence-order"," option is used to specify the order in which the required arguments in a call to the ",(0,r.jsx)(n.em,{children:"generic function"})," are tested for specificity when selecting a particular ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})}),". Each required argument, as specified in the ",(0,r.jsx)(n.em,{children:"gf-lambda-list"})," argument, must be included exactly once as a ",(0,r.jsx)(n.em,{children:"parameter-name"})," so that the full and unambiguous precedence order is supplied. If this condition is not met, an error is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})})," option is used to specify declarations that pertain to the ",(0,r.jsx)(n.em,{children:"generic function"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(i,{term:"optimize",children:(0,r.jsx)("b",{children:"optimize"})})," ",(0,r.jsx)(n.em,{children:"declaration specifier"})," is allowed. It specifies whether method selection should be optimized for speed or space, but it has no effect on ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})}),". To control how a ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," is optimized, an ",(0,r.jsx)(i,{term:"optimize",children:(0,r.jsx)("b",{children:"optimize"})})," declaration must be placed directly in the ",(0,r.jsx)(i,{term:"defmethod",children:(0,r.jsx)("b",{children:"defmethod"})})," ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," or method description. The optimization qualities ",(0,r.jsx)(n.strong,{children:"speed"})," and ",(0,r.jsx)(n.strong,{children:"space"})," are the only qualities this standard requires, but an implementation can extend the object system to recognize other qualities. A simple implementation that has only one method selection technique and ignores ",(0,r.jsx)(i,{term:"optimize",children:(0,r.jsx)("b",{children:"optimize"})})," ",(0,r.jsx)(n.em,{children:"declaration specifiers"})," is valid."]}),"\n",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(i,{term:"special",children:(0,r.jsx)("b",{children:"special"})}),", ",(0,r.jsx)(i,{term:"ftype",children:(0,r.jsx)("b",{children:"ftype"})}),", ",(0,r.jsx)(i,{term:"function",children:(0,r.jsx)("b",{children:"function"})}),", ",(0,r.jsx)(i,{term:"inline",children:(0,r.jsx)("b",{children:"inline"})}),", ",(0,r.jsx)(i,{term:"notinline",children:(0,r.jsx)("b",{children:"notinline"})}),", and ",(0,r.jsx)(i,{term:"declaration",children:(0,r.jsx)("b",{children:"declaration"})})," declarations are not permitted. Individual implementations can extend the ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})})," option to support additional declarations. If an implementation notices a ",(0,r.jsx)(n.em,{children:"declaration specifier"})," that it does not support and that has not been proclaimed as a non-standard ",(0,r.jsx)(n.em,{children:"declaration identifier"})," name in a ",(0,r.jsx)(i,{term:"declaration",children:(0,r.jsx)("b",{children:"declaration"})})," ",(0,r.jsx)(t,{term:"proclamation",children:(0,r.jsx)("i",{children:"proclamation"})}),", it should issue a warning."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})})," option may be specified more than once. The effect is the same as if the lists of ",(0,r.jsx)(n.em,{children:"declaration specifiers"})," had been appended together into a single list and specified as a single ",(0,r.jsx)(i,{term:"declare",children:(0,r.jsx)("b",{children:"declare"})})," option."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",":documentation"," argument is a ",(0,r.jsx)(n.em,{children:"documentation string"})," to be attached to the ",(0,r.jsx)(n.em,{children:"generic function object"}),", and to be attached with kind ",(0,r.jsx)(i,{term:"function",children:(0,r.jsx)("b",{children:"function"})})," to the ",(0,r.jsx)(n.em,{children:"function-name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",":generic-function-class"," option may be used to specify that the ",(0,r.jsx)(n.em,{children:"generic function"})," is to have a different ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," than the default provided by the system (the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," ",(0,r.jsx)(i,{term:"standard-generic-function",children:(0,r.jsx)("b",{children:"standard-generic-function"})}),"). The ",(0,r.jsx)(n.em,{children:"class-name"})," argument is the name of a ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," that can be the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," of a ",(0,r.jsx)(n.em,{children:"generic function"}),". If ",(0,r.jsx)(n.em,{children:"function-name"})," specifies an existing ",(0,r.jsx)(n.em,{children:"generic function"})," that has a different value for the ",":generic-function-class"," argument and the new generic function ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," is compatible with the old, ",(0,r.jsx)(i,{term:"change-class",children:(0,r.jsx)("b",{children:"change-class"})})," is called to change the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," of the ",(0,r.jsx)(n.em,{children:"generic function"}),"; otherwise an error is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",":method-class"," option is used to specify that all ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," on this ",(0,r.jsx)(n.em,{children:"generic function"})," are to have a different ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," from the default provided by the system (the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," ",(0,r.jsx)(i,{term:"standard-method",children:(0,r.jsx)("b",{children:"standard-method"})}),"). The ",(0,r.jsx)(n.em,{children:"class-name"})," argument is the name of a ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," that is capable of being the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," of a ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"\u2022"})," The ",":method-combination"," option is followed by a symbol that names a type of method combination. The arguments (if any) that follow that symbol depend on the type of method combination. Note that the standard method combination type does not support any arguments. However, all types of method combination defined by the short form of ",(0,r.jsx)(i,{term:"define-method-combination",children:(0,r.jsx)("b",{children:"define-method-combination"})})," accept an optional argument named ",(0,r.jsx)(n.em,{children:"order"}),", defaulting to ",":most-specific-first",", where a value of ",":most-specific-last"," reverses the order of the primary ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," without affecting the order of the auxiliary ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"method-description"})," arguments define ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," that will be associated with the ",(0,r.jsx)(n.em,{children:"generic function"}),". The ",(0,r.jsx)(n.em,{children:"method-qualifier"})," and ",(0,r.jsx)(n.em,{children:"specialized-lambda-list"})," arguments in a method description are the same as for ",(0,r.jsx)(i,{term:"defmethod",children:(0,r.jsx)("b",{children:"defmethod"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(t,{term:"form",children:(0,r.jsx)("i",{children:"form"})})," arguments specify the method body. The body of the ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," is enclosed in an ",(0,r.jsx)(n.em,{children:"implicit block"}),". If ",(0,r.jsx)(n.em,{children:"function-name"})," is a ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),", this block bears the same name as the ",(0,r.jsx)(n.em,{children:"generic function"}),". If ",(0,r.jsx)(n.em,{children:"function-name"})," is a ",(0,r.jsx)(t,{term:"list",children:(0,r.jsx)("i",{children:"list"})})," of the form (setf ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"), the name of the block is ",(0,r.jsx)(t,{term:"symbol",children:(0,r.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Implementations can extend ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," to include other options. It is required that an implementation signal an error if it observes an option that is not implemented locally."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," is not required to perform any compile-time side effects. In particular, the ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," are not installed for invocation during compilation. An ",(0,r.jsx)(t,{term:"implementation",children:(0,r.jsx)("i",{children:"implementation"})})," may choose to store"]}),"\n",(0,r.jsxs)(n.p,{children:["information about the ",(0,r.jsx)(t,{styled:!0,term:"generic function",children:(0,r.jsx)("i",{children:"generic function"})})," for the purposes of compile-time error-checking (such as checking the number of arguments on calls, or noting that a definition for the function name has been seen)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"function-name"})," names an ",(0,r.jsx)(t,{styled:!0,term:"ordinary function",children:(0,r.jsx)("i",{children:"ordinary function"})}),", a ",(0,r.jsx)(t,{term:"macro",children:(0,r.jsx)("i",{children:"macro"})}),", or a ",(0,r.jsx)(t,{styled:!0,term:"special operator",children:(0,r.jsx)("i",{children:"special operator"})})," , an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"program-error",children:(0,r.jsx)("b",{children:"program-error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["Each required argument, as specified in the ",(0,r.jsx)(n.em,{children:"gf-lambda-list"})," argument, must be included exactly once as a ",(0,r.jsx)(n.em,{children:"parameter-name"}),", or an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"program-error",children:(0,r.jsx)("b",{children:"program-error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(t,{styled:!0,term:"lambda list",children:(0,r.jsx)("i",{children:"lambda list"})})," of each ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"method"})})," specified by a ",(0,r.jsx)(n.em,{children:"method-description"})," must be congruent with the ",(0,r.jsx)(t,{styled:!0,term:"lambda list",children:(0,r.jsx)("i",{children:"lambda list"})})," specified by the ",(0,r.jsx)(n.em,{children:"gf-lambda-list"})," option, or an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"error",children:(0,r.jsx)("b",{children:"error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," form is evaluated and some ",(0,r.jsx)(t,{term:"method",children:(0,r.jsx)("i",{children:"methods"})})," for that ",(0,r.jsx)(t,{styled:!0,term:"generic function",children:(0,r.jsx)("i",{children:"generic function"})})," have ",(0,r.jsx)(t,{styled:!0,term:"lambda list",children:(0,r.jsx)("i",{children:"lambda lists"})})," that are not congruent with that given in the ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," form, an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"error",children:(0,r.jsx)("b",{children:"error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["A given ",(0,r.jsx)(n.em,{children:"option"})," may occur only once, or an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"program-error",children:(0,r.jsx)("b",{children:"program-error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"function-name"})," specifies an existing ",(0,r.jsx)(t,{styled:!0,term:"generic function",children:(0,r.jsx)("i",{children:"generic function"})})," that has a different value for the ",":generic-function-class"," argument and the new generic function ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," is compatible with the old, ",(0,r.jsx)(i,{term:"change-class",children:(0,r.jsx)("b",{children:"change-class"})})," is called to change the ",(0,r.jsx)(t,{term:"class",children:(0,r.jsx)("i",{children:"class"})})," of the ",(0,r.jsx)(t,{styled:!0,term:"generic function",children:(0,r.jsx)("i",{children:"generic function"})}),"; otherwise an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"error",children:(0,r.jsx)("b",{children:"error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["Implementations can extend ",(0,r.jsx)(i,{term:"defgeneric",children:(0,r.jsx)("b",{children:"defgeneric"})})," to include other options. It is required that an implementation signal an error of ",(0,r.jsx)(t,{term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(i,{term:"program-error",children:(0,r.jsx)("b",{children:"program-error"})})," if it observes an option that is not implemented locally."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(i,{term:"defmethod",children:(0,r.jsx)("b",{children:"defmethod"})}),", ",(0,r.jsx)(n.strong,{children:"documentation"}),", ",(0,r.jsx)(i,{term:"ensure-generic-function",children:(0,r.jsx)("b",{children:"ensure-generic-function"})}),", ",(0,r.jsx)(i,{term:"generic-function",children:(0,r.jsx)("b",{children:"generic-function"})}),", Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function)"]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const l={title:"defgeneric"},h="defgeneric",o={id:"chap-7/h-h-dictionary/defgeneric_macro",title:"defgeneric",description:"Expanded Reference: defgeneric",source:"@site/docs/chap-7/h-h-dictionary/defgeneric_macro.md",sourceDirName:"chap-7/h-h-dictionary",slug:"/chap-7/h-h-dictionary/defgeneric_macro",permalink:"/cl-language-reference/chap-7/h-h-dictionary/defgeneric_macro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-7/h-h-dictionary/defgeneric_macro.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"defgeneric"},sidebar:"tutorialSidebar",previous:{title:"defclass",permalink:"/cl-language-reference/chap-7/h-h-dictionary/defclass_macro"},next:{title:"define-method-combination",permalink:"/cl-language-reference/chap-7/h-h-dictionary/define-method-combination_macro"}},a={},m=[{value:"Expanded Reference: defgeneric",id:"expanded-reference-defgeneric",level:2}];function x(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"defgeneric",children:"defgeneric"}),"\n","\n","\n",(0,r.jsx)(c,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-defgeneric",children:"Expanded Reference: defgeneric"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(defgeneric )\n"})})]})}function j(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>c});var r=i(67294);const s={},t=r.createContext(s);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);