"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[34164],{85555:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>h});var t=i(85893),s=i(11151);function o(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"define-condition"})," ",(0,t.jsx)(n.em,{children:"Macro"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"define-condition"})," ",(0,t.jsx)(n.em,{children:"name"})," (",(0,t.jsx)(n.em,{children:"{parent-type}"}),"*) (",(0,t.jsx)(n.em,{children:"{\u2193slot-spec}"}),"*) ",(0,t.jsx)(n.em,{children:"{option}"}),"*"]}),"\n",(0,t.jsx)(n.p,{children:"\u2192 name"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"slot-spec::"}),"=",(0,t.jsx)(n.em,{children:"slot-name |"})," (",(0,t.jsx)(n.em,{children:"slot-name \u2193slot-option"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"slot-option::"}),"=[[ ",(0,t.jsx)(n.em,{children:"{"}),":reader"," ",(0,t.jsx)(n.em,{children:"symbol}"}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":writer"," ",(0,t.jsx)(n.em,{children:"\u2193function-name}"}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":accessor"," ",(0,t.jsx)(n.em,{children:"symbol}"}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":allocation"," ",(0,t.jsx)(n.em,{children:"\u2193allocation-type} |"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":initarg"," ",(0,t.jsx)(n.em,{children:"symbol}"}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":initform"," ",(0,t.jsx)(n.em,{children:"form} |"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":type"," ",(0,t.jsx)(n.em,{children:"type-specifier}"})," ]]"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"option::"}),"=[[(",":default-initargs"," . ",(0,t.jsx)(n.em,{children:"initarg-list"}),") ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:["(",":documentation"," ",(0,t.jsx)(n.em,{children:"string"}),") ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:["(",":report"," ",(0,t.jsx)(n.em,{children:"report-name"}),") ]]"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"function-name::"}),"=",(0,t.jsx)(n.em,{children:"{symbol |"})," (setf ",(0,t.jsx)(n.em,{children:"symbol"}),")",(0,t.jsx)(n.em,{children:"}"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"allocation-type::"}),"=",":instance"," ",(0,t.jsx)(n.em,{children:"|"})," ",":class"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"report-name::"}),"=",(0,t.jsx)(n.em,{children:"string | symbol | lambda expression"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"name"}),"\u2014a ",(0,t.jsx)(n.em,{children:"symbol"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"parent-type"}),"\u2014a ",(0,t.jsx)(n.em,{children:"symbol"})," naming a ",(0,t.jsx)(n.em,{children:"condition type"}),". If no ",(0,t.jsx)(n.em,{children:"parent-types"})," are supplied, the ",(0,t.jsx)(n.em,{children:"parent-types"})," default to (condition)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"default-initargs"}),"\u2014a ",(0,t.jsx)(n.em,{children:"list"})," of ",(0,t.jsx)(n.em,{children:"keyword/value pairs"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Slot-spec"})," \u2013 the ",(0,t.jsx)(n.em,{children:"name"})," of a ",(0,t.jsx)(n.em,{children:"slot"})," or a ",(0,t.jsx)(n.em,{children:"list"})," consisting of the ",(0,t.jsx)(n.em,{children:"slot-name"})," followed by zero or more ",(0,t.jsx)(n.em,{children:"slot-options"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Slot-name"})," \u2013 a slot name (a ",(0,t.jsx)(n.em,{children:"symbol"}),"), the ",(0,t.jsx)(n.em,{children:"list"})," of a slot name, or the ",(0,t.jsx)(n.em,{children:"list"})," of slot name/slot form pairs. ",(0,t.jsx)(n.em,{children:"Option"})," \u2013 Any of the following:"]}),"\n",(0,t.jsx)(n.p,{children:":reader"}),"\n",(0,t.jsxs)(n.p,{children:[":reader"," can be supplied more than once for a given ",(0,t.jsx)(n.em,{children:"slot"})," and cannot be ",(0,t.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":writer"}),"\n",(0,t.jsxs)(n.p,{children:[":writer"," can be supplied more than once for a given ",(0,t.jsx)(n.em,{children:"slot"})," and must name a ",(0,t.jsx)(n.em,{children:"generic function"}),". ",":accessor"]}),"\n",(0,t.jsxs)(n.p,{children:[":accessor"," can be supplied more than once for a given ",(0,t.jsx)(n.em,{children:"slot"})," and cannot be ",(0,t.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":allocation"}),"\n",(0,t.jsxs)(n.p,{children:[":allocation"," can be supplied once at most for a given ",(0,t.jsx)(n.em,{children:"slot"}),". The default if ",":allocation"," is not supplied is ",":instance","."]}),"\n",(0,t.jsx)(n.p,{children:":initarg"}),"\n",(0,t.jsxs)(n.p,{children:[":initarg"," can be supplied more than once for a given ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":initform"}),"\n",(0,t.jsxs)(n.p,{children:[":initform"," can be supplied once at most for a given ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":type"}),"\n",(0,t.jsxs)(n.p,{children:[":type"," can be supplied once at most for a given ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"define-condition"})}),"\n",(0,t.jsx)(n.p,{children:":documentation"}),"\n",(0,t.jsxs)(n.p,{children:[":documentation"," can be supplied once at most for a given ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":report"}),"\n",(0,t.jsxs)(n.p,{children:[":report"," can be supplied once at most."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"define-condition"})," defines a new condition type called ",(0,t.jsx)(n.em,{children:"name"}),", which is a ",(0,t.jsx)(n.em,{children:"subtype"})," of the ",(0,t.jsx)(n.em,{children:"type"})," or ",(0,t.jsx)(n.em,{children:"types"})," named by ",(0,t.jsx)(n.em,{children:"parent-type"}),". Each ",(0,t.jsx)(n.em,{children:"parent-type"})," argument specifies a direct ",(0,t.jsx)(n.em,{children:"supertype"})," of the new ",(0,t.jsx)(n.em,{children:"condition"}),". The new ",(0,t.jsx)(n.em,{children:"condition"})," inherits ",(0,t.jsx)(n.em,{children:"slots"})," and ",(0,t.jsx)(n.em,{children:"methods"})," from each of its direct ",(0,t.jsx)(n.em,{children:"supertypes"}),", and so on."]}),"\n",(0,t.jsxs)(n.p,{children:["If a slot name/slot form pair is supplied, the slot form is a ",(0,t.jsx)(n.em,{children:"form"})," that can be evaluated by ",(0,t.jsx)(n.strong,{children:"make-condition"})," to produce a default value when an explicit value is not provided. If no slot form is supplied, the contents of the ",(0,t.jsx)(n.em,{children:"slot"})," is initialized in an ",(0,t.jsx)(n.em,{children:"implementation-dependent"})," way."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.em,{children:"type"})," being defined and some other ",(0,t.jsx)(n.em,{children:"type"})," from which it inherits have a slot by the same name, only one slot is allocated in the ",(0,t.jsx)(n.em,{children:"condition"}),", but the supplied slot form overrides any slot form that might otherwise have been inherited from a ",(0,t.jsx)(n.em,{children:"parent-type"}),". If no slot form is supplied, the inherited slot form (if any) is still visible."]}),"\n",(0,t.jsxs)(n.p,{children:["Accessors are created according to the same rules as used by ",(0,t.jsx)(n.strong,{children:"defclass"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["A description of ",(0,t.jsx)(n.em,{children:"slot-options"})," follows:"]}),"\n",(0,t.jsx)(n.p,{children:":reader"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":reader"," slot option specifies that an ",(0,t.jsx)(n.em,{children:"unqualified method"})," is to be defined on the ",(0,t.jsx)(n.em,{children:"generic function"})," named by the argument to ",":reader"," to read the value of the given ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"\u2022"})," The ",":initform"," slot option is used to provide a default initial value form to be used in the initialization of the ",(0,t.jsx)(n.em,{children:"slot"}),". This ",(0,t.jsx)(n.em,{children:"form"})," is evaluated every time it is used to initialize the ",(0,t.jsx)(n.em,{children:"slot"}),". The ",(0,t.jsx)(n.em,{children:"lexical environment"})," in which this ",(0,t.jsx)(n.em,{children:"form"})," is evaluated is the lexical ",(0,t.jsx)(n.em,{children:"environment"})," in which the ",(0,t.jsx)(n.strong,{children:"define-condition"})," form was evaluated. Note that the ",(0,t.jsx)(n.em,{children:"lexical environment"})," refers both to variables and to ",(0,t.jsx)(n.em,{children:"functions"}),". For ",(0,t.jsx)(n.em,{children:"local slots"}),", the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," is the dynamic ",(0,t.jsx)(n.em,{children:"environment"})," in which ",(0,t.jsx)(n.strong,{children:"make-condition"})," was called; for ",(0,t.jsx)(n.em,{children:"shared slots"}),", the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," is the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," in which the ",(0,t.jsx)(n.strong,{children:"define-condition"})," form was evaluated."]}),"\n",(0,t.jsxs)(n.p,{children:["No implementation is permitted to extend the syntax of ",(0,t.jsx)(n.strong,{children:"define-condition"})," to allow (",(0,t.jsx)(n.em,{children:"slot-name form"}),") as an abbreviation for (",(0,t.jsx)(n.em,{children:"slot-name"})," ",":initform"," ",(0,t.jsx)(n.em,{children:"form"}),")."]}),"\n",(0,t.jsx)(n.p,{children:":initarg"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":initarg"," slot option declares an initialization argument named by its ",(0,t.jsx)(n.em,{children:"symbol"})," argument and specifies that this initialization argument initializes the given ",(0,t.jsx)(n.em,{children:"slot"}),". If the initialization"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:["argument has a value in the call to ",(0,t.jsx)(n.strong,{children:"initialize-instance"}),", the value is stored into the given ",(0,t.jsx)(n.em,{children:"slot"}),", and the slot\u2019s ",":initform"," slot option, if any, is not evaluated. If none of the initialization arguments specified for a given ",(0,t.jsx)(n.em,{children:"slot"})," has a value, the ",(0,t.jsx)(n.em,{children:"slot"})," is initialized according to the ",":initform"," slot option, if specified."]}),"\n",(0,t.jsx)(n.p,{children:":type"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":type"," slot option specifies that the contents of the ",(0,t.jsx)(n.em,{children:"slot"})," is always of the specified ",(0,t.jsx)(n.em,{children:"type"}),". It effectively declares the result type of the reader generic function when applied to an ",(0,t.jsx)(n.em,{children:"object"})," of this ",(0,t.jsx)(n.em,{children:"condition"})," type. The consequences of attempting to store in a ",(0,t.jsx)(n.em,{children:"slot"})," a value that does not satisfy the type of the ",(0,t.jsx)(n.em,{children:"slot"})," is undefined."]}),"\n",(0,t.jsx)(n.p,{children:":default-initargs"}),"\n",(0,t.jsxs)(n.p,{children:["This option is treated the same as it would be ",(0,t.jsx)(n.strong,{children:"defclass"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":documentation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":documentation"," slot option provides a ",(0,t.jsx)(n.em,{children:"documentation string"})," for the ",(0,t.jsx)(n.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(n.p,{children:":report"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Condition"})," reporting is mediated through the ",(0,t.jsx)(n.strong,{children:"print-object"})," method for the ",(0,t.jsx)(n.em,{children:"condition"})," type in question, with ",(0,t.jsx)(n.strong,{children:"*print-escape*"})," always being ",(0,t.jsx)(n.strong,{children:"nil"}),". Specifying (",":report"," ",(0,t.jsx)(n.em,{children:"report-name"}),") in the definition of a condition type C is equivalent to:"]}),"\n",(0,t.jsx)(n.p,{children:"(defmethod print-object ((x c) stream)"}),"\n",(0,t.jsxs)(n.p,{children:["(if *print-escape* (call-next-method) (",(0,t.jsx)(n.em,{children:"report-name"})," x stream)))"]}),"\n",(0,t.jsxs)(n.p,{children:["If the value supplied by the argument to ",":report"," (",(0,t.jsx)(n.em,{children:"report-name"}),") is a ",(0,t.jsx)(n.em,{children:"symbol"})," or a ",(0,t.jsx)(n.em,{children:"lambda expression"}),", it must be acceptable to ",(0,t.jsx)(n.strong,{children:"function"}),". (function ",(0,t.jsx)(n.em,{children:"report-name"}),") is evaluated in the current ",(0,t.jsx)(n.em,{children:"lexical environment"}),". It should return a ",(0,t.jsx)(n.em,{children:"function"})," of two arguments, a ",(0,t.jsx)(n.em,{children:"condition"})," and a ",(0,t.jsx)(n.em,{children:"stream"}),", that prints on the ",(0,t.jsx)(n.em,{children:"stream"})," a description of the ",(0,t.jsx)(n.em,{children:"condition"}),". This ",(0,t.jsx)(n.em,{children:"function"})," is called whenever the ",(0,t.jsx)(n.em,{children:"condition"})," is printed while ",(0,t.jsx)(n.strong,{children:"*print-escape*"})," is ",(0,t.jsx)(n.strong,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.em,{children:"report-name"})," is a ",(0,t.jsx)(n.em,{children:"string"}),", it is a shorthand for"]}),"\n",(0,t.jsx)(n.p,{children:"(lambda (condition stream)"}),"\n",(0,t.jsx)(n.p,{children:"(declare (ignore condition))"}),"\n",(0,t.jsxs)(n.p,{children:["(write-string ",(0,t.jsx)(n.em,{children:"report-name"})," stream))"]}),"\n",(0,t.jsxs)(n.p,{children:["This option is processed after the new ",(0,t.jsx)(n.em,{children:"condition"})," type has been defined, so use of the ",(0,t.jsx)(n.em,{children:"slot"})," accessors within the ",":report"," function is permitted. If this option is not supplied, information about how to report this type of ",(0,t.jsx)(n.em,{children:"condition"})," is inherited from the ",(0,t.jsx)(n.em,{children:"parent-type"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The consequences are unspecifed if an attempt is made to ",(0,t.jsx)(n.em,{children:"read"})," a ",(0,t.jsx)(n.em,{children:"slot"})," that has not been explicitly initialized and that has not been given a default value."]}),"\n",(0,t.jsxs)(n.p,{children:["The consequences are unspecified if an attempt is made to assign the ",(0,t.jsx)(n.em,{children:"slots"})," by using ",(0,t.jsx)(n.strong,{children:"setf"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:["If a ",(0,t.jsx)(n.strong,{children:"define-condition"})," ",(0,t.jsx)(n.em,{children:"form"})," appears as a ",(0,t.jsx)(n.em,{children:"top level form"}),", the ",(0,t.jsx)(n.em,{children:"compiler"})," must make ",(0,t.jsx)(n.em,{children:"name"})," recognizable as a valid ",(0,t.jsx)(n.em,{children:"type"})," name, and it must be possible to reference the ",(0,t.jsx)(n.em,{children:"condition type"})," as the ",(0,t.jsx)(n.em,{children:"parent-type"})," of another ",(0,t.jsx)(n.em,{children:"condition type"})," in a subsequent ",(0,t.jsx)(n.strong,{children:"define-condition"})," ",(0,t.jsx)(n.em,{children:"form"})," in the ",(0,t.jsx)(n.em,{children:"file"})," being compiled."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:' \n\nThe following form defines a condition of *type* peg/hole-mismatch which inherits from a condition type called blocks-world-error: \n\n(define-condition peg/hole-mismatch \n\n(blocks-world-error) \n\n((peg-shape :initarg :peg-shape \n\n:reader peg/hole-mismatch-peg-shape) \n\n(hole-shape :initarg :hole-shape \n\n:reader peg/hole-mismatch-hole-shape)) \n\n(:report (lambda (condition stream) \n\n(format stream "A &#126;A peg cannot go in a &#126;A hole." \n\n(peg/hole-mismatch-peg-shape condition) \n\n(peg/hole-mismatch-hole-shape condition))))) \n\nThe new type has slots peg-shape and hole-shape, so **make-condition** accepts :peg-shape and :hole-shape keywords. The *readers* peg/hole-mismatch-peg-shape and peg/hole-mismatch-hole-shape apply to objects of this type, as illustrated in the :report information. \n\nThe following form defines a *condition type* named machine-error which inherits from **error**: \n\n(define-condition machine-error \n\n(error) \n\n((machine-name :initarg :machine-name \n\n:reader machine-error-machine-name)) \n\n(:report (lambda (condition stream) \n\n(format stream "There is a problem with &#126;A." \n\n(machine-error-machine-name condition))))) \n\nBuilding on this definition, a new error condition can be defined which is a subtype of machine-error for use when machines are not available: \n\n(define-condition machine-not-available-error (machine-error) () \n\n(:report (lambda (condition stream) \n\n(format stream "The machine &#126;A is not available." \n\n(machine-error-machine-name condition))))) \n\nThis defines a still more specific condition, built upon machine-not-available-error, which provides a slot initialization form for machine-name but which does not provide any new slots or report information. It just gives the machine-name slot a default initialization: \n\n(define-condition my-favorite-machine-not-available-error \n\n(machine-not-available-error) \n\n\n\n \n\n \n\n((machine-name :initform "mc.lcs.mit.edu"))) \n\nNote that since no :report clause was given, the information inherited from machine-not-available-error is used to report this type of condition. \n\n(define-condition ate-too-much (error) \n\n((person :initarg :person :reader ate-too-much-person) \n\n(weight :initarg :weight :reader ate-too-much-weight) \n\n(kind-of-food :initarg :kind-of-food \n\n:reader :ate-too-much-kind-of-food))) \n\n\u2192 ATE-TOO-MUCH \n\n(define-condition ate-too-much-ice-cream (ate-too-much) \n\n((kind-of-food :initform \u2019ice-cream) \n\n(flavor :initarg :flavor \n\n:reader ate-too-much-ice-cream-flavor \n\n:initform \u2019vanilla )) \n\n(:report (lambda (condition stream) \n\n(format stream "&#126;A ate too much &#126;A ice-cream" \n\n(ate-too-much-person condition) \n\n(ate-too-much-ice-cream-flavor condition))))) \n\n\u2192 ATE-TOO-MUCH-ICE-CREAM \n\n(make-condition \u2019ate-too-much-ice-cream \n\n:person \u2019fred \n\n:weight 300 \n\n:flavor \u2019chocolate) \n\n\u2192 #<ATE-TOO-MUCH-ICE-CREAM 32236101> \n\n(format t "&#126;A" \\*) \n\n\u25b7 FRED ate too much CHOCOLATE ice-cream \n\n\u2192 NIL \n\n\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"make-condition"}),", ",(0,t.jsx)(n.strong,{children:"defclass"}),", Section 9.1 (Condition System Concepts)"]})]})}function r(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}const c={},d="define-condition",l={id:"chap-9/j-c-dictionary/definecondition",title:"define-condition",description:"Expanded Reference: define-condition",source:"@site/docs/chap-9/j-c-dictionary/definecondition.md",sourceDirName:"chap-9/j-c-dictionary",slug:"/chap-9/j-c-dictionary/definecondition",permalink:"/cl-language-reference/docs/chap-9/j-c-dictionary/definecondition",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-9/j-c-dictionary/definecondition.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"continue",permalink:"/cl-language-reference/docs/chap-9/j-c-dictionary/continue"},next:{title:"error",permalink:"/cl-language-reference/docs/chap-9/j-c-dictionary/error"}},a={},h=[{value:"Expanded Reference: define-condition",id:"expanded-reference-define-condition",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"define-condition",children:"define-condition"}),"\n","\n","\n",(0,t.jsx)(r,{}),"\n",(0,t.jsx)(n.h2,{id:"expanded-reference-define-condition",children:"Expanded Reference: define-condition"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(define-condition )\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>r});var t=i(67294);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);