"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[99266],{13357:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>d,toc:()=>p});var t=s(85893),c=s(11151);function i(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"})," ",(0,t.jsx)(n.em,{children:"Function"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapc"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 list-1"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapcar"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 result-list"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapcan"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 concatenated-results"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapl"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 list-1"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"maplist"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 result-list"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapcon"})," ",(0,t.jsx)(n.em,{children:"function"})," &rest ",(0,t.jsx)(n.em,{children:"lists"}),(0,t.jsx)("sup",{children:"+"})," \u2192 concatenated-results"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"function"}),"\u2014a ",(0,t.jsx)(n.em,{children:"designator"})," for a ",(0,t.jsx)(n.em,{children:"function"})," that must take as many ",(0,t.jsx)(n.em,{children:"arguments"})," as there are ",(0,t.jsx)(n.em,{children:"lists"}),". ",(0,t.jsx)(n.em,{children:"list"}),"\u2014a ",(0,t.jsx)(n.em,{children:"proper list"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"list-1"}),"\u2014the first ",(0,t.jsx)(n.em,{children:"list"})," (which must be a ",(0,t.jsx)(n.em,{children:"proper list"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"result-list"}),"\u2014a ",(0,t.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"concatenated-results"}),"\u2014a ",(0,t.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(n.p,{children:["The mapping operation involves applying ",(0,t.jsx)(n.em,{children:"function"})," to successive sets of arguments in which one argument is obtained from each ",(0,t.jsx)(n.em,{children:"sequence"}),". Except for ",(0,t.jsx)(n.strong,{children:"mapc"})," and ",(0,t.jsx)(n.strong,{children:"mapl"}),", the result contains the results returned by ",(0,t.jsx)(n.em,{children:"function"}),". In the cases of ",(0,t.jsx)(n.strong,{children:"mapc"})," and ",(0,t.jsx)(n.strong,{children:"mapl"}),", the resulting ",(0,t.jsx)(n.em,{children:"sequence"})," is ",(0,t.jsx)(n.em,{children:"list"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"function"})," is called first on all the elements with index 0, then on all those with index 1, and so on. ",(0,t.jsx)(n.em,{children:"result-type"})," specifies the ",(0,t.jsx)(n.em,{children:"type"})," of the resulting ",(0,t.jsx)(n.em,{children:"sequence"}),". If ",(0,t.jsx)(n.em,{children:"function"})," is a ",(0,t.jsx)(n.em,{children:"symbol"}),", it is ",(0,t.jsx)(n.strong,{children:"coerce"}),"d to a ",(0,t.jsx)(n.em,{children:"function"})," as if by ",(0,t.jsx)(n.strong,{children:"symbol-function"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapcar"})," operates on successive ",(0,t.jsx)(n.em,{children:"elements"})," of the ",(0,t.jsx)(n.em,{children:"lists"}),". ",(0,t.jsx)(n.em,{children:"function"})," is applied to the first ",(0,t.jsx)(n.em,{children:"element"})," of each ",(0,t.jsx)(n.em,{children:"list"}),", then to the second ",(0,t.jsx)(n.em,{children:"element"})," of each ",(0,t.jsx)(n.em,{children:"list"}),", and so on. The iteration terminates when the shortest ",(0,t.jsx)(n.em,{children:"list"})," runs out, and excess elements in other lists are ignored. The value returned by ",(0,t.jsx)(n.strong,{children:"mapcar"})," is a ",(0,t.jsx)(n.em,{children:"list"})," of the results of successive calls to ",(0,t.jsx)(n.em,{children:"function"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapc"})," is like ",(0,t.jsx)(n.strong,{children:"mapcar"})," except that the results of applying ",(0,t.jsx)(n.em,{children:"function"})," are not accumulated. The ",(0,t.jsx)(n.em,{children:"list"})," argument is returned."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"maplist"})," is like ",(0,t.jsx)(n.strong,{children:"mapcar"})," except that ",(0,t.jsx)(n.em,{children:"function"})," is applied to successive sublists of the ",(0,t.jsx)(n.em,{children:"lists"}),". ",(0,t.jsx)(n.em,{children:"function"})," is first applied to the ",(0,t.jsx)(n.em,{children:"lists"})," themselves, and then to the ",(0,t.jsx)(n.em,{children:"cdr"})," of each ",(0,t.jsx)(n.em,{children:"list"}),", and then to the ",(0,t.jsx)(n.em,{children:"cdr"})," of the ",(0,t.jsx)(n.em,{children:"cdr"})," of each ",(0,t.jsx)(n.em,{children:"list"}),", and so on."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapl"})," is like ",(0,t.jsx)(n.strong,{children:"maplist"})," except that the results of applying ",(0,t.jsx)(n.em,{children:"function"})," are not accumulated; ",(0,t.jsx)(n.em,{children:"list-1"})," is returned."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"mapcan"})," and ",(0,t.jsx)(n.strong,{children:"mapcon"})," are like ",(0,t.jsx)(n.strong,{children:"mapcar"})," and ",(0,t.jsx)(n.strong,{children:"maplist"})," respectively, except that the results of applying ",(0,t.jsx)(n.em,{children:"function"})," are combined into a ",(0,t.jsx)(n.em,{children:"list"})," by the use of ",(0,t.jsx)(n.strong,{children:"nconc"})," rather than ",(0,t.jsx)(n.strong,{children:"list"}),". That is,"]}),"\n",(0,t.jsx)(n.p,{children:"(mapcon f x1 ... xn)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"\u2261"})," (apply #\u2019nconc (maplist f x1 ... xn))"]}),"\n",(0,t.jsxs)(n.p,{children:["and similarly for the relationship between ",(0,t.jsx)(n.strong,{children:"mapcan"})," and ",(0,t.jsx)(n.strong,{children:"mapcar"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"\n(mapcar #\u2019car \u2019((1 a) (2 b) (3 c))) \u2192 (1 2 3) \n(mapcar #\u2019abs \u2019(3 -4 2 -5 -6)) \u2192 (3 4 2 5 6) \n\n\n\n(mapcar #\u2019cons \u2019(a b c) \u2019(1 2 3)) \u2192 ((A . 1) (B . 2) (C . 3)) \n(maplist #\u2019append \u2019(1 2 3 4) \u2019(1 2) \u2019(1 2 3)) \n\u2192 ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) \n(maplist #\u2019(lambda (x) (cons \u2019foo x)) \u2019(a b c d)) \n\u2192 ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D)) \n(maplist #\u2019(lambda (x) (if (member (car x) (cdr x)) 0 1)) \u2019(a b a c d b c)) \u2192 (0 0 1 0 1 1 1) \n\t\t\t\t\t;An entry is 1 if the corresponding element of the input \n\t\t\t\t\t; list was the last instance of that element in the input list. \n(setq dummy nil) \u2192 NIL \n(mapc #\u2019(lambda (&amp;rest x) (setq dummy (append dummy x))) \n\t\t \u2019(1 2 3 4) \n\t\t \u2019(a b c d e) \n\t\t \u2019(x y z)) \u2192 (1 2 3 4) \n\t\t  dummy \u2192 (1 A X 2 B Y 3 C Z) \n\t\t  (setq dummy nil) \u2192 NIL \n\t\t  (mapl #\u2019(lambda (x) (push x dummy)) \u2019(1 2 3 4)) \u2192 (1 2 3 4) \n\t\t  dummy \u2192 ((4) (3 4) (2 3 4) (1 2 3 4)) \n\t\t  (mapcan #\u2019(lambda (x y) (if (null x) nil (list x y))) \n\t\t\t    \u2019(nil nil nil d e) \n\t\t\t    \u2019(1 2 3 4 5 6)) \u2192 (D 4 E 5) \n\t\t  (mapcan #\u2019(lambda (x) (and (numberp x) (list x))) \n\t\t\t    \u2019(a 1 b c 3 4 d 5)) \n\t\t  \u2192 (1 3 4 5) \n\t\t  In this case the function serves as a filter; this is a standard Lisp idiom using **mapcan**. (mapcon #\u2019list \u2019(1 2 3 4)) \u2192 ((1 2 3 4) (2 3 4) (3 4) (4)) \n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,t.jsxs)(n.p,{children:["Should be prepared to signal an error of ",(0,t.jsx)(n.em,{children:"type"})," ",(0,t.jsx)(n.strong,{children:"type-error"})," if any ",(0,t.jsx)(n.em,{children:"list"})," is not a ",(0,t.jsx)(n.em,{children:"proper list"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"dolist"}),", ",(0,t.jsx)(n.strong,{children:"map"}),", Section 3.6 (Traversal Rules and Side Effects)"]})]})}function r(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}const a={},l="mapc, mapcar, mapcan, mapl, maplist, mapcon",d={id:"chap-14/be-c-dictionary/mapc",title:"mapc, mapcar, mapcan, mapl, maplist, mapcon",description:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon",source:"@site/docs/chap-14/be-c-dictionary/mapc.md",sourceDirName:"chap-14/be-c-dictionary",slug:"/chap-14/be-c-dictionary/mapc",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/mapc",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-14/be-c-dictionary/mapc.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"make-list",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/makelist"},next:{title:"member, member-if, member-if-not",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/member"}},m={},p=[{value:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon",id:"expanded-reference-mapc-mapcar-mapcan-mapl-maplist-mapcon",level:2}];function o(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"mapc-mapcar-mapcan-mapl-maplist-mapcon",children:"mapc, mapcar, mapcan, mapl, maplist, mapcon"}),"\n","\n","\n",(0,t.jsx)(r,{}),"\n",(0,t.jsx)(n.h2,{id:"expanded-reference-mapc-mapcar-mapcan-mapl-maplist-mapcon",children:"Expanded Reference: mapc, mapcar, mapcan, mapl, maplist, mapcon"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(mapc, mapcar, mapcan, mapl, maplist, mapcon )\n"})})]})}function h(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>r});var t=s(67294);const c={},i=t.createContext(c);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);