"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[94335],{59187:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>j,frontMatter:()=>a,metadata:()=>d,toc:()=>x});var i=s(85893),t=s(11151);function r(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,t.a)(),...e.components},{DictionaryLink:s,GlossaryTerm:r}=n;return s||c("DictionaryLink",!0),r||c("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"sxhash"})," ",(0,i.jsx)(r,{term:"function",children:(0,i.jsx)("i",{children:"Function"})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})})," ",(0,i.jsx)(n.em,{children:"object \u2192 hash-code"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})}),"\u2014an ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"hash-code"}),"\u2014a non-negative ",(0,i.jsx)(r,{term:"fixnum",children:(0,i.jsx)("i",{children:"fixnum"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})})," returns a hash code for ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The manner in which the hash code is computed is ",(0,i.jsx)(r,{term:"implementation-dependent",children:(0,i.jsx)("i",{children:"implementation-dependent"})}),", but subject to certain constraints:"]}),"\n",(0,i.jsxs)(n.p,{children:["1. (equal ",(0,i.jsx)(n.em,{children:"x y"}),") implies (= (sxhash ",(0,i.jsx)(n.em,{children:"x"}),") (sxhash ",(0,i.jsx)(n.em,{children:"y"}),"))."]}),"\n",(0,i.jsxs)(n.p,{children:["2. For any two ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"objects"})}),", ",(0,i.jsx)(n.em,{children:"x"})," and ",(0,i.jsx)(n.em,{children:"y"}),", both of which are ",(0,i.jsx)(r,{styled:!0,term:"bit vector",children:(0,i.jsx)("i",{children:"bit vectors"})}),", ",(0,i.jsx)(r,{styled:!0,term:"character",children:(0,i.jsx)("i",{children:"characters"})}),", ",(0,i.jsx)(n.em,{children:"conses"}),", ",(0,i.jsx)(r,{styled:!0,term:"number",children:(0,i.jsx)("i",{children:"numbers"})}),", ",(0,i.jsx)(r,{styled:!0,term:"pathname",children:(0,i.jsx)("i",{children:"pathnames"})}),", ",(0,i.jsx)(r,{styled:!0,term:"string",children:(0,i.jsx)("i",{children:"strings"})}),", or ",(0,i.jsx)(r,{term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})}),", and which are ",(0,i.jsx)(r,{term:"similar",children:(0,i.jsx)("i",{children:"similar"})})," , (sxhash ",(0,i.jsx)(n.em,{children:"x"}),") and (sxhash ",(0,i.jsx)(n.em,{children:"y"}),") ",(0,i.jsx)(r,{term:"yield",children:(0,i.jsx)("i",{children:"yield"})})," the same mathematical value even if ",(0,i.jsx)(n.em,{children:"x"})," and ",(0,i.jsx)(n.em,{children:"y"})," exist in different ",(0,i.jsx)(n.em,{children:"Lisp images"})," of the same ",(0,i.jsx)(r,{term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})}),". See Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,i.jsxs)(n.p,{children:["3. The ",(0,i.jsx)(n.em,{children:"hash-code"})," for an ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})})," is always the ",(0,i.jsx)(r,{term:"same",children:(0,i.jsx)("i",{children:"same"})})," within a single ",(0,i.jsx)(r,{term:"session",children:(0,i.jsx)("i",{children:"session"})})," provided that the ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})})," is not visibly modified with regard to the equivalence test ",(0,i.jsx)(s,{term:"equal",children:(0,i.jsx)("b",{children:"equal"})}),". See Section 18.1.2 (Modifying Hash Table Keys)."]}),"\n",(0,i.jsx)(n.p,{children:"Hash"}),"\n",(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})}),"\n",(0,i.jsxs)(n.p,{children:["4. The ",(0,i.jsx)(n.em,{children:"hash-code"})," is intended for hashing. This places no verifiable constraint on a ",(0,i.jsx)(r,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})}),", but the intent is that an ",(0,i.jsx)(r,{term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," should make a good-faith effort to produce ",(0,i.jsx)(n.em,{children:"hash-codes"})," that are well distributed within the range of non-negative ",(0,i.jsx)(r,{term:"fixnum",children:(0,i.jsx)("i",{children:"fixnums"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["5. Computation of the ",(0,i.jsx)(n.em,{children:"hash-code"})," must terminate, even if the ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"object"})})," contains circularities."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:'(= (sxhash (list \u2019list "ab")) (sxhash (list \u2019list "ab"))) \u2192 true \n(= (sxhash "a") (sxhash (make-string 1 :initial-element #\\a))) \u2192 true \n(let ((r (make-random-state))) \n  (= (sxhash r) (sxhash (make-random-state r)))) \n\u2192 implementation-dependent \n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(r,{term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["Many common hashing needs are satisfied by ",(0,i.jsx)(s,{term:"make-hash-table",children:(0,i.jsx)("b",{children:"make-hash-table"})})," and the related functions on ",(0,i.jsx)(r,{styled:!0,term:"hash table",children:(0,i.jsx)("i",{children:"hash tables"})}),". ",(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})})," is intended for use where the pre-defined abstractions are insufficient. Its main intent is to allow the user a convenient means of implementing more complicated hashing paradigms than are provided through ",(0,i.jsx)(r,{styled:!0,term:"hash table",children:(0,i.jsx)("i",{children:"hash tables"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The hash codes returned by ",(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})})," are not necessarily related to any hashing strategy used by any other ",(0,i.jsx)(r,{term:"function",children:(0,i.jsx)("i",{children:"function"})})," in Common Lisp."]}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"objects"})})," of ",(0,i.jsx)(r,{term:"type",children:(0,i.jsx)("i",{children:"types"})})," that ",(0,i.jsx)(s,{term:"equal",children:(0,i.jsx)("b",{children:"equal"})})," compares with ",(0,i.jsx)(s,{term:"eq",children:(0,i.jsx)("b",{children:"eq"})}),", item 3 requires that the ",(0,i.jsx)(n.em,{children:"hash-code"})," be based on some immutable quality of the identity of the object. Another legitimate implementation technique would be to have ",(0,i.jsx)(s,{term:"sxhash",children:(0,i.jsx)("b",{children:"sxhash"})})," assign (and cache) a random hash code for these ",(0,i.jsx)(r,{term:"object",children:(0,i.jsx)("i",{children:"objects"})}),", since there is no requirement that ",(0,i.jsx)(r,{term:"similar",children:(0,i.jsx)("i",{children:"similar"})})," but non-",(0,i.jsx)(s,{term:"eq",children:(0,i.jsx)("b",{children:"eq"})})," objects have the same hash code."]}),"\n",(0,i.jsxs)(n.p,{children:["Although ",(0,i.jsx)(r,{term:"similarity",children:(0,i.jsx)("i",{children:"similarity"})})," is defined for ",(0,i.jsx)(r,{term:"symbol",children:(0,i.jsx)("i",{children:"symbols"})})," in terms of both the ",(0,i.jsx)(r,{term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})}),"\u2019s ",(0,i.jsx)(r,{term:"name",children:(0,i.jsx)("i",{children:"name"})})," and the ",(0,i.jsx)(r,{term:"package",children:(0,i.jsx)("i",{children:"packages"})})," in which the ",(0,i.jsx)(r,{term:"symbol",children:(0,i.jsx)("i",{children:"symbol"})})," is ",(0,i.jsx)(r,{term:"accessible",children:(0,i.jsx)("i",{children:"accessible"})}),", item 3 disallows using ",(0,i.jsx)(r,{term:"package",children:(0,i.jsx)("i",{children:"package"})})," information to compute the hash code, since changes to the package status of a symbol are not visible to ",(0,i.jsx)(n.em,{children:"equal"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const a={title:"sxhash"},l="sxhash",d={id:"chap-18/bi-c-dictionary/sxhash_function",title:"sxhash",description:"Expanded Reference: sxhash",source:"@site/docs/chap-18/bi-c-dictionary/sxhash_function.md",sourceDirName:"chap-18/bi-c-dictionary",slug:"/chap-18/bi-c-dictionary/sxhash_function",permalink:"/cl-language-reference/chap-18/bi-c-dictionary/sxhash_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-18/bi-c-dictionary/sxhash_function.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"sxhash"},sidebar:"tutorialSidebar",previous:{title:"remhash",permalink:"/cl-language-reference/chap-18/bi-c-dictionary/remhash_function"},next:{title:"with-hash-table-iterator",permalink:"/cl-language-reference/chap-18/bi-c-dictionary/with-hash-table-iterator_macro"}},o={},x=[{value:"Expanded Reference: sxhash",id:"expanded-reference-sxhash",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"sxhash",children:"sxhash"}),"\n","\n","\n",(0,i.jsx)(h,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-sxhash",children:"Expanded Reference: sxhash"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(sxhash )\n"})})]})}function j(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>c,a:()=>h});var i=s(67294);const t={},r=i.createContext(t);function h(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:h(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);