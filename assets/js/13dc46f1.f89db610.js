"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[81114],{47173:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var i=s(85893),h=s(11151);function t(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"sxhash"})," ",(0,i.jsx)(n.em,{children:"Function"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"sxhash"})," ",(0,i.jsx)(n.em,{children:"object \u2192 hash-code"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"object"}),"\u2014an ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"hash-code"}),"\u2014a non-negative ",(0,i.jsx)(n.em,{children:"fixnum"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"sxhash"})," returns a hash code for ",(0,i.jsx)(n.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The manner in which the hash code is computed is ",(0,i.jsx)(n.em,{children:"implementation-dependent"}),", but subject to certain constraints:"]}),"\n",(0,i.jsxs)(n.p,{children:["1. (equal ",(0,i.jsx)(n.em,{children:"x y"}),") implies (= (sxhash ",(0,i.jsx)(n.em,{children:"x"}),") (sxhash ",(0,i.jsx)(n.em,{children:"y"}),"))."]}),"\n",(0,i.jsxs)(n.p,{children:["2. For any two ",(0,i.jsx)(n.em,{children:"objects"}),", ",(0,i.jsx)(n.em,{children:"x"})," and ",(0,i.jsx)(n.em,{children:"y"}),", both of which are ",(0,i.jsx)(n.em,{children:"bit vectors"}),", ",(0,i.jsx)(n.em,{children:"characters"}),", ",(0,i.jsx)(n.em,{children:"conses"}),", ",(0,i.jsx)(n.em,{children:"numbers"}),", ",(0,i.jsx)(n.em,{children:"pathnames"}),", ",(0,i.jsx)(n.em,{children:"strings"}),", or ",(0,i.jsx)(n.em,{children:"symbols"}),", and which are ",(0,i.jsx)(n.em,{children:"similar"})," , (sxhash ",(0,i.jsx)(n.em,{children:"x"}),") and (sxhash ",(0,i.jsx)(n.em,{children:"y"}),") ",(0,i.jsx)(n.em,{children:"yield"})," the same mathematical value even if ",(0,i.jsx)(n.em,{children:"x"})," and ",(0,i.jsx)(n.em,{children:"y"})," exist in different ",(0,i.jsx)(n.em,{children:"Lisp images"})," of the same ",(0,i.jsx)(n.em,{children:"implementation"}),". See Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,i.jsxs)(n.p,{children:["3. The ",(0,i.jsx)(n.em,{children:"hash-code"})," for an ",(0,i.jsx)(n.em,{children:"object"})," is always the ",(0,i.jsx)(n.em,{children:"same"})," within a single ",(0,i.jsx)(n.em,{children:"session"})," provided that the ",(0,i.jsx)(n.em,{children:"object"})," is not visibly modified with regard to the equivalence test ",(0,i.jsx)(n.strong,{children:"equal"}),". See Section 18.1.2 (Modifying Hash Table Keys)."]}),"\n",(0,i.jsx)(n.p,{children:"Hash"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"sxhash"})}),"\n",(0,i.jsxs)(n.p,{children:["4. The ",(0,i.jsx)(n.em,{children:"hash-code"})," is intended for hashing. This places no verifiable constraint on a ",(0,i.jsx)(n.em,{children:"conforming implementation"}),", but the intent is that an ",(0,i.jsx)(n.em,{children:"implementation"})," should make a good-faith effort to produce ",(0,i.jsx)(n.em,{children:"hash-codes"})," that are well distributed within the range of non-negative ",(0,i.jsx)(n.em,{children:"fixnums"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["5. Computation of the ",(0,i.jsx)(n.em,{children:"hash-code"})," must terminate, even if the ",(0,i.jsx)(n.em,{children:"object"})," contains circularities. ",(0,i.jsx)(n.strong,{children:"Examples:"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:' \n\n(= (sxhash (list \u2019list "ab")) (sxhash (list \u2019list "ab"))) \u2192 true \n\n(= (sxhash "a") (sxhash (make-string 1 :initial-element #\\a))) \u2192 true \n\n(let ((r (make-random-state))) \n\n(= (sxhash r) (sxhash (make-random-state r)))) \n\n\u2192 implementation-dependent \n\n\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"implementation"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(n.p,{children:["Many common hashing needs are satisfied by ",(0,i.jsx)(n.strong,{children:"make-hash-table"})," and the related functions on ",(0,i.jsx)(n.em,{children:"hash tables"}),". ",(0,i.jsx)(n.strong,{children:"sxhash"})," is intended for use where the pre-defined abstractions are insufficient. Its main intent is to allow the user a convenient means of implementing more complicated hashing paradigms than are provided through ",(0,i.jsx)(n.em,{children:"hash tables"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The hash codes returned by ",(0,i.jsx)(n.strong,{children:"sxhash"})," are not necessarily related to any hashing strategy used by any other ",(0,i.jsx)(n.em,{children:"function"})," in Common Lisp."]}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(n.em,{children:"objects"})," of ",(0,i.jsx)(n.em,{children:"types"})," that ",(0,i.jsx)(n.strong,{children:"equal"})," compares with ",(0,i.jsx)(n.strong,{children:"eq"}),", item 3 requires that the ",(0,i.jsx)(n.em,{children:"hash-code"})," be based on some immutable quality of the identity of the object. Another legitimate implementation technique would be to have ",(0,i.jsx)(n.strong,{children:"sxhash"})," assign (and cache) a random hash code for these ",(0,i.jsx)(n.em,{children:"objects"}),", since there is no requirement that ",(0,i.jsx)(n.em,{children:"similar"})," but non-",(0,i.jsx)(n.strong,{children:"eq"})," objects have the same hash code."]}),"\n",(0,i.jsxs)(n.p,{children:["Although ",(0,i.jsx)(n.em,{children:"similarity"})," is defined for ",(0,i.jsx)(n.em,{children:"symbols"})," in terms of both the ",(0,i.jsx)(n.em,{children:"symbol"}),"\u2019s ",(0,i.jsx)(n.em,{children:"name"})," and the ",(0,i.jsx)(n.em,{children:"packages"})," in which the ",(0,i.jsx)(n.em,{children:"symbol"})," is ",(0,i.jsx)(n.em,{children:"accessible"}),", item 3 disallows using ",(0,i.jsx)(n.em,{children:"package"})," information to compute the hash code, since changes to the package status of a symbol are not visible to ",(0,i.jsx)(n.em,{children:"equal"}),"."]})]})}function r(e={}){const{wrapper:n}={...(0,h.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}const a={},c="sxhash",d={id:"chap-18/bi-c-dictionary/sxhash",title:"sxhash",description:"Expanded Reference: sxhash",source:"@site/docs/chap-18/bi-c-dictionary/sxhash.md",sourceDirName:"chap-18/bi-c-dictionary",slug:"/chap-18/bi-c-dictionary/sxhash",permalink:"/cl-language-reference/docs/chap-18/bi-c-dictionary/sxhash",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-18/bi-c-dictionary/sxhash.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"remhash",permalink:"/cl-language-reference/docs/chap-18/bi-c-dictionary/remhash"},next:{title:"with-hash-table-iterator",permalink:"/cl-language-reference/docs/chap-18/bi-c-dictionary/withhashtableiterator"}},o={},l=[{value:"Expanded Reference: sxhash",id:"expanded-reference-sxhash",level:2}];function x(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"sxhash",children:"sxhash"}),"\n","\n","\n",(0,i.jsx)(r,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-sxhash",children:"Expanded Reference: sxhash"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(sxhash )\n"})})]})}function m(e={}){const{wrapper:n}={...(0,h.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>r});var i=s(67294);const h={},t=i.createContext(h);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(h):e.components||h:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);