"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[57733],{57232:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>le,contentTitle:()=>oe,default:()=>de,frontMatter:()=>re,metadata:()=>ae,toc:()=>ce});var i=s(85893),t=s(11151);function r(e){return(0,i.jsx)(i.Fragment,{})}function o(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r()}function a(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Common Lisp provides a large variety of operations related to ",(0,i.jsx)(n.em,{children:"numbers"}),". This section provides an overview of those operations by grouping them into categories that emphasize some of the relationships among them."]}),"\n",(0,i.jsxs)(n.p,{children:["Figure 12\u20131 shows ",(0,i.jsx)(n.em,{children:"operators"})," relating to arithmetic operations."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"* 1+ gcd"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"+ 1- incf"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"- conjugate lcm"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"/ decf"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20131. Operators relating to Arithmetic."})}),"\n",(0,i.jsxs)(n.p,{children:["Figure 12\u20132 shows ",(0,i.jsx)(n.em,{children:"defined names"})," relating to exponential, logarithmic, and trigonometric operations."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"abs cos signum"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"acos cosh sin"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"acosh exp sinh"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"asin expt sqrt"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"asinh isqrt tan"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"atan log tanh"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"atanh phase"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"cis pi"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Figure 12\u20132. Defined names relating to Exponentials, Logarithms, and Trigonometry."})," Figure 12\u20133 shows ",(0,i.jsx)(n.em,{children:"operators"})," relating to numeric comparison and predication."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"/="})," >",(0,i.jsx)(n.strong,{children:"= oddp"})," "]}),(0,i.jsxs)("p",{children:["< ",(0,i.jsx)(n.strong,{children:"evenp plusp"})," "]}),(0,i.jsxs)("p",{children:["<",(0,i.jsx)(n.strong,{children:"= max zerop"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"= min"})," "]}),(0,i.jsxs)("p",{children:["> ",(0,i.jsx)(n.strong,{children:"minusp"})]}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20133. Operators for numeric comparison and predication."})}),"\n",(0,i.jsxs)(n.p,{children:["Figure 12\u20134 shows ",(0,i.jsx)(n.em,{children:"defined names"})," relating to numeric type manipulation and coercion."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"ceiling float-radix rational"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"complex float-sign rationalize decode-float floor realpart"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"denominator fround rem"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"fceiling ftruncate round"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"ffloor imagpart scale-float float integer-decode-float truncate"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"float-digits mod"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"float-precision numerator"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20134. Defined names relating to numeric type manipulation and coercion."})})]})}function l(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}function c(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["For functions that are mathematically associative (and possibly commutative), a ",(0,i.jsx)(n.em,{children:"conforming implementation"})," may process the ",(0,i.jsx)(n.em,{children:"arguments"})," in any manner consistent with associative (and possibly commutative) rearrangement. This does not affect the order in which the ",(0,i.jsx)(n.em,{children:"argument"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"forms"})," are ",(0,i.jsx)(n.em,{children:"evaluated"}),"; for a discussion of evaluation order, see Section 3.1.2.1.2.3 (Function Forms). What is unspecified is only the order in which the ",(0,i.jsx)(n.em,{children:"parameter values"})," are processed. This implies that ",(0,i.jsx)(n.em,{children:"implementations"})," may differ in which automatic ",(0,i.jsx)(n.em,{children:"coercions"})," are applied; see Section 12.1.1.2 (Contagion in Numeric Operations)."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"conforming program"})," can control the order of processing explicitly by separating the operations into separate (possibly nested) ",(0,i.jsx)(n.em,{children:"function forms"}),", or by writing explicit calls to ",(0,i.jsx)(n.em,{children:"functions"})," that perform coercions."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function d(e){const n={code:"code",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"\nConsider the following expression, in which we assume that 1.0 and 1.0e-15 both denote *single floats*: \n(+ 1/3 2/3 1.0d0 1.0 1.0e-15) \nOne *conforming implementation* might process the *arguments* from left to right, first adding 1/3 and 2/3 to get 1, then converting that to a *double float* for combination with 1.0d0, then successively converting and adding 1.0 and 1.0e-15. \nAnother *conforming implementation* might process the *arguments* from right to left, first performing a *single float* addition of 1.0 and 1.0e-15 (perhaps losing accuracy in the process), then converting the sum to a *double float* and adding 1.0d0, then converting 2/3 to a *double float* and adding it, and then converting 1/3 and adding that. \nA third *conforming implementation* might first scan all the *arguments*, process all the *rationals* first to keep that part of the computation exact, then find an *argument* of the largest floating-point \n\n\n\nformat among all the *arguments* and add that, and then add in all other *arguments*, converting each in turn (all in a perhaps misguided attempt to make the computation as accurate as possible). \nIn any case, all three strategies are legitimate. \nA *conforming program* could control the order by writing, for example, \n(+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0) \n\n"})})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function m(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["For information about the contagion rules for implicit coercions of ",(0,i.jsx)(n.em,{children:"arguments"})," in numeric operations, see Section 12.1.4.4 (Rule of Float Precision Contagion), Section 12.1.4.1 (Rule of Float and Rational Contagion), and Section 12.1.5.2 (Rule of Complex Contagion)."]})}function x(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}function u(e){return(0,i.jsx)(i.Fragment,{})}function j(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u()}function f(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Logical operations require ",(0,i.jsx)(n.em,{children:"integers"})," as arguments; an error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"type-error"})," should be signaled if an argument is supplied that is not an ",(0,i.jsx)(n.em,{children:"integer"})," . ",(0,i.jsx)(n.em,{children:"Integer"})," arguments to logical operations are treated as if they were represented in two\u2019s-complement notation."]}),"\n",(0,i.jsxs)(n.p,{children:["Figure 12\u20135 shows ",(0,i.jsx)(n.em,{children:"defined names"})," relating to logical operations on numbers."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"ash boole-ior logbitp"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole boole-nand logcount"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-1 boole-nor logeqv"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-2 boole-orc1 logior"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-and boole-orc2 lognand"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-andc1 boole-set lognor"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-andc2 boole-xor lognot"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-c1 integer-length logorc1"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-c2 logand logorc2"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"boole-clr logandc1 logtest"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"boole-eqv logandc2 logxor"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20135. Defined names relating to logical operations on numbers."})})]})}function g(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}function b(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The byte-manipulation ",(0,i.jsx)(n.em,{children:"functions"})," use ",(0,i.jsx)(n.em,{children:"objects"})," called ",(0,i.jsx)(n.em,{children:"byte specifiers"})," to designate the size and position of a specific ",(0,i.jsx)(n.em,{children:"byte"})," within an ",(0,i.jsx)(n.em,{children:"integer"})," . The representation of a ",(0,i.jsx)(n.em,{children:"byte specifier"})," is ",(0,i.jsx)(n.em,{children:"implementation dependent"}),"; it might or might not be a ",(0,i.jsx)(n.em,{children:"number"})," . The ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"byte"})," will construct a ",(0,i.jsx)(n.em,{children:"byte specifier"})," , which various other byte-manipulation ",(0,i.jsx)(n.em,{children:"functions"})," will accept."]}),"\n",(0,i.jsxs)(n.p,{children:["Figure 12\u20136 shows ",(0,i.jsx)(n.em,{children:"defined names"})," relating to manipulating ",(0,i.jsx)(n.em,{children:"bytes"})," of ",(0,i.jsx)(n.em,{children:"numbers"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"byte deposit-field ldb-test"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"byte-position dpb mask-field"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"byte-size ldb"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20136. Defined names relating to byte manipulation."})})]})}function v(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}function y(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Figure 12\u20137 shows ",(0,i.jsx)(n.em,{children:"defined names"})," relating to ",(0,i.jsx)(n.em,{children:"implementation-dependent"})," details about ",(0,i.jsx)(n.em,{children:"numbers"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"double-float-epsilon most-negative-fixnum"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"double-float-negative-epsilon most-negative-long-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-negative-double-float most-negative-short-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-negative-long-float most-negative-single-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-negative-short-float most-positive-double-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-negative-single-float most-positive-fixnum"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-positive-double-float most-positive-long-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-positive-long-float most-positive-short-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-positive-short-float most-positive-single-float"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"least-positive-single-float short-float-epsilon"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"long-float-epsilon short-float-negative-epsilon long-float-negative-epsilon single-float-epsilon"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"most-negative-double-float single-float-negative-epsilon"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20137. Defined names relating to implementation-dependent details about numbers."})})]})}function w(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(y,{...e})}):y(e)}function C(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["The rules in this section apply to ",(0,i.jsx)(n.em,{children:"rational"})," computations."]})}function F(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(C,{...e})}):C(e)}function R(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["Rational computations cannot overflow in the usual sense (though there may not be enough storage to represent a result), since ",(0,i.jsx)(n.em,{children:"integers"})," and ",(0,i.jsx)(n.em,{children:"ratios"})," may in principle be of any magnitude."]})}function T(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(R,{...e})}):R(e)}function I(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["If any computation produces a result that is a mathematical ratio of two integers such that the denominator evenly divides the numerator, then the result is converted to the equivalent ",(0,i.jsx)(n.em,{children:"integer"})," ."]}),"\n",(0,i.jsxs)(n.p,{children:["If the denominator does not evenly divide the numerator, the canonical representation of a ",(0,i.jsx)(n.em,{children:"rational"})," number is as the ",(0,i.jsx)(n.em,{children:"ratio"})," that numerator and that denominator, where the greatest common divisor of the numerator and denominator is one, and where the denominator is positive and greater than one."]}),"\n",(0,i.jsxs)(n.p,{children:["When used as input (in the default syntax), the notation -0 always denotes the ",(0,i.jsx)(n.em,{children:"integer"})," 0. A ",(0,i.jsx)(n.em,{children:"conforming implementation"})," must not have a representation of \u201cminus zero\u201d for ",(0,i.jsx)(n.em,{children:"integers"})," that is distinct from its representation of zero for ",(0,i.jsx)(n.em,{children:"integers"}),". However, such a distinction is possible for ",(0,i.jsx)(n.em,{children:"floats"}),"; see the ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"float"}),"."]})]})}function N(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(I,{...e})}):I(e)}function z(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When the arguments to an irrational mathematical ",(0,i.jsx)(n.em,{children:"function"})," are all ",(0,i.jsx)(n.em,{children:"rational"})," and the true mathe matical result is also (mathematically) rational, then unless otherwise noted an implementation is free to return either an accurate ",(0,i.jsx)(n.em,{children:"rational"})," result or a ",(0,i.jsx)(n.em,{children:"single float"})," approximation. If the arguments"]}),"\n",(0,i.jsxs)(n.p,{children:["are all ",(0,i.jsx)(n.em,{children:"rational"})," but the result cannot be expressed as a ",(0,i.jsx)(n.em,{children:"rational"})," number, then a ",(0,i.jsx)(n.em,{children:"single float"})," approximation is always returned."]}),"\n",(0,i.jsxs)(n.p,{children:["If the arguments to an irrational mathematical ",(0,i.jsx)(n.em,{children:"function"})," are all of type"]}),"\n",(0,i.jsxs)(n.p,{children:["(or rational (complex rational)) and the true mathematical result is (mathematically) a complex number with rational real and imaginary parts, then unless otherwise noted an imple mentation is free to return either an accurate result of type (or rational (complex rational)) or a ",(0,i.jsx)(n.em,{children:"single float"})," (permissible only if the imaginary part of the true mathematical result is zero) or (complex single-float). If the arguments are all of type (or rational (complex rational)) but the result cannot be expressed as a ",(0,i.jsx)(n.em,{children:"rational"})," or ",(0,i.jsx)(n.em,{children:"complex rational"}),", then the returned value will be of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"single-float"})," (permissible only if the imaginary part of the true mathematical result is zero) or (complex single-float)."]}),"\n",(0,i.jsxs)(n.p,{children:["Float substitutability applies neither to the rational ",(0,i.jsx)(n.em,{children:"functions"})," ",(0,i.jsx)(n.strong,{children:"+"}),", ",(0,i.jsx)(n.strong,{children:"-"}),", ",(0,i.jsx)(n.strong,{children:"*"}),", and ",(0,i.jsx)(n.strong,{children:"/"})," nor to the related ",(0,i.jsx)(n.em,{children:"operators"})," ",(0,i.jsx)(n.strong,{children:"1+"}),", ",(0,i.jsx)(n.strong,{children:"1-"}),", ",(0,i.jsx)(n.strong,{children:"incf"}),", ",(0,i.jsx)(n.strong,{children:"decf"}),", and ",(0,i.jsx)(n.strong,{children:"conjugate"}),". For rational ",(0,i.jsx)(n.em,{children:"functions"}),", if all arguments are ",(0,i.jsx)(n.em,{children:"rational"}),", then the result is ",(0,i.jsx)(n.em,{children:"rational"}),"; if all arguments are of type (or rational (complex rational)), then the result is of type (or rational (complex rational))."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsx)(n.strong,{children:"Function Sample Results"}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"abs"})," (abs #c(3 4)) \u2192 5 ",(0,i.jsx)(n.em,{children:"or"})," 5.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"acos"})," (acos 1) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"acosh"})," (acosh 1) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"asin"})," (asin 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"asinh"})," (asinh 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"atan"})," (atan 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"atanh"})," (atanh 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"cis"})," (cis 0) \u2192 1 ",(0,i.jsx)(n.em,{children:"or"})," #c(1.0 0.0) "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"cos"})," (cos 0) \u2192 1 ",(0,i.jsx)(n.em,{children:"or"})," 1.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"cosh"})," (cosh 0) \u2192 1 ",(0,i.jsx)(n.em,{children:"or"})," 1.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"exp"})," (exp 0) \u2192 1 ",(0,i.jsx)(n.em,{children:"or"})," 1.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"expt"})," (expt 8 1/3) \u2192 2 ",(0,i.jsx)(n.em,{children:"or"})," 2.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"log"})," (log 1) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:["(log 8 2) \u2192 3 ",(0,i.jsx)(n.em,{children:"or"})," 3.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"phase"})," (phase 7) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"signum"})," (signum #c(3 4)) \u2192 #c(3/5 4/5) ",(0,i.jsx)(n.em,{children:"or"})," #c(0.6 0.8) ",(0,i.jsx)(n.strong,{children:"sin"})," (sin 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"sinh"})," (sinh 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"sqrt"})," (sqrt 4) \u2192 2 ",(0,i.jsx)(n.em,{children:"or"})," 2.0 "]}),(0,i.jsxs)("p",{children:["(sqrt 9/16) \u2192 3/4 ",(0,i.jsx)(n.em,{children:"or"})," 0.75 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"tan"})," (tan 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0 "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"tanh"})," (tanh 0) \u2192 0 ",(0,i.jsx)(n.em,{children:"or"})," 0.0"]}),"|"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20138. Functions Affected by Rule of Float Substitutability"})})]})}function A(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(z,{...e})}):z(e)}function O(e){const n={p:"p",...(0,t.a)(),...e.components};return(0,i.jsx)(n.p,{children:"The following rules apply to floating point computations."})}function E(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(O,{...e})}):O(e)}function q(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.em,{children:"rationals"})," and ",(0,i.jsx)(n.em,{children:"floats"})," are combined by a numerical function, the ",(0,i.jsx)(n.em,{children:"rational"})," is first converted to a ",(0,i.jsx)(n.em,{children:"float"})," of the same format. For ",(0,i.jsx)(n.em,{children:"functions"})," such as ",(0,i.jsx)(n.strong,{children:"+"})," that take more than two arguments, it is permitted that part of the operation be carried out exactly using ",(0,i.jsx)(n.em,{children:"rationals"})," and the rest be done using floating-point arithmetic."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.em,{children:"rationals"})," and ",(0,i.jsx)(n.em,{children:"floats"})," are compared by a numerical function, the ",(0,i.jsx)(n.em,{children:"function"})," ",(0,i.jsx)(n.strong,{children:"rational"})," is effectively called to convert the ",(0,i.jsx)(n.em,{children:"float"})," to a ",(0,i.jsx)(n.em,{children:"rational"})," and then an exact comparison is performed. In the case of ",(0,i.jsx)(n.em,{children:"complex"})," numbers, the real and imaginary parts are effectively handled individually."]})]})}function k(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}function P(e){const n={code:"code",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"\n;;;; Combining rationals with floats. \n;;; This example assumes an implementation in which \n;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360), \n;;; or else some other implementation in which 1/2 has an exact \n;;; representation in floating point. \n(+ 1/2 0.5) \u2192 1.0 \n(- 1/2 0.5d0) \u2192 0.0d0 \n(+ 0.5 -0.5 1/2) \u2192 0.5 \n;;;; Comparing rationals with floats. \n;;; This example assumes an implementation in which the default float \n;;; format is IEEE single-float, IEEE double-float, or some other format \n;;; in which 5/7 is rounded upwards by FLOAT. \n(< 5/7 (float 5/7)) \u2192 true \n(< 5/7 (rational (float 5/7))) \u2192 true \n(< (float 5/7) (float 5/7)) \u2192 false \n\n"})})}function L(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(P,{...e})}):P(e)}function S(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["Computations with ",(0,i.jsx)(n.em,{children:"floats"})," are only approximate, although they are described as if the results were mathematically accurate. Two mathematically identical expressions may be computationally different because of errors inherent in the floating-point approximation process. The precision of a ",(0,i.jsx)(n.em,{children:"float"})," is not necessarily correlated with the accuracy of that number. For instance, 3.142857142857142857 is a more precise approximation to ",(0,i.jsx)(n.em,{children:"\u03c0"})," than 3.14159, but the latter is more accurate. The precision refers to the number of bits retained in the representation. When an operation combines a ",(0,i.jsx)(n.em,{children:"short float"})," with a ",(0,i.jsx)(n.em,{children:"long float"}),", the result will be a ",(0,i.jsx)(n.em,{children:"long float"}),". Common Lisp functions assume that the accuracy of arguments to them does not exceed their precision. Therefore when two ",(0,i.jsx)(n.em,{children:"small floats"})," are combined, the result is a ",(0,i.jsx)(n.em,{children:"small float"}),". Common Lisp functions never convert automatically from a larger size to a smaller one."]})}function B(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(S,{...e})}):S(e)}function M(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["An error of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"floating-point-overflow"})," or ",(0,i.jsx)(n.strong,{children:"floating-point-underflow"})," should be signaled if a floating-point computation causes exponent overflow or underflow, respectively."]})}function D(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(M,{...e})}):M(e)}function W(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["The result of a numerical function is a ",(0,i.jsx)(n.em,{children:"float"})," of the largest format among all the floating-point arguments to the ",(0,i.jsx)(n.em,{children:"function"}),"."]})}function V(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(W,{...e})}):W(e)}function U(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["The following rules apply to ",(0,i.jsx)(n.em,{children:"complex"})," computations:"]})}function _(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(U,{...e})}):U(e)}function H(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["Except during the execution of irrational and transcendental ",(0,i.jsx)(n.em,{children:"functions"}),", no numerical ",(0,i.jsx)(n.em,{children:"function"})," ever ",(0,i.jsx)(n.em,{children:"yields"})," a ",(0,i.jsx)(n.em,{children:"complex"})," unless one or more of its ",(0,i.jsx)(n.em,{children:"arguments"})," is a ",(0,i.jsx)(n.em,{children:"complex"})," ."]})}function Q(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(H,{...e})}):H(e)}function Z(e){const n={em:"em",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.em,{children:"real"})," and a ",(0,i.jsx)(n.em,{children:"complex"})," are both part of a computation, the ",(0,i.jsx)(n.em,{children:"real"})," is first converted to a ",(0,i.jsx)(n.em,{children:"complex"})," by providing an imaginary part of 0."]})}function G(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(Z,{...e})}):Z(e)}function J(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["If the result of any computation would be a ",(0,i.jsx)(n.em,{children:"complex"})," number whose real part is of ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.strong,{children:"rational"})," and whose imaginary part is zero, the result is converted to the ",(0,i.jsx)(n.em,{children:"rational"})," which is the real part. This rule does not apply to ",(0,i.jsx)(n.em,{children:"complex"})," numbers whose parts are ",(0,i.jsx)(n.em,{children:"floats"}),". For example, #C(5 0) and 5 are not ",(0,i.jsx)(n.em,{children:"different objects"})," in Common Lisp(they are always the ",(0,i.jsx)(n.em,{children:"same"})," under ",(0,i.jsx)(n.strong,{children:"eql"}),"); #C(5.0 0.0) and"]}),"\n",(0,i.jsxs)(n.p,{children:["5.0 are always ",(0,i.jsx)(n.em,{children:"different objects"})," in Common Lisp (they are never the ",(0,i.jsx)(n.em,{children:"same"})," under ",(0,i.jsx)(n.strong,{children:"eql"}),", although they are the ",(0,i.jsx)(n.em,{children:"same"})," under ",(0,i.jsx)(n.strong,{children:"equalp"})," and ",(0,i.jsx)(n.strong,{children:"="}),")."]})]})}function K(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(J,{...e})}):J(e)}function X(e){const n={code:"code",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"\n#c(1.0 1.0) \u2192 #C(1.0 1.0) \n#c(0.0 0.0) \u2192 #C(0.0 0.0) \n#c(1.0 1) \u2192 #C(1.0 1.0) \n#c(0.0 0) \u2192 #C(0.0 0.0) \n#c(1 1) \u2192 #C(1 1) \n#c(0 0) \u2192 0 \n(typep #c(1 1) \u2019(complex (eql 1))) \u2192 true \n(typep #c(0 0) \u2019(complex (eql 0))) \u2192 false \n\n\n\n\n"})})}function Y(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(X,{...e})}):X(e)}function $(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Many of the irrational and transcendental functions are multiply defined in the complex domain; for example, there are in general an infinite number of complex values for the logarithm function. In each such case, a ",(0,i.jsx)(n.em,{children:"principal value"})," must be chosen for the function to return. In general, such values cannot be chosen so as to make the range continuous; lines in the domain called branch cuts must be defined, which in turn define the discontinuities in the range. Common Lisp defines the branch cuts, ",(0,i.jsx)(n.em,{children:"principal values"}),", and boundary conditions for the complex functions following \u201cPrincipal Values and Branch Cuts in Complex APL.\u201d The branch cut rules that apply to each function are located with the description of that function."]}),"\n",(0,i.jsx)(n.p,{children:"Figure 12\u20139 lists the identities that are obeyed throughout the applicable portion of the complex domain, even on the branch cuts:"}),"\n",(0,i.jsx)(n.p,{children:"|sin i z = i sinh z sinh i z = i sin z arctan i z = i arctanh z cos i z = cosh z cosh i z = cos z arcsinh i z = i arcsin z tan i z = i tanh z arcsin i z = i arcsinh z arctanh i z = i arctan z|"}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u20139. Trigonometric Identities for Complex Domain"})}),"\n",(0,i.jsx)(n.p,{children:"The quadrant numbers referred to in the discussions of branch cuts are as illustrated in Figure 12\u201310."}),"\n",(0,i.jsx)(n.p,{children:"Positive"}),"\n",(0,i.jsx)(n.p,{children:"Imaginary Axis"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("sup",{children:".."}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("sub",{children:"II"}),(0,i.jsx)("sup",{children:".."}),". I"]}),"\n",(0,i.jsxs)(n.p,{children:["Negative Real Axis ",(0,i.jsx)(n.em,{children:"\xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7 \xb7"})," Positive Real Axis"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("sub",{children:"III"}),(0,i.jsx)("sup",{children:".."}),". IV"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("sup",{children:".."}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Negative"}),"\n",(0,i.jsx)(n.p,{children:"Imaginary Axis"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u201310. Quadrant Numbering for Branch Cuts"})})]})}function ee(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)($,{...e})}):$(e)}function ne(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"compound type specifier"})," form of the numeric ",(0,i.jsx)(n.em,{children:"type specifiers"})," permit the user to specify an interval on the real number line which describe a ",(0,i.jsx)(n.em,{children:"subtype"})," of the ",(0,i.jsx)(n.em,{children:"type"})," which would be described by the corresponding ",(0,i.jsx)(n.em,{children:"atomic type specifier"})," . A ",(0,i.jsx)(n.em,{children:"subtype"})," of some ",(0,i.jsx)(n.em,{children:"type T"})," is specified using an ordered pair of ",(0,i.jsx)(n.em,{children:"objects"})," called ",(0,i.jsx)(n.em,{children:"interval designators"})," for ",(0,i.jsx)(n.em,{children:"type T"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The first of the two ",(0,i.jsx)(n.em,{children:"interval designators"})," for ",(0,i.jsx)(n.em,{children:"type T"})," can be any of the following:"]}),"\n",(0,i.jsxs)(n.p,{children:["a number ",(0,i.jsx)(n.em,{children:"N"})," of ",(0,i.jsx)(n.em,{children:"type T"})]}),"\n",(0,i.jsxs)(n.p,{children:["This denotes a lower inclusive bound of ",(0,i.jsx)(n.em,{children:"N"}),". That is, ",(0,i.jsx)(n.em,{children:"elements"})," of the ",(0,i.jsx)(n.em,{children:"subtype"})," of ",(0,i.jsx)(n.em,{children:"T"})," will be greater than or equal to ",(0,i.jsx)(n.em,{children:"N"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["a ",(0,i.jsx)(n.em,{children:"singleton list"})," whose ",(0,i.jsx)(n.em,{children:"element"})," is a number ",(0,i.jsx)(n.em,{children:"M"})," of ",(0,i.jsx)(n.em,{children:"type T"})]}),"\n",(0,i.jsxs)(n.p,{children:["This denotes a lower exclusive bound of ",(0,i.jsx)(n.em,{children:"M"}),". That is, ",(0,i.jsx)(n.em,{children:"elements"})," of the ",(0,i.jsx)(n.em,{children:"subtype"})," of ",(0,i.jsx)(n.em,{children:"T"})," will be greater than ",(0,i.jsx)(n.em,{children:"M"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["the symbol ",(0,i.jsx)(n.strong,{children:"*"})]}),"\n",(0,i.jsx)(n.p,{children:"This denotes the absence of a lower bound on the interval."}),"\n",(0,i.jsxs)(n.p,{children:["The second of the two ",(0,i.jsx)(n.em,{children:"interval designators"})," for ",(0,i.jsx)(n.em,{children:"type T"})," can be any of the following:"]}),"\n",(0,i.jsxs)(n.p,{children:["a number ",(0,i.jsx)(n.em,{children:"N"})," of ",(0,i.jsx)(n.em,{children:"type T"})]}),"\n",(0,i.jsxs)(n.p,{children:["This denotes an upper inclusive bound of ",(0,i.jsx)(n.em,{children:"N"}),". That is, ",(0,i.jsx)(n.em,{children:"elements"})," of the ",(0,i.jsx)(n.em,{children:"subtype"})," of ",(0,i.jsx)(n.em,{children:"T"})," will be less than or equal to ",(0,i.jsx)(n.em,{children:"N"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["a ",(0,i.jsx)(n.em,{children:"singleton list"})," whose ",(0,i.jsx)(n.em,{children:"element"})," is a number ",(0,i.jsx)(n.em,{children:"M"})," of ",(0,i.jsx)(n.em,{children:"type T"})]}),"\n",(0,i.jsxs)(n.p,{children:["This denotes an upper exclusive bound of ",(0,i.jsx)(n.em,{children:"M"}),". That is, ",(0,i.jsx)(n.em,{children:"elements"})," of the ",(0,i.jsx)(n.em,{children:"subtype"})," of ",(0,i.jsx)(n.em,{children:"T"})," will be less than ",(0,i.jsx)(n.em,{children:"M"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["the symbol ",(0,i.jsx)(n.strong,{children:"*"})]}),"\n",(0,i.jsx)(n.p,{children:"This denotes the absence of an upper bound on the interval."})]})}function se(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(ne,{...e})}):ne(e)}function ie(e){const n={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Figure 12\u201311 lists some ",(0,i.jsx)(n.em,{children:"defined names"})," that are applicable to ",(0,i.jsx)(n.em,{children:"random states"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"*random-state* random"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"make-random-state random-state-p"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 12\u201311. Random-state defined names"})})]})}function te(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(ie,{...e})}):ie(e)}const re={title:"12.1 Number Concepts"},oe="12.1 Number Concepts",ae={id:"chap-12/bc-b-number-concepts",title:"12.1 Number Concepts",description:"12.1.1 Numeric Operations",source:"@site/docs/chap-12/bc-b-number-concepts.md",sourceDirName:"chap-12",slug:"/chap-12/bc-b-number-concepts",permalink:"/cl-language-reference/docs/chap-12/bc-b-number-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-12/bc-b-number-concepts.md",tags:[],version:"current",frontMatter:{title:"12.1 Number Concepts"},sidebar:"tutorialSidebar",previous:{title:"12. Numbers",permalink:"/cl-language-reference/docs/category/12-numbers"},next:{title:"12.2 Numbers Dictionary",permalink:"/cl-language-reference/docs/category/122-numbers-dictionary"}},le={},ce=[{value:"12.1.1 Numeric Operations",id:"1211-numeric-operations",level:2},{value:"12.1.1.1 Associativity and Commutativity in Numeric Operations",id:"12111-associativity-and-commutativity-in-numeric-operations",level:3},{value:"12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations",id:"121111-examples-of-associativity-and-commutativity-in-numeric-operations",level:4},{value:"12.1.1.2 Contagion in Numeric Operations",id:"12112-contagion-in-numeric-operations",level:3},{value:"12.1.1.3 Viewing Integers as Bits and Bytes",id:"12113-viewing-integers-as-bits-and-bytes",level:3},{value:"12.1.1.3.1 Logical Operations on Integers",id:"121131-logical-operations-on-integers",level:4},{value:"12.1.1.3.2 Byte Operations on Integers",id:"121132-byte-operations-on-integers",level:4},{value:"12.1.2 Implementation",id:"1212-implementation",level:2},{value:"12.1.3 Rational Computations",id:"1213-rational-computations",level:2},{value:"12.1.3.1 Rule of Unbounded Rational Precision",id:"12131-rule-of-unbounded-rational-precision",level:3},{value:"12.1.3.2 Rule of Canonical Representation for Rationals",id:"12132-rule-of-canonical-representation-for-rationals",level:3},{value:"12.1.3.3 Rule of Float Substitutability",id:"12133-rule-of-float-substitutability",level:3},{value:"12.1.4 Floating",id:"1214-floating",level:2},{value:"12.1.4.1 Rule of Float and Rational Contagion",id:"12141-rule-of-float-and-rational-contagion",level:3},{value:"12.1.4.1.1 Examples of Rule of Float and Rational Contagion",id:"121411-examples-of-rule-of-float-and-rational-contagion",level:4},{value:"12.1.4.2 Rule of Float Approximation",id:"12142-rule-of-float-approximation",level:3},{value:"12.1.4.3 Rule of Float Underflow and Overflow",id:"12143-rule-of-float-underflow-and-overflow",level:3},{value:"12.1.4.4 Rule of Float Precision Contagion",id:"12144-rule-of-float-precision-contagion",level:3},{value:"12.1.5 Complex Computations",id:"1215-complex-computations",level:2},{value:"12.1.5.1 Rule of Complex Substitutability",id:"12151-rule-of-complex-substitutability",level:3},{value:"12.1.5.2 Rule of Complex Contagion",id:"12152-rule-of-complex-contagion",level:3},{value:"12.1.5.3 Rule of Canonical Representation for Complex Rationals",id:"12153-rule-of-canonical-representation-for-complex-rationals",level:3},{value:"12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals",id:"121531-examples-of-rule-of-canonical-representation-for-complex-rationals",level:4},{value:"12.1.5.4 Principal Values and Branch Cuts",id:"12154-principal-values-and-branch-cuts",level:3},{value:"12.1.6 Interval Designators",id:"1216-interval-designators",level:2},{value:"12.1.7 Random",id:"1217-random",level:2}];function he(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"121-number-concepts",children:"12.1 Number Concepts"}),"\n","\n",(0,i.jsx)(o,{}),"\n",(0,i.jsx)(n.h2,{id:"1211-numeric-operations",children:"12.1.1 Numeric Operations"}),"\n","\n",(0,i.jsx)(l,{}),"\n",(0,i.jsx)(n.h3,{id:"12111-associativity-and-commutativity-in-numeric-operations",children:"12.1.1.1 Associativity and Commutativity in Numeric Operations"}),"\n","\n",(0,i.jsx)(h,{}),"\n",(0,i.jsx)(n.h4,{id:"121111-examples-of-associativity-and-commutativity-in-numeric-operations",children:"12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations"}),"\n","\n",(0,i.jsx)(p,{}),"\n",(0,i.jsx)(n.h3,{id:"12112-contagion-in-numeric-operations",children:"12.1.1.2 Contagion in Numeric Operations"}),"\n","\n",(0,i.jsx)(x,{}),"\n",(0,i.jsx)(n.h3,{id:"12113-viewing-integers-as-bits-and-bytes",children:"12.1.1.3 Viewing Integers as Bits and Bytes"}),"\n","\n",(0,i.jsx)(j,{}),"\n",(0,i.jsx)(n.h4,{id:"121131-logical-operations-on-integers",children:"12.1.1.3.1 Logical Operations on Integers"}),"\n","\n",(0,i.jsx)(g,{}),"\n",(0,i.jsx)(n.h4,{id:"121132-byte-operations-on-integers",children:"12.1.1.3.2 Byte Operations on Integers"}),"\n","\n",(0,i.jsx)(v,{}),"\n",(0,i.jsx)(n.h2,{id:"1212-implementation",children:"12.1.2 Implementation"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(n.h2,{id:"1213-rational-computations",children:"12.1.3 Rational Computations"}),"\n","\n",(0,i.jsx)(F,{}),"\n",(0,i.jsx)(n.h3,{id:"12131-rule-of-unbounded-rational-precision",children:"12.1.3.1 Rule of Unbounded Rational Precision"}),"\n","\n",(0,i.jsx)(T,{}),"\n",(0,i.jsx)(n.h3,{id:"12132-rule-of-canonical-representation-for-rationals",children:"12.1.3.2 Rule of Canonical Representation for Rationals"}),"\n","\n",(0,i.jsx)(N,{}),"\n",(0,i.jsx)(n.h3,{id:"12133-rule-of-float-substitutability",children:"12.1.3.3 Rule of Float Substitutability"}),"\n","\n",(0,i.jsx)(A,{}),"\n",(0,i.jsx)(n.h2,{id:"1214-floating",children:"12.1.4 Floating"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(n.h3,{id:"12141-rule-of-float-and-rational-contagion",children:"12.1.4.1 Rule of Float and Rational Contagion"}),"\n","\n",(0,i.jsx)(k,{}),"\n",(0,i.jsx)(n.h4,{id:"121411-examples-of-rule-of-float-and-rational-contagion",children:"12.1.4.1.1 Examples of Rule of Float and Rational Contagion"}),"\n","\n",(0,i.jsx)(L,{}),"\n",(0,i.jsx)(n.h3,{id:"12142-rule-of-float-approximation",children:"12.1.4.2 Rule of Float Approximation"}),"\n","\n",(0,i.jsx)(B,{}),"\n",(0,i.jsx)(n.h3,{id:"12143-rule-of-float-underflow-and-overflow",children:"12.1.4.3 Rule of Float Underflow and Overflow"}),"\n","\n",(0,i.jsx)(D,{}),"\n",(0,i.jsx)(n.h3,{id:"12144-rule-of-float-precision-contagion",children:"12.1.4.4 Rule of Float Precision Contagion"}),"\n","\n",(0,i.jsx)(V,{}),"\n",(0,i.jsx)(n.h2,{id:"1215-complex-computations",children:"12.1.5 Complex Computations"}),"\n","\n",(0,i.jsx)(_,{}),"\n",(0,i.jsx)(n.h3,{id:"12151-rule-of-complex-substitutability",children:"12.1.5.1 Rule of Complex Substitutability"}),"\n","\n",(0,i.jsx)(Q,{}),"\n",(0,i.jsx)(n.h3,{id:"12152-rule-of-complex-contagion",children:"12.1.5.2 Rule of Complex Contagion"}),"\n","\n",(0,i.jsx)(G,{}),"\n",(0,i.jsx)(n.h3,{id:"12153-rule-of-canonical-representation-for-complex-rationals",children:"12.1.5.3 Rule of Canonical Representation for Complex Rationals"}),"\n","\n",(0,i.jsx)(K,{}),"\n",(0,i.jsx)(n.h4,{id:"121531-examples-of-rule-of-canonical-representation-for-complex-rationals",children:"12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals"}),"\n","\n",(0,i.jsx)(Y,{}),"\n",(0,i.jsx)(n.h3,{id:"12154-principal-values-and-branch-cuts",children:"12.1.5.4 Principal Values and Branch Cuts"}),"\n","\n",(0,i.jsx)(ee,{}),"\n",(0,i.jsx)(n.h2,{id:"1216-interval-designators",children:"12.1.6 Interval Designators"}),"\n","\n",(0,i.jsx)(se,{}),"\n",(0,i.jsx)(n.h2,{id:"1217-random",children:"12.1.7 Random"}),"\n","\n","\n",(0,i.jsx)(te,{})]})}function de(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(he,{...e})}):he(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>o});var i=s(67294);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);