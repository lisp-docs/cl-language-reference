"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[73754],{56729:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>_,contentTitle:()=>T,default:()=>I,frontMatter:()=>v,metadata:()=>k,toc:()=>S});var t=n(85893),s=n(11151);function o(e){const i={a:"a",h1:"h1",h3:"h3",li:"li",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"chapter-6-sections",children:"Chapter 6 Sections"}),"\n",(0,t.jsx)(i.h3,{id:"chapter-6-sections-1",children:"Chapter 6 Sections"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects2",children:"Initialization of class metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/initialization-of-generic-function-metaobjects",children:"Initialization of generic function metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/initialization-of-method-metaobjects",children:"Initialization of method metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/initialization-of-slot-definition-metaobjects",children:"Initialization of slot definition metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-class-metaobjects",children:"Readers for class metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-generic-function-metaobjects",children:"Readers for generic function metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-method-metaobjects",children:"Readers for method metaobjects"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-slot-definition-metaobjects",children:"Readers for slot definition metaobjects"})}),"\n"]})]})}function r(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}function a(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"initialization-of-class-metaobjects",children:"Initialization of Class Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"initialization-of-class-metaobjects-1",children:"Initialization of Class Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["A class metaobject can be created by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the class. A class metaobject can be redefined by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Some classes of class metaobject do not support redefinition; in these cases, ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization of a class metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Reinitialization of a class metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a class metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize or reinitialize a class metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any class metaobject or to turn a non-class object into a class metaobject."]}),"\n",(0,t.jsxs)(i.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on class metaobjects. Since the class of class metaobjects may not be changed, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on class metaobjects."]}),"\n",(0,t.jsxs)(i.p,{children:["During initialization or reinitialization, each initialization argument is checked for errors and then associated with the class metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below. (FIXME",":insert"," anchor)"]}),"\n",(0,t.jsx)(i.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. Initialization behavior specific to the different specified class metaobject classes comes next. The section ends with a set of restrictions on portable methods affecting class metaobject initialization and reinitialization."}),"\n",(0,t.jsxs)(i.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,t.jsx)(i.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,t.jsx)(i.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified class metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_class.htm#class",children:"class"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Unless there is a specific note to the contrary, then during reinitialization, if an initialization argument is not supplied, the previously stored value is left unchanged."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":direct-default-initargs"})," argument is a list of canonicalized default initialization arguments."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper list, or if any element of the list is not a canonicalized default initialization argument."}),"\n",(0,t.jsx)(i.p,{children:"If the class metaobject is being initialized, this argument defaults to the empty list."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":direct-slots"})," argument is a list of canonicalized slot specifications."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper list or if any element of the list is not a canonicalized slot specification."}),"\n",(0,t.jsxs)(i.p,{children:["After error checking, this value is converted to a list of direct slot definition metaobjects before it is associated with the class metaobject. Conversion of each canonicalized slot specification to a direct slot definition metaobject is a two-step process. First, the generic function ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/direct-slot-definition-class",children:"direct-slot-definition-class"})," is called with the class metaobject and the canonicalized slot specification to determine the class of the new direct slot definition metaobject; this permits both the class metaobject and the canonicalized slot specification to control the resulting direct slot definition metaobject class. Second, ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," is applied to the direct slot definition metaobject class and the canonicalized slot specification. This conversion could be implemented as shown in the following code:"]}),"\n",(0,t.jsx)(i.p,{children:"(defun convert-to-direct-slot-definition (class canonicalized-slot)\n(apply #'make-instance\n(apply #'direct-slot-definition-class\nclass canonicalized-slot)\ncanonicalized-slot))"}),"\n",(0,t.jsx)(i.p,{children:"If the class metaobject is being initialized, this argument defaults to the empty list."}),"\n",(0,t.jsxs)(i.p,{children:["Once the direct slot definition metaobjects have been created, the specified reader and writer methods are created. The generic functions ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/reader-method-class",children:"reader-method-class"})," and ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/writer-method-class",children:"writer-method-class"})," are called to determine the classes of the method metaobjects created."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":direct-superclasses"})," argument is a list of class metaobjects. Classes which do not support multiple inheritance signal an error if the list contains more than one element."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a proper list or if ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/validate-superclass",children:"validate-superclass"})," applied to ",(0,t.jsx)(i.em,{children:"class"})," and any element of this list returns false."]}),"\n",(0,t.jsxs)(i.p,{children:["When the class metaobject is being initialized, and this argument is either not supplied or is the empty list, this argument defaults as follows: if the class is an instance of ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," or one of its subclasses the default value is a list of the class ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_std_ob.htm#standard-object",children:"standard-object"}),"; if the class is an instance of ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," or one of its subclasses the default value is list of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-funcallable-standard-object",children:"funcallable-standard-object"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["After any defaulting of the value, the generic function ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/add-direct-subclass",children:"add-direct-subclass"})," is called once for each element of the list."]}),"\n",(0,t.jsxs)(i.p,{children:["When the class metaobject is being reinitialized and this argument is supplied, the generic function ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/remove-direct-subclass",children:"remove-direct-subclass"})," is called once for each class metaobject in the previously stored value but not in the new value; the generic function ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/add-direct-subclass",children:"add-direct-subclass"})," is called once for each class metaobject in the new value but not in the previously stored value."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":documentation"})," argument is a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If the class metaobject is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":name"})," argument is an object."]}),"\n",(0,t.jsxs)(i.p,{children:["If the class is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the class metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,t.jsx)(i.p,{children:"Initialization Argument        Generic Function"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:":direct-default-initargs"}),"   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-default-initargs",children:"class-direct-default-initargs"}),"\n",(0,t.jsx)(i.strong,{children:":direct-slots"}),"              ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-slots",children:"class-direct-slots"}),"\n",(0,t.jsx)(i.strong,{children:":direct-superclasses"}),"       ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-superclasses",children:"class-direct-superclasses"}),"\n",(0,t.jsx)(i.strong,{children:":documentation"}),"             ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"}),"\n",(0,t.jsx)(i.strong,{children:":name"}),"                      ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-name",children:"class-name"})]}),"\n",(0,t.jsx)(i.p,{children:"Initialization arguments and accessors for class metaobjects."}),"\n",(0,t.jsxs)(i.p,{children:["Instances of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," support multiple inheritance and reinitialization. Instances of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," support multiple inheritance and reinitialization. For forward referenced classes, all of the initialization arguments default to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Since built-in classes cannot be created or reinitialized by the user, an error is signaled if ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," or ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," are called to initialize or reinitialize a derived instance of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-built-in-class",children:"built-in-class"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"It is not specified which methods provide the initialization and reinitialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the class metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,t.jsxs)(i.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),", ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_class.htm#class",children:"class"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Portable programs must not define methods on ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["For ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable programs must not define primary methods."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The results are undefined if any of these restrictions are violated."}),"\n",(0,t.jsx)(i.h2,{id:"comments-and-remarks",children:"Comments and remarks"}),"\n",(0,t.jsxs)(i.p,{children:["This section is named ",(0,t.jsx)(i.em,{children:"Initialization of Class Metaobjects"})," and appears in Chapter 6 (Generic functions and methods) of the original text. There is ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects",children:"a section with the same name in Chapter 5 (Concepts) of the original text."})," When sections are referred to in the text, it is not specified which one."]})]})}function c(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function l(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"initialization-of-generic-function-metaobjects",children:"Initialization of Generic Function Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"initialization-of-generic-function-metaobjects-1",children:"Initialization of Generic Function Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["A generic function metaobject can be created by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the generic function. A generic function metaobject can be redefined by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Some classes of generic function metaobject do not support redefinition; in these cases, ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization of a generic function metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Reinitialization of a generic-function metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a generic function metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize or reinitialize a generic function metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any generic function metaobject or to turn a non-generic-function object into a generic function metaobject."]}),"\n",(0,t.jsxs)(i.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on generic function metaobjects. Since the class of a generic function metaobject may not be changed, no behavior is specified for the results of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on generic function metaobjects."]}),"\n",(0,t.jsxs)(i.p,{children:["During initialization or reinitialization, each initialization argument is checked for errors and then associated with the generic function metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below. (FIXME",":insert"," anchor)."]}),"\n",(0,t.jsx)(i.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. The section ends with a set of restrictions on portable methods affecting generic function metaobject initialization and reinitialization."}),"\n",(0,t.jsxs)(i.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,t.jsx)(i.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,t.jsx)(i.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified generic function metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-generic-function",children:"generic-function"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Unless there is a specific note to the contrary, then during reinitialization, if an initialization argument is not supplied, the previously stored value is left unchanged."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":argument-precedence-order"})," argument is a list of symbols."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this argument appears but the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument does not appear. An error is signaled if this value is not a proper list or if this value is not a permutation of the symbols from the required arguments part of the ",(0,t.jsx)(i.code,{children:":lambda-list"})," initialization argument."]}),"\n",(0,t.jsxs)(i.p,{children:["When the generic function is being initialized or reinitialized, and this argument is not supplied, but the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument is supplied, this value defaults to the symbols from the required arguments part of the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument, in the order they appear in that argument. If neither argument is supplied, neither are initialized (see the description of ",(0,t.jsx)(i.code,{children:":lambda-list"}),".)"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":declarations"})," argument is a list of declarations."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper list or if each of its elements is not a legal declaration."}),"\n",(0,t.jsx)(i.p,{children:"When the generic function is being initialized, and this argument is not supplied, it defaults to the empty list."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":documentation"})," argument is a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a string or ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If the generic function is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument is a lambda list."]}),"\n",(0,t.jsx)(i.p,{children:"An error is signaled if this value is not a proper generic function lambda list."}),"\n",(0,t.jsx)(i.p,{children:"When the generic function is being initialized, and this argument is not supplied, the generic function's lambda list is not initialized. The lambda list will be initialized later, either when the first method is added to the generic function, or a later reinitialization of the generic function."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":method-combination"})," argument is a method combination metaobject. (But see the note at the end of this page. [RS])"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":method-class"})," argument is a class metaobject. (But see the note at the end of this page. [RS])"]}),"\n",(0,t.jsxs)(i.p,{children:["An error is signaled if this value is not a subclass of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-generic-function",children:"method"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["When the generic function is being initialized, and this argument is not supplied, it defaults to the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-standard-method.md",children:"standard-method"}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":name"})," argument is an object."]}),"\n",(0,t.jsxs)(i.p,{children:["If the generic function is being initialized, this argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the generic function metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,t.jsx)(i.p,{children:"Initialization Argument        Generic Function"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:":argument-precedence-order"}),"   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-argument-precedence-order",children:"generic-function-argument-precedence-order"}),"\n",(0,t.jsx)(i.code,{children:":declarations"}),"                ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-declarations",children:"generic-function-declarations"}),"\n",(0,t.jsx)(i.code,{children:":documentation"}),"               ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"}),"\n",(0,t.jsx)(i.code,{children:":lambda-list"}),"                 ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-lambda-list",children:"generic-function-lambda-list"}),"\n",(0,t.jsx)(i.code,{children:":method-combination"}),"          ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-combination",children:"generic-function-method-combination"}),"\n",(0,t.jsx)(i.code,{children:":method-class"}),"                ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-class",children:"generic-function-method-class"}),"\n",(0,t.jsx)(i.code,{children:":name"}),"                        ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-name",children:"generic-function-name"})]}),"\n",(0,t.jsx)(i.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"It is not specified which methods provide the initialization and reinitialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the generic function metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,t.jsxs)(i.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),", ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-generic-function.md",children:"generic-function"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Portable programs must not define methods on ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["For ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Portable programs must not define primary methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n",(0,t.jsx)(i.li,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The results are undefined if any of these restrictions are violated."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Note:"})}),"\n",(0,t.jsxs)(i.p,{children:["Nowhere in the chain of functions that initialize generic-function metaobjects is any defaulting behavior for method-combination metaobjects defined. One possible solution to this dilemma is to implement that defaulting behavior here, so that if the ",(0,t.jsx)(i.code,{children:":method-combination"})," keyword argument is not supplied, then it defaults to the ",(0,t.jsx)(i.code,{children:"standard"})," method combination. [RS]"]})]})}function d(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}function h(e){const i={a:"a",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"initialization-of-method-metaobjects",children:"Initialization of Method Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"initialization-of-method-metaobjects-1",children:"Initialization of Method Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["A method metaobject can be created by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the method. A method metaobject cannot be redefined; calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization of a method metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a method metaoject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize a method metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any method metaobject or to turn a non-method object into a method metaobject."]}),"\n",(0,t.jsxs)(i.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on method metaobjects. Since the class of a method metaobject cannot be changed, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on method metaobjects."]}),"\n",(0,t.jsx)(i.p,{children:"During initialization, each initialization argument is checked for errors and then associated with the method metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below (FIXME: insert anchor reference)."}),"\n",(0,t.jsx)(i.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. The section ends with a set of restrictions on portable methods affecting method metaobject initialization."}),"\n",(0,t.jsxs)(i.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,t.jsx)(i.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,t.jsx)(i.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified method metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method",children:"method"}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":qualifiers"})," argument is a list of method qualifiers. An error is signaled if this value is not a proper list, or if any element of the list is not a non-null atom. This argument defaults to the empty list."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument is the unspecialized lambda list of the method. An error is signaled if this value is not a proper lambda list. If this value is not supplied, an error is signaled."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":specializers"})," argument is a list of the specializer metaobjects for the method. An error is signaled if this value is not a proper list, or if the length of the list differs from the number of required arguments in the ",(0,t.jsx)(i.code,{children:":lambda-list"})," argument, or if any element of the list is not a specializer metaobject. If this value is not supplied, an error is signaled."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":function"})," argument is a method function. It must be compatible with the methods on ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," defined for this class of method and generic function with which it will be used. That is, it must accept the same number of arguments as all uses of ",(0,t.jsx)(i.a,{href:"/cl-language-reference/chap-7/h-h-dictionary/call-method_make-method_local-macro",children:"call-method"})," that will call it supply. (See ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," for more information.) An error is signaled if this argument is not supplied."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["When the method being initialized is an instance of a subclass of ",(0,t.jsx)(i.code,{children:"standard-accessor-method"}),", the ",(0,t.jsx)(i.code,{children:":slot-definition"})," initialization argument must be provided. Its value is the direct slot definition metaobject which defines this accessor method. An error is signaled if the value is not an instance of a subclass of ",(0,t.jsx)(i.code,{children:"direct-slot-definition"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:":documentation"})," argument is a string or ",(0,t.jsx)(i.code,{children:"nil"}),". An error is signaled if this value is not a string or ",(0,t.jsx)(i.code,{children:"nil"}),". This argument defaults to ",(0,t.jsx)(i.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the method metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,t.jsx)(i.p,{children:"Initialization Argument   Generic Function"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.div,{children:[(0,t.jsxs)(i.div,{children:[(0,t.jsx)(i.code,{children:":qualifiers"}),"             ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-qualifiers",children:"method-qualifiers"})]}),(0,t.jsxs)(i.div,{children:["  ",(0,t.jsx)(i.code,{children:":lambda-list"}),"            ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-lambda-list",children:"method-lambda-list"})]}),(0,t.jsxs)(i.div,{children:["  ",(0,t.jsx)(i.code,{children:":specializers"}),"           ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-specializers",children:"method-specializers"})]}),(0,t.jsxs)(i.div,{children:["  ",(0,t.jsx)(i.code,{children:":function"}),"               ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-function",children:"method-function"})]}),(0,t.jsxs)(i.div,{children:["  ",(0,t.jsx)(i.code,{children:":slot-definition"}),"        ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/accessor-method-slot-definition",children:"accessor-method-slot-definition"})]}),(0,t.jsxs)(i.div,{children:["  ",(0,t.jsx)(i.code,{children:":documentation"}),"          ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"})]}),(0,t.jsx)(i.div,{children:(0,t.jsx)(i.p,{children:"Initialization arguments and accessors for method metaobjects."})})]}),"\n",(0,t.jsx)(i.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"It is not specified which methods provide the initialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented in as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the method metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,t.jsxs)(i.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method",children:"method"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Portable programs must not define methods on ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," or ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["For ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable programs must not define primary methods."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The results are undefined if any of these restrictions are violated."})]})}function m(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function f(e){const i={a:"a",em:"em",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["A slot definition metaobject can be created by calling ",(0,t.jsx)(i.a,{href:"make-instance.html",children:"make-instance"}),". The initialization arguments establish the definition of the slot definition. A slot definition metaobject cannot be redefined; calling ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization of a slot definition metaobject must be done by calling ",(0,t.jsx)(i.a,{href:"make-instance.html",children:"make-instance"})," and allowing it to call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," Portable programs must not call ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a slot definition metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"https://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize a slot definition metaobject. Portable programs must not call ",(0,t.jsx)(i.a,{href:"change-class.html",children:"change-class"})," to change the class of any slot definition metaobject or to turn a non-slot-definition object into a slot definition metaobject."]}),"\n",(0,t.jsxs)(i.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"update-instance-for-redefined-class.html",children:"update-instance-for-redefined-class"})," on slot definition metaobjects. Since the class of a slot definition metaobject cannot be changed, no behavior is specified for the result of calls to ",(0,t.jsx)(i.a,{href:"update-instance-for-different-class",children:"update-instance-for-different-class"})," on slot definition metaobjects."]}),"\n",(0,t.jsxs)(i.p,{children:["During initialization, each initialization argument is checked for errors and then associated with the slot definition metaobject. The value can then be accessed by calling the appropriate accessor as shown in ",(0,t.jsx)(i.a,{href:"#slotd-mo-initargs",children:"the table below"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments."}),"\n",(0,t.jsxs)(i.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,t.jsx)(i.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization is performed as if ",(0,t.jsx)(i.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified slot definition metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,t.jsx)(i.a,{href:"slot-definition.html",children:"slot-definition"}),"."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The ",":name"," argument is a slot name. An error is signaled if this argument is not a symbol which can be used as a variable name. An error is signaled if this argument is not supplied."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":initform"," argument is a form. The ",":initform"," argument defaults to ",(0,t.jsx)(i.strong,{children:"nil"}),". An error is signaled if the ",":initform"," argument is supplied, but the ",":initfunction"," argument is not supplied."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":initfunction"," argument is a function of zero arguments which, when called, evaluates the ",":initform"," in the appropriate lexical environment. The ",":initfunction"," argument defaults to false. An error is signaled if the ",":initfunction"," argument is supplied, but the ",":initform"," argument is not supplied."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":type"," argument is a type specifier name. An error is signaled otherwise. The ",":type"," argument defaults to the symbol ",(0,t.jsx)(i.strong,{children:"t"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":allocation"," argument is a symbol. An error is signaled otherwise. The ",":allocation"," argument defaults to the symbol ",":instance","."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":initargs"," argument is a list of symbols. An error is signaled if this argument is not a proper list, or if any element of this list is not a symbol. The ",":initargs"," argument defaults to the empty list."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":readers"," argument is a list of function names. An error is signaled if it is not a proper list, or if any element is not a valid function name. It defaults to the empty list. An error is signaled if this argument is supplied and the metaobject is not a direct slot definition."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":writers"," argument is a list of function names. An error is signaled if it is not a proper list, or if any element is not a valid function name. It defaults to the empty list. An error is signaled if this argument is supplied and the metaobject is not a direct slot definition."]}),"\n",(0,t.jsxs)(i.li,{children:["The ",":documentation"," argument is a string or ",(0,t.jsx)(i.strong,{children:"nil"}),". An error is signaled otherwise. The ",":documentation"," argument defaults to ",(0,t.jsx)(i.strong,{children:"nil"}),"."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the slot definition metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,t.jsx)(i.p,{children:"Initialization arguments and accessors for slot definition metaobjects."}),"\n",(0,t.jsx)(i.p,{children:"Initialization Argument"}),"\n",(0,t.jsx)(i.p,{children:"Generic Function"}),"\n",(0,t.jsx)(i.p,{children:":name"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-name.html",children:"slot-definition-name"})}),"\n",(0,t.jsx)(i.p,{children:":initform"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-initform.html",children:"slot-definition-initform"})}),"\n",(0,t.jsx)(i.p,{children:":initfunction"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-initfunction.html",children:"slot-definition-initfunction"})}),"\n",(0,t.jsx)(i.p,{children:":type"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-type.html",children:"slot-definition-type"})}),"\n",(0,t.jsx)(i.p,{children:":allocation"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-allocation.html",children:"slot-definition-allocation"})}),"\n",(0,t.jsx)(i.p,{children:":initargs"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-initargs.html",children:"slot-definition-initargs"})}),"\n",(0,t.jsx)(i.p,{children:":readers"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-readers.html",children:"slot-definition-readers"})}),"\n",(0,t.jsx)(i.p,{children:":writers"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"slot-definition-writers.html",children:"slot-definition-writers"})}),"\n",(0,t.jsx)(i.p,{children:":documentation"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"documentation.html",children:"documentation"})}),"\n",(0,t.jsx)(i.p,{children:"It is not specified which methods provide the initialization and reinitialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the slot definition metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,t.jsxs)(i.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),", ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,t.jsx)(i.a,{href:"https://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,t.jsx)(i.a,{href:"slot-definition.html",children:"slot-definition"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Portable programs must not define methods on ",(0,t.jsx)(i.a,{href:"https://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," or ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["For ",(0,t.jsx)(i.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Portable programs must not define primary methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n",(0,t.jsx)(i.li,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n",(0,t.jsx)(i.li,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The results are undefined if any of these restrictions are violated."})]})}function p(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}function j(e){const i={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"readers-for-class-metaobjects",children:"readers for Class Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-class-metaobjects-1",children:"Readers for Class Metaobjects"}),"\n",(0,t.jsx)(i.p,{children:"In this and the immediately following sections, the ``reader'' generic functions which simply return information associated with a particular kind of metaobject are presented together. General information is presented first, followed by a description of the purpose of each, and ending with the specified methods for these generic functions."}),"\n",(0,t.jsx)(i.p,{children:"The reader generic functions which simply return information associated with class metaobjects are presented together in this section."}),"\n",(0,t.jsxs)(i.p,{children:["Each of the reader generic functions for class metaobjects has the same syntax, accepting one required argument called ",(0,t.jsx)(i.em,{children:"class"}),", which must be an class metaobject; otherwise, an error is signaled. An error is also signaled if the class metaobject has not been initialized."]}),"\n",(0,t.jsx)(i.p,{children:"These generic functions can be called by the user or the implementation."}),"\n",(0,t.jsx)(i.p,{children:"For any of these generic functions which returns a list, such lists will not be mutated by the implementation. The results are undefined if a portable program allows such a list to be mutated."}),"\n",(0,t.jsx)(i.h4,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-default-initargs",children:(0,t.jsx)(i.strong,{children:"class-default-initargs"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-default-initargs",children:(0,t.jsx)(i.strong,{children:"class-direct-default-initargs"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-slots",children:(0,t.jsx)(i.strong,{children:"class-direct-slots"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-subclasses",children:(0,t.jsx)(i.strong,{children:"class-direct-subclasses"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-direct-superclasses",children:(0,t.jsx)(i.strong,{children:"class-direct-superclasses"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-finalized-p",children:(0,t.jsx)(i.strong,{children:"class-finalized-p"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-name",children:(0,t.jsx)(i.strong,{children:"class-name"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-precedence-list",children:(0,t.jsx)(i.strong,{children:"class-precedence-list"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-prototype",children:(0,t.jsx)(i.strong,{children:"class-prototype"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/class-slots",children:(0,t.jsx)(i.strong,{children:"class-slots"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"The specified methods for the class metaobject reader generic functions are presented below."}),"\n",(0,t.jsx)(i.p,{children:"Each entry in the table indicates a method on one of the reader generic functions, specialized to a specified class. The number in each entry is a reference to the full description of the method. The full descriptions appear after the table."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"standard-class an "}),"forward-reference ",(0,t.jsx)(i.code,{children:"built-in-class"}),"\nd",(0,t.jsx)(i.code,{children:"                 d-class"})]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"funcallable-stand                                          ard-class"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-default-ini 2                  3                  4   targs"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-direct-defa 1                  4                  4   ult-initargs"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-direct-slot 1                  4                  4   s"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-direct-subc 9                  9                  7   lasses"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-direct-supe 1                  4                  7   rclasses"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-finalized-p 2                  6                  5   "})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"class-name"}),"       1                  1                  8"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"class-precedence- 2                  3                  7   list"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"class-prototype"}),"  10                 10                 10"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"class-slots"}),"      2                  3                  4"]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method returns the value which was associated with the class metaobject during initialization or reinitialization."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["This method returns the value associated with the class metaobject by ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/finalize-inheritance-standard-class",children:[(0,t.jsx)(i.code,{children:"finalize-inheritance"})," (",(0,t.jsx)(i.em,{children:"class"})," standard-class)"]})," or ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/finalize-inheritance-funcallable-standard-class",children:[(0,t.jsx)(i.code,{children:"finalize-inheritance"})," (",(0,t.jsx)(i.em,{children:"class"})," funcallable-standard-class)"]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method signals an error."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method returns the empty list."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method returns true."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method returns false."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["This method returns a value derived from the information in [this table](/meta-object-protocol/table-class-inheritance), except that implementation-specific modifications are permitted as described in ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/implementation-and-user-specialization",children:"section ``Implementation and User Specialization.''"})]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"This method returns the name of the built-in class."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["This methods returns a value which is maintained by ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/add-direct-subclass-class-class",children:[(0,t.jsx)(i.code,{children:"add-direct-subclass"})," (",(0,t.jsx)(i.em,{children:"superclass"})," class) (",(0,t.jsx)(i.em,{children:"subclass"})," class)"]})," and ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/remove-direct-subclass-class-class",children:[(0,t.jsx)(i.code,{children:"remove-direct-subclass"})," (",(0,t.jsx)(i.em,{children:"superclass"})," class) (",(0,t.jsx)(i.em,{children:"subclass"})," class)"]})," This method can be overridden only if those methods are overridden as well."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"No behavior is specified for this method beyond that specified for the generic function."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"comments-and-remarks",children:"Comments and remarks"}),"\n",(0,t.jsxs)(i.p,{children:['It is not clear what is meant by the phrase "Each entry in the table indicates a method on one of the reader generic functions" above. It clearly does not mean that each number represents one method, because the same number appears in different rows of the table. One interpretation is that there are exactly 30 methods, but this can not be the case because the specification does not mention a common superclass for ',(0,t.jsx)(i.code,{children:"standard-class"})," and ",(0,t.jsx)(i.code,{children:"funcallable-standard-class"}),", so there can not be a single method for the two. Another interpretation, then, is that there are exactly 40 methods. However, in other parts of the document, there is mention of a single method specialized for ",(0,t.jsx)(i.code,{children:"class"})," that does not correspond to the table above."]})]})}function u(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}function x(e){const i={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"readers-for-generic-function-metaobjects",children:"Readers for Generic Function Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-generic-function-metaobjects-1",children:"Readers for Generic Function Metaobjects"}),"\n",(0,t.jsx)(i.p,{children:"The reader generic functions which simply return information associated with generic function metaobjects are presented together in this section."}),"\n",(0,t.jsxs)(i.p,{children:["Each of the reader generic functions for generic function metaobjects has the same syntax, accepting one required argument called ",(0,t.jsx)(i.em,{children:"generic-function"}),", which must be a generic function metaobject; otherwise, an error is signaled. An error is also signaled if the generic function metaobject has not been initialized."]}),"\n",(0,t.jsx)(i.p,{children:"These generic functions can be called by the user or the implementation."}),"\n",(0,t.jsx)(i.p,{children:"For any of these generic functions which returns a list, such lists will not be mutated by the implementation. The results are undefined if a portable program allows such a list to be mutated."}),"\n",(0,t.jsx)(i.h4,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-argument-precedence-order",children:(0,t.jsx)(i.strong,{children:"generic-function-argument-precedence-order"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-declarations",children:(0,t.jsx)(i.strong,{children:"generic-function-declarations"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-lambda-list",children:(0,t.jsx)(i.strong,{children:"generic-function-lambda-list"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-class",children:(0,t.jsx)(i.strong,{children:"generic-function-method-class"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-method-combination",children:(0,t.jsx)(i.strong,{children:"generic-function-method-combination"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-methods",children:(0,t.jsx)(i.strong,{children:"generic-function-methods"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/generic-function-name",children:(0,t.jsx)(i.strong,{children:"generic-function-name"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"The specified methods for the generic function metaobject reader generic functions are presented below."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-argument-precedence-order-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-argument-precedence-order"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-declarations-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-declarations"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-lambda-list-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-lambda-list"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-method-class-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-method-class"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-method-combination-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-method-combination"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-name-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-name"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for these methods beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/generic-function-methods-standard-generic-function",children:[(0,t.jsx)(i.strong,{children:"generic-function-methods"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for this method beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsxs)(i.p,{children:["The value returned by this method is maintained by ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/add-method-standard-generic-function-standard-method",children:[(0,t.jsx)(i.code,{children:"add-method"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function) (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]})," and ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/remove-method-standard-generic-function-standard-method",children:[(0,t.jsx)(i.code,{children:"remove-method"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function) (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]}),"."]}),"\n",(0,t.jsx)(i.h4,{id:"comments-and-remarks",children:"Comments and remarks"}),"\n",(0,t.jsx)(i.p,{children:"The fourth paragraph of the original text reads like this:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.em,{children:"The list returned by this generic function will not be mutated by the implementation. The results are undefined if a portable program mutates the list returned by this generic function."})}),"\n",(0,t.jsx)(i.p,{children:"But we think this is an editing error because there is not a single generic function being referred to, rather several generic functions. For that reason, we copied a similar paragraph from the previous section in the book."})]})}function b(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}function g(e){const i={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"readers-for-method-metaobjects",children:"Readers for Method Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-method-metaobjects-1",children:"Readers for Method Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["The reader generic functions which simply return information associated with method metaobjects are presented together here in the format described under ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-class-metaobjects",children:"``Readers for Class Metaobjects.''"})]}),"\n",(0,t.jsxs)(i.p,{children:["Each of these reader generic functions have the same syntax, accepting one required argument called ",(0,t.jsx)(i.em,{children:"method"}),", which must be a method metaobject; otherwise, an error is signaled. An error is also signaled if the method metaobject has not been initialized."]}),"\n",(0,t.jsx)(i.p,{children:"These generic functions can be called by the user or the implementation."}),"\n",(0,t.jsx)(i.p,{children:"For any of these generic functions which returns a list, such lists will not be mutated by the implementation. The results are undefined if a portable program allows such a list to be mutated."}),"\n",(0,t.jsx)(i.h4,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-function",children:(0,t.jsx)(i.strong,{children:"method-function"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-generic-function",children:(0,t.jsx)(i.strong,{children:"method-generic-function"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-lambda-list",children:(0,t.jsx)(i.strong,{children:"method-lambda-list"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-specializers",children:(0,t.jsx)(i.strong,{children:"method-specializers"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/method-qualifiers",children:(0,t.jsx)(i.strong,{children:"method-qualifiers"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/accessor-method-slot-definition",children:(0,t.jsx)(i.strong,{children:"accessor-method-slot-definition"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"The specified methods for the method metaobject reader generic functions are presented below."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/method-function-standard-method",children:[(0,t.jsx)(i.strong,{children:"method-function"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/method-lambda-list-standard-method",children:[(0,t.jsx)(i.strong,{children:"method-lambda-list"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/method-specializers-standard-method",children:[(0,t.jsx)(i.strong,{children:"method-specializers"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/method-qualifiers-standard-method",children:[(0,t.jsx)(i.strong,{children:"method-qualifiers"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for these methods beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/method-generic-function-standard-method",children:[(0,t.jsx)(i.strong,{children:"method-generic-function"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for this method beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsxs)(i.p,{children:["The value returned by this method is maintained by ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/add-method-standard-generic-function-standard-method",children:[(0,t.jsx)(i.code,{children:"add-method"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function) (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]})," and ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/remove-method-standard-generic-function-standard-method",children:[(0,t.jsx)(i.code,{children:"remove-method"})," (",(0,t.jsx)(i.em,{children:"generic-function"})," standard-generic-function) (",(0,t.jsx)(i.em,{children:"method"})," standard-method)"]}),"."]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/accessor-method-slot-definition-standard-accessor-method",children:[(0,t.jsx)(i.strong,{children:"accessor-method-slot-definition"})," (",(0,t.jsx)(i.em,{children:"method"})," standard-accessor-method)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for this method beyond that which is specified for their respective generic functions."})]})}function w(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}function z(e){const i={a:"a",em:"em",h1:"h1",h3:"h3",h4:"h4",hr:"hr",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"readers-for-slot-definition-metaobjects",children:"Readers for Slot Definition Metaobjects"}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-slot-definition-metaobjects-1",children:"Readers for Slot Definition Metaobjects"}),"\n",(0,t.jsxs)(i.p,{children:["The reader generic functions which simply return information associated with slot definition metaobjects are presented together here in the format described under ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/readers-for-class-metaobjects",children:"``Readers for Class Metaobjects.''"})]}),"\n",(0,t.jsxs)(i.p,{children:["Each of the reader generic functions for slot definition metaobjects has the same syntax, accepting one required argument called ",(0,t.jsx)(i.em,{children:"slot"}),", which must be a slot definition metaobject; otherwise, an error is signaled. An error is also signaled if the slot definition metaobject has not been initialized."]}),"\n",(0,t.jsx)(i.p,{children:"These generic functions can be called by the user or the implementation."}),"\n",(0,t.jsx)(i.p,{children:"For any of these generic functions which returns a list, such lists will not be mutated by the implementation. The results are undefined if a portable program allows such a list to be mutated."}),"\n",(0,t.jsx)(i.h4,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-allocation",children:(0,t.jsx)(i.strong,{children:"slot-definition-allocation"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-initargs",children:(0,t.jsx)(i.strong,{children:"slot-definition-initargs"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-initform",children:(0,t.jsx)(i.strong,{children:"slot-definition-initform"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-initfunction",children:(0,t.jsx)(i.strong,{children:"slot-definition-initfunction"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-name",children:(0,t.jsx)(i.strong,{children:"slot-definition-name"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-type",children:(0,t.jsx)(i.strong,{children:"slot-definition-type"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(i.p,{children:"The specified methods for the slot definition metaobject reader generic functions are presented below."}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-allocation-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-allocation"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-initargs-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-initargs"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-initform-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-initform"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-initfunction-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-initfunction"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-name-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-name"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-type-standard-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-type"})," (",(0,t.jsx)(i.em,{children:"slot"})," standard-slot-definition)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for these methods beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-direct-slot-definition-metaobjects",children:"Readers for Direct Slot Definition Metaobjects"}),"\n",(0,t.jsx)(i.p,{children:"The following additional reader generic functions are defined for direct slot definition metaobjects."}),"\n",(0,t.jsx)(i.h4,{id:"functions-1",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-readers",children:(0,t.jsx)(i.strong,{children:"slot-definition-readers"})}),"\nGeneric Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-writers",children:(0,t.jsx)(i.strong,{children:"slot-definition-writers"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods-1",children:"Methods"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-readers-standard-direct-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-readers"})," (",(0,t.jsx)(i.em,{children:"direct-slot"})," standard-direct-slot-definition)"]}),"\nMethod   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-writers-standard-direct-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-writers"})," (",(0,t.jsx)(i.em,{children:"direct-slot"})," standard-direct-slot-definition)"]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.p,{children:"No behavior is specified for this method beyond that which is specified for their respective generic functions."}),"\n",(0,t.jsx)(i.h3,{id:"readers-for-effective-slot-definition-metaobjects",children:"Readers for Effective Slot Definition Metaobjects"}),"\n",(0,t.jsx)(i.p,{children:"The following reader generic function is defined for effective slot definition metaobjects."}),"\n",(0,t.jsx)(i.h4,{id:"functions-2",children:"Functions"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Generic Function   ",(0,t.jsx)(i.a,{href:"/meta-object-protocol/slot-definition-location",children:(0,t.jsx)(i.strong,{children:"slot-definition-location"})})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h4,{id:"methods-2",children:"Methods"}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:["Method   ",(0,t.jsxs)(i.a,{href:"/meta-object-protocol/slot-definition-location-standard-effective-slot-definition",children:[(0,t.jsx)(i.strong,{children:"slot-definition-location"})," (",(0,t.jsx)(i.em,{children:"effective-slot-definition"})," standard-effective-slot-definition)"]})]}),"\n",(0,t.jsx)(i.hr,{})]})}function y(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(z,{...e})}):z(e)}const v={title:"6.1 Sections"},T="6.1 Sections",k={id:"meta-object-protocol/chap-6/6-1-sections",title:"6.1 Sections",description:"6.1.2 Initialization of class metaobjects",source:"@site/docs/meta-object-protocol/chap-6/6-1-sections.md",sourceDirName:"meta-object-protocol/chap-6",slug:"/meta-object-protocol/chap-6/6-1-sections",permalink:"/cl-language-reference/meta-object-protocol/chap-6/6-1-sections",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/chap-6/6-1-sections.md",tags:[],version:"current",lastUpdatedBy:"daninus14",frontMatter:{title:"6.1 Sections"},sidebar:"tutorialSidebar",previous:{title:"Chapter 6 - Generic Functions and Methods",permalink:"/cl-language-reference/category/chapter-6---generic-functions-and-methods"},next:{title:"Index of all functions and methods",permalink:"/cl-language-reference/meta-object-protocol/chap-6/all"}},_={},S=[{value:"6.1.2 Initialization of class metaobjects",id:"612-initialization-of-class-metaobjects",level:2},{value:"6.1.3 Initialization of generic function metaobjects",id:"613-initialization-of-generic-function-metaobjects",level:2},{value:"6.1.4 Initialization of method metaobjects",id:"614-initialization-of-method-metaobjects",level:2},{value:"6.1.5 Initialization of slot definition metaobjects",id:"615-initialization-of-slot-definition-metaobjects",level:2},{value:"6.1.6 Readers for class metaobjects",id:"616-readers-for-class-metaobjects",level:2},{value:"6.1.7 Readers for generic function metaobjects",id:"617-readers-for-generic-function-metaobjects",level:2},{value:"6.1.8 Readers for method metaobjects",id:"618-readers-for-method-metaobjects",level:2},{value:"6.1.9 Readers for slot definition metaobjects",id:"619-readers-for-slot-definition-metaobjects",level:2}];function F(e){const i={h1:"h1",h2:"h2",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"61-sections",children:"6.1 Sections"}),"\n","\n",(0,t.jsx)(r,{}),"\n",(0,t.jsx)(i.h2,{id:"612-initialization-of-class-metaobjects",children:"6.1.2 Initialization of class metaobjects"}),"\n","\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(i.h2,{id:"613-initialization-of-generic-function-metaobjects",children:"6.1.3 Initialization of generic function metaobjects"}),"\n","\n",(0,t.jsx)(d,{}),"\n",(0,t.jsx)(i.h2,{id:"614-initialization-of-method-metaobjects",children:"6.1.4 Initialization of method metaobjects"}),"\n","\n",(0,t.jsx)(m,{}),"\n",(0,t.jsx)(i.h2,{id:"615-initialization-of-slot-definition-metaobjects",children:"6.1.5 Initialization of slot definition metaobjects"}),"\n","\n",(0,t.jsx)(p,{}),"\n",(0,t.jsx)(i.h2,{id:"616-readers-for-class-metaobjects",children:"6.1.6 Readers for class metaobjects"}),"\n","\n",(0,t.jsx)(u,{}),"\n",(0,t.jsx)(i.h2,{id:"617-readers-for-generic-function-metaobjects",children:"6.1.7 Readers for generic function metaobjects"}),"\n","\n",(0,t.jsx)(b,{}),"\n",(0,t.jsx)(i.h2,{id:"618-readers-for-method-metaobjects",children:"6.1.8 Readers for method metaobjects"}),"\n","\n",(0,t.jsx)(w,{}),"\n",(0,t.jsx)(i.h2,{id:"619-readers-for-slot-definition-metaobjects",children:"6.1.9 Readers for slot definition metaobjects"}),"\n","\n","\n",(0,t.jsx)(y,{})]})}function I(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(F,{...e})}):F(e)}},11151:(e,i,n)=>{n.d(i,{Z:()=>a,a:()=>r});var t=n(67294);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);