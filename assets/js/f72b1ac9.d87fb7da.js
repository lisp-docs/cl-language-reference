"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[65067],{59942:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=a(85893),t=a(11151);const r={},l=void 0,i={id:"code-blocks",title:"code-blocks",description:"(funcall (formatter \"~&~A~A\") standard-output 'a 'b 'c)",source:"@site/docs/code-blocks.md",sourceDirName:".",slug:"/code-blocks",permalink:"/cl-language-reference/docs/code-blocks",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/code-blocks.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Blocks TODO Fixes",permalink:"/cl-language-reference/docs/code-blocks-double-slashes"}},o={},c=[];function d(n){const e={code:"code",pre:"pre",...(0,t.a)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (&key radix (type 'integer)) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.\n ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) \u2192 1\n;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.\n ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) \u2192 1\n;;; :ALLOW-OTHER-KEYS NIL is always permitted.\n ((lambda (&key) t) :allow-other-keys nil) \u2192 T\n;;; As with other keyword arguments, only the left-most pair\n;;; named :ALLOW-OTHER-KEYS has any effect.\n ((lambda (&key x) x) \n  :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)\n\u2192 1\n;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,\n;;; so in safe code this signals a PROGRAM-ERROR (and might enter the\n;;; debugger).  In unsafe code, the consequences are undefined.\n ((lambda (&key x) x)                   ;This call is not valid\n  :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))\n    \\EQ (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((lambda (a b) (+ a (* b 3))) 4 5) \u2192 19\n ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) \u2192 19\n ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) \u2192 10\n ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))\n\u2192 (2 NIL 3 NIL NIL)\n ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)\n\u2192 (6 T 3 NIL NIL)\n ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)\n\u2192 (6 T 3 T NIL)\n ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)\n\u2192 (6 T 3 T (8))\n ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))\n  6 3 8 9 10 11)\n\u2192 (6 t 3 t (8 9 10 11))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((lambda (a b &key c d) (list a b c d)) 1 2) \u2192 (1 2 NIL NIL)\n ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) \u2192 (1 2 6 NIL)\n ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) \u2192 (1 2 NIL 8)\n ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) \u2192 (1 2 6 8)\n ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) \u2192 (1 2 6 8)\n ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) \u2192 (:a 1 6 8)\n ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) \u2192 (:a :b :d NIL)\n ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) \u2192 (1 2 6 NIL)\n ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) \u2192 (1 2 6 NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) 1)   \n\u2192 (1 3 NIL 1 ()) \n ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) 1 2)\n\u2192 (1 2 NIL 1 ())\n ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) :c 7)\n\u2192 (:c 7 NIL :c ())\n ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) 1 6 :c 7)\n\u2192 (1 6 7 1 (:c 7))\n ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) 1 6 :d 8)\n\u2192 (1 6 NIL 8 (:d 8))\n ((lambda (a &optional (b 3) &rest x &key c (d a))\n    (list a b c d x)) 1 6 :d 8 :c 9 :d 10)\n\u2192 (1 6 9 8 (:d 8 :c 9 :d 10))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun array-of-strings (str dims &rest named-pairs\n                          &key (start 0) end &allow-other-keys)\n   (apply #'make-array dims\n          :initial-element (subseq str start end)\n          :allow-other-keys t\n          named-pairs))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (:constructor create-foo\n         (a &optional b (c 'sea) &rest d &aux e (f 'eff)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)\n                                             &key (d 2)\n                                             &aux e (f 'eff))))\n   (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))\n \n (create-foo 10) \u2192 #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)\n (create-foo 10 'bee 'see :d 'dee) \n\u2192 #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (create-foo 1 2)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-foo :a 1 :b 2)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (frob (:constructor create-frob\n                  (a &key (b 3 have-b) (c-token 'c) \n                          (c (list c-token (if have-b 7 2))))))\n         a b c)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z\n a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z\n 0<1<2<3<4<5<6<7<8<9\n either 9<A or Z<0\n either 9<a or z<0                                                      \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass C1 () \n     ((S1 :initform 5.4 :type number) \n      (S2 :allocation :class)))\n \n (defclass C2 (C1) \n     ((S1 :initform 5 :type integer)\n      (S2 :allocation :instance)\n      (S3 :accessor C2-S3)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass pie (apple cinnamon) ())\n \n (defclass apple (fruit) ())\n \n (defclass cinnamon (spice) ())\n \n (defclass fruit (food) ())\n\n (defclass spice (food) ())\n\n (defclass food () ())\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass new-class (fruit apple) ())\n \n (defclass apple (fruit) ())\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass pie (apple cinnamon) ())\n \n (defclass pastry (cinnamon apple) ())\n \n (defclass apple () ())\n \n (defclass cinnamon () ())\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro foo (x) `(car ,x))\n (eval-when (:execute :compile-toplevel :load-toplevel)\n   (print (foo '(a b c))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (eval-when (:execute :compile-toplevel :load-toplevel)\n   (defmacro foo (x) `(car ,x))\n   (print (foo '(a b c))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep \\param{c} 'condition) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (apply #'make-condition \\param{datum} \\param{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-condition \\param{defaulted-type} \n                 :format-control \\param{datum}\n                 :format-arguments \\param{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))\n  (error c))\n\\EQ (error 'arithmetic-error :operator '/ :operands '(7 0))\n\n(error \"Bad luck.\")\n\\EQ (error 'simple-error :format-control \"Bad luck.\" :format-arguments '())\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (error "This is a message")  ; Not recommended\n (error "this is a message.") ; Not recommended\n\n (error "This is a message.") ; Recommended instead\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (error "This is a message.~%")   ; Not recommended\n (error "~&This is a message.")   ; Not recommended\n (error "~&This is a message.~%") ; Not recommended\n\n (error "This is a message.")     ; Recommended instead\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun test ()\n   (error "This is an error message.~\\%It has two lines."))\n\n ;; Implementation A\n (test)\n This is an error message.\n It has two lines.\n\n ;; Implementation B\n (test)\n ;; Error: This is an error message.\n ;;        It has two lines.\n\n ;; Implementation C\n (test)\n >> Error: This is an error message. \n           It has two lines.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (evenp most-positive-fixnum) \u2192 implementation-dependent\n (random) \u2192 implementation-dependent\n (> lambda-parameters-limit 93) \u2192 implementation-dependent\n (char-name #\\A) \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun foo ()\n  \\#+ACME (acme:initialize-something)\n  (print 'hello-there))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% %  (defun bar (x y)           ;[1] 1st occurrence of x\n% %    (let ((old-x x)          ;[2] 2nd occurrence of x \n% %          (x y))             ;[3] 3rd occurrence of x\n% %      (declare (special x))\n% %      (list old-x x)))\n% % \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (let ((x 1))                ;[1] 1st occurrence of x\n%    (declare (special x))     ;[2] 2nd occurrence of x\n%    (let ((x 2))              ;[3] 3rd occurrence of x\n%      (let ((old-x x)         ;[4] 4th occurrence of x\n%            (x 3))            ;[5] 5th occurrence of x\n%        (declare (special x)) ;[6] 6th occurrence of x\n%        (list old-x x))))     ;[7] 7th occurrence of x\n% \u2192 (2 3)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (lambda (&optional (x (foo 1))) ;[1]\n%    (declare (notinline foo))     ;[2]\n%    (foo x))                      ;[3]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (locally (declare (notinline foo)) ;[1]\n%    (lambda (&optional (x (foo 1)))  ;[2]\n%      (foo x)))                      ;[3]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (lambda (&optional                               ;[1]\n%             (x (locally (declare (notinline foo)) ;[2]\n%                  (foo 1))))                       ;[3]\n%    (declare (notinline foo))                      ;[4]\n%    (foo x))                                       ;[5]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defun foo (x)                               ;[1]\n%    (if (typep x 'integer)                     ;[2]\n%        (list (let ((y (+ x 42)))              ;[3]\n%                (declare (fixnum x y))         ;[4]\n%                y)                             ;[5]\n%              (+ x 42))                        ;[6]\n%        `(foo ,x)))                            ;[7]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (foo (- most-negative-fixnum 1))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defun foo (x)                               ;[1]\n%    (if (typep x 'integer)                     ;[2]\n%        (list (let ((y (+ x 42)))              ;[3]\n%                (declare (fixnum x))           ;[4]\n%                x                              ;[5]\n%                y)                             ;[6]\n%              (+ x 42))                        ;[7]\n%        `(foo ,x)))                            ;[8]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (foo most-positive-fixnum)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defun foo (x)                               ;[1]\n%    (if (typep x 'integer)                     ;[2]\n%        (list (let ((y (the fixnum (+ x 42)))) ;[3]\n%                (declare (fixnum x y))         ;[4]\n%                x                              ;[5]\n%                y)                             ;[6]\n%              (+ x 42))                        ;[7]\n%        `(foo ,x)))                            ;[8]\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x 1))                ;[1] 1st occurrence of x\n   (declare (special x))     ;[2] 2nd occurrence of x\n   (let ((x 2))              ;[3] 3rd occurrence of x\n     (let ((old-x x)         ;[4] 4th occurrence of x\n           (x 3))            ;[5] 5th occurrence of x\n       (declare (special x)) ;[6] 6th occurrence of x\n       (list old-x x))))     ;[7] 7th occurrence of x\n\u2192 (2 3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda (&optional (x (foo 1))) ;[1]\n   (declare (notinline foo))     ;[2]\n   (foo x))                      ;[3]\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (locally (declare (notinline foo)) ;[1]\n   (lambda (&optional (x (foo 1)))  ;[2]\n     (foo x)))                      ;[3]\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda (&optional                               ;[1]\n            (x (locally (declare (notinline foo)) ;[2]\n                 (foo 1))))                       ;[3]\n   (declare (notinline foo))                      ;[4]\n   (foo x))                                       ;[5]\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x  1))                     ;[1]\n   (declare (special x))           ;[2]\n     (let ((x 2))                  ;[3]\n       (dotimes (i x x)            ;[4]\n         (declare (special x)))))  ;[5]\n\u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (x y)\n (x B A C y)\n (x A B B B B B C y)\n (x C B A B B B y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (x B B A A C C y)\n (x C B C y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (x B y)\n (x B A C y)\n (x A B B B B B C y)\n (x C B A B B B y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (x y)\n (x B B A A C C y)\n (x C B C y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (x A B C y)\n (x A C B y)\n (x A B y)\n (x B A C y)\n (x B C A y)\n (x B A y)\n (x C A B y)\n (x C B A y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+ 4 5) \u2192 9 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (truncate 7 5)\n\u2192 1 2\n (truncate 7 5) \n\u2192 1\n   2\n (truncate 7 5)\n\u2192 1, 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (char-name #\\a)\n\u2192 NIL\nOR=> "LOWERCASE-a"\nOR=> "Small-A"\nOR=> "LA01"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char-name #\\a) \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (function-lambda-expression \n    (funcall #'(lambda (x) #'(lambda () x)) nil))\n\u2192 NIL, true, NIL\nOR=> (LAMBDA () X), true, NIL\n\\NV NIL, false, NIL\n\\NV (LAMBDA () X), false, NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (gcd x (gcd y z)) \\EQ (gcd (gcd x y) z)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))\n\\OUT \\IN{9 16 }\n\\OUT 7\n\u2192 8\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (progn (format t "~&Who? ") (read-line))\n\\OUT Who? \\IN{Fred, Mary, and Sally\\CRLF}\n\u2192 "Fred, Mary, and Sally", false\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (print ())                          ;avoided\n (defun three nil 3)                 ;avoided \n '(nil nil)                          ;list of two symbols\n '(() ())                            ;list of empty lists\n (defun three () 3)                  ;Emphasize empty parameter list.\n (append '() '()) \u2192 ()              ;Emphasize use of empty lists\n (not nil) \u2192 T                   ;Emphasize use as Boolean false\n (get 'nil 'color)                   ;Emphasize use as a symbol\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun add-some (x) \n   (defun add-some (x) (+ x 2))\n   (+ x 1)) \u2192 ADD-SOME\n (mapcar 'add-some '(1 2 3 4))\n\u2192 (2 3 4 5)\nOR=> (2 4 5 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (x) (+ x 1))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find 'a '(a b . c))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find 'd '(a b . c))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find 'd '#1=(a b . #1#))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((a (list 2 1 4 3 7 6 'five)))\n   (ignore-errors (sort a #'<))\n   a)\n\u2192 (1 2 3 4 6 7 FIVE)\nOR=> (2 1 4 3 7 6 FIVE)\nOR=> (2)\n\n (prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))\n   (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))\n\u2192 (1 2 3 4 5 6 7 8 9 10)\nOR=> (3 4 5 6 2 7 8 9 10 1)\nOR=> (1 2 4 3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x 1))            ;Binds a special variable X\n   (declare (special x))\n   (let ((x 2))          ;Binds a lexical variable X\n     (+ x                ;Reads a lexical variable X\n        (locally (declare (special x))\n                 x))))   ;Reads a special variable X\n\u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (x) (+ x 3))\n (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))\n (foo (progn (bar) 20))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' 3 \u2192 3\n #c(2/3 5/8) \u2192 #C(2/3 5/8)\n #p"S:[BILL]OTHELLO.TXT" \u2192 #P"S:[BILL]OTHELLO.TXT"\n #(a b c) \u2192 #(A B C)\n "fred smith" \u2192 "fred smith"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun two-funs (x)\n   (list (function (lambda () x))\n         (function (lambda (y) (setq x y)))))\n (setq funs (two-funs 6))\n (funcall (car funs)) \u2192 6\n (funcall (cadr funs) 43) \u2192 43\n (funcall (car funs)) \u2192 43\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x 5) (funs '()))\n   (dotimes (j 10)                          \n     (push #'(lambda (z)                        \n               (if (null z) (setq x 0) (+ x z)))\n           funs))\n   funs)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((funs '()))     \n   (dotimes (j 10)\n     (let ((x 5))\n       (push (function (lambda (z)\n                        (if (null z) (setq x 0) (+ x z))))\n             funs)))\n  funs)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((funs '()))\n   (dotimes (j 10)\n     (let ((x 5))\n       (push (function (lambda (z) (+ x z)))\n            funs)))\n   funs)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((funs '()))\n   (dotimes (j 10)\n     (push (function (lambda (z) (+ 5 z)))\n           funs))\n  funs)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mapcar (function (lambda (x) (+ x 2))) y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test (x z)\n   (let ((z (* x 2)))\n     (print z))\n   z)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun contorted-example (f g x)\n   (if (= x 0)\n       (funcall f)\n       (block here\n          (+ 5 (contorted-example g\n                                  #'(lambda () (return-from here 4))\n                                  (- x 1))))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (contorted-example nil nil 2)\n   (block here\\ssso ...)\n     (contorted-example nil #'(lambda () (return-from here\\ssso 4)) 1)\n       (block here\\ssst ...)\n         (contorted-example #'(lambda () (return-from here\\ssso 4))\n                            #'(lambda () (return-from here\\ssst 4))\n                            0)\n             (funcall f)\n                    where f \u2192 #'(lambda () (return-from here\\ssso 4))\n                 (return-from here\\ssso 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun invalid-example ()\n   (let ((y (block here #'(lambda (z) (return-from here z)))))\n     (if (numberp y) y (funcall y 5))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun fun1 (x)\n   (catch 'trap (+ 3 (fun2 x))))\n (defun fun2 (y)\n   (catch 'trap (* 5 (fun3 y))))\n (defun fun3 (z)\n   (throw 'trap z))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun fun2 (y)\n   (catch 'snare (* 5 (fun3 y))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~C" #\\A) \u2192 "A"\n (format nil "~C" #\\Space) \u2192 " "\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~:C" #\\A) \u2192 "A"\n (format nil "~:C" #\\Space) \u2192 "Space"\n;; This next example assumes an implementation-defined "Control" attribute.\n (format nil "~:C" #\\Control-Space)\n\u2192 "Control-Space"\nOR=> "c-Space"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~:@C" #\\Control-Partial) \u2192 "Control-{\\Partial} (Top-F)"  \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~,,\' ,4:B" 13) \u2192 "1101"\n (format nil "~,,\' ,4:B" 17) \u2192 "1 0001"\n (format nil "~19,0,\' ,4:B" 3333) \u2192 "0000 1101 0000 0101"\n (format nil "~3,,,\' ,2:R" 17) \u2192 "1 22"\n (format nil "~,,\'|,2:D" #xFFFF) \u2192  "6|55|35"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' "~%;; ~\\lbr\\ ~<~%;; ~1:; ~S~>~\\hat\\ ,~\\rbr\\ .~%"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' "~%;; ~\\lbr\\ ~<~%;; ~1,50:; ~S~>~\\hat\\ ,~\\rbr \\ .~%"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq *print-level* nil *print-length* 5)\n (format nil\n        "~@[ print level = ~D~]~@[ print length = ~D~]"\n        *print-level* *print-length*)\n\u2192  " print length = 5"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format \\param{stream} "...~@[\\param{str}~]..." ...)\n\\EQ (format \\param{stream} "...~:[~;~:*\\param{str}~]..." ...)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq foo "Items:~#[ none~; ~S~; ~S and ~S~\n           ~:;~@\\{~#[~; and~] ~S~\\hat\\ ,~\\}~].")\n (format nil foo) \u2192  "Items: none."\n (format nil foo \'foo) \u2192  "Items: FOO."\n (format nil foo \'foo \'bar) \u2192  "Items: FOO and BAR."\n (format nil foo \'foo \'bar \'baz) \u2192  "Items: FOO, BAR, and BAZ."\n (format nil foo \'foo \'bar \'baz \'quux) \u2192  "Items: FOO, BAR, BAZ, and QUUX."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "The winners are:~\\{ ~S~\\}." \n         \'(fred harry jill)) \n\u2192 "The winners are: FRED HARRY JILL."                           \n (format nil "Pairs:~\\{ <~S,~S>~\\}." \n         \'(a 1 b 2 c 3))\n\u2192 "Pairs: <A,1> <B,2> <C,3>."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "Pairs:~:\\lbr <~S,~S>~\\rbr\\ ." \n                 \'((a 1) (b 2) (c 3)))\n\u2192 "Pairs: <A,1> <B,2> <C,3>."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "Pairs:~@\\lbr <~S,~S>~\\rbr\\ ." \'a 1 \'b 2 \'c 3)\n\u2192 "Pairs: <A,1> <B,2> <C,3>."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "Pairs:~:@\\lbr <~S,~S>~\\rbr\\ ." \n              \'(a 1) \'(b 2) \'(c 3)) \n\u2192 "Pairs: <A,1> <B,2> <C,3>."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'    (apply #\'format stream string arguments)\n \\EQ (format stream "~1\\{~:\\}" string arguments)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~? ~D" "<~A ~D>" \'("Foo" 5) 7) \u2192 "<Foo 5> 7"\n (format nil "~? ~D" "<~A ~D>" \'("Foo" 5 14) 7) \u2192 "<Foo 5> 7"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) \u2192 "<Foo 5> 7"\n (format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) \u2192 "<Foo 5> 14"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~@R ~(~@R~)" 14 14) \n\u2192 "XIV xiv"\n (defun f (n) (format nil "~@(~R~) error~:P detected." n)) \u2192 F\n (f 0) \u2192 "Zero errors detected."\n (f 1) \u2192 "One error detected."\n (f 23) \u2192 "Twenty-three errors detected."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~@(how is ~:(BOB SMITH~)?~)")\n \u2192 "How is bob smith?"\n \\NV "How is Bob Smith?"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~D tr~:@P/~D win~:P" 7 1) \u2192 "7 tries/1 win"\n (format nil "~D tr~:@P/~D win~:P" 1 0) \u2192 "1 try/0 wins"\n (format nil "~D tr~:@P/~D win~:P" 1 3) \u2192 "1 try/3 wins"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq donestr "Done.~{\\hat} ~D warning~:P.~{\\hat} ~D error~:P.")\n\u2192 "Done.~{\\hat} ~D warning~:P.~{\\hat} ~D error~:P."\n (format nil donestr) \u2192 "Done."\n (format nil donestr 3) \u2192 "Done. 3 warnings."\n (format nil donestr 1 5) \u2192 "Done. 1 warning. 5 errors."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~:\\lbr\\ ~@?~:\\hat\\ ...~\\rbr\\ " \'(("a") ("b"))) \u2192 "a...b"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq tellstr "~@(~@[~R~]~{\\hat} ~A!~)")\n\u2192 "~@(~@[~R~]~{\\hat} ~A!~)"\n (format nil tellstr 23) \u2192 "Twenty-three!"\n (format nil tellstr nil "losers") \u2192 " Losers!"\n (format nil tellstr 23 "losers") \u2192 "Twenty-three losers!"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~15<~S~;~{\\hat}~S~;~{\\hat}~S~>" \'foo)\n\u2192  "            FOO"\n (format nil "~15<~S~;~{\\hat}~S~;~{\\hat}~S~>" \'foo \'bar)\n\u2192  "FOO         BAR"\n (format nil "~15<~S~;~{\\hat}~S~;~{\\hat}~S~>" \'foo \'bar \'baz)\n\u2192  "FOO   BAR   BAZ"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun type-clash-error (fn nargs argnum right-type wrong-type)\n   (format *error-output*\n           \"~&~S requires its ~:[~:R~;~*~]~ \n           argument to be of type ~S,~%but it was called ~\n           with an argument of type ~S.~%\"\n           fn (eql nargs 1) argnum right-type wrong-type))\n (type-clash-error 'aref nil 2 'integer 'vector)  prints:\nAREF requires its second argument to be of type INTEGER,\nbut it was called with an argument of type VECTOR.\nNIL\n (type-clash-error 'car 1 1 'list 'short-float)  prints:\nCAR requires its argument to be of type LIST,\nbut it was called with an argument of type SHORT-FLOAT.\nNIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~:[abc~:@(def~;ghi~\n:@(jkl~]mno~)" x) ;Invalid!\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~@?ghi~)" "abc~@(def") ;Invalid!\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "foo") \u2192 "foo"\n (setq x 5) \u2192 5\n (format nil "The answer is ~D." x) \u2192 "The answer is 5."\n (format nil "The answer is ~3D." x) \u2192 "The answer is   5."\n (format nil "The answer is ~3,\'0D." x) \u2192 "The answer is 005."\n (format nil "The answer is ~:D." (expt 47 x))\n\u2192 "The answer is 229,345,007."\n (setq y "elephant") \u2192 "elephant"\n (format nil "Look at the ~A!" y) \u2192 "Look at the elephant!"\n (setq n 3) \u2192 3\n (format nil "~D item~:P found." n) \u2192 "3 items found."\n (format nil "~R dog~:[s are~; is~] here." n (= n 1))\n\u2192 "three dogs are here."\n (format nil "~R dog~:*~[s are~; is~:;s are~] here." n)\n\u2192 "three dogs are here."\n (format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)\n\u2192 "Here are three puppies."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun foo (x)\n   (format nil "~6,2F|~6,2,1,\'*F|~6,2,,\'?F|~6F|~,2F|~F"\n           x x x x x x)) \u2192 FOO\n (foo 3.14159)  \u2192 "  3.14| 31.42|  3.14|3.1416|3.14|3.14159"\n (foo -3.14159) \u2192 " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"\n (foo 100.0)    \u2192 "100.00|******|100.00| 100.0|100.00|100.0"\n (foo 1234.0)   \u2192 "1234.00|******|??????|1234.0|1234.00|1234.0"\n (foo 0.006)    \u2192 "  0.01|  0.06|  0.01| 0.006|0.01|0.006"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun foo (x)  \n    (format nil\n           "~9,2,1,,\'*E|~10,3,2,2,\'?,,\'\\$E|~\n            ~9,3,2,-2,\'%@E|~9,2E"\n           x x x x))\n (foo 3.14159)  \u2192 "  3.14E+0| 31.42\\$-01|+.003E+03|  3.14E+0"\n (foo -3.14159) \u2192 " -3.14E+0|-31.42\\$-01|-.003E+03| -3.14E+0"\n (foo 1100.0)   \u2192 "  1.10E+3| 11.00\\$+02|+.001E+06|  1.10E+3"\n (foo 1100.0L0) \u2192 "  1.10L+3| 11.00\\$+02|+.001L+06|  1.10L+3"\n (foo 1.1E13)   \u2192 "*********| 11.00\\$+12|+.001E+16| 1.10E+13"\n (foo 1.1L120)  \u2192 "*********|??????????|%%%%%%%%%|1.10L+120"\n (foo 1.1L1200) \u2192 "*********|??????????|%%%%%%%%%|1.10L+1200"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (dotimes (k 13)\n   (format t "~%Scale factor ~2D: |~13,6,2,VE|"\n           (- k 5) (- k 5) 3.14159))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"Scale factor -5: | 0.000003E+06|\nScale factor -4: | 0.000031E+05|\nScale factor -3: | 0.000314E+04|\nScale factor -2: | 0.003142E+03|\nScale factor -1: | 0.031416E+02|\nScale factor  0: | 0.314159E+01|\nScale factor  1: | 3.141590E+00|\nScale factor  2: | 31.41590E-01|\nScale factor  3: | 314.1590E-02|\nScale factor  4: | 3141.590E-03|\nScale factor  5: | 31415.90E-04|\nScale factor  6: | 314159.0E-05|\nScale factor  7: | 3141590.E-06|\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun foo (x)\n   (format nil "~9,2,1,,\'*G|~9,3,2,3,\'?,,\'\\$G|~9,3,2,0,\'%G|~9,2G"\n          x x x x))                                     \n (foo 0.0314159) \u2192 "  3.14E-2|314.2\\$-04|0.314E-01|  3.14E-2"\n (foo 0.314159)  \u2192 "  0.31   |0.314    |0.314    | 0.31    "\n (foo 3.14159)   \u2192 "   3.1   | 3.14    | 3.14    |  3.1    "\n (foo 31.4159)   \u2192 "   31.   | 31.4    | 31.4    |  31.    "\n (foo 314.159)   \u2192 "  3.14E+2| 314.    | 314.    |  3.14E+2"\n (foo 3141.59)   \u2192 "  3.14E+3|314.2\\$+01|0.314E+04|  3.14E+3"\n (foo 3141.59L0) \u2192 "  3.14L+3|314.2\\$+01|0.314L+04|  3.14L+3"\n (foo 3.14E12)   \u2192 "*********|314.0\\$+10|0.314E+13| 3.14E+12"\n (foo 3.14L120)  \u2192 "*********|?????????|%%%%%%%%%|3.14L+120"\n (foo 3.14L1200) \u2192 "*********|?????????|%%%%%%%%%|3.14L+1200"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format nil "~10<foo~;bar~>")   \u2192 "foo    bar"\n (format nil "~10:<foo~;bar~>")  \u2192 "  foo  bar"\n (format nil "~10<foobar~>")     \u2192 "    foobar"\n (format nil "~10:<foobar~>")    \u2192 "    foobar"\n (format nil "~10:@<foo~;bar~>") \u2192 "  foo bar "\n (format nil "~10@<foobar~>")    \u2192 "foobar    "\n (format nil "~10:@<foobar~>")   \u2192 "  foobar  "\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'  (FORMAT NIL "Written to ~A." #P"foo.bin")\n  \u2192 "Written to foo.bin."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod width ((c character-class) &key font) ...)\n \n (defmethod width ((p picture-class) &key pixel-size) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (width (make-instance `character-class :char #\\Q) \n        :font 'baskerville :pixel-size 10)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (width (make-instance `picture-class :glyph (glyph #\\Q)) \n        :font 'baskerville :pixel-size 10)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (width (make-instance `character-picture-class :char #\\Q)\n        :font 'baskerville :pixel-size 10)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32536573>\n (setf (gethash 'color a) 'brown) \u2192 BROWN\n (setf (gethash 'name a) 'fred) \u2192 FRED\n (gethash 'color a) \u2192 BROWN, true\n (gethash 'name a) \u2192 FRED, true\n (gethash 'pointy a) \u2192 NIL, false\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (loop for i from 1 to (compute-top-value)       ; first clause\n       while (not (unacceptable i))              ; second clause\n       collect (square i)                        ; third clause\n       do (format t "Working on ~D now" i)       ; fourth clause\n       when (evenp i)                            ; fifth clause\n         do (format t "~D is a non-odd number" i)\n       finally (format t "About to exit!"))      ; sixth clause\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; This expression uses the old syntax for type specifiers.\n (loop for i fixnum upfrom 3 ...)\n \n;;; This expression uses the new syntax for type specifiers.\n (loop for i of-type fixnum upfrom 3 ...)\n\n;; Declare X and Y to be of type VECTOR and FIXNUM respectively.\n (loop for (x y) of-type (vector fixnum) \n       in l do ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Collect values by using FOR constructs.\n (loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n       for a of-type integer = (first numlist)\n       and b of-type integer = (second numlist)\n       and c of-type float = (third numlist)\n       collect (list c b a))\n\u2192 ((4.0 2 1) (8.3 6 5) (10.4 9 8))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Destructuring simplifies the process.\n (loop for (a b c) of-type (integer integer float) in\n       '((1 2 4.0) (5 6 8.3) (8 9 10.4))\n       collect (list c b a))\n\u2192 ((4.0 2 1) (8.3 6 5) (10.4 9 8))\n \n\n;; If all the types are the same, this way is even simpler.\n (loop for (a b c) of-type float in\n       '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))\n       collect (list c b a))\n\u2192 ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Initialize and declare variables in parallel by using the AND construct.\\kern-7pt\n (loop with (a b) of-type float = '(1.0 2.0)\n       and (c d) of-type integer = '(3 4)\n       and (e f)\n       return (list a b c d e f))\n\u2192 (1.0 2.0 3 4 NIL NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for (a nil b) = '(1 2 3)\n       do (return (list a b)))\n\u2192 (1 3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for (x . y) = '(1 . 2)\n       do (return y))\n\u2192 2\n (loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in\n       '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))\n       collect (list a b c d))\n\u2192 ((1.2 2.4 3 4) (3.4 4.6 5 6))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(let ((x 1)) (loop for i from x by (incf x) to 10 collect i))\n\u2192 (1 3 5 7 9)\n(let ((x 1)) (loop for i by (incf x) from x to 10 collect i))\n\u2192 (2 4 6 8 10)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Print some numbers.\n (loop for i from 1 to 3\n       do (print i))\n\\OUT 1\n\\OUT 2\n\\OUT 3\n\u2192 NIL\n \n;; Print every third number.\n (loop for i from 10 downto 1 by 3\n       do (print i))\n\\OUT 10 \n\\OUT 7 \n\\OUT 4 \n\\OUT 1 \n\u2192 NIL\n \n;; Step incrementally from the default starting value.\n (loop for i below 3\n       do (print i))\n\\OUT 0\n\\OUT 1\n\\OUT 2\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Print every item in a list.\n (loop for item in '(1 2 3) do (print item))\n\\OUT 1\n\\OUT 2\n\\OUT 3\n\u2192 NIL\n \n;; Print every other item in a list.\n (loop for item in '(1 2 3 4 5) by #'cddr\n       do (print item))\n\\OUT 1\n\\OUT 3\n\\OUT 5\n\u2192 NIL\n \n;; Destructure a list, and sum the x values using fixnum arithmetic.\n (loop for (item . x) of-type (t . fixnum) in '((A . 1) (B . 2) (C . 3))\n       unless (eq item 'B) sum x)\n\u2192 4\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Collect successive tails of a list.\n (loop for sublist on '(a b c d)\n       collect sublist)\n\u2192 ((A B C D) (B C D) (C D) (D))\n \n;; Print a list by using destructuring with the loop keyword ON.\n (loop for (item) on '(1 2 3)\n       do (print item))\n\\OUT 1 \n\\OUT 2 \n\\OUT 3 \n\u2192 NIL\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%;; The original code:\n% (prog (...)\n%       (setq x (some-value))\n%   tag (print x)\n%       (setq x (some-value))\n%       (go tag))\n% \n%;; The expanded code:\n% (prog (...)\n%   tag (setq x (some-value))\n%       (print x)\n%       (go tag))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Collect some numbers.\n (loop for item = 1 then (+ item 10)\n       for iteration from 1 to 5\n       collect item)\n\u2192 (1 11 21 31 41)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for char across (the simple-string (find-message channel))\n       do (write-char char stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% being \\lbracket\\ each|the\\rbracket \\lbracket\\ hash-value|hash-values|hash-key|hash-key\\rbracket \\lbracket\\ in|of\\rbracket \n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% being \\lbracket\\ each|the\\rbracket \\lbracket\\ \\lbracket\\ \\lbracket\\ \n% present|external\\rbracket\\ symbol\\rbracket | \\lbracket\\ \n% \\lbracket\\ present|external\\rbracket symbols\\rbracket\\rbracket \\lbracket\\ in|of\\rbracket\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((*package* (make-package "TEST-PACKAGE-1")))\n   ;; For effect, intern some symbols\n   (read-from-string "(THIS IS A TEST)")\n   (export (intern "THIS"))\n   (loop for x being each present-symbol of *package*\n          do (print x)))\n\\OUT A \n\\OUT TEST \n\\OUT THIS\n\\OUT IS \n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop with a = 1 \n       with b = (+ a 2) \n       with c = (+ b 3)\n       return (list a b c))\n\u2192 (1 3 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block nil\n   (let* ((a 1)\n          (b (+ a 2))\n          (c (+ b 3)))\n     (tagbody\n         (next-loop (return (list a b c))\n                    (go next-loop)\n                    end-loop))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop with a = 1 \n       and b = 2 \n       and c = 3\n       return (list a b c))\n\u2192 (1 2 3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block nil\n   (let ((a 1)\n         (b 2)\n         (c 3))\n     (tagbody\n         (next-loop (return (list a b c))\n                    (go next-loop)\n                    end-loop))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; These bindings occur in sequence.\n (loop with a = 1 \n       with b = (+ a 2) \n       with c = (+ b 3)\n       return (list a b c))\n\u2192 (1 3 6)\n \n;; These bindings occur in parallel.\n (setq a 5 b 10)\n\u2192 10\n (loop with a = 1\n       and b = (+ a 2)\n       and c = (+ b 3)\n       return (list a b c))\n\u2192 (1 7 13)\n \n;; This example shows a shorthand way to declare local variables \n;; that are of different types.\n (loop with (a b c) of-type (float integer float)\n       return (format nil "~A ~A ~A" a b c))\n\u2192 "0.0 0 0.0"\n \n;; This example shows a shorthand way to declare local variables \n;; that are the same type.\n (loop with (a b c) of-type float \n       return (format nil "~A ~A ~A" a b c))\n\u2192 "0.0 0.0 0.0"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Collect every name and the kids in one list by using \n;; COLLECT and APPEND.\n (loop for name in '(fred sue alice joe june)\n       for kids in '((bob ken) () () (kris sunshine) ())\n       collect name\n       append kids)\n\u2192 (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%;; Count and collect names and ages.\n% (loop for name in '(fred sue alice joe june)\n%       as age in '(22 26 19 20 10)\n%       append (list name age) into name-and-age-list\n%       count name into name-count\n%       sum age into total-age\n%       finally\n%       (return\n%        (values (round total-age name-count)\n%                 name-and-age-list)))\n%\u2192 19, (FRED 22 SUE 26 ALICE 19 JOE 20 JUNE 10)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Collect all the symbols in a list.\n (loop for i in '(bird 3 4 turtle (1 . 4) horse cat)\n       when (symbolp i) collect i)\n\u2192 (BIRD TURTLE HORSE CAT)\n \n;; Collect and return odd numbers.\n (loop for i from 1 to 10\n       if (oddp i) collect i)\n\u2192 (1 3 5 7 9)\n \n;; Collect items into local variable, but don't return them.\n (loop for i in '(a b c d) by #'cddr\n       collect i into my-list\n       finally (print my-list))\n\\OUT (A C) \n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Use APPEND to concatenate some sublists.\n  (loop for x in '((a) (b) ((c)))\n        append x)\n\u2192 (A B (C))\n \n;; NCONC some sublists together.  Note that only lists made by the\n;; call to LIST are modified.\n  (loop for i upfrom 0 \n        as x in '(a b (c))\n        nconc (if (evenp i) (list x) nil))\n\u2192 (A (C))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for i in '(a b nil c nil d e)\n       count i)\n\u2192 5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for i in '(2 1 5 3 4)\n       maximize i)\n\u2192 5\n (loop for i in '(2 1 5 3 4)\n       minimize i)\n\u2192 1\n \n;; In this example, FIXNUM applies to the internal variable that holds\n;; the maximum value.\n (setq series '(1.2 4.3 5.7))\n\u2192 (1.2 4.3 5.7)\n (loop for v in series \n       maximize (round v) of-type fixnum)\n\u2192 6\n \n;; In this example, FIXNUM applies to the variable RESULT.\n (loop for v of-type float in series\n       minimize (round v) into result of-type fixnum\n       finally (return result))\n\u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for i of-type fixnum in '(1 2 3 4 5)\n       sum i)\n\u2192 15\n (setq series '(1.2 4.3 5.7))\n\u2192 (1.2 4.3 5.7)\n (loop for v in series \n       sum (* 2.0 v))\n\u2192 22.4\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (loop repeat 3\n       do (format t "~&What I say three times is true.~%"))\n\\OUT What I say three times is true.\n\\OUT What I say three times is true.\n\\OUT What I say three times is true.\n\u2192 NIL\n (loop repeat -15\n   do (format t "What you see is what you expect~%"))\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Make sure I is always less than 11 (two ways).\n;; The FOR construct terminates these loops.\n (loop for i from 0 to 10\n       always (< i 11))\n\u2192 T\n (loop for i from 0 to 10\n       never (> i 11))\n\u2192 T\n \n;; If I exceeds 10 return I; otherwise, return NIL.\n;; The THEREIS construct terminates this loop.\n (loop for i from 0\n       thereis (when (> i 10) i) )\n\u2192 11\n\n;;; The FINALLY clause is not evaluated in these examples.\n (loop for i from 0 to 10\n       always (< i 9)\n       finally (print "you won\'t see this"))\n\u2192 NIL\n (loop never t\n       finally (print "you won\'t see this"))\n\u2192 NIL\n (loop thereis "Here is my value"\n       finally (print "you won\'t see this"))\n\u2192 "Here is my value"\n \n;; The FOR construct terminates this loop, so the FINALLY clause \n;; is evaluated.\n (loop for i from 1 to 10\n       thereis (> i 11)\n       finally (prin1 \'got-here))\n\\OUT GOT-HERE\n\u2192 NIL\n \n;; If this code could be used to find a counterexample to Fermat\'s\n;; last theorem, it would still not return the value of the\n;; counterexample because all of the THEREIS clauses in this example\n;; only return T.  But if Fermat is right, that won\'t matter\n;; because this won\'t terminate.\n \n (loop for z upfrom 2\n       thereis\n         (loop for n upfrom 3 below (log z 2)\n               thereis\n                 (loop for x below z\n                       thereis\n                         (loop for y below z\n                               thereis (= (+ (expt x n) (expt y n))\n                                          (expt z n))))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop while (hungry-p) do (eat))\n \n;; UNTIL NOT is equivalent to WHILE.\n (loop until (not (hungry-p)) do (eat))\n \n;; Collect the length and the items of STACK.\n (let ((stack '(a b c d e f)))\n   (loop for item = (length stack) then (pop stack)\n         collect item\n         while stack))\n\u2192 (6 A B C D E F)\n \n;; Use WHILE to terminate a loop that otherwise wouldn't terminate.\n;; Note that WHILE occurs after the WHEN.\n (loop for i fixnum from 3\n       when (oddp i) collect i\n       while (< i 5))\n\u2192 (3 5)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Print numbers and their squares.\n;; The DO construct applies to multiple forms.\n (loop for i from 1 to 3\n       do (print i)\n          (print (* i i)))\n\\OUT 1 \n\\OUT 1 \n\\OUT 2 \n\\OUT 4 \n\\OUT 3 \n\\OUT 9 \n\u2192 NIL\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Signal an exceptional condition.\n (loop for item in \'(1 2 3 a 4 5)\n       when (not (numberp item))\n        return (cerror "enter new value" "non-numeric value: ~s" item))\nError: non-numeric value: A\n \n;; The previous example is equivalent to the following one.\n (loop for item in \'(1 2 3 a 4 5)\n       when (not (numberp item))\n        do (return \n            (cerror "Enter new value" "non-numeric value: ~s" item)))\nError: non-numeric value: A\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; This example parses a simple printed string representation from \n;; BUFFER (which is itself a string) and returns the index of the\n;; closing double-quote character.\n (let ((buffer "\\"a\\" \\"b\\""))\n   (loop initially (unless (char= (char buffer 0) #\\")\n                     (loop-finish))\n         for i of-type fixnum from 1 below (length (the string buffer))\n         when (char= (char buffer i) #\\")\n          return i))\n\u2192 2\n \n;; The collected value is returned.\n (loop for i from 1 to 10\n       when (> i 5)\n         collect i\n       finally (prin1 \'got-here))\n\\OUT GOT-HERE\n\u2192 (6 7 8 9 10) \n\n;; Return both the count of collected numbers and the numbers.\n (loop for i from 1 to 10\n       when (> i 5)\n         collect i into number-list\n         and count i into number-count\n       finally (return (values number-count number-list)))\n\u2192 5, (6 7 8 9 10)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; Just name and return.\n (loop named max\n       for i from 1 to 10\n       do (print i)\n       do (return-from max 'done))\n\\OUT 1 \n\u2192 DONE\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((i 0))                     ; no loop keywords are used\n    (loop (incf i) (if (= i 3) (return i)))) \u2192 3\n (let ((i 0)(j 0))\n    (tagbody\n      (loop (incf j 3) (incf i) (if (= i 3) (go exit)))\n      exit)\n    j) \u2192 9\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for x from 1 to 10 \n       for y = nil then x \n       collect (list x y))\n\u2192 ((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for x from 1 to 10 \n       and y = nil then x \n       collect (list x y))\n\u2192 ((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Group conditional clauses.\n (loop for i in \'(1 324 2345 323 2 4 235 252)\n       when (oddp i)\n         do (print i)\n         and collect i into odd-numbers\n         and do (terpri)\n       else                              ; I is even.\n         collect i into even-numbers\n       finally\n         (return (values odd-numbers even-numbers)))\n\\OUT 1 \n\\OUT \n\\OUT 2345 \n\\OUT \n\\OUT 323 \n\\OUT \n\\OUT 235 \n\u2192 (1 2345 323 235), (324 2 4 252)\n\n;; Collect numbers larger than 3.\n (loop for i in \'(1 2 3 4 5 6)\n       when (and (> i 3) i)\n       collect it)                      ; IT refers to (and (> i 3) i).\n\u2192 (4 5 6)\n \n;; Find a number in a list.\n (loop for i in \'(1 2 3 4 5 6)\n       when (and (> i 3) i)\n       return it)\n\u2192 4\n     \n;; The above example is similar to the following one.\n (loop for i in \'(1 2 3 4 5 6)\n       thereis (and (> i 3) i))\n\u2192 4\n\n\\medbreak\n;; Nest conditional clauses.\n (let ((list \'(0 3.0 apple 4 5 9.8 orange banana)))\n   (loop for i in list\n         when (numberp i)\n           when (floatp i)\n             collect i into float-numbers\n           else                                  ; Not (floatp i)\n             collect i into other-numbers\n         else                                    ; Not (numberp i)\n           when (symbolp i) \n             collect i into symbol-list\n           else                                  ; Not (symbolp i)\n             do (error "found a funny value in list ~S, value ~S~%" list i)\n         finally (return (values float-numbers other-numbers symbol-list))))\n\u2192 (3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)\n\n;; Without the END preposition, the last AND would apply to the\n;; inner IF rather than the outer one.\n (loop for x from 0 to 3 \n       do (print x)\n       if (zerop (mod x 2))\n         do (princ " a")\n          and if (zerop (floor x 2))\n                do (princ " b")\n                end\n          and do (princ " c"))\n\\OUT 0  a b c\n\\OUT 1 \n\\OUT 2  a c\n\\OUT 3 \n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop for \\i{internal-variable} downfrom (- \\i{n} 1) to 0 ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (a b c)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defun traffic-light (color)\n%   (case color\n%     (green)\n%     (red (stop))\n%     (amber (accelerate))      ;Insert more colors after this line.\n%     ))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (a b c . d)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cons 'a (cons 'b (cons 'c 'd)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cons 'this-one 'that-one) \u2192 (this-one . that-one)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (a b c d . (e f . (g))) \\EQ (a b c d e f g)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" 'foo \u2192 FOO\n ''foo \u2192 (QUOTE FOO)\n (car ''foo) \u2192 QUOTE\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+ 3 ; three\n    4)\n\u2192 7    \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;;; Math Utilities\n\n;;; FIB computes the the Fibonacci function in the traditional\n;;; recursive way.\n\n(defun fib (n)\n  (check-type n integer)\n  ;; At this point we're sure we have an integer argument.\n  ;; Now we can get down to some serious computation.\n  (cond ((< n 0)\n         ;; Hey, this is just supposed to be a simple example.\n         ;; Did you really expect me to handle the general case?\n         (error \"FIB got ~D as an argument.\" n))\n        ((< n 2) n)             ;fib[0]=0 and fib[1]=1\n        ;; The cheap cases didn't work.\n        ;; Nothing more to do but recurse.\n        (t (+ (fib (- n 1))     ;The traditional formula\n              (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (list 'cond \n       (cons (list 'numberp x) y) \n       (list* 't (list 'print x) y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))\n\u2192 (x (a b c) a b c foo b bar (b c) baz b c)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append \\lbracket\\ x1\\rbracket \\lbracket\\ x2\\rbracket \\lbracket\\ x3\\rbracket ... \\lbracket\\ xn\\rbracket (quote atom))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append \\lbracket\\ x1\\rbracket \\lbracket\\ x2\\rbracket \\lbracket\\ x3\\rbracket ... \\lbracket\\ xn\\rbracket form)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" `((,a b) ,c ,@d)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append (list (append (list a) (list 'b) '\\nil)) (list c) d '\\nil)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append (list (append (list a) (list 'b))) (list c) d)\n (append (list (append (list a) '(b))) (list c) d)\n (list* (cons a '(b)) c d)\n (list* (cons a (list 'b)) c d)\n (append (list (cons a '(b))) (list c) d)\n (list* (cons a '(b)) c (copy-list d))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(apply #'+ l) \\EQ (apply (function +) l)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #(a b c c c c)\n #6(a b c c c c)\n #6(a b c)\n #6(a b c c)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #(a b c)               ;A vector of length 3\n #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)\n                        ;A vector containing the primes below 50\n #()                    ;An empty vector\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  #*101111\n #6*101111\n #6*101\n #6*1011\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #*         ;An empty bit-vector\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #B1101 \\EQ 13 ;1101\\ssst\n #b101/11 \\EQ 5/3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #o37/15 \\EQ 31/13\n #o777 \\EQ 511\n #o105 \\EQ 69 ;105\\ssse\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #xF00 \\EQ 3840             \n #x105 \\EQ 261 ;105\\ssss\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" 0       1       5\n foo     2       (hot dog)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (0 1 5) (foo 2 (hot dog))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((0 1 5) (foo 2 (hot dog)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #.(cm keyword1 'value1 keyword2 'value2 ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (intern (string slotj) (find-package 'keyword))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (list 'p 'q))\n (setq y (list (list 'a 'b) x 'foo x))\n (rplacd (last y) (cdr y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((a b) . #1=(#2=(p q) foo #2# . #1#))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"#-\\param{test} \\param{expression} \\EQ #+(not \\param{test}) \\param{expression}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; In this example, some debugging code is commented out with #|...|#\n;;; Note that this kind of comment can occur in the middle of a line\n;;; (because a delimiter marks where the end of the comment occurs)\n;;; where a semicolon comment can only occur at the end of a line \n;;; (because it comments out the rest of the line).\n (defun add3 (n) #|(format t \"~&Adding 3 to ~D.\" n)|# (+ n 3))\n\\goodbreak\n;;; The examples that follow show issues related to #| ... |# nesting.\n\n;;; In this first example, #| and |# always occur properly paired,\n;;; so nesting works naturally.\n (defun mention-fun-fact-1a ()\n   (format t \"CL uses ; and #|...|# in comments.\"))\n\u2192 MENTION-FUN-FACT-1A\n (mention-fun-fact-1a)\n\\OUT CL uses ; and #|...|# in comments.\n\u2192 NIL\n #| (defun mention-fun-fact-1b ()\n      (format t \"CL uses ; and #|...|# in comments.\")) |#\n (fboundp 'mention-fun-fact-1b) \u2192 NIL\n\\goodbreak\n;;; In this example, vertical-bar followed by sharpsign needed to appear\n;;; in a string without any matching sharpsign followed by vertical-bar\n;;; having preceded this.  To compensate, the programmer has included a\n;;; slash separating the two characters.  In case 2a, the slash is \n;;; unnecessary but harmless, but in case 2b, the slash is critical to\n;;; allowing the outer #| ... |# pair match.  If the slash were not present,\n;;; the outer comment would terminate prematurely.\n (defun mention-fun-fact-2a ()\n   (format t \"Don't use |\\# unmatched or you'll get in trouble!\"))\n\u2192 MENTION-FUN-FACT-2A\n (mention-fun-fact-2a)\n\\OUT Don't use |# unmatched or you'll get in trouble!\n\u2192 NIL\n #| (defun mention-fun-fact-2b ()\n      (format t \"Don't use |\\# unmatched or you'll get in trouble!\") |#\n (fboundp 'mention-fun-fact-2b) \u2192 NIL\n\\goodbreak\n;;; In this example, the programmer attacks the mismatch problem in a\n;;; different way.  The sharpsign vertical bar in the comment is not needed\n;;; for the correct parsing of the program normally (as in case 3a), but \n;;; becomes important to avoid premature termination of a comment when such \n;;; a program is commented out (as in case 3b).\n (defun mention-fun-fact-3a () ; #|\n   (format t \"Don't use |# unmatched or you'll get in trouble!\"))\n\u2192 MENTION-FUN-FACT-3A\n (mention-fun-fact-3a)\n\\OUT Don't use |# unmatched or you'll get in trouble!\n\u2192 NIL\n #|\n (defun mention-fun-fact-3b () ; #|\n   (format t \"Don't use |# unmatched or you'll get in trouble!\"))\n |#\n (fboundp 'mention-fun-fact-3b) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #|| (+ #|| 3 ||# 4 5) ||# \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #| (+ #| 3 |# 4 5) |#\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+ 1/3 2/3 1.0d0 1.0 1.0e-15)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;;;; Combining rationals with floats.\n ;;; This example assumes an implementation in which \n ;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),\n ;;; or else some other implementation in which 1/2 has an exact \n ;;;  representation in floating point.\n (+ 1/2 0.5) \u2192 1.0\n (- 1/2 0.5d0) \u2192 0.0d0\n (+ 0.5 -0.5 1/2) \u2192 0.5\n\n ;;;; Comparing rationals with floats.\n ;;; This example assumes an implementation in which the default float \n ;;; format is IEEE single-float, IEEE double-float, or some other format\n ;;; in which 5/7 is rounded upwards by FLOAT.\n (< 5/7 (float 5/7)) \u2192 T\n (< 5/7 (rational (float 5/7))) \u2192 T\n (< (float 5/7) (float 5/7)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #c(1.0 1.0) \u2192 #C(1.0 1.0)\n #c(0.0 0.0) \u2192 #C(0.0 0.0)\n #c(1.0 1) \u2192 #C(1.0 1.0)\n #c(0.0 0) \u2192 #C(0.0 0.0)\n #c(1 1) \u2192 #C(1 1)\n #c(0 0) \u2192 0\n (typep #c(1 1) '(complex (eql 1))) \u2192 T\n (typep #c(0 0) '(complex (eql 0))) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass q () ((x :initarg a)))\n (defclass r (q) ((x :initarg b))\n   (:default-initargs a 1 b 2))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod make-instance ((class standard-class) &rest initargs)\n   ...\n   (let ((instance (apply #'allocate-instance class initargs)))\n     (apply #'initialize-instance instance initargs)\n     instance))\n\n (defmethod make-instance ((class-name symbol) &rest initargs)\n   (apply #'make-instance (find-class class-name) initargs))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod initialize-instance ((instance standard-object) &rest initargs)\n   (apply #'shared-initialize instance t initargs)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; In a TOPS-20 implementation, which uses {\\hat}V to quote \n (NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))\n\u2192 #P"OZ:PS:{\\hat}V<TEST{\\hat}V>"\n\\NV #P"OZ:PS:<TEST>"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (pathname-type \n   (merge-pathnames (make-pathname :type "LISP")\n                    (make-pathname :type "TEXT")))\n\u2192 "LISP"\n\\smallbreak\n (pathname-type \n   (merge-pathnames (make-pathname :type nil)\n                    (make-pathname :type "LISP")))\n\u2192 "LISP"\n\\smallbreak\n (pathname-type \n   (merge-pathnames (make-pathname :type :unspecific)\n                    (make-pathname :type "LISP")))\n\u2192 :UNSPECIFIC\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro wrong-order (x y) `(getf ,y ,x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (push value (wrong-order place1 place2))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf place1 value1 place2 value2 ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((ref2 (list '())))\n   (push (progn (princ \"1\") 'ref-1)\n         (car (progn (princ \"2\") ref2)))) \n\\OUT 12\n\u2192 (REF1)\n\n (let (x)\n    (push (setq x (list 'a))\n          (car (setq x (list 'b))))\n     x)\n\u2192 (((A) . B))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq integer #x69) \u2192 #x69\n (rotatef (ldb (byte 4 4) integer) \n          (ldb (byte 4 0) integer))\n integer \u2192 #x96\n;;; This example is trying to swap two independent bit fields \n;;; in an integer.  Note that the generalized variable of \n;;; interest here is just the (possibly local) program variable\n;;; integer.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) \u2192 ((a 1 b 2 c 3))\n (setf (getf (car r) 'b) \n       (progn (setq r nil) 6)) \u2192 6\n r \u2192 NIL\n s \u2192 ((A 1 B 6 C 3))\n;;; Note that the (setq r nil) does not affect the actions of \n;;; the SETF because the value of R had already been saved in \n;;; a temporary variable as part of the step 1. Only the CAR\n;;; of this value will be retrieved, and subsequently modified \n;;; after the value computation.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (the integer (cadr x)) (+ y 3))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (cadr x) (the integer (+ y 3)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (apply \\#'\\param{name} \\starparam{arg}) \\param{val})\n \\EQ (apply \\#'(setf \\param{name}) \\param{val} \\starparam{arg})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((#:temp-1 arg1)          ;force correct order of evaluation\n       (#:temp-2 arg2)\n       ...\n       (#:temp-0 \\param{new-value}))\n   (funcall (function (setf \\param{f})) #:temp-0 #:temp-1 #:temp-2...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (operator \\starparam{preceding-form} \\param{place} \\starparam{following-form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" <-1---<--<--2---3->--4--\x3e->\n 000000000000000000000000000\n 11 111111111111111111111111\n           22 222\n              333 3333\n        44444444444444 44444\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(defun simple-pprint-defun (*standard-output* list)\n  (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")\n    (write (first list))\n    (write-char #\\Space)\n    (pprint-newline :miser)\n    (pprint-indent :current 0)\n    (write (second list))\n    (write-char #\\Space)\n    (pprint-newline :fill)\n    (write (third list))\n    (pprint-indent :block 1)\n    (write-char #\\Space)\n    (pprint-newline :linear)\n    (write (fourth list))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (DEFUN PROD (X Y) \n   (* X Y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(DEFUN PROD\n       (X Y)\n  (* X Y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (DEFUN\n  PROD\n  (X Y)\n  (* X Y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")\n   (simple-pprint-defun *standard-output* \'(defun prod (x y) (* x y))))\n \n ;;; (DEFUN PROD\n ;;;        (X Y)\n ;;;   (* X Y))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun pprint-let (*standard-output* list)\n   (pprint-logical-block (nil list :prefix "(" :suffix ")")\n     (write (pprint-pop))\n     (pprint-exit-if-list-exhausted)\n     (write-char #\\Space)\n     (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")\n       (pprint-exit-if-list-exhausted)\n       (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")\n               (pprint-exit-if-list-exhausted)\n               (loop (write (pprint-pop))\n                     (pprint-exit-if-list-exhausted)\n                     (write-char #\\Space)\n                     (pprint-newline :linear)))\n             (pprint-exit-if-list-exhausted)\n             (write-char #\\Space)\n             (pprint-newline :fill)))\n     (pprint-indent :block 1)\n     (loop (pprint-exit-if-list-exhausted)\n           (write-char #\\Space)\n           (pprint-newline :linear)\n           (write (pprint-pop)))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pprint-let *standard-output*\n             '#1=(let (x (*print-length* (f (g 3))) \n                       (z . 2) (k (car y)))\n                   (setq x (sqrt z)) #1#))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y))) \n      (SETQ X (SQRT Z))\n      #1#)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #1=(LET (X (*PRINT-PRETTY* (F #))\n          (Z . 2) (K (CAR Y)))\n      (SETQ X (SQRT Z))\n      #1#)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (LET (X\n       (*PRINT-LENGTH*\n        (F #))\n       (Z . 2) ...)\n   (SETQ X (SQRT Z))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(defun pprint-vector (*standard-output* v)\n  (pprint-logical-block (nil nil :prefix "#(" :suffix ")")\n    (let ((end (length v)) (i 0))\n      (when (plusp end)\n        (loop (pprint-pop)\n              (write (aref v i))\n              (if (= (incf i) end) (return nil))\n              (write-char #\\Space)\n              (pprint-newline :fill))))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))\n \n #(12 34 567 8 \n   9012 34 567 \n   89 0 1 23)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(defun simple-pprint-defun (*standard-output* list)\n  (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))\n\n(defun pprint-let (*standard-output* list)\n  (format T "~:<~W~{\\hat}~:<~@\\{~:<~@\\{~W~{\\hat}~_~\\}~:>~{\\hat}~:_~\\}~:>~1I~@\\{~{\\hat}~_~W~\\}~:>" list)) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))\n\n (set-pprint-dispatch 'ratio\n   #'(lambda (s obj)\n       (format s \"#.(/ ~W ~W)\" \n                 (numerator obj) (denominator obj))))\n\n (set-pprint-dispatch '(and ratio (satisfies minusp))\n   #'(lambda (s obj)\n       (format s \"#.(- (/ ~W ~W))\" \n               (- (numerator obj)) (denominator obj)))\n   5)\n\n (pprint '(1/3 -2/3))\n (#.(/ 1 3) \\#.(- (/ 2 3)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-pprint-dispatch '(cons (member quote)) () \n   #'(lambda (s list)\n       (if (and (consp (cdr list)) (null (cddr list)))\n          (funcall (formatter \"'~W\") s (cadr list))\n          (pprint-fill s list))))\n \n (set-pprint-dispatch '(cons (member my-let)) \n                      (pprint-dispatch '(let) nil))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))\n                      #'pprint-fill -5)\n \n ;; Assume a line length of 9\n (pprint '(0 b c d e f g h i j k))\n (0 b c d\n  e f g h\n  i j k)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct family mom kids)\n \n (set-pprint-dispatch 'family\n   #'(lambda (s f)\n       (funcall (formatter \"~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>\")\n               s (family-mom f) (family-kids f))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (write (list \'principal-family\n              (make-family :mom "Lucy"\n                           :kids \'("Mark" "Bob" . "Dan")))\n        :right-margin 25 :pretty T :escape nil :miser-width nil)\n (PRINCIPAL-FAMILY\n  #<Lucy and\n      Mark Bob . Dan>)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" 27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (A B)    (a b)    (  a  b )    (\\A |B|) \n(|\\A|\n  B\n)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((x (make-symbol "FOO"))) (list x x))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun test-readtable-case-printing ()\n   (let ((*readtable* (copy-readtable nil))\n         (*print-case* *print-case*))\n     (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~\n              ~%--------------------------------------------------~\n              ~%")\n     (dolist (readtable-case \'(:upcase :downcase :preserve :invert))\n       (setf (readtable-case *readtable*) readtable-case)\n       (dolist (print-case \'(:upcase :downcase :capitalize))\n         (dolist (symbol \'(|ZEBRA| |Zebra| |zebra|))\n           (setq *print-case* print-case)\n           (format t "~&:~A~15T:~A~29T~A~42T~A"\n                   (string-upcase readtable-case)\n                   (string-upcase print-case)\n                   (symbol-name symbol)\n                   (prin1-to-string symbol)))))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"    READTABLE-CASE *PRINT-CASE*  Symbol-name  Output\n    --------------------------------------------------\n    :UPCASE        :UPCASE       ZEBRA        ZEBRA\n    :UPCASE        :UPCASE       Zebra        |Zebra|\n    :UPCASE        :UPCASE       zebra        |zebra|\n    :UPCASE        :DOWNCASE     ZEBRA        zebra\n    :UPCASE        :DOWNCASE     Zebra        |Zebra|\n    :UPCASE        :DOWNCASE     zebra        |zebra|\n    :UPCASE        :CAPITALIZE   ZEBRA        Zebra\n    :UPCASE        :CAPITALIZE   Zebra        |Zebra|\n    :UPCASE        :CAPITALIZE   zebra        |zebra|\n    :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|\n    :DOWNCASE      :UPCASE       Zebra        |Zebra|\n    :DOWNCASE      :UPCASE       zebra        ZEBRA\n    :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|\n    :DOWNCASE      :DOWNCASE     Zebra        |Zebra|\n    :DOWNCASE      :DOWNCASE     zebra        zebra\n    :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|\n    :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|\n    :DOWNCASE      :CAPITALIZE   zebra        Zebra\n    :PRESERVE      :UPCASE       ZEBRA        ZEBRA\n    :PRESERVE      :UPCASE       Zebra        Zebra\n    :PRESERVE      :UPCASE       zebra        zebra\n    :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA\n    :PRESERVE      :DOWNCASE     Zebra        Zebra\n    :PRESERVE      :DOWNCASE     zebra        zebra\n    :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA\n    :PRESERVE      :CAPITALIZE   Zebra        Zebra\n    :PRESERVE      :CAPITALIZE   zebra        zebra\n    :INVERT        :UPCASE       ZEBRA        zebra\n    :INVERT        :UPCASE       Zebra        Zebra\n    :INVERT        :UPCASE       zebra        ZEBRA\n    :INVERT        :DOWNCASE     ZEBRA        zebra\n    :INVERT        :DOWNCASE     Zebra        Zebra\n    :INVERT        :DOWNCASE     zebra        ZEBRA\n    :INVERT        :CAPITALIZE   ZEBRA        zebra\n    :INVERT        :CAPITALIZE   Zebra        Zebra\n    :INVERT        :CAPITALIZE   zebra        ZEBRA\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (a . (b . ((c . (d . nil)) . (e . nil))))\n (a b (c d) e)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (a . b)     ;A dotted pair of a and b\n (a.b)       ;A list of one element, the symbol named a.b\n (a. b)      ;A list of two elements a. and b\n (a .b)      ;A list of two elements a and .b\n (a b . c)   ;A dotted list of a and b with c at the end; two conses\n .iot        ;The symbol whose name is .iot\n (. b)       ;Invalid -- an error is signaled if an attempt is made to read \n             ;this syntax.\n (a .)       ;Invalid -- an error is signaled.\n (a .. b)    ;Invalid -- an error is signaled.\n (a . . b)   ;Invalid -- an error is signaled.\n (a b c ...) ;Invalid -- an error is signaled.\n (a \\. b)    ;A list of three elements a, ., and b\n (a |.| b)   ;A list of three elements a, ., and b\n (a \\... b)  ;A list of three elements a, ..., and b\n (a |...| b) ;A list of three elements a, ..., and b\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% #3A(\n% ((#\\s #\\t #\\o #\\p) (#\\s #\\p #\\o #\\t))\n% ((#\\p #\\o #\\s #\\t) (#\\p #\\o #\\t #\\s))\n% ((#\\t #\\o #\\p #\\s) (#\\o #\\p #\\t #\\s)))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% #3A(("stop" "spot") ("post" "pots") ("tops" "opts"))\n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((a (make-array \'(3 3)))\n       (*print-pretty* t)\n       (*print-array* t))\n   (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))\n   (print a)\n   (print (make-array 9 :displaced-to a)))\n\\OUT #2A(("<0,0>" "<0,1>" "<0,2>") \n\\OUT     ("<1,0>" "<1,1>" "<1,2>") \n\\OUT     ("<2,0>" "<2,1>" "<2,2>")) \n\\OUT #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>") \n\u2192 #<ARRAY 9 indirect 36363476>\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% #S(RANDOM-STATE DATA #(14 49 98436589 786345 8734658324 ... ))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #S(\\param{structure-name} \\star{\\curly{\\param{slot-key} \\param{slot-value}}})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((*print-escape* t)) (fresh-line) (write #\\a))\n\\OUT #\\a\n\u2192 #\\a\n (let ((*print-escape* nil) (*print-readably* nil))\n   (fresh-line)\n   (write #\\a))\n\\OUT a\n\u2192 #\\a\n (progn (fresh-line) (prin1 #\\a))\n\\OUT #\\a\n\u2192 #\\a\n (progn (fresh-line) (print #\\a))\n\\OUT \n\\OUT #\\a\n\u2192 #\\a\n (progn (fresh-line) (princ #\\a))\n\\OUT a\n\u2192 #\\a\n\\medbreak\n (dolist (val '(t nil))\n   (let ((*print-escape* val) (*print-readably* val))\n     (print '#\\a) \n     (prin1 #\\a) (write-char #\\Space)\n     (princ #\\a) (write-char #\\Space)\n     (write #\\a)))\n\\OUT #\\a #\\a a #\\a\n\\OUT #\\a #\\a a a\n\u2192 NIL\n\\medbreak\n (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))\n\\OUT (LET ((A 1) (B 2)) (+ A B))\n\u2192 (LET ((A 1) (B 2)) (+ A B))\n\\medbreak\n (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))\n\\OUT (LET ((A 1)\n\\OUT       (B 2))               \n\\OUT   (+ A B))\n\u2192 (LET ((A 1) (B 2)) (+ A B))\n\\medbreak\n (progn (fresh-line) \n        (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))\n\\OUT (LET ((A 1)\n\\OUT       (B 2))\n\\OUT   (+ A B))                 \n\u2192 (LET ((A 1) (B 2)) (+ A B))\n\\medbreak\n (with-output-to-string (s)  \n    (write 'write :stream s)\n    (prin1 'prin1 s))\n\u2192 \"WRITEPRIN1\"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun test-readtable-case-reading ()\n   (let ((*readtable* (copy-readtable nil)))\n     (format t "READTABLE-CASE  Input   Symbol-name~\n              ~%-----------------------------------~\n              ~%")\n     (dolist (readtable-case \'(:upcase :downcase :preserve :invert))\n       (setf (readtable-case *readtable*) readtable-case)\n       (dolist (input \'("ZEBRA" "Zebra" "zebra"))\n         (format t "~&:~A~16T~A~24T~A"\n                 (string-upcase readtable-case)\n                 input\n                 (symbol-name (read-from-string input)))))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" READTABLE-CASE     Input Symbol-name\n -------------------------------------\n    :UPCASE         ZEBRA   ZEBRA\n    :UPCASE         Zebra   ZEBRA\n    :UPCASE         zebra   ZEBRA\n    :DOWNCASE       ZEBRA   zebra\n    :DOWNCASE       Zebra   zebra\n    :DOWNCASE       zebra   zebra\n    :PRESERVE       ZEBRA   ZEBRA\n    :PRESERVE       Zebra   Zebra\n    :PRESERVE       zebra   zebra\n    :INVERT         ZEBRA   zebra\n    :INVERT         Zebra   Zebra\n    :INVERT         zebra   ZEBRA\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cons '#3=(p q r) '(x y . #3#))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-macro-character #\\'       ;incorrect\n    #'(lambda (stream char)\n         (declare (ignore char))\n         (list 'quote (read stream))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-macro-character #\\'       ;correct\n    #'(lambda (stream char)\n         (declare (ignore char))\n         (list 'quote (read stream t nil t))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; The following examples assume the readtable case of *readtable* \n ;; and *print-case* are both :upcase.\n (eq 'abc 'ABC) \u2192 T\n (eq 'abc '|ABC|) \u2192 T\n (eq 'abc 'a|B|c) \u2192 T\n (eq 'abc '|abc|) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; The following examples assume the readtable case of *readtable* \n ;; and *print-case* are both :upcase.\n (eq 'abc '\\A\\B\\C) \u2192 T\n (eq 'abc 'a\\Bc) \u2192 T\n (eq 'abc '\\ABC) \u2192 T\n (eq 'abc '\\abc) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (length '(this-that)) \u2192 1\n (length '(this - that)) \u2192 3\n (length '(a\n           b)) \u2192 2\n (+ 34) \u2192 34\n (+ 3 4) \u2192 7\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (remove "FOO" \'(foo bar "FOO" "BAR" "foo" "bar") :test #\'equal)\n\u2192 (foo bar "BAR" "foo" "bar")\n (remove "FOO" \'(foo bar "FOO" "BAR" "foo" "bar") :test #\'equalp)\n\u2192 (foo bar "BAR" "bar")\n (remove "FOO" \'(foo bar "FOO" "BAR" "foo" "bar") :test #\'string-equal)\n\u2192 (bar "BAR" "bar")\n (remove "FOO" \'(foo bar "FOO" "BAR" "foo" "bar") :test #\'string=)\n\u2192 (BAR "BAR" "foo" "bar")\n\n (remove 1 \'(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #\'eql)\n\u2192 (1)\n (remove 1 \'(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #\'=)\n\u2192 (1 1.0 #C(1.0 0.0))\n (remove 1 \'(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #\'=))\n\u2192 (1 1.0 #C(1.0 0.0))\n\n (count 1 \'((one 1) (uno 1) (two 2) (dos 2)) :key #\'cadr) \u2192 2\n\n (count 2.0 \'(1 2 3) :test #\'eql :key #\'float) \u2192 1\n\n (count "FOO" (list (make-pathname :name "FOO" :type "X")  \n                    (make-pathname :name "FOO" :type "Y"))\n        :key #\'pathname-name\n        :test #\'equal)\n\u2192 2\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (count-if #\'zerop \'(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) \u2192 4\n\n (remove-if-not #\'symbolp \'(0 1 2 3 4 5 6 7 8 9 A B C D E F))\n\u2192 (A B C D E F)\n (remove-if (complement #\'symbolp) \'(0 1 2 3 4 5 6 7 8 9 A B C D E F))\n\u2192 (A B C D E F)\n\n (count-if #\'zerop \'("foo" "" "bar" "" "" "baz" "quux") :key #\'length)\n\u2192 3\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" \\256   25\\64   1.0\\E6   |100|   3\\.14159   |3/4|   3\\/4   5||\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector double-float 100)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector double-float *)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector * 100)                                      \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (array integer 3)       ;Three-dimensional arrays of integers\n% (array integer (* * *)) ;Three-dimensional arrays of integers\n% (array * (4 5 6))       ;4-by-5-by-6 arrays\n% (array character (3 *)) ;Two-dimensional arrays of characters that have \n%                         ;three rows\n% (array short-float \\empty)   ;Zero-rank arrays of short-floats\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (typep foo '(array character))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (subtypep 'character (array-element-type foo))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-array '(4 2 3) :initial-contents\n             '(((a b c) (1 2 3))\n              ((d e f) (3 1 2))\n              ((g h i) (2 3 1))\n              ((j k l) (0 0 0))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"\n (make-array 5) ;; Creates a one-dimensional array of five elements.\n (make-array '(3 4) :element-type '(mod 16)) ;; Creates a \n                ;;two-dimensional array, 3 by 4, with four-bit elements.\n (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-array nil :initial-element nil) \u2192 #0ANIL\n (make-array 4 :initial-element nil) \u2192 #(NIL NIL NIL NIL)\n (make-array '(2 4) \n              :element-type '(unsigned-byte 2) \n              :initial-contents '((0 1 2 3) (3 2 1 0)))\n\u2192 #2A((0 1 2 3) (3 2 1 0))\n (make-array 6\n              :element-type 'character \n              :initial-element #\\a \n              :fill-pointer 3) \u2192 \"aaa\"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (make-array '(4 3))) \n\u2192 #<ARRAY 4x3 simple 32546632>\n (dotimes (i 4)\n   (dotimes (j 3)\n     (setf (aref a i j) (list i 'x j '= (* i j)))))\n\u2192 NIL\n (setq b (make-array 8 :displaced-to a\n                       :displaced-index-offset 2))\n\u2192 #<ARRAY 8 indirect 32550757>\n (dotimes (i 8)\n   (print (list i (aref b i))))\n\\OUT (0 (0 X 2 = 0)) \n\\OUT (1 (1 X 0 = 0)) \n\\OUT (2 (1 X 1 = 1)) \n\\OUT (3 (1 X 2 = 2)) \n\\OUT (4 (2 X 0 = 0)) \n\\OUT (5 (2 X 1 = 2)) \n\\OUT (6 (2 X 2 = 4)) \n\\OUT (7 (3 X 0 = 0)) \n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a1 (make-array 50))\n\u2192 #<ARRAY 50 simple 32562043>\n (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))\n\u2192 #<ARRAY 20 indirect 32563346>\n (length b1) \u2192 20\n\n (setq a2 (make-array 50 :fill-pointer 10))\n\u2192 #<ARRAY 50 fill-pointer 10 46100216>\n (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))\n\u2192 #<ARRAY 20 indirect 46104010>\n (length a2) \u2192 10\n (length b2) \u2192 20\n\n (setq a3 (make-array 50 :fill-pointer 10))\n\u2192 #<ARRAY 50 fill-pointer 10 46105663>\n (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10\n                         :fill-pointer 5))\n\u2192 #<ARRAY 20 indirect, fill-pointer 5 46107432>\n (length a3) \u2192 10\n (length b3) \u2192 5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjust-array A ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjust-array A ... :displaced-to C)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjust-array A ... :displaced-to B)\n (adjust-array A ... :displaced-to C)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjust-array A ... :displaced-to B)\n (adjust-array A ... :displaced-to nil)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjustable-array-p\n  (setq ada (adjust-array\n              (make-array '(2 3)\n                          :adjustable t\n                          :initial-contents '((a b c) (1 2 3)))\n              '(4 6)))) \u2192 T \n (array-dimensions ada) \u2192 (4 6) \n (aref ada 1 1) \u2192 2 \n (setq beta (make-array '(2 3) :adjustable t))\n\u2192 #2A((NIL NIL NIL) (NIL NIL NIL)) \n (adjust-array beta '(4 6) :displaced-to ada)\n\u2192 #2A((A B C NIL NIL NIL)\n       (1 2 3 NIL NIL NIL)\n       (NIL NIL NIL NIL NIL NIL) \n       (NIL NIL NIL NIL NIL NIL))\n (array-dimensions beta) \u2192 (4 6)\n (aref beta 1 1) \u2192 2 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"#2A(( alpha     beta      gamma     delta )\n    ( epsilon   zeta      eta       theta )\n    ( iota      kappa     lambda    mu    )\n    ( nu        xi        omicron   pi    ))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjust-array m '(3 5) :initial-element 'baz)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"#2A(( alpha     beta      gamma     delta     baz )\n    ( epsilon   zeta      eta       theta     baz )\n    ( iota      kappa     lambda    mu        baz ))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjustable-array-p \n   (make-array 5\n               :element-type 'character \n               :adjustable t \n               :fill-pointer 3)) \u2192 T\n (adjustable-array-p (make-array 4)) \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (aref (setq alpha (make-array 4)) 3) \u2192 implementation-dependent\n (setf (aref alpha 3) 'sirens) \u2192 SIRENS\n (aref alpha 3) \u2192 SIRENS\n (aref (setq beta (make-array '(2 4) \n                    :element-type '(unsigned-byte 2)\n                    :initial-contents '((0 1 2 3) (3 2 1 0))))\n        1 2) \u2192 1\n (setq gamma '(0 2))\n (apply #'aref beta gamma) \u2192 2\n (setf (apply #'aref beta gamma) 3) \u2192 3\n (apply #'aref beta gamma) \u2192 3\n (aref beta 0 2) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-dimension (make-array 4) 0) \u2192 4\n (array-dimension (make-array '(2 3)) 1) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-dimension array n) \\EQ (nth n (array-dimensions array))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-dimensions (make-array 4)) \u2192 (4)\n (array-dimensions (make-array '(2 3))) \u2192 (2 3)\n (array-dimensions (make-array 4 :fill-pointer 2)) \u2192 (4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-element-type (make-array 4)) \u2192 T\n (array-element-type (make-array 12 :element-type '(unsigned-byte 8))) \n\u2192 implementation-dependent\n (array-element-type (make-array 12 :element-type '(unsigned-byte 5)))\n\u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-element-type (make-array 5 :element-type '(mod 5)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-has-fill-pointer-p (make-array 4)) \u2192 implementation-dependent\n (array-has-fill-pointer-p (make-array '(2 3))) \u2192 NIL\n (array-has-fill-pointer-p\n   (make-array 8 \n               :fill-pointer 2 \n               :initial-element 'filler)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a1 (make-array 5)) \u2192 #<ARRAY 5 simple 46115576>\n (setq a2 (make-array 4 :displaced-to a1\n                        :displaced-index-offset 1))\n\u2192 #<ARRAY 4 indirect 46117134>\n (array-displacement a2)\n\u2192 #<ARRAY 5 simple 46115576>, 1\n (setq a3 (make-array 2 :displaced-to a2\n                        :displaced-index-offset 2))\n\u2192 #<ARRAY 2 indirect 46122527>\n (array-displacement a3)\n\u2192 #<ARRAY 4 indirect 46117134>, 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (make-array '(7 11) :element-type 'string-char))\n (array-in-bounds-p a 0  0) \u2192 T\n (array-in-bounds-p a 6 10) \u2192 T\n (array-in-bounds-p a 0 -1) \u2192 NIL\n (array-in-bounds-p a 0 11) \u2192 NIL\n (array-in-bounds-p a 7  0) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-in-bounds-p array subscripts)   \n \\EQ (and (not (some #'minusp (list subscripts)))\n         (every #'< (list subscripts) (array-dimensions array)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-rank (make-array '())) \u2192 0\n (array-rank (make-array 4)) \u2192 1\n (array-rank (make-array '(4))) \u2192 1\n (array-rank (make-array '(2 3))) \u2192 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))\n (array-row-major-index a 1 2) \u2192 9\n (array-row-major-index \n    (make-array '(2 3 4) \n                :element-type '(unsigned-byte 8)\n                :displaced-to a\n                :displaced-index-offset 4)\n    0 2 1) \u2192 9\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun array-row-major-index (a &rest subscripts)\n   (apply #'+ (maplist #'(lambda (x y)\n                            (* (car x) (apply #'* (cdr y))))\n                       subscripts\n                       (array-dimensions a))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-total-size (make-array 4)) \u2192 4\n (array-total-size (make-array 4 :fill-pointer 2)) \u2192 4\n (array-total-size (make-array 0)) \u2192 0\n (array-total-size (make-array '(4 2))) \u2192 8\n (array-total-size (make-array '(4 0))) \u2192 0\n (array-total-size (make-array '())) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (array-total-size x)\n    \\EQ (apply #'* (array-dimensions x))\n    \\EQ (reduce #'* (array-dimensions x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (arrayp (make-array '(2 3 4) :adjustable t)) \u2192 T\n (arrayp (make-array 6)) \u2192 T\n (arrayp #*1011) \u2192 T\n (arrayp \"hi\") \u2192 T\n (arrayp 'hi) \u2192 NIL\n (arrayp 12) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (arrayp \\param{object}) \\EQ (typep \\param{object} 'array)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (make-array 8 :fill-pointer 4)) \u2192 #(NIL NIL NIL NIL)\n (fill-pointer a) \u2192 4\n (dotimes (i (length a)) (setf (aref a i) (* i i))) \u2192 NIL\n a \u2192 #(0 1 4 9)\n (setf (fill-pointer a) 3) \u2192 3\n (fill-pointer a) \u2192 3\n a \u2192 #(0 1 4)\n (setf (fill-pointer a) 8) \u2192 8\n a \u2192 #(0 1 4 9 NIL NIL NIL NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (row-major-aref array index) \\EQ\n   (aref (make-array (array-total-size array)\n                     :displaced-to array\n                     :element-type (array-element-type array))\n         index)\n\n (aref array i1 i2 ...) \\EQ\n     (row-major-aref array (array-row-major-index array i1 i2))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun upgraded-array-element-type (type &optional environment)\n   (array-element-type (make-array 0 :element-type type)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (simple-vector-p (make-array 6)) \u2192 T\n (simple-vector-p "aaaaaa") \u2192 NIL\n (simple-vector-p (make-array 6 :fill-pointer t)) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (simple-vector-p \\param{object}) \\EQ (typep \\param{object} 'simple-vector)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (simple-vector-p (setq v (vector 1 2 'sirens))) \u2192 T\n (svref v 0) \u2192 1\n (svref v 2) \u2192 SIRENS\n (setf (svref v 1) 'newcomer) \u2192 NEWCOMER               \n v \u2192 #(1 NEWCOMER SIRENS)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (svref \\param{v} \\param{i}) \\EQ (aref (the simple-vector \\param{v}) \\param{i})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (arrayp (setq v (vector 1 2 'sirens))) \u2192 T\n (vectorp v) \u2192 T\n (simple-vector-p v) \u2192 T         \n (length v) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector a\\ssso a\\ssst ... a\\sssn)\n  \\EQ (make-array (list \\i{n}) :element-type t\n                          :initial-contents \n                            (list a\\ssso a\\ssst ... a\\sssn))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector-push (setq fable (list 'fable))\n              (setq fa (make-array 8\n                                   :fill-pointer 2\n                                   :initial-element 'sisyphus))) \u2192 2 \n (fill-pointer fa) \u2192 3 \n (eq (vector-pop fa) fable) \u2192 T\n (vector-pop fa) \u2192 SISYPHUS \n (fill-pointer fa) \u2192 1 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vector-push (setq fable (list 'fable))\n              (setq fa (make-array 8 \n                                   :fill-pointer 2\n                                   :initial-element 'first-one))) \u2192 2 \n (fill-pointer fa) \u2192 3 \n (eq (aref fa 2) fable) \u2192 T\n (vector-push-extend #\\X\n                    (setq aa \n                          (make-array 5\n                                      :element-type 'character\n                                      :adjustable t\n                                      :fill-pointer 3))) \u2192 3 \n (fill-pointer aa) \u2192 4 \n (vector-push-extend #\\Y aa 4) \u2192 4 \n (array-total-size aa) \u2192 at least 5 \n (vector-push-extend #\\Z aa 4) \u2192 5 \n (array-total-size aa) \u2192 9 ;(or more)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (vectorp "aaaaaa") \u2192 T\n (vectorp (make-array 6 :fill-pointer t)) \u2192 T\n (vectorp (make-array \'(2 3 4))) \u2192 NIL\n (vectorp #*11) \u2192 T\n (vectorp #b11) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (vectorp \\param{object}) \\EQ (typep \\param{object} 'vector)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (bit (setq ba (make-array 8 \n                            :element-type 'bit \n                            :initial-element 1))\n       3) \u2192 1\n (setf (bit ba 3) 0) \u2192 0\n (bit ba 3) \u2192 0\n (sbit ba 5) \u2192 1\n (setf (sbit ba 5) 1) \u2192 1\n (sbit ba 5) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (bit-and (setq ba #*11101010) #*01101011) \u2192 #*01101010\n (bit-and #*1100 #*1010) \u2192 #*1000      \n (bit-andc1 #*1100 #*1010) \u2192 #*0010\n (setq rba (bit-andc2 ba #*00110011 t)) \u2192 #*11001000\n (eq rba ba) \u2192 T\n (bit-not (setq ba #*11101010)) \u2192 #*00010101\n (setq rba (bit-not ba \n                     (setq tba (make-array 8 \n                                           :element-type 'bit))))\n\u2192 #*00010101\n (equal rba tba) \u2192 T\n (bit-xor #*1100 #*1010) \u2192 #*0110\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (bit-vector-p (make-array 6 \n                           :element-type 'bit \n                           :fill-pointer t)) \u2192 T\n (bit-vector-p #*) \u2192 T\n (bit-vector-p (make-array 6)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (bit-vector-p \\param{object}) \\EQ (typep \\param{object} 'bit-vector)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (simple-bit-vector-p (make-array 6)) \u2192 NIL\n (simple-bit-vector-p #*) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (simple-bit-vector-p \\param{object}) \\EQ (typep \\param{object} 'simple-bit-vector)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char= #\\d #\\d) \u2192 T\n (char= #\\A #\\a) \u2192 NIL\n (char= #\\d #\\x) \u2192 NIL\n (char= #\\d #\\D) \u2192 NIL\n (char/= #\\d #\\d) \u2192 NIL\n (char/= #\\d #\\x) \u2192 T\n (char/= #\\d #\\D) \u2192 T\n (char= #\\d #\\d #\\d #\\d) \u2192 T\n (char/= #\\d #\\d #\\d #\\d) \u2192 NIL\n (char= #\\d #\\d #\\x #\\d) \u2192 NIL\n (char/= #\\d #\\d #\\x #\\d) \u2192 NIL\n (char= #\\d #\\y #\\x #\\c) \u2192 NIL\n (char/= #\\d #\\y #\\x #\\c) \u2192 T\n (char= #\\d #\\c #\\d) \u2192 NIL\n (char/= #\\d #\\c #\\d) \u2192 NIL\n (char< #\\d #\\x) \u2192 T\n (char<= #\\d #\\x) \u2192 T\n (char< #\\d #\\d) \u2192 NIL\n (char<= #\\d #\\d) \u2192 T\n (char< #\\a #\\e #\\y #\\z) \u2192 T\n (char<= #\\a #\\e #\\y #\\z) \u2192 T\n (char< #\\a #\\e #\\e #\\y) \u2192 NIL\n (char<= #\\a #\\e #\\e #\\y) \u2192 T\n (char> #\\e #\\d) \u2192 T\n (char>= #\\e #\\d) \u2192 T\n (char> #\\d #\\c #\\b #\\a) \u2192 T\n (char>= #\\d #\\c #\\b #\\a) \u2192 T\n (char> #\\d #\\d #\\c #\\a) \u2192 NIL\n (char>= #\\d #\\d #\\c #\\a) \u2192 T\n (char> #\\e #\\d #\\b #\\c #\\a) \u2192 NIL\n (char>= #\\e #\\d #\\b #\\c #\\a) \u2192 NIL\n (char> #\\z #\\A) \u2192 implementation-dependent\n (char> #\\Z #\\a) \u2192 implementation-dependent\n (char-equal #\\A #\\a) \u2192 T\n (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char-lessp)\n\u2192 (#\\A #\\a #\\b #\\B #\\c #\\C)\n (stable-sort (list #\\b #\\A #\\B #\\a #\\c #\\C) #'char<)\n\u2192 (#\\A #\\B #\\C #\\a #\\b #\\c) ;Implementation A\n\u2192 (#\\a #\\b #\\c #\\A #\\B #\\C) ;Implementation B\n\u2192 (#\\a #\\A #\\b #\\B #\\c #\\C) ;Implementation C\n\u2192 (#\\A #\\a #\\B #\\b #\\C #\\c) ;Implementation D\n\u2192 (#\\A #\\B #\\a #\\b #\\C #\\c) ;Implementation E\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (character #\\a) \u2192 #\\a\n (character \"a\") \u2192 #\\a\n (character 'a) \u2192 #\\A\n (character '\\a) \u2192 #\\a\n (character 65.) is an error.\n (character 'apple) is an error.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (character \\param{object}) \\EQ (coerce \\param{object} 'character)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (characterp #\\a) \u2192 T\n (characterp \'a) \u2192 NIL\n (characterp "a") \u2192 NIL\n (characterp 65.) \u2192 NIL\n (characterp #\\Newline) \u2192 T\n ;; This next example presupposes an implementation \n ;; in which #\\Rubout is an implementation-defined character.\n (characterp #\\Rubout) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (characterp \\param{object}) \\EQ (typep \\param{object} 'character)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (alpha-char-p #\\a) \u2192 T\n (alpha-char-p #\\5) \u2192 NIL\n (alpha-char-p #\\Newline) \u2192 NIL\n ;; This next example presupposes an implementation\n ;; in which #\\<alfa> is a defined character.\n (alpha-char-p #\\<alfa>) \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (alphanumericp #\\Z) \u2192 T\n (alphanumericp #\\9) \u2192 T\n (alphanumericp #\\Newline) \u2192 NIL\n (alphanumericp #\\#) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (alphanumericp x)\n   \\EQ (or (alpha-char-p x) (not (null (digit-char-p x))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (digit-char 0) \u2192 #\\0\n (digit-char 10 11) \u2192 #\\A\n (digit-char 10 10) \u2192 NIL\n (digit-char 7) \u2192 #\\7\n (digit-char 12) \u2192 NIL\n (digit-char 12 16) \u2192 #\\C  ;not #\\c\n (digit-char 6 2) \u2192 NIL\n (digit-char 1 2) \u2192 #\\1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (digit-char-p #\\5)    \u2192 5\n (digit-char-p #\\5 2)  \u2192 NIL\n (digit-char-p #\\A)    \u2192 NIL\n (digit-char-p #\\a)    \u2192 NIL\n (digit-char-p #\\A 11) \u2192 10\n (digit-char-p #\\a 11) \u2192 10\n (mapcar #'(lambda (radix) \n             (map 'list #'(lambda (x) (digit-char-p x radix)) \n                  \"059AaFGZ\"))\n         '(2 8 10 16 36))\n \u2192 ((0 NIL NIL NIL NIL NIL NIL NIL)\n     (0 5 NIL NIL NIL NIL NIL NIL)\n     (0 5 9 NIL NIL NIL NIL NIL)\n     (0 5 9 10 10 15 NIL NIL)\n     (0 5 9 10 10 15 16 35))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (graphic-char-p #\\G) \u2192 T\n (graphic-char-p #\\#) \u2192 T\n (graphic-char-p #\\Space) \u2192 T\n (graphic-char-p #\\Newline) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (standard-char-p #\\Space) \u2192 T\n (standard-char-p #\\~) \u2192 T\n ;; This next example presupposes an implementation\n ;; in which #\\Bell is a defined character.\n (standard-char-p #\\Bell) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char-upcase #\\a) \u2192 #\\A\n (char-upcase #\\A) \u2192 #\\A\n (char-downcase #\\a) \u2192 #\\a\n (char-downcase #\\A) \u2192 #\\a\n (char-upcase #\\9) \u2192 #\\9\n (char-downcase #\\9) \u2192 #\\9\n (char-upcase #\\@) \u2192 #\\@\n (char-downcase #\\@) \u2192 #\\@\n ;; Note that this next example might run for a very long time in \n ;; some implementations if CHAR-CODE-LIMIT happens to be very large\n ;; for that implementation.\n (dotimes (code char-code-limit)\n   (let ((char (code-char code)))\n     (when char\n       (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))\n                     ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))\n                     (t (and (char= (char-upcase (char-downcase char)) char)\n                             (char= (char-downcase (char-upcase char)) char))))\n         (return char)))))\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (upper-case-p #\\A) \u2192 T\n (upper-case-p #\\a) \u2192 NIL\n (both-case-p #\\a) \u2192 T\n (both-case-p #\\5) \u2192 NIL\n (lower-case-p #\\5) \u2192 NIL\n (upper-case-p #\\5) \u2192 NIL\n ;; This next example presupposes an implementation \n ;; in which #\\Bell is an implementation-defined character.\n (lower-case-p #\\Bell) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; An implementation using ASCII character encoding \n;; might return these values:\n(char-code #\\$) \u2192 36\n(char-code #\\a) \u2192 97\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char= \\i{c1} \\i{c2}) \\EQ (= (char-int \\i{c1}) (char-int \\i{c2}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char-int #\\A) \u2192 65       ; implementation A\n (char-int #\\A) \u2192 577      ; implementation B\n (char-int #\\A) \u2192 262145   ; implementation C\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(code-char 65.) \u2192 #\\A  ;in an implementation using ASCII codes\n(code-char (char-code #\\Space)) \u2192 #\\Space  ;in any implementation\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (char-name #\\ ) \u2192 "Space"\n (char-name #\\Space) \u2192 "Space"\n (char-name #\\Page) \u2192 "Page"\n\n (char-name #\\a)\n\u2192 NIL\nOR=> "LOWERCASE-a"\nOR=> "Small-A"\nOR=> "LA01"\n\n (char-name #\\A)\n\u2192 NIL\nOR=> "UPPERCASE-A"\nOR=> "Capital-A"\nOR=> "LA02"\n\n ;; Even though its CHAR-NAME can vary, #\\A prints as #\\A\n (prin1-to-string (read-from-string (format nil "#\\\\~A" (or (char-name #\\A) "A"))))\n\u2192 "#\\\\A"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(name-char \'space) \u2192 #\\Space\n(name-char "space") \u2192 #\\Space\n(name-char "Space") \u2192 #\\Space\n(let ((x (char-name #\\a)))\n  (or (not x) (eql (name-char x) #\\a))) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (make-array '(3 5) :initial-element 3))\n\u2192 #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))\n (setq y (make-array '(3 5) :initial-element 7))\n\u2192 #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))\n (defun matrix-multiply (a b)\n   (let ((*print-array* nil))\n     (assert (and (= (array-rank a) (array-rank b) 2)\n                  (= (array-dimension a 1) (array-dimension b 0)))\n             (a b)\n             \"Cannot multiply ~S by ~S.\" a b)\n            (really-matrix-multiply a b))) \u2192 MATRIX-MULTIPLY\n (matrix-multiply x y)\n\\OUT Correctable error in MATRIX-MULTIPLY: \n\\OUT Cannot multiply #<ARRAY ...> by #<ARRAY ...>.\n\\OUT Restart options:\n\\OUT  1: You will be prompted for one or more new values.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Value for A: \\IN{x}\n\\OUT Value for B: \\IN{(make-array '(5 3) :initial-element 6)}\n\u2192 #2A((54 54 54 54 54)\n       (54 54 54 54 54)\n       (54 54 54 54 54)\n       (54 54 54 54 54)\n       (54 54 54 54 54))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun double-safely (x) (assert (numberp x) (x)) (+ x x))\n (double-safely 4) \n\u2192 8\n \n (double-safely t)\n\\OUT Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.\n\\OUT Restart options:\n\\OUT  1: You will be prompted for one or more new values.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Value for X: \\IN{7}\n\u2192 14\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun factorial (x)\n   (cond ((or (not (typep x \'integer)) (minusp x))\n          (error "~S is not a valid argument to FACTORIAL." x))\n         ((zerop x) 1)\n         (t (* x (factorial (- x 1))))))\n\u2192 FACTORIAL\n(factorial 20)\n\u2192 2432902008176640000\n(factorial -1)\n\\OUT Error: -1 is not a valid argument to FACTORIAL.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return to Lisp Toplevel.\n\\OUT Debug> \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a \'fred)\n\u2192 FRED\n (if (numberp a) (1+ a) (error "~S is not a number." A))\n\\OUT Error: FRED is not a number.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:Continue 1}\n\\OUT Return to Lisp Toplevel.\n \n (define-condition not-a-number (error) \n                   ((argument :reader not-a-number-argument :initarg :argument))\n   (:report (lambda (condition stream)\n              (format stream "~S is not a number."\n                      (not-a-number-argument condition)))))\n\u2192 NOT-A-NUMBER\n \n (if (numberp a) (1+ a) (error \'not-a-number :argument a))\n\\OUT Error: FRED is not a number.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:Continue 1}\n\\OUT Return to Lisp Toplevel.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun wargames:no-win-scenario ()\n   (if (error "pushing the button would be stupid."))\n   (push-the-button))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun real-sqrt (n)\n   (when (minusp n)\n     (setq n (- n))\n     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))\n   (sqrt n))\n\n (real-sqrt 4)\n\u2192 2.0\n\n (real-sqrt -9)\n\\OUT Correctable error in REAL-SQRT: Tried to take sqrt(-9).\n\\OUT Restart options:\n\\OUT  1: Return sqrt(9) instead.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\u2192 3.0\n \n (define-condition not-a-number (error)\n   ((argument :reader not-a-number-argument :initarg :argument))\n   (:report (lambda (condition stream)\n              (format stream "~S is not a number." \n                      (not-a-number-argument condition)))))\n \n (defun assure-number (n)\n   (loop (when (numberp n) (return n))\n         (cerror "Enter a number."\n                 \'not-a-number :argument n)\n         (format t "~&Type a number: ")\n         (setq n (read))\n         (fresh-line)))\n\n (assure-number \'a)\n\\OUT Correctable error in ASSURE-NUMBER: A is not a number.\n\\OUT Restart options:\n\\OUT  1: Enter a number.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Type a number: \\IN{1/2}\n\u2192 1/2\n\n (defun assure-large-number (n)\n   (loop (when (and (numberp n) (> n 73)) (return n))\n         (cerror "Enter a number~:[~; a bit larger than ~D~]."\n                 "~*~A is not a large number." \n                 (numberp n) n)\n         (format t "~&Type a large number: ")\n         (setq n (read))\n         (fresh-line)))\n \n (assure-large-number 10000)\n\u2192 10000\n\n (assure-large-number \'a)\n\\OUT Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.\n\\OUT Restart options:\n\\OUT  1: Enter a number.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Type a large number: \\IN{88}\n\u2192 88\n\n (assure-large-number 37)\n\\OUT Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.\n\\OUT Restart options:\n\\OUT  1: Enter a number a bit larger than 37.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Type a large number: \\IN{259}\n\u2192 259\n \n (define-condition not-a-large-number (error)\n   ((argument :reader not-a-large-number-argument :initarg :argument))\n   (:report (lambda (condition stream)\n              (format stream "~S is not a large number." \n                      (not-a-large-number-argument condition)))))\n \n (defun assure-large-number (n)\n   (loop (when (and (numberp n) (> n 73)) (return n))\n         (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."\n                 \'not-a-large-number\n                 :argument n \n                 :ignore (numberp n)\n                 :ignore n\n                 :allow-other-keys t)\n         (format t "~&Type a large number: ")\n         (setq n (read))\n         (fresh-line)))\n \n\n (assure-large-number \'a)\n\\OUT Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.\n\\OUT Restart options:\n\\OUT  1: Enter a number.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Type a large number: \\IN{88}\n\u2192 88\n \n (assure-large-number 37)\n\\OUT Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.\n\\OUT Restart options:\n\\OUT  1: Enter a number a bit larger than 37.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Type a large number: \\IN{259}\n\u2192 259\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(cerror "enter a new value to replace ~*~s" \n        \'not-a-number\n        :argument a)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq aardvarks '(sam harry fred))\n\u2192 (SAM HARRY FRED)\n (check-type aardvarks (array * (3)))\n\\OUT Error: The value of AARDVARKS, (SAM HARRY FRED),\n\\OUT        is not a 3-long array.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Use Value: \\IN{#(SAM FRED HARRY)}\n\u2192 NIL\n aardvarks\n\u2192 #<ARRAY-T-3 13571>\n (map 'list #'identity aardvarks)\n\u2192 (SAM FRED HARRY)\n (setq aardvark-count 'foo)\n\u2192 FOO\n (check-type aardvark-count (integer 0 *) \"A positive integer\")\n\\OUT Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:CONTINUE 2}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro define-adder (name amount)\n   (check-type name (and symbol (not null)) \"a name for an adder function\")\n   (check-type amount integer)\n   `(defun ,name (x) (+ x ,amount)))\n  \n (macroexpand '(define-adder add3 3))\n\u2192 (defun add3 (x) (+ x 3))\n \n (macroexpand '(define-adder 7 7))\n\\OUT Error: The value of NAME, 7, is not a name for an adder function.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:Continue 1}\n\\OUT Specify a value to use instead.\n\\OUT Type a form to be evaluated and used instead: \\IN{'ADD7}\n\u2192 (defun add7 (x) (+ x 7))\n \n (macroexpand '(define-adder add5 something))\n\\OUT Error: The value of AMOUNT, SOMETHING, is not an integer.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:Continue 1}\n\\OUT Type a form to be evaluated and used instead: \\IN{5}\n\u2192 (defun add5 (x) (+ x 5))\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (check-type \\param{place} \\param{typespec})\n \\EQ (assert (typep \\param{place} '\\param{typespec}) (\\param{place})\n            'type-error :datum \\param{place} :expected-type '\\param{typespec})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun handle-division-conditions (condition)\n   (format t \"Considering condition for division condition handling~%\")\n   (when (and (typep condition 'arithmetic-error)\n              (eq '/ (arithmetic-error-operation condition)))\n     (invoke-debugger condition)))\nHANDLE-DIVISION-CONDITIONS\n (defun handle-other-arithmetic-errors (condition)\n   (format t \"Considering condition for arithmetic condition handling~%\")\n   (when (typep condition 'arithmetic-error)\n     (abort)))\nHANDLE-OTHER-ARITHMETIC-ERRORS\n (define-condition a-condition-with-no-handler (condition) ())\nA-CONDITION-WITH-NO-HANDLER\n (signal 'a-condition-with-no-handler)\nNIL\n (handler-bind ((condition #'handle-division-conditions)\n                  (condition #'handle-other-arithmetic-errors))\n   (signal 'a-condition-with-no-handler))\nConsidering condition for division condition handling\nConsidering condition for arithmetic condition handling\nNIL\n (handler-bind ((arithmetic-error #'handle-division-conditions)\n                  (arithmetic-error #'handle-other-arithmetic-errors))\n   (signal 'arithmetic-error :operation '* :operands '(1.2 b)))\nConsidering condition for division condition handling\nConsidering condition for arithmetic condition handling\nBack to Lisp Toplevel\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq foo (make-condition \'simple-condition\n                          :format-control "Hi ~S"\n                          :format-arguments \'(ho)))\n\u2192 #<SIMPLE-CONDITION 26223553>\n (apply #\'format nil (simple-condition-format-control foo)\n                     (simple-condition-format-arguments foo))\n\u2192 "Hi HO"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  (defun foo (x)\n    (let ((result (* x 2)))\n      (if (not (typep result 'fixnum))\n          (warn \"You're using very big numbers.\"))\n      result))\n\u2192 FOO\n \n  (foo 3)\n\u2192 6\n \n  (foo most-positive-fixnum)\n\\OUT Warning: You're using very big numbers.\n\u2192 4294967294\n \n  (setq *break-on-signals* t)\n\u2192 T\n \n  (foo most-positive-fixnum)\n\\OUT Break: Caveat emptor.\n\\OUT To continue, type :CONTINUE followed by an option number.\n\\OUT  1: Return from Break.\n\\OUT  2: Abort to Lisp Toplevel.\n\\OUT Debug> :continue 1\n\\OUT Warning: You're using very big numbers.\n\u2192 4294967294\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (ignore-errors ;Normally, this would suppress debugger entry\n   (handler-bind ((error #\'invoke-debugger)) ;But this forces debugger entry\n     (error "Foo.")))\nDebug: Foo.\nTo continue, type :CONTINUE followed by an option number:\n 1: Return to Lisp Toplevel.\nDebug>\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (break "You got here with arguments: ~:S." \'(FOO 37 A))\n\\OUT BREAK: You got here with these arguments: FOO, 37, A.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return from BREAK.\n\\OUT  2: Top level.\n\\OUT Debug> :CONTINUE 1\n\\OUT Return from BREAK.\n\u2192 NIL\n \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun break (&optional (format-control "Break") &rest format-arguments)\n   (with-simple-restart (continue "Return from BREAK.")\n     (let ((*debugger-hook* nil))\n       (invoke-debugger\n           (make-condition \'simple-condition\n                           :format-control format-control\n                           :format-arguments format-arguments))))\n   nil)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun one-of (choices &optional (prompt "Choice"))\n   (let ((n (length choices)) (i))\n     (do ((c choices (cdr c)) (i 1 (+ i 1)))\n         ((null c))\n       (format t "~&[~D] ~A~%" i (car c)))\n     (do () ((typep i `(integer 1 ,n)))\n       (format t "~&~A: " prompt)\n       (setq i (read))\n       (fresh-line))\n     (nth (- i 1) choices)))\n\n (defun my-debugger (condition me-or-my-encapsulation)\n   (format t "~&Fooey: ~A" condition)\n   (let ((restart (one-of (compute-restarts))))\n     (if (not restart) (error "My debugger got an error."))\n     (let ((*debugger-hook* me-or-my-encapsulation))\n       (invoke-restart-interactively restart))))\n \n (let ((*debugger-hook* #\'my-debugger))\n   (+ 3 \'a))\n\\OUT Fooey: The argument to +, A, is not a number.\n\\OUT  [1] Supply a replacement for A.\n\\OUT  [2] Return to Cloe Toplevel.\n\\OUT Choice: 1\n\\OUT  Form to evaluate and use: (+ 5 \'b)\n\\OUT  Fooey: The argument to +, B, is not a number.\n\\OUT  [1] Supply a replacement for B.\n\\OUT  [2] Supply a replacement for A.\n\\OUT  [3] Return to Cloe Toplevel.\n\\OUT Choice: 1\n\\OUT  Form to evaluate and use: 1\n\u2192 9\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' *break-on-signals* \u2192 NIL\n (ignore-errors (error \'simple-error :format-control "Fooey!"))\n\u2192 NIL, #<SIMPLE-ERROR 32207172>\n\n (let ((*break-on-signals* \'error))\n   (ignore-errors (error \'simple-error :format-control "Fooey!")))\n\\OUT Break: Fooey!\n\\OUT BREAK entered because of *BREAK-ON-SIGNALS*.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Continue to signal.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Continue to signal.\n\u2192 NIL, #<SIMPLE-ERROR 32212257>\n\n (let ((*break-on-signals* \'error))\n   (error \'simple-error :format-control "Fooey!"))\n\\OUT Break: Fooey!\n\\OUT BREAK entered because of *BREAK-ON-SIGNALS*.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Continue to signal.\n\\OUT  2: Top level.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Continue to signal.\n\\OUT Error: Fooey!\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Top level.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Top level.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (handler-bind ((unbound-variable #'(lambda ...))\n                (error #'(lambda ...)))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun trap-error-handler (condition)\n   (format *error-output* "~&~A~&" condition)\n   (throw \'trap-errors nil))\n\n (defmacro trap-errors (&rest forms)\n   `(catch \'trap-errors\n      (handler-bind ((error #\'trap-error-handler))\n        ,@forms)))\n \n (list (trap-errors (signal "Foo.") 1)\n       (trap-errors (error  "Bar.") 2)\n       (+ 1 2))\n\\OUT Bar.\n\u2192 (1 NIL 3)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  (handler-case \\i{form}\n    (\\i{typespec1} (\\i{var1}) \\i{form1})\n    (\\i{typespec2} (\\i{var2}) \\i{form2}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  (\\param{typespec} (\\param{var}) (declare (ignore \\param{var})) \\param{form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun assess-condition (condition)\n   (handler-case (signal condition)\n     (warning () "Lots of smoke, but no fire.")\n     ((or arithmetic-error control-error cell-error stream-error)\n        (condition)\n       (format nil "~S looks especially bad." condition))\n     (serious-condition (condition)\n       (format nil "~S looks serious." condition))\n     (condition () "Hardly worth mentioning.")))\n\u2192 ASSESS-CONDITION\n (assess-condition (make-condition \'stream-error :stream *terminal-io*))\n\u2192 "#<STREAM-ERROR 12352256> looks especially bad."\n (define-condition random-condition (condition) () \n   (:report (lambda (condition stream)\n              (declare (ignore condition))\n              (princ "Yow" stream))))\n\u2192 RANDOM-CONDITION\n (assess-condition (make-condition \'random-condition))\n\u2192 "Hardly worth mentioning."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (handler-case form\n   (\\i{type1} (\\i{var1}) . \\i{body1})\n   (\\i{type2} (\\i{var2}) . \\i{body2}) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block #1=#:g0001\n   (let ((#2=#:g0002 nil))\n     (tagbody\n       (handler-bind ((\\i{type1} #'(lambda (temp)\n                                       (setq #1# temp)\n                                       (go #3=#:g0003)))\n                      (\\i{type2} #'(lambda (temp)\n                                       (setq #2# temp)\n                                       (go #4=#:g0004))) ...)\n       (return-from #1# form))\n         #3# (return-from #1# (let ((\\i{var1} #2#)) . \\i{body1}))\n         #4# (return-from #1# (let ((\\i{var2} #2#)) . \\i{body2})) ...)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (handler-case form\n   (\\i{type1} \\i{(var1)} . \\i{body1})\n   ...\n   (:no-error (\\i{varN-1} \\i{varN-2} ...) . \\i{bodyN}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"\n (block #1=#:error-return\n  (multiple-value-call #'(lambda (\\i{varN-1} \\i{varN-2} ...) . \\i{bodyN})\n     (block #2=#:normal-return\n       (return-from #1#\n         (handler-case (return-from #2# form)\n           (\\i{type1} (\\i{var1}) . \\i{body1}) ...)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun load-init-file (program)\n   (let ((win nil))\n     (ignore-errors ;if this fails, don\'t enter debugger\n       (load (merge-pathnames (make-pathname :name program :type :lisp)\n                              (user-homedir-pathname)))\n       (setq win t))\n     (unless win (format t "~&Init file failed to load.~%"))\n     win))\n \n (load-init-file "no-such-program")\n\\OUT Init file failed to load.\nNIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ignore-errors . \\i{forms})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (handler-case (progn . \\i{forms})\n   (error (condition) (values nil condition)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod print-object ((x c) stream)\n   (if *print-escape* (call-next-method) (\\param{report-name} x stream)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda (condition stream)\n   (declare (ignore condition))\n   (write-string \\param{report-name} stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(define-condition peg/hole-mismatch \n                  (blocks-world-error)\n                  ((peg-shape  :initarg :peg-shape\n                               :reader peg/hole-mismatch-peg-shape)\n                   (hole-shape :initarg :hole-shape\n                               :reader peg/hole-mismatch-hole-shape))\n  (:report (lambda (condition stream)\n             (format stream "A ~A peg cannot go in a ~A hole."\n                     (peg/hole-mismatch-peg-shape  condition)\n                     (peg/hole-mismatch-hole-shape condition)))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(define-condition machine-error \n                  (error)\n                  ((machine-name :initarg :machine-name\n                                 :reader machine-error-machine-name))\n  (:report (lambda (condition stream)\n             (format stream "There is a problem with ~A."\n                     (machine-error-machine-name condition)))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(define-condition machine-not-available-error (machine-error) ()\n  (:report (lambda (condition stream)\n             (format stream "The machine ~A is not available."\n                     (machine-error-machine-name condition)))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(define-condition my-favorite-machine-not-available-error\n                  (machine-not-available-error)\n  ((machine-name :initform "mc.lcs.mit.edu")))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (define-condition ate-too-much (error) \n     ((person :initarg :person :reader ate-too-much-person)\n      (weight :initarg :weight :reader ate-too-much-weight)\n      (kind-of-food :initarg :kind-of-food\n                    :reader :ate-too-much-kind-of-food)))\n\u2192 ATE-TOO-MUCH\n (define-condition ate-too-much-ice-cream (ate-too-much)\n   ((kind-of-food :initform 'ice-cream)\n    (flavor       :initarg :flavor\n                  :reader ate-too-much-ice-cream-flavor\n                  :initform 'vanilla ))\n   (:report (lambda (condition stream)\n              (format stream \"~A ate too much ~A ice-cream\"\n                      (ate-too-much-person condition)\n                      (ate-too-much-ice-cream-flavor condition)))))\n\u2192 ATE-TOO-MUCH-ICE-CREAM\n (make-condition 'ate-too-much-ice-cream\n                 :person 'fred\n                 :weight 300\n                 :flavor 'chocolate)\n\u2192 #<ATE-TOO-MUCH-ICE-CREAM 32236101>\n (format t \"~A\" *)\n\\OUT FRED ate too much CHOCOLATE ice-cream\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defvar *oops-count* 0)\n\n (setq a (make-condition \'simple-error\n                         :format-control "This is your ~:R error."\n                         :format-arguments (list (incf *oops-count*))))\n\u2192 #<SIMPLE-ERROR 32245104>\n \n (format t "~&~A~%" a)\n\\OUT This is your first error.\n\u2192 NIL\n \n (error a)\n\\OUT Error: This is your first error.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return to Lisp Toplevel.\n\\OUT Debug> \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; One possible way in which an interactive debugger might present\n ;; restarts to the user.\n (defun invoke-a-restart ()\n   (let ((restarts (compute-restarts)))\n     (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))\n       (format t "~&~D: ~A~%" i (car r)))\n     (let ((n nil) (k (length restarts)))\n       (loop (when (and (typep n \'integer) (>= n 0) (< n k))\n               (return t))\n             (format t "~&Option: ")\n             (setq n (read))\n             (fresh-line))\n       (invoke-restart-interactively (nth n restarts)))))\n\n (restart-case (invoke-a-restart)\n   (one () 1)\n   (two () 2)\n   (nil () :report "Who knows?" \'anonymous)\n   (one () \'I)\n   (two () \'II))\n\\OUT 0: ONE\n\\OUT 1: TWO\n\\OUT 2: Who knows?\n\\OUT 3: ONE\n\\OUT 4: TWO\n\\OUT 5: Return to Lisp Toplevel.\n\\OUT Option: \\IN{4}\n\u2192 II\n \n ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS\n ;; also returns information about any system-supplied restarts, such as\n ;; the "Return to Lisp Toplevel" restart offered above.\n \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (restart-case\n     (let ((r (find-restart 'my-restart)))\n       (format t \"~S is named ~S\" r (restart-name r)))\n   (my-restart () nil))\n\\OUT #<RESTART 32307325> is named MY-RESTART\n\u2192 NIL\n (find-restart 'my-restart)\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find-restart \\param{identifier})\n \\EQ (find \\param{identifier} (compute-restarts) :key :restart-name)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun add3 (x) (check-type x number) (+ x 3))\n \n (foo 'seven)\n\\OUT Error: The value SEVEN was not of type NUMBER.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a different value to use.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{(invoke-restart 'store-value 7)}\n\u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (apply #'invoke-restart \\i{restart} \\i{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun add3 (x) (check-type x number) (+ x 3))\n \n (add3 'seven)\n\\OUT Error: The value SEVEN was not of type NUMBER.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a different value to use.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{(invoke-restart-interactively 'store-value)}\n\\OUT Type a form to evaluate and use: \\IN{7}\n\u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (defun choose-an-interactive-restart ()\n%   (restart-bind\n%       ((optional-value\n%          #\'(lambda (&optional (x \'default)) x)\n%          :report-function #\'(lambda (stream)\n%                               (format stream "Return an optional value")))\\kern-3pt\n%        (return-value\n%          #\'identity\n%          :report-function #\'(lambda (stream)\n%                               (format stream "Return the given value"))\n%          :interactive-function #\'(lambda ()\n%                                    (format t "Enter a value to return: ")\n%                                  (list (eval (read))))))\n%     (let ((cases (compute-restarts))\n%           (*print-structure* t)\n%           (index -1))\n%       (dolist (case cases)\n%         (format t "~&~D: ~A~%" (incf index) case))\n%       (format t "Please enter restart to invoke: ")\n%       (invoke-restart-interactively (nth (eval (read)) cases)))))\n%\u2192\\ CHOOSE-AN-INTERACTIVE-RESTART\n% (choose-an-interactive-restart)\n%\u2192\\ 0: Return an optional value\n%1: Return the given value\n%2: Abort to Lisp Top Level\n%Please enter restart to invoke: 0\n%DEFAULT\n% (choose-an-interactive-restart)\n%\u2192\\ 0: Return an optional value\n%1: Return the given value\n%2: Abort to Lisp Top Level\n%Please enter restart to invoke: 1\n%Enter a value to return: t\n%T\n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda (stream) (write-string value stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (format t "~&~S -- ~A~%" \':continue some-restart)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" :CONTINUE -- Return to command level\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (restart-case\n     (handler-bind ((error #\'(lambda (c)\n                             (declare (ignore condition))\n                             (invoke-restart \'my-restart 7))))\n       (error "Foo."))\n   (my-restart (&optional v) v))\n\u2192 7\n\n (define-condition food-error (error) ())\n\u2192 FOOD-ERROR\n (define-condition bad-tasting-sundae (food-error) \n   ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)\n    (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)\n    (topping :initarg :topping :reader bad-tasting-sundae-topping))\n   (:report (lambda (condition stream)\n              (format stream "Bad tasting sundae with ~S, ~S, and ~S"\n                      (bad-tasting-sundae-ice-cream condition)\n                      (bad-tasting-sundae-sauce condition)\n                      (bad-tasting-sundae-topping condition)))))\n\u2192 BAD-TASTING-SUNDAE\n (defun all-start-with-same-letter (symbol1 symbol2 symbol3)\n   (let ((first-letter (char (symbol-name symbol1) 0)))\n     (and (eql first-letter (char (symbol-name symbol2) 0))\n          (eql first-letter (char (symbol-name symbol3) 0)))))\n\u2192 ALL-START-WITH-SAME-LETTER\n (defun read-new-value ()\n   (format t "Enter a new value: ")\n   (multiple-value-list (eval (read))))\n\u2192 READ-NEW-VALUE\\eject\n (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)\n   (do ()\n      ((all-start-with-same-letter ice-cream sauce topping))\n     (restart-case\n       (error \'bad-tasting-sundae\n              :ice-cream ice-cream\n              :sauce sauce\n              :topping topping)\n       (use-new-ice-cream (new-ice-cream)\n         :report "Use a new ice cream."\n         :interactive read-new-value  \n         (setq ice-cream new-ice-cream))\n       (use-new-sauce (new-sauce)\n         :report "Use a new sauce."\n         :interactive read-new-value\n         (setq sauce new-sauce))\n       (use-new-topping (new-topping)\n         :report "Use a new topping."\n         :interactive read-new-value\n         (setq topping new-topping))))\n   (values ice-cream sauce topping))\n\u2192 VERIFY-OR-FIX-PERFECT-SUNDAE\n (verify-or-fix-perfect-sundae \'vanilla \'caramel \'cherry)\n\\OUT Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Use a new ice cream.\n\\OUT  2: Use a new sauce.\n\\OUT  3: Use a new topping.\n\\OUT  4: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:continue 1}\n\\OUT Use a new ice cream.\n\\OUT Enter a new ice cream: \\IN{\'chocolate}\n\u2192 CHOCOLATE, CARAMEL, CHERRY\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (restart-case \\i{expression}\n    (\\i{name1} \\i{arglist1} ...\\i{options1}... . \\i{body1})\n    (\\i{name2} \\i{arglist2} ...\\i{options2}... . \\i{body2}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block #1=#:g0001\n   (let ((#2=#:g0002 nil))\n        (tagbody\n        (restart-bind ((name1 #'(lambda (&rest temp)\n                                (setq #2# temp)\n                                (go #3=#:g0003))\n                          ...\\i{slightly-transformed-options1}...)\n                       (name2 #'(lambda (&rest temp)\n                                (setq #2# temp)\n                                (go #4=#:g0004))\n                          ...\\i{slightly-transformed-options2}...))\n        (return-from #1# \\i{expression}))\n          #3# (return-from #1#\n                  (apply #'(lambda \\i{arglist1} . \\i{body1}) #2#))\n          #4# (return-from #1#\n                  (apply #'(lambda \\i{arglist2} . \\i{body2}) #2#)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (restart-case (signal fred)\n   (a ...)\n   (b ...))\n \\EQ\n (restart-case\n     (with-condition-restarts fred \n                              (list (find-restart 'a) \n                                    (find-restart 'b))\n       (signal fred))\n   (a ...)\n   (b ...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (restart-case \n     (loop for restart in (compute-restarts)\n               collect (restart-name restart))\n   (case1 () :report "Return 1." 1)\n   (nil   () :report "Return 2." 2)\n   (case3 () :report "Return 3." 3)\n   (case1 () :report "Return 4." 4))\n\u2192 (CASE1 NIL CASE3 CASE1 ABORT)\n ;; In the example above the restart named ABORT was not created\n ;; explicitly, but was implicitly supplied by the system.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun read-eval-print-loop (level)\n   (with-simple-restart (abort "Exit command level ~D." level)\n     (loop\n       (with-simple-restart (abort "Return to command level ~D." level)\n         (let ((form (prog2 (fresh-line) (read) (fresh-line))))\n           (prin1 (eval form)))))))\n\u2192 READ-EVAL-PRINT-LOOP\n (read-eval-print-loop 1)\n (+ \'a 3)\n\\OUT Error: The argument, A, to the function + was of the wrong type.\n\\OUT        The function expected a number.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use this time.\n\\OUT  2: Return to command level 1.\n\\OUT  3: Exit command level 1.\n\\OUT  4: Return to Lisp Toplevel.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun compute-fixnum-power-of-2 (x)\n   (with-simple-restart (nil "Give up on computing 2{\\hat}~D." x)\n     (let ((result 1))\n       (dotimes (i x result)\n         (setq result (* 2 result))\n         (unless (fixnump result)\n           (error "Power of 2 is too large."))))))\nCOMPUTE-FIXNUM-POWER-OF-2\n (defun compute-power-of-2 (x)\n   (or (compute-fixnum-power-of-2 x) \'something big))\nCOMPUTE-POWER-OF-2\n (compute-power-of-2 10)\n1024\n (compute-power-of-2 10000)\n\\OUT Error: Power of 2 is too large.\n\\OUT To continue, type :CONTINUE followed by an option number.\n\\OUT  1: Give up on computing 2{\\hat}10000.\n\\OUT  2: Return to Lisp Toplevel\n\\OUT Debug> \\IN{:continue 1}\n\u2192 SOMETHING-BIG\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro with-simple-restart ((restart-name format-control\n                                              &rest format-arguments)\n                                &body forms)\n   `(restart-case (progn ,@forms)\n      (,restart-name ()\n          :report (lambda (stream)\n                    (format stream ,format-control ,@format-arguments))\n         (values nil t))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((x 3))\n   (handler-bind ((error #\'(lambda (c)\n                             (let ((r (find-restart \'continue c)))\n                               (when r (invoke-restart r))))))\n     (cond ((not (floatp x))\n            (cerror "Try floating it." "~D is not a float." x)\n            (float x))\n           (t x)))) \u2192 3.0\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defvar *all-quiet* nil) \u2192 *ALL-QUIET*\n (defvar *saved-warnings* \'()) \u2192 *SAVED-WARNINGS*\n (defun quiet-warning-handler (c)\n   (when *all-quiet*\n     (let ((r (find-restart \'muffle-warning c)))\n       (when r \n         (push c *saved-warnings*)\n         (invoke-restart r)))))\n\u2192 CUSTOM-WARNING-HANDLER\n (defmacro with-quiet-warnings (&body forms)\n   `(let ((*all-quiet* t)\n          (*saved-warnings* \'()))\n      (handler-bind ((warning #\'quiet-warning-handler))\n        ,@forms\n        *saved-warnings*)))\n\u2192 WITH-QUIET-WARNINGS\n (setq saved\n   (with-quiet-warnings\n     (warn "Situation #1.")\n     (let ((*all-quiet* nil))\n       (warn "Situation #2."))\n     (warn "Situation #3.")))\n\\OUT Warning: Situation #2.\n\u2192 (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)\n (dolist (s saved) (format t "~&~A~%" s))\n\\OUT Situation #3.\n\\OUT Situation #1.\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun type-error-auto-coerce (c)\n   (when (typep c 'type-error)\n     (let ((r (find-restart 'store-value c)))\n       (handler-case (let ((v (coerce (type-error-datum c)\n                                      (type-error-expected-type c))))\n                       (invoke-restart r v))\n         (error ()))))) \u2192 TYPE-ERROR-AUTO-COERCE\n (let ((x 3))\n   (handler-bind ((type-error #'type-error-auto-coerce))\n     (check-type x float)\n     x)) \u2192 3.0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; Example of the ABORT retart\n\n (defmacro abort-on-error (&body forms)\n   `(handler-bind ((error #'abort))\n      ,@forms)) \u2192 ABORT-ON-ERROR\n (abort-on-error (+ 3 5)) \u2192 8\n (abort-on-error (error \"You lose.\"))\n\\OUT Returned to Lisp Top Level.\n\n;;; Example of the CONTINUE restart\n\n (defun real-sqrt (n)\n   (when (minusp n)\n     (setq n (- n))\n     (cerror \"Return sqrt(~D) instead.\" \"Tried to take sqrt(-~D).\" n))\n   (sqrt n))\n\n (real-sqrt 4) \u2192 2\n (real-sqrt -9)\n\\OUT Error: Tried to take sqrt(-9).\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Return sqrt(9) instead.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{(continue)}\n\\OUT Return sqrt(9) instead.\n\u2192 3\n \n (handler-bind ((error #'(lambda (c) (continue))))\n   (real-sqrt -9)) \u2192 3\n\n;;; Example of the MUFFLE-WARNING restart\n\n (defun count-down (x)\n   (do ((counter x (1- counter)))\n       ((= counter 0) 'done)\n     (when (= counter 1)\n       (warn \"Almost done\"))\n     (format t \"~&~D~%\" counter)))\n\u2192 COUNT-DOWN\n (count-down 3)\n\\OUT 3\n\\OUT 2\n\\OUT Warning: Almost done\n\\OUT 1\n\u2192 DONE\n (defun ignore-warnings-while-counting (x)\n   (handler-bind ((warning #'ignore-warning))\n     (count-down x)))\n\u2192 IGNORE-WARNINGS-WHILE-COUNTING\n (defun ignore-warning (condition)\n   (declare (ignore condition))\n   (muffle-warning))\n\u2192 IGNORE-WARNING\n (ignore-warnings-while-counting 3)\n\\OUT 3\n\\OUT 2\n\\OUT 1\n\u2192 DONE\n\n;;; Example of the STORE-VALUE and USE-VALUE restarts\n\n (defun careful-symbol-value (symbol)\n   (check-type symbol symbol)\n   (restart-case (if (boundp symbol)\n                     (return-from careful-symbol-value \n                                  (symbol-value symbol))\n                     (error 'unbound-variable\n                            :name symbol))\n     (use-value (value)\n       :report \"Specify a value to use this time.\"\n       value)\n     (store-value (value)\n       :report \"Specify a value to store and use in the future.\"\n       (setf (symbol-value symbol) value))))\n (setq a 1234) \u2192 1234\n (careful-symbol-value 'a) \u2192 1234\n (makunbound 'a) \u2192 A\n (careful-symbol-value 'a)\n\\OUT Error: A is not bound.\n\\OUT To continue, type :CONTINUE followed by an option number.\n\\OUT  1: Specify a value to use this time.\n\\OUT  2: Specify a value to store and use in the future.\n\\OUT  3: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{(use-value 12)}\n\u2192 12\n (careful-symbol-value 'a)\n\\OUT Error: A is not bound.\n\\OUT To continue, type :CONTINUE followed by an option number.\n\\OUT   1: Specify a value to use this time.\n\\OUT   2: Specify a value to store and use in the future.\n\\OUT   3: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{(store-value 24)}\n\u2192 24\n (careful-symbol-value 'a)\n\u2192 24\n\n;;; Example of the USE-VALUE restart\n\n (defun add-symbols-with-default (default &rest symbols)\n   (handler-bind ((sys:unbound-symbol\n                    #'(lambda (c)\n                        (declare (ignore c)) \n                        (use-value default))))\n     (apply #'+ (mapcar #'careful-symbol-value symbols))))\n\u2192 ADD-SYMBOLS-WITH-DEFAULT\n (setq x 1 y 2) \u2192 2\n (add-symbols-with-default 3 'x 'y 'z) \u2192 6\n\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (abort condition) \\EQ (invoke-restart 'abort)\n (muffle-warning)  \\EQ (invoke-restart 'muffle-warning)\n (continue)        \\EQ (let ((r (find-restart 'continue))) (if r (invoke-restart r)))\n (use-value \\param{x}) \\EQ (let ((r (find-restart 'use-value))) (if r (invoke-restart r \\param{x})))\n (store-value x) \\EQ (let ((r (find-restart 'store-value))) (if r (invoke-restart r \\param{x})))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cons 1 2) \u2192 (1 . 2)\n (cons 1 nil) \u2192 (1)\n (cons nil 2) \u2192 (NIL . 2)\n (cons nil nil) \u2192 (NIL)\n (cons 1 (cons 2 (cons 3 (cons 4 nil)))) \u2192 (1 2 3 4)\n (cons 'a 'b) \u2192 (A . B)\n (cons 'a (cons 'b (cons 'c '\\empty))) \u2192 (A B C)\n (cons 'a '(b c d)) \u2192 (A B C D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (consp nil) \u2192 NIL\n (consp (cons 1 2)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (consp '()) \\EQ (consp 'nil) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (consp \\param{object}) \\EQ (typep \\param{object} 'cons) \\EQ (not (typep \\param{object} 'atom)) \\EQ (typep \\param{object} '(not atom))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (atom 'sss) \u2192 T\n (atom (cons 1 2)) \u2192 NIL\n (atom nil) \u2192 T\n (atom '()) \u2192 T\n (atom 3) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (atom \\param{object}) \\EQ (typep \\param{object} 'atom) \\EQ (not (consp \\param{object}))\n \\EQ (not (typep \\param{object} 'cons)) \\EQ (typep \\param{object} '(not cons))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defparameter *some-list* (list* 'one 'two 'three 'four)) \u2192 *some-list*\n *some-list* \u2192 (ONE TWO THREE . FOUR)\n (rplaca *some-list* 'uno) \u2192 (UNO TWO THREE . FOUR)\n *some-list* \u2192 (UNO TWO THREE . FOUR)\n (rplacd (last *some-list*) (list 'IV)) \u2192 (THREE IV)\n *some-list* \u2192 (UNO TWO THREE IV)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (car nil) \u2192 NIL  \n (cdr '(1 . 2)) \u2192 2\n (cdr '(1 2)) \u2192 (2)\n (cadr '(1 2)) \u2192 2 \n (car '(a b c)) \u2192 A\n (cdr '(a b c)) \u2192 (B C)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(car \\i{x})    \\EQ (first \\i{x})\n(cadr \\i{x})   \\EQ (second \\i{x}) \\EQ (car (cdr \\i{x}))\n(caddr \\i{x})  \\EQ (third \\i{x})  \\EQ (car (cdr (cdr \\i{x})))\n(cadddr \\i{x}) \\EQ (fourth \\i{x}) \\EQ (car (cdr (cdr (cdr \\i{x}))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq object (list (cons 1 "one")\n                    (cons 2 (list \'a \'b \'c))))\n\u2192 ((1 . "one") (2 A B C))\n (setq object-too object) \u2192 ((1 . "one") (2 A B C))\n (setq copy-as-list (copy-list object))\n (setq copy-as-alist (copy-alist object))\n (setq copy-as-tree (copy-tree object))\n (eq object object-too) \u2192 T\n (eq copy-as-tree object) \u2192 NIL\n (eql copy-as-tree object) \u2192 NIL\n (equal copy-as-tree object) \u2192 T\n (setf (first (cdr (second object))) "a"\n       (car (second object)) "two"\n       (car object) \'(one . 1)) \u2192 (ONE . 1)\n object \u2192 ((ONE . 1) ("two" "a" B C))\n object-too \u2192 ((ONE . 1) ("two" "a" B C))\n copy-as-list \u2192 ((1 . "one") ("two" "a" B C))\n copy-as-alist \u2192 ((1 . "one") (2 "a" B C))\n copy-as-tree \u2192 ((1 . "one") (2 A B C)) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (sublis \'((x . 100) (z . zprime))\n         \'(plus x (minus g z x p) 4 . x))\n\u2192 (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)\n (sublis \'(((+ x y) . (- x y)) ((- x y) . (+ x y)))\n         \'(* (/ (+ x y) (+ x p)) (- x y))\n         :test #\'equal)\n\u2192 (* (/ (- X Y) (+ X P)) (+ X Y))\n (setq tree1 \'(1 (1 2) ((1 2 3)) (((1 2 3 4)))))\n\u2192 (1 (1 2) ((1 2 3)) (((1 2 3 4))))\n (sublis \'((3 . "three")) tree1) \n\u2192 (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))\n (sublis \'((t . "string"))\n          (sublis \'((1 . "") (4 . 44)) tree1)\n          :key #\'stringp)\n\u2192 ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))\n tree1 \u2192 (1 (1 2) ((1 2 3)) (((1 2 3 4))))\n (setq tree2 \'("one" ("one" "two") (("one" "Two" "three"))))\n\u2192 ("one" ("one" "two") (("one" "Two" "three"))) \n (sublis \'(("two" . 2)) tree2) \n\u2192 ("one" ("one" "two") (("one" "Two" "three"))) \n tree2 \u2192 ("one" ("one" "two") (("one" "Two" "three"))) \n (sublis \'(("two" . 2)) tree2 :test \'equal) \n\u2192 ("one" ("one" 2) (("one" "Two" "three"))) \n\n (nsublis \'((t . \'temp))\n           tree1\n           :key #\'(lambda (x) (or (atom x) (< (list-length x) 3))))\n\u2192 ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test-it (fn)\n   (let* ((shared-piece (list 'a 'b))\n          (data (list shared-piece shared-piece)))\n     (funcall fn '((a . b) (b . a)) data)))\n (test-it #'sublis) \u2192 ((B A) (B A))\n (test-it #'nsublis) \u2192 ((A B) (A B))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) \u2192 (1 (1 2) (1 2 3) (1 2 3 4))\n (subst \"two\" 2 tree1) \u2192 (1 (1 \"two\") (1 \"two\" 3) (1 \"two\" 3 4))\n (subst \"five\" 5 tree1) \u2192 (1 (1 2) (1 2 3) (1 2 3 4))\n (eq tree1 (subst \"five\" 5 tree1)) \u2192 implementation-dependent\n (subst 'tempest 'hurricane\n        '(shakespeare wrote (the hurricane)))\n\u2192 (SHAKESPEARE WROTE (THE TEMPEST))\n (subst 'foo 'nil '(shakespeare wrote (twelfth night)))\n\u2192 (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)\n (subst '(a . cons) '(old . pair)\n        '((old . spice) ((old . shoes) old . pair) (old . pair))\n        :test #'equal)\n\u2192 ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))\n\n (subst-if 5 #'listp tree1) \u2192 5\n (subst-if-not '(x) #'consp tree1) \n\u2192 (1 X)\n\n tree1 \u2192 (1 (1 2) (1 2 3) (1 2 3 4))\n (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) \n\u2192 (1 (1 2) X X)\n tree1 \u2192 (1 (1 2) X X)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun subst (old new tree &rest x &key test test-not key)\n   (cond ((satisfies-the-test old tree :test test\n                              :test-not test-not :key key)\n          new)\n         ((atom tree) tree)\n         (t (let ((a (apply #'subst old new (car tree) x))\n                  (d (apply #'subst old new (cdr tree) x)))\n              (if (and (eql a (car tree))\n                       (eql d (cdr tree)))\n                  tree\n                  (cons a d))))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq tree1 '(1 (1 2))\n       tree2 '(1 (1 2))) \u2192 (1 (1 2))\n (tree-equal tree1 tree2) \u2192 T\n (eql tree1 tree2) \u2192 NIL\n (setq tree1 '('a ('b 'c))\n       tree2 '('a ('b 'c))) \u2192 ('a ('b 'c)) \n\u2192 ((QUOTE A) ((QUOTE B) (QUOTE C)))\n (tree-equal tree1 tree2 :test 'eq) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq lst (list 1 (list 2 3))) \u2192 (1 (2 3))\n (setq slst lst) \u2192 (1 (2 3))\n (setq clst (copy-list lst)) \u2192 (1 (2 3))\n (eq slst lst) \u2192 T\n (eq clst lst) \u2192 NIL\n (equal clst lst) \u2192 T\n (rplaca lst "one") \u2192 ("one" (2 3))\n slst \u2192 ("one" (2 3))\n clst \u2192 (1 (2 3))\n (setf (caadr lst) "two") \u2192 "two"\n lst \u2192 ("one" ("two" 3))\n slst \u2192 ("one" ("two" 3))\n clst \u2192 (1 ("two" 3))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (list 1) \u2192 (1)\n (list* 1) \u2192 1\n (setq a 1) \u2192 1\n (list a 2) \u2192 (1 2)\n '(a 2) \u2192 (A 2)\n (list 'a 2) \u2192 (A 2)\n (list* a 2) \u2192 (1 . 2)\n (list) \u2192 NIL ;\\ie ()\n (setq a '(1 2)) \u2192 (1 2)\n (eq a (list* a)) \u2192 T\n (list 3 4 'a (car '(b . c)) (+ 6 -2)) \u2192 (3 4 A B 4)\n (list* 'a 'b 'c 'd) \\EQ (cons 'a (cons 'b (cons 'c 'd))) \u2192 (A B C . D)\n (list* 'a 'b 'c '(d e f)) \u2192 (A B C D E F)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (list* \\param{x}) \\EQ \\param{x}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (list-length '(a b c d)) \u2192 4\n (list-length '(a (b c) d)) \u2192 3\n (list-length '()) \u2192 0\n (list-length nil) \u2192 0\n (defun circular-list (&rest elements)\n   (let ((cycle (copy-list elements))) \n     (nconc cycle cycle)))\n (list-length (circular-list 'a 'b)) \u2192 NIL\n (list-length (circular-list 'a)) \u2192 NIL\n (list-length (circular-list)) \u2192 0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun list-length (x)  \n   (do ((n 0 (+ n 2))           ;Counter.\n        (fast x (cddr fast))    ;Fast pointer: leaps by 2.\n        (slow x (cdr slow)))    ;Slow pointer: leaps by 1.\n       (nil)\n     ;; If fast pointer hits the end, return the count.\n     (when (endp fast) (return n))\n     (when (endp (cdr fast)) (return (+ n 1)))\n     ;; If fast pointer eventually equals slow pointer,\n     ;;  then we must be stuck in a circular list.\n     ;; (A deeper property is the converse: if we are\n     ;;  stuck in a circular list, then eventually the\n     ;;  fast pointer will equal the slow pointer.\n     ;;  That fact justifies this implementation.)\n     (when (and (eq fast slow) (> n 0)) (return nil))))\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (listp nil) \u2192 T\n (listp (cons 1 2)) \u2192 T\n (listp (make-array 6)) \u2192 NIL\n (listp t) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (listp \\param{object}) \\EQ (typep \\param{object} 'list) \\EQ (typep \\param{object} '(or cons null))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-list 5) \u2192 (NIL NIL NIL NIL NIL)\n (make-list 3 :initial-element 'rah) \u2192 (RAH RAH RAH)\n (make-list 2 :initial-element '(1 2 3)) \u2192 ((1 2 3) (1 2 3))\n (make-list 0) \u2192 NIL ;\\ie ()\n (make-list 0 :initial-element 'new-element) \u2192 NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq llst '(nil)) \u2192 (NIL)\n (push 1 (car llst)) \u2192 (1)\n llst \u2192 ((1))\n (push 1 (car llst)) \u2192 (1 1)\n llst \u2192 ((1 1))\n (setq x '(a (b c) d)) \u2192 (A (B C) D)\n (push 5 (cadr x)) \u2192 (5 B C)  \n x \u2192 (A (5 B C) D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf place (cons \\i{item} \\i{place}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq stack '(a b c)) \u2192 (A B C)\n (pop stack) \u2192 A  \n stack \u2192 (B C)\n (setq llst '((1 2 3 4))) \u2192 ((1 2 3 4))\n (pop (car llst)) \u2192 1\n llst \u2192 ((2 3 4))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (prog1 (car \\param{place}) (setf \\param{place} (cdr \\param{place})))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (first \\param{list})    \\EQ  (car \\param{list})\n (second \\param{list})   \\EQ  (car (cdr \\param{list}))\n (third \\param{list})    \\EQ  (car (cddr \\param{list}))\n (fourth \\param{list})   \\EQ  (car (cdddr \\param{list}))\n (fifth \\param{list})    \\EQ  (car (cddddr \\param{list}))\n (sixth \\param{list})    \\EQ  (car (cdr (cddddr \\param{list})))\n (seventh \\param{list})  \\EQ  (car (cddr (cddddr \\param{list})))\n (eighth \\param{list})   \\EQ  (car (cdddr (cddddr \\param{list})))\n (ninth \\param{list})    \\EQ  (car (cddddr (cddddr \\param{list})))\n (tenth \\param{list})    \\EQ  (car (cdr (cddddr (cddddr \\param{list}))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (fifth \\param{list}) \\param{new-object}) \\EQ (setf (car (cddddr \\param{list})) \\param{new-object})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq lst \'(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) \n\u2192 (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)\n (first lst) \u2192 1\n (tenth lst) \u2192 10\n (fifth lst) \u2192 ((V))\n (second (fourth lst)) \u2192 5\n (sixth \'(1 2 3)) \u2192 NIL\n (setf (fourth lst) "four") \u2192 "four"\n lst \u2192 (1 2 3 "four" ((V)) VI 7 8 9 10)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (fifth x) \\EQ (nth 4 x)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nth \\param{n} \\param{list}) \\EQ (car (nthcdr \\param{n} \\param{list}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (nth \\param{n} \\param{list}) \\param{new-object}) \\EQ (setf (car (nthcdr \\param{n} \\param{list})) \\param{new-object})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (nth 0 \'(foo bar baz)) \u2192 FOO\n (nth 1 \'(foo bar baz)) \u2192 BAR\n (nth 3 \'(foo bar baz)) \u2192 NIL\n (setq 0-to-3 (list 0 1 2 3)) \u2192 (0 1 2 3)\n (setf (nth 2 0-to-3) "two") \u2192 "two"\n 0-to-3 \u2192 (0 1 "two" 3)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (endp nil) \u2192 T\n (endp '(1 2)) \u2192 NIL\n (endp (cddr '(1 2))) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (null '()) \u2192 T\n (null nil) \u2192 T\n (null t) \u2192 NIL\n (null 1) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (null \\param{object}) \\EQ (typep \\param{object} 'null) \\EQ (eq \\param{object} '\\empty)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nconc) \u2192 ()\n (nconc nil . \\param{lists}) \\EQ (nconc . \\param{lists})\n (nconc \\param{list}) \u2192 \\param{list}\n (nconc \\param{list-1} \\param{list-2}) \\EQ (progn (rplacd (last \\param{list-1}) \\param{list-2}) \\param{list-1})\n (nconc \\param{list-1} \\param{list-2} . \\param{lists}) \\EQ (nconc (nconc \\param{list-1} \\param{list-2}) . \\param{lists})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nconc) \u2192 NIL\n (setq x '(a b c)) \u2192 (A B C)\n (setq y '(d e f)) \u2192 (D E F)\n (nconc x y) \u2192 (A B C D E F)\n x \u2192 (A B C D E F)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq foo (list 'a 'b 'c 'd 'e)\n       bar (list 'f 'g 'h 'i 'j)\n       baz (list 'k 'l 'm)) \u2192 (K L M)\n (setq foo (nconc foo bar baz)) \u2192 (A B C D E F G H I J K L M)\n foo \u2192 (A B C D E F G H I J K L M)\n bar \u2192 (F G H I J K L M)\n baz \u2192 (K L M)\n\n (setq foo (list 'a 'b 'c 'd 'e)\n       bar (list 'f 'g 'h 'i 'j)\n       baz (list 'k 'l 'm)) \u2192 (K L M)\n (setq foo (nconc nil foo bar nil baz)) \u2192 (A B C D E F G H I J K L M) \n foo \u2192 (A B C D E F G H I J K L M)\n bar \u2192 (F G H I J K L M)\n baz \u2192 (K L M)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append '(a b c) '(d e f) '() '(g)) \u2192 (A B C D E F G)\n (append '(a b c) 'd) \u2192 (A B C . D)\n (setq lst '(a b c)) \u2192 (A B C)\n (append lst '(d)) \u2192 (A B C D)\n lst \u2192 (A B C)\n (append) \u2192 NIL\n (append 'a) \u2192 A\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((list-1 (list 1 2 3))\n       (list-2 (list 'a 'b 'c)))\n   (print (revappend list-1 list-2))\n   (print (equal list-1 '(1 2 3)))\n   (print (equal list-2 '(a b c))))\n\\OUT (3 2 1 A B C) \n\\OUT T\n\\OUT T\n\u2192 T\n\n (revappend '(1 2 3) '()) \u2192 (3 2 1)\n (revappend '(1 2 3) '(a . b)) \u2192 (3 2 1 A . B)\n (revappend '() '(a b c)) \u2192 (A B C)\n (revappend '(1 2 3) 'a) \u2192 (3 2 1 . A)\n (revappend '() 'a) \u2192 A   ;degenerate case\n\n (let ((list-1 '(1 2 3))\n       (list-2 '(a b c)))\n   (print (nreconc list-1 list-2))\n   (print (equal list-1 '(1 2 3)))\n   (print (equal list-2 '(a b c))))\n\\OUT (3 2 1 A B C) \n\\OUT NIL\n\\OUT T\n\u2192 T\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nconc (nreverse \\param{list}) \\param{tail})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (revappend \\param{list} \\param{tail}) \\EQ (nconc (reverse \\param{list}) \\param{tail})\n (nreconc \\param{list} \\param{tail}) \\EQ (nconc (nreverse \\param{list}) \\param{tail})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defparameter *list-1* (list 1 2 3))\n%  (defparameter *list-2* (list 'a 'b 'c))\n%  (nreconc *list-1* *list-2*) \u2192 (3 2 1 A B C)\n%  *list-1* \u2192 implementation-dependent\n%  *list-2* \u2192 (A B C)\n% \n%  (nreconc (list) 'a) \u2192 A  ;degenerate situation\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% %  (nreconc (cons 1 2) nil) \u2192 (1)\n% % \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setq lst1 '(1 2 3)\n%         lst2 '(a b c))  \u2192 (A B C)\n%  (revappend lst1 lst2) \u2192 (3 2 1 A B C)\n%  lst1 \u2192 (1 2 3)\n%  lst2 \u2192 (A B C)\n%  (revappend '(1 2 3) '(a . b)) \u2192 (3 2 1 A . B)\n%  (revappend nil '(a b c)) \u2192 (A B C)\n%  (revappend '() 'a) \u2192 A ;degenerate case\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% %  (revappend '(1 . 2) '(a b c)) \u2192 (1 A B C)\n% % \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (revappend x y) \\EQ (nconc (reverse x) y)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq lst '(1 2 3 4 5 6 7 8 9)) \u2192 (1 2 3 4 5 6 7 8 9)\n (butlast lst) \u2192 (1 2 3 4 5 6 7 8)\n (butlast lst 5) \u2192 (1 2 3 4)\n (butlast lst (+ 5 5)) \u2192 NIL\n lst \u2192 (1 2 3 4 5 6 7 8 9)\n (nbutlast lst 3) \u2192 (1 2 3 4 5 6)\n lst \u2192 (1 2 3 4 5 6)\n (nbutlast lst 99) \u2192 NIL\n lst \u2192 (1 2 3 4 5 6)\n (butlast '(a b c d)) \u2192 (A B C)\n (butlast '((a b) (c d))) \u2192 ((A B))\n (butlast '(a)) \u2192 NIL\n (butlast nil) \u2192 NIL\n (setq foo (list 'a 'b 'c 'd)) \u2192 (A B C D)\n (nbutlast foo) \u2192 (A B C)\n foo \u2192 (A B C)\n (nbutlast (list 'a)) \u2192 NIL\n (nbutlast '()) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (butlast \\param{list} \\param{n}) \\EQ (ldiff \\param{list} (last \\param{list} \\param{n}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (last nil) \u2192 NIL\n (last '(1 2 3)) \u2192 (3)\n (last '(1 2 . 3)) \u2192 (2 . 3)\n (setq x (list 'a 'b 'c 'd)) \u2192 (A B C D)\n (last x) \u2192 (D)\n (rplacd (last x) (list 'e 'f)) x \u2192 (A B C D E F)\n (last x) \u2192 (F)\n\n (last '(a b c))   \u2192 (C)\n\n (last '(a b c) 0) \u2192 ()\n (last '(a b c) 1) \u2192 (C)\n (last '(a b c) 2) \u2192 (B C)\n (last '(a b c) 3) \u2192 (A B C)\n (last '(a b c) 4) \u2192 (A B C)\n\n (last '(a . b) 0) \u2192 B\n (last '(a . b) 1) \u2192 (A . B)\n (last '(a . b) 2) \u2192 (A . B)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun last (list &optional (n 1))\n   (check-type n (integer 0))\n   (do ((l list (cdr l))\n        (r list)\n        (i 0 (+ i 1)))\n       ((atom l) r)\n     (if (>= i n) (pop r))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((lists '#((a b c) (a b c . d))))\n   (dotimes (i (length lists)) ()\n     (let ((list (aref lists i)))\n       (format t \"~2&list=~S ~21T(tailp object list)~\n                  ~44T(ldiff list object)~%\" list)\n         (let ((objects (vector list (cddr list) (copy-list (cddr list))\n                                '(f g h) '() 'd 'x)))\n           (dotimes (j (length objects)) ()\n             (let ((object (aref objects j)))\n               (format t \"~& object=~S ~21T~S ~44T~S\"\n                       object (tailp object list) (ldiff list object))))))))\n\\OUT \n\\OUT list=(A B C)         (tailp object list)    (ldiff list object)\n\\OUT  object=(A B C)      T                      NIL\n\\OUT  object=(C)          T                      (A B)\n\\OUT  object=(C)          NIL                    (A B C)\n\\OUT  object=(F G H)      NIL                    (A B C)\n\\OUT  object=NIL          T                      (A B C)\n\\OUT  object=D            NIL                    (A B C)\n\\OUT  object=X            NIL                    (A B C)\n\\OUT \n\\OUT list=(A B C . D)     (tailp object list)    (ldiff list object)\n\\OUT  object=(A B C . D)  T                      NIL\n\\OUT  object=(C . D)      T                      (A B)\n\\OUT  object=(C . D)      NIL                    (A B C . D)\n\\OUT  object=(F G H)      NIL                    (A B C . D)\n\\OUT  object=NIL          NIL                    (A B C . D)\n\\OUT  object=D            T                      (A B C)\n\\OUT  object=X            NIL                    (A B C . D)\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun tailp (object list)\n   (do ((list list (cdr list)))\n       ((atom list) (eql list object))\n      (if (eql object list)\n          (return t))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun ldiff (list object)\n  (do ((list list (cdr list))\n       (r '() (cons (car list) r)))\n      ((atom list)\n       (if (eql list object) (nreverse r) (nreconc r list)))\n    (when (eql object list)\n      (return (nreverse r)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setq x '(a b c d e)) \u2192 (A B C D E)\n%  (setq y (cdddr x)) \u2192 (D E)\n%  (ldiff x y) \u2192 (A B C)\n%  (ldiff x (copy-list y)) \u2192 (A B C D E)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (let ((x '(b c))) (tailp x (cons 'a x))) \u2192 T\n%  (tailp '(x y) '(a b c)) \u2192 NIL\n%  (tailp '() '(a b c)) \u2192 T\n%  (tailp 3 '(a b c)) \u2192 NIL\n%  (tailp 3 '(a b c . 3)) \u2192 T\n%  (tailp '(x y) '(a b c . 3)) \u2192 NIL\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defun tailp (sublist list)\n%    (do ((list list (cdr list)))\n%        ((atom list) (eql list sublist))\n%       (if (eql sublist list)\n%           (return t))))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nthcdr 0 '()) \u2192 NIL\n (nthcdr 3 '()) \u2192 NIL\n (nthcdr 0 '(a b c)) \u2192 (A B C)\n (nthcdr 2 '(a b c)) \u2192 (C)\n (nthcdr 4 '(a b c)) \u2192 ()\n (nthcdr 1 '(0 . 1)) \u2192 1\n\n (locally (declare (optimize (safety 3)))\n   (nthcdr 3 '(0 . 1)))\n Error: Attempted to take CDR of 1.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rest \\param{list}) \\EQ (cdr \\param{list})\n (setf (rest \\param{list}) \\param{new-tail}) \\EQ (setf (cdr \\param{list}) \\param{new-tail})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (rest \'(1 2)) \u2192 (2)\n (rest \'(1 . 2)) \u2192 2\n (rest \'(1)) \u2192 NIL\n (setq *cons* \'(1 . 2)) \u2192 (1 . 2)\n (setf (rest *cons*) "two") \u2192 "two"\n *cons* \u2192 (1 . "two")\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (member 2 '(1 2 3)) \u2192 (2 3)                                 \n (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) \u2192 ((3 . 4))\n (member 'e '(a b c d)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (member-if #'listp '(a b nil c d)) \u2192 (NIL C D)\n (member-if #'numberp '(a #\\Space 5/3 foo)) \u2192 (5/3 FOO)\n (member-if-not #'zerop \n                 '(3 6 9 11 . 12)\n                 :key #'(lambda (x) (mod x 3))) \u2192 (11 . 12)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (member 'a '(g (a y) c a d e a f)) \u2192 (A D E A F)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mapcon f x1 ... xn)\n   \\EQ (apply #'nconc (maplist f x1 ... xn))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mapcar #'car '((1 a) (2 b) (3 c))) \u2192 (1 2 3) \n (mapcar #'abs '(3 -4 2 -5 -6)) \u2192 (3 4 2 5 6)\n (mapcar #'cons '(a b c) '(1 2 3)) \u2192 ((A . 1) (B . 2) (C . 3))\n\n (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) \n\u2192 ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) \n (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))\n\u2192 ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))\n (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))\n\u2192 (0 0 1 0 1 1 1)\n;An entry is 1 if the corresponding element of the input\n;  list was the last instance of that element in the input list.\n\n (setq dummy nil) \u2192 NIL \n (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))\n        '(1 2 3 4)\n        '(a b c d e)\n        '(x y z)) \u2192 (1 2 3 4) \n dummy \u2192 (1 A X 2 B Y 3 C Z)                   \n\n (setq dummy nil) \u2192 NIL \n (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) \u2192 (1 2 3 4) \n dummy \u2192 ((4) (3 4) (2 3 4) (1 2 3 4)) \n\n (mapcan #'(lambda (x y) (if (null x) nil (list x y)))\n          '(nil nil nil d e)\n          '(1 2 3 4 5 6)) \u2192 (D 4 E 5) \n (mapcan #'(lambda (x) (and (numberp x) (list x)))\n          '(a 1 b c 3 4 d 5))\n\u2192 (1 3 4 5)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mapcon #'list '(1 2 3 4)) \u2192 ((1 2 3 4) (2 3 4) (3 4) (4)) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq alist \'()) \u2192 NIL\n (acons 1 "one" alist) \u2192 ((1 . "one"))\n alist \u2192 NIL\n (setq alist (acons 1 "one" (acons 2 "two" alist))) \u2192 ((1 . "one") (2 . "two"))\n (assoc 1 alist) \u2192 (1 . "one")\n (setq alist (acons 1 "uno" alist)) \u2192 ((1 . "uno") (1 . "one") (2 . "two"))\n (assoc 1 alist) \u2192 (1 . "uno")\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(acons \\param{key} \\param{datum} \\param{alist}) \\EQ (cons (cons \\param{key} \\param{datum}) \\param{alist})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq values \'((x . 100) (y . 200) (z . 50))) \u2192 ((X . 100) (Y . 200) (Z . 50))\n (assoc \'y values) \u2192 (Y . 200)\n (rplacd (assoc \'y values) 201) \u2192 (Y . 201)\n (assoc \'y values) \u2192 (Y . 201)\n (setq alist \'((1 . "one")(2 . "two")(3 . "three"))) \n\u2192 ((1 . "one") (2 . "two") (3 . "three"))\n (assoc 2 alist) \u2192 (2 . "two")\n (assoc-if #\'evenp alist) \u2192 (2 . "two")\n (assoc-if-not #\'(lambda(x) (< x 3)) alist) \u2192 (3 . "three")\n (setq alist \'(("one" . 1)("two" . 2))) \u2192 (("one" . 1) ("two" . 2))\n (assoc "one" alist) \u2192 NIL\n (assoc "one" alist :test #\'equalp) \u2192 ("one" . 1)\n (assoc "two" alist :key #\'(lambda(x) (char x 2))) \u2192 NIL \n (assoc #\\o alist :key #\'(lambda(x) (char x 2))) \u2192 ("two" . 2)\n (assoc \'r \'((a . b) (c . d) (r . x) (s . y) (r . z))) \u2192  (R . X)\n (assoc \'goo \'((foo . bar) (zoo . goo))) \u2192 NIL\n (assoc \'2 \'((1 a b c) (2 b c d) (-7 x y z))) \u2192 (2 B C D)\n (setq alist \'(("one" . 1) ("2" . 2) ("three" . 3)))\n\u2192 (("one" . 1) ("2" . 2) ("three" . 3))\n (assoc-if-not #\'alpha-char-p alist\n               :key #\'(lambda (x) (char x 0))) \u2192 ("2" . 2)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (assoc item list :test fn)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find item list :test fn :key #'car)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(defparameter *alist* (acons 1 "one" (acons 2 "two" \'())))\n*alist* \u2192 ((1 . "one") (2 . "two"))\n(defparameter *list-copy* (copy-list *alist*))\n*list-copy* \u2192 ((1 . "one") (2 . "two"))\n(defparameter *alist-copy* (copy-alist *alist*))\n*alist-copy* \u2192 ((1 . "one") (2 . "two"))\n(setf (cdr (assoc 2 *alist-copy*)) "deux") \u2192 "deux"\n*alist-copy* \u2192 ((1 . "one") (2 . "deux"))\n*alist* \u2192 ((1 . "one") (2 . "two"))\n(setf (cdr (assoc 1 *list-copy*)) "uno") \u2192 "uno"\n*list-copy* \u2192 ((1 . "uno") (2 . "two"))\n*alist* \u2192 ((1 . "uno") (2 . "two"))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((one . 1) (two . 2) (three . 3) (four . 19))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((two . 2) (one . 1) (three . 3) (four . 19))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq keys \'(1 2 3)\n        data \'("one" "two" "three")\n        alist \'((4 . "four"))) \u2192 ((4 . "four"))\n (pairlis keys data) \u2192 ((3 . "three") (2 . "two") (1 . "one"))\n (pairlis keys data alist)\n\u2192 ((3 . "three") (2 . "two") (1 . "one") (4 . "four"))\n alist \u2192 ((4 . "four"))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq alist \'((1 . "one") (2 . "two") (3 . 3))) \n\u2192 ((1 . "one") (2 . "two") (3 . 3))\n (rassoc 3 alist) \u2192 (3 . 3)\n (rassoc "two" alist) \u2192 NIL\n (rassoc "two" alist :test \'equal) \u2192 (2 . "two")\n (rassoc 1 alist :key #\'(lambda (x) (if (numberp x) (/ x 3)))) \u2192 (3 . 3)\n (rassoc \'a \'((a . b) (b . c) (c . a) (z . a))) \u2192 (C . A)\n (rassoc-if #\'stringp alist) \u2192 (1 . "one")\n (rassoc-if-not #\'vectorp alist) \u2192 (3 . 3)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rassoc item list :test fn)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find item list :test fn :key #'cdr)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x '()) \u2192 NIL\n (setq *indicator-list* '(prop1 prop2)) \u2192 (PROP1 PROP2)\n (getf x 'prop1) \u2192 NIL\n (setf (getf x 'prop1) 'val1) \u2192 VAL1\n (eq (getf x 'prop1) 'val1) \u2192 T\n (get-properties x *indicator-list*) \u2192 PROP1, VAL1, (PROP1 VAL1)\n x \u2192 (PROP1 VAL1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x '()) \u2192 NIL\n (getf x 'prop1) \u2192 NIL\n (getf x 'prop1 7) \u2192 7\n (getf x 'prop1) \u2192 NIL\n (setf (getf x 'prop1) 'val1) \u2192 VAL1\n (eq (getf x 'prop1) 'val1) \u2192 T\n (getf x 'prop1) \u2192 VAL1\n (getf x 'prop1 7) \u2192 VAL1\n x \u2192 (PROP1 VAL1)\n\n;; Examples of implementation variation permitted.\n (setq foo (list 'a 'b 'c 'd 'e 'f)) \u2192 (A B C D E F)\n (setq bar (cddr foo)) \u2192 (C D E F)\n (remf foo 'c) \u2192 T\n foo \u2192 (A B E F)\n bar\n\u2192 (C D E F)\nOR=> (C)\nOR=> (NIL)\nOR=> (C NIL)\nOR=> (C D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((plist '()))\n   (incf (getf plist 'count 0))\n   plist) \u2192 (COUNT 1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (cons () ())) \u2192 (NIL)\n (setf (getf (car x) 'prop1) 'val1) \u2192 VAL1\n (remf (car x) 'prop1) \u2192 T\n (remf (car x) 'prop1) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")\n       list2 (list 1 4 5 b c d "a" "B" "c" "D")) \n  \u2192 (1 4 5 B C D "a" "B" "c" "D")\n (intersection list1 list2) \u2192 (C B 4 1 1)\n (intersection list1 list2 :test \'equal) \u2192 ("B" C B 4 1 1)\n (intersection list1 list2 :test #\'equalp) \u2192 ("d" "C" "B" "A" C B 4 1 1) \n (nintersection list1 list2) \u2192 (1 1 4 B C)\n list1 \u2192 implementation-dependent ;\\eg (1 1 4 B C)\n list2 \u2192 implementation-dependent ;\\eg (1 4 5 B C D "a" "B" "c" "D")\n (setq list1 (copy-list \'((1 . 2) (2 . 3) (3 . 4) (4 . 5))))\n\u2192 ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) \n (setq list2 (copy-list \'((1 . 3) (2 . 4) (3 . 6) (4 . 8))))\n\u2192 ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) \n (nintersection list1 list2 :key #\'cdr) \u2192 ((2 . 3) (3 . 4)) \n list1 \u2192 implementation-dependent ;\\eg ((1 . 2) (2 . 3) (3 . 4)) \n list2 \u2192 implementation-dependent ;\\eg ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq slist '()) \u2192 NIL \n (adjoin 'a slist) \u2192 (A) \n slist \u2192 NIL \n (setq slist (adjoin '(test-item 1) slist)) \u2192 ((TEST-ITEM 1)) \n (adjoin '(test-item 1) slist) \u2192 ((TEST-ITEM 1) (TEST-ITEM 1)) \n (adjoin '(test-item 1) slist :test 'equal) \u2192 ((TEST-ITEM 1)) \n (adjoin '(new-test-item 1) slist :key #'cadr) \u2192 ((TEST-ITEM 1)) \n (adjoin '(new-test-item 1) slist) \u2192 ((NEW-TEST-ITEM 1) (TEST-ITEM 1)) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (adjoin item list :key fn)\n   \\EQ (if (member (fn item) list :key fn) list (cons item list))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x '(a (b c) d)) \u2192 (A (B C) D)\n (pushnew 5 (cadr x)) \u2192 (5 B C)   \n x \u2192 (A (5 B C) D)\n (pushnew 'b (cadr x)) \u2192 (5 B C)  \n x \u2192 (A (5 B C) D)\n (setq lst '((1) (1 2) (1 2 3))) \u2192 ((1) (1 2) (1 2 3))\n (pushnew '(2) lst) \u2192 ((2) (1) (1 2) (1 2 3))\n (pushnew '(1) lst) \u2192 ((1) (2) (1) (1 2) (1 2 3))\n (pushnew '(1) lst :test 'equal) \u2192 ((1) (2) (1) (1 2) (1 2 3))\n (pushnew '(1) lst :key #'car) \u2192 ((1) (2) (1) (1 2) (1 2 3)) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pushnew item place :test p)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf place (adjoin item place :test p))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq lst1 (list "A" "b" "C" "d")\n       lst2 (list "a" "B" "C" "d")) \u2192 ("a" "B" "C" "d")\n (set-difference lst1 lst2) \u2192 ("d" "C" "b" "A")\n (set-difference lst1 lst2 :test \'equal) \u2192 ("b" "A")\n (set-difference lst1 lst2 :test #\'equalp) \u2192 NIL \n (nset-difference lst1 lst2 :test #\'string=) \u2192 ("A" "b")\n (setq lst1 \'(("a" . "b") ("c" . "d") ("e" . "f")))\n\u2192 (("a" . "b") ("c" . "d") ("e" . "f")) \n (setq lst2 \'(("c" . "a") ("e" . "b") ("d" . "a")))\n\u2192 (("c" . "a") ("e" . "b") ("d" . "a")) \n (nset-difference lst1 lst2 :test #\'string= :key #\'cdr)\n\u2192 (("c" . "d") ("e" . "f")) \n lst1 \u2192 (("a" . "b") ("c" . "d") ("e" . "f")) \n lst2 \u2192 (("c" . "a") ("e" . "b") ("d" . "a")) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Remove all flavor names that contain "c" or "w".\n (set-difference \'("strawberry" "chocolate" "banana"\n                  "lemon" "pistachio" "rhubarb")\n          \'(#\\c #\\w)\n          :test #\'(lambda (s c) (find c s)))\n\u2192 ("banana" "rhubarb" "lemon")    ;One possible ordering.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq lst1 (list 1 "a" "b")\n       lst2 (list 1 "A" "b")) \u2192 (1 "A" "b")\n (set-exclusive-or lst1 lst2) \u2192 ("b" "A" "b" "a")\n (set-exclusive-or lst1 lst2 :test #\'equal) \u2192 ("A" "a")\n (set-exclusive-or lst1 lst2 :test \'equalp) \u2192 NIL \n (nset-exclusive-or lst1 lst2) \u2192 ("a" "b" "A" "b") \n (setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))\n\u2192 (("a" . "b") ("c" . "d") ("e" . "f"))\n (setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))\n\u2192 (("c" . "a") ("e" . "b") ("d" . "a")) \n (nset-exclusive-or lst1 lst2 :test #\'string= :key #\'cdr)\n\u2192 (("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a")) \n lst1 \u2192 (("a" . "b") ("c" . "d") ("e" . "f"))\n lst2 \u2192 (("c" . "a") ("d" . "a")) \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq cosmos '(1 \"a\" (1 2))) \u2192 (1 \"a\" (1 2))\n (subsetp '(1) cosmos) \u2192 T\n (subsetp '((1 2)) cosmos) \u2192 NIL\n (subsetp '((1 2)) cosmos :test 'equal) \u2192 T\n (subsetp '(1 \"A\") cosmos :test #'equalp) \u2192 T\n (subsetp '((1) (2)) '((1) (2))) \u2192 NIL\n (subsetp '((1) (2)) '((1) (2)) :key #'car) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (union \'(a b c) \'(f a d))\n\u2192 (A B C F D)\nOR=> (B C F A D)\nOR=> (D F A B C)\n (union \'((x 5) (y 6)) \'((z 2) (x 4)) :key #\'car)\n\u2192 ((X 5) (Y 6) (Z 2))\nOR=> ((X 4) (Y 6) (Z 2))\n\n (setq lst1 (list 1 2 \'(1 2) "a" "b")\n       lst2 (list 2 3 \'(2 3) "B" "C"))\n\u2192 (2 3 (2 3) "B" "C")\n (nunion lst1 lst2)\n\u2192 (1 (1 2) "a" "b" 2 3 (2 3) "B" "C") \nOR=> (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (decode-universal-time 0 0) \u2192 0, 0, 0, 1, 1, 1900, 0, false, 0\n\n;; The next two examples assume Eastern Daylight Time.\n (decode-universal-time 2414296800 5) \u2192 0, 0, 1, 4, 7, 1976, 6, false, 5\n (decode-universal-time 2414293200) \u2192 0, 0, 1, 4, 7, 1976, 6, true, 5\n\n;; This example assumes that the time zone is Eastern Daylight Time\n;; (and that the time zone is constant throughout the example).\n (let* ((here (nth 8 (multiple-value-list (get-decoded-time)))) ;Time zone\n        (recently (get-universal-time))\n        (a (nthcdr 7 (multiple-value-list (decode-universal-time recently))))\n        (b (nthcdr 7 (multiple-value-list (decode-universal-time recently here)))))\n   (list a b (equal a b))) \u2192 ((T 5) (NIL 5) NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (encode-universal-time 0 0 0 1 1 1900 0) \u2192 0\n (encode-universal-time 0 0 1 4 7 1976 5) \u2192 2414296800\n;; The next example assumes Eastern Daylight Time.\n (encode-universal-time 0 0 1 4 7 1976) \u2192 2414293200\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; At noon on July 4, 1976 in Eastern Daylight Time.\n (get-decoded-time) \u2192 0, 0, 12, 4, 7, 1976, 6, true, 5\n;; At exactly the same instant.\n (get-universal-time) \u2192 2414332800\n;; Exactly five minutes later.\n (get-universal-time) \u2192 2414333100\n;; The difference is 300 seconds (five minutes)\n (- * **) \u2192 300\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get-decoded-time) \\EQ (decode-universal-time (get-universal-time))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (sleep 1) \u2192 NIL \n\n;; Actually, since SLEEP is permitted to use approximate timing, \n;; this might not always yield true, but it will often enough that\n;; we felt it to be a productive example of the intent.\n (let ((then (get-universal-time))\n       (now  (progn (sleep 10) (get-universal-time))))\n   (>= (- now then) 10))\n\u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defvar *my-table* (make-hash-table))\n%  (setf (gethash 'foo *my-table*) 1)\n%  (setf (gethash 'bar *my-table*) 2)\n%  (setf (gethash 'foobar *my-table*) 3)\n%  (describe *my-table* :interactive t)\n% #<EQ-HASH-TABLE 259> has 3 entries.\n% Do you want to see its contents? (Yes or No) Yes\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defclass spaceship ()\n   ((captain :initarg :captain :accessor spaceship-captain)\n    (serial# :initarg :serial-number :accessor spaceship-serial-number)))\n\n (defclass federation-starship (spaceship) ())\n\n (defmethod describe-object ((s spaceship) stream)\n   (with-slots (captain serial#) s\n     (format stream "~&~S is a spaceship of type ~S,~\n                     ~%with ~A at the helm ~\n                       and with serial number ~D.~%"\n             s (type-of s) captain serial#)))\n\n (make-instance \'federation-starship\n                :captain "Rachel Garrett"\n                :serial-number "NCC-1701-C")\n\u2192 #<FEDERATION-STARSHIP 26312465>\n\n (describe *)\n\\OUT #<FEDERATION-STARSHIP 26312465> is a spaceship of type FEDERATION-STARSHIP,\n\\OUT with Rachel Garrett at the helm and with serial number NCC-1701-C.\n\u2192 \\novalues\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))\n\u2192 FACT\n (trace fact)\n\u2192 (FACT)\n;; Of course, the format of traced output is implementation-dependent.\n (fact 3)\n\\OUT 1 Enter FACT 3\n\\OUT | 2 Enter FACT 2\n\\OUT |   3 Enter FACT 1\n\\OUT |   | 4 Enter FACT 0\n\\OUT |   | 4 Exit FACT 1\n\\OUT |   3 Exit FACT 1\n\\OUT | 2 Exit FACT 2\n\\OUT 1 Exit FACT 6\n\u2192 6\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (a) (1+ a)) \u2192 F\n (eq (symbol-function 'f)\n     (progn (disassemble 'f)\n            (symbol-function 'f))) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(format t "~&Evaluating ~S~%" -)\n\\OUT Evaluating (FORMAT T "~&Evaluating ~S~%" -)\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(+ 0 1) \u2192 1\n(- 4 2) \u2192 2\n(/ 9 3) \u2192 3\n(list + ++ +++) \u2192 ((/ 9 3) (- 4 2) (+ 0 1))\n(setq a 1 b 2 c 3 d (list a b c)) \u2192 (1 2 3)\n(setq a 4 b 5 c 6 d (list a b c)) \u2192 (4 5 6)\n(list a b c) \u2192 (4 5 6)\n(eval +++) \u2192 (1 2 3)\n#.`(,@++ d) \u2192 (1 2 3 (1 2 3))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(values 'a1 'a2) \u2192 A1, A2\n'b \u2192 B\n(values 'c1 'c2 'c3) \u2192 C1, C2, C3\n(list * ** ***) \u2192 (C1 B A1)\n\n(defun cube-root (x) (expt x 1/3)) \u2192 CUBE-ROOT\n(compile *) \u2192 CUBE-ROOT\n(setq a (cube-root 27.0)) \u2192 3.0\n(* * 9.0) \u2192 27.0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" *   \\EQ (car /)\n **  \\EQ (car //)\n *** \\EQ (car ///)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (floor 22 7) \u2192 3, 1\n (+ (* (car /) 7) (cadr /)) \u2192 22\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (lisp-implementation-type)\n\u2192 "ACME Lisp"\nOR=> "Joe\'s Common Lisp"\n (lisp-implementation-version)\n\u2192 "1.3a"\n\u2192 "V2"\nOR=> "Release 17.3, ECO #6"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (short-site-name)\n\u2192 "MIT AI Lab"\nOR=> "CMU-CSD"\n (long-site-name)\n\u2192 "MIT Artificial Intelligence Laboratory"\nOR=> "CMU Computer Science Department"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (machine-instance)\n\u2192 "ACME.COM"\nOR=> "S/N 123231"\nOR=> "18.26.0.179"\nOR=> "AA-00-04-00-A7-A4"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (machine-type)\n\u2192 "DEC PDP-10"\nOR=> "Symbolics LM-2"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (machine-version) \u2192 "KL-10, microcode 9"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (software-type) \u2192 "Multics"\n (software-version) \u2192 "1.3x"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pathnamep (user-homedir-pathname)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ((lambda \\param{lambda-list} . \\param{body}) . \\param{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall #'(lambda \\param{lambda-list} . \\param{body}) . \\param{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"    (lambda \\param{lambda-list} {\\DeclsAndDoc} \\starparam{form})\n \\EQ (function (lambda \\param{lambda-list} {\\DeclsAndDoc} \\starparam{form}))\n \\EQ #'(lambda \\param{lambda-list} {\\DeclsAndDoc} \\starparam{form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall (lambda (x) (+ x 3)) 4) \u2192 7\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defmacro lambda (&whole form &rest bvl-decls-and-body)\n  (declare (ignore bvl-decls-and-body))\n  `#',form)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun foo () "bar") \u2192 FOO\n (compiled-function-p #\'foo) \u2192 implementation-dependent\n (compile \'foo) \u2192 FOO \n (compiled-function-p #\'foo) \u2192 T\n (setf (symbol-function \'foo)\n       (compile nil \'(lambda () "replaced"))) \u2192 #<Compiled-Function>\n (foo) \u2192 "replaced"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq form '(1+ a) a 999) \u2192 999\n (eval form) \u2192 1000\n (eval 'form) \u2192 (1+ A)\n (let ((a '(this would break if eval used local value))) (eval form))\n\u2192 1000\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (eval (list 'cdr (car '((quote (a . b)) c)))) \u2192 b\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setq temp 3) \u2192 3 \n%  (eval-when (:compile-toplevel) (setq temp 2)) \u2192 NIL \n%  temp \u2192 3 \n%  (eval-when (:execute) (setq temp 2)) \u2192 2 \n%  temp \u2192 2 \n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (eval-when (:compile-toplevel :load-toplevel :execute)\n   (set-macro-character #\\$ #'(lambda (stream char)\n                                (declare (ignore char))\n                                (list 'dollar (read stream))))) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE\n;;;     keyword is considered. At compile time, this has no effect.\n;;;     At load time (if the LET is at toplevel), or at execution time\n;;;     (if the LET is embedded in some other form which does not execute\n;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which\n;;;     returns 1.\n (let ((x 1))\n   (eval-when (:execute :load-toplevel :compile-toplevel)\n     (setf (symbol-function 'foo1) #'(lambda () x))))\n\n;;;     If this expression occurs at the toplevel of a file to be compiled,\n;;;     it has BOTH a compile time AND a load-time effect of setting\n;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.\n (eval-when (:execute :load-toplevel :compile-toplevel)\n   (let ((x 2))\n     (eval-when (:execute :load-toplevel :compile-toplevel)\n       (setf (symbol-function 'foo2) #'(lambda () x)))))\n\n;;;     If this expression occurs at the toplevel of a file to be compiled,\n;;;     it has BOTH a compile time AND a load-time effect of setting the\n;;;     function cell of FOO3 to a function which returns 3.\n (eval-when (:execute :load-toplevel :compile-toplevel)\n   (setf (symbol-function 'foo3) #'(lambda () 3)))\n \n;;; #4: This always does nothing. It simply returns NIL.\n (eval-when (:compile-toplevel)\n   (eval-when (:compile-toplevel) \n     (print 'foo4)))\n\n;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is\n;;;     printed at compile time. If this form occurs in a non-top-level\n;;;     position, nothing is printed at compile time. Regardless of context,\n;;;     nothing is ever printed at load time or execution time.\n (eval-when (:compile-toplevel) \n   (eval-when (:execute)\n     (print 'foo5)))\n \n;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is\n;;;     printed at compile time.  If this form occurs in a non-top-level\n;;;     position, nothing is printed at compile time. Regardless of context,\n;;;     nothing is ever printed at load time or execution time.\n (eval-when (:execute :load-toplevel)\n   (eval-when (:compile-toplevel)\n     (print 'foo6)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro foo ()\n   (really-foo)\n   `(really-foo))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro foo ()\n   `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x 3))\n   (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun bar (x) (defun foo () (+ x 3)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun bar (x) \n   (progn (eval-when (:compile-toplevel) \n            (compiler::notice-function-definition 'foo '(x)))\n          (eval-when (:execute :load-toplevel)\n            (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun bar (x) \n   (setf (symbol-function 'foo) #'(lambda () (+ x 3))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; The function INCR1 always returns the same value, even in different images.\n;;; The function INCR2 always returns the same value in a given image, \n;;; but the value it returns might vary from image to image.\n(defun incr1 (x) (+ x #.(random 17)))\n(defun incr2 (x) (+ x (load-time-value (random 17))))\n\n;;; The function FOO1-REF references the nth element of the first of \n;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for\n;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the\n;;; updated values.\n(defvar *foo-arrays* (list (make-array 7) (make-array 8)))\n(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))\n(defun set-foo1-ref (n val) \n  (setf (aref (load-time-value (first *my-arrays*) nil) n) val))\n\n;;; The function BAR1-REF references the nth element of the first of \n;;; the *BAR-ARRAYS* that is available at load time.  The programmer has\n;;; promised that the array will be treated as read-only, so the system \n;;; can copy or coalesce the array.\n(defvar *bar-arrays* (list (make-array 7) (make-array 8)))\n(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))\n\n;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n;;; even though NIL was specified, because the object was already read-only\n;;; when it was written as a literal vector rather than created by a constructor.\n;;; User programs must treat the vector v as read-only.\n(defun baz-ref (n)\n  (let ((v (load-time-value #(A B C) nil)))\n    (values (svref v n) v)))\n\n;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced\n;;; even though NIL was specified in the outer situation because T was specified\n;;; in the inner situation.  User programs must treat the vector v as read-only.\n(defun baz-ref (n)\n  (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))\n    (values (svref v n) v)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a 1) \u2192 1\n (quote (setq a 3)) \u2192 (SETQ A 3)\n a \u2192 1\n 'a \u2192 A\n ''a \u2192 (QUOTE A) \n '''a \u2192 (QUOTE (QUOTE A))\n (setq a 43) \u2192 43\n (list a (cons a 3)) \u2192 (43 (43 . 3))\n (list (quote a) (quote (cons a 3))) \u2192 (A (CONS A 3)) \n 1 \u2192 1\n '1 \u2192 1\n \"foo\" \u2192 \"foo\"\n '\"foo\" \u2192 \"foo\"\n (car '(a b)) \u2192 A\n '(car '(a b)) \u2192 (CAR (QUOTE (A B)))\n #(car '(a b)) \u2192 #(CAR (QUOTE (A B)))\n '#(car '(a b)) \u2192 #(CAR (QUOTE (A B)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun square (x) (expt x 2)) \u2192 SQUARE\n (define-compiler-macro square (&whole form arg)\n   (if (atom arg)\n       `(expt ,arg 2)\n       (case (car arg)\n         (square (if (= (length arg) 2)\n                     `(expt ,(nth 1 arg) 4)\n                     form))\n         (expt   (if (= (length arg) 3)\n                     (if (numberp (nth 2 arg))\n                         `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))\n                         `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))\n                     form))\n         (otherwise `(expt ,arg 2))))) \u2192 SQUARE\n (square (square 3)) \u2192 81\n (macroexpand '(square x)) \u2192 (SQUARE X), false\n (funcall (compiler-macro-function 'square) '(square x) nil)\n\u2192 (EXPT X 2)\n (funcall (compiler-macro-function 'square) '(square (square x)) nil)\n\u2192 (EXPT X 4)\n (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)\n\u2192 (EXPT X 2)\n\n (defun distance-positional (x1 y1 x2 y2)\n   (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))\n\u2192 DISTANCE-POSITIONAL\n (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))\n   (distance-positional x1 y1 x2 y2))\n\u2192 DISTANCE\n (define-compiler-macro distance (&whole form\n                                  &rest key-value-pairs\n                                  &key (x1 0  x1-p)\n                                       (y1 0  y1-p)\n                                       (x2 x1 x2-p)\n                                       (y2 y1 y2-p)\n                                  &allow-other-keys\n                                  &environment env)\n   (flet ((key (n) (nth (* n 2) key-value-pairs))\n          (arg (n) (nth (1+ (* n 2)) key-value-pairs))\n          (simplep (x)\n            (let ((expanded-x (macroexpand x env)))\n              (or (constantp expanded-x env)\n                  (symbolp expanded-x)))))\n     (let ((n (/ (length key-value-pairs) 2)))\n       (multiple-value-bind (x1s y1s x2s y2s others)\n           (loop for (key) on key-value-pairs by #'cddr\n                 count (eq key ':x1) into x1s\n                 count (eq key ':y1) into y1s\n                 count (eq key ':x2) into x2s\n                 count (eq key ':y1) into y2s\n                 count (not (member key '(:x1 :x2 :y1 :y2)))\n                   into others\n                 finally (return (values x1s y1s x2s y2s others)))\n         (cond ((and (= n 4)\n                     (eq (key 0) :x1)\n                     (eq (key 1) :y1)\n                     (eq (key 2) :x2)\n                     (eq (key 3) :y2))\n                `(distance-positional ,x1 ,y1 ,x2 ,y2))\n               ((and (if x1-p (and (= x1s 1) (simplep x1)) t)\n                     (if y1-p (and (= y1s 1) (simplep y1)) t)\n                     (if x2-p (and (= x2s 1) (simplep x2)) t)\n                     (if y2-p (and (= y2s 1) (simplep y2)) t)\n                     (zerop others))\n                `(distance-positional ,x1 ,y1 ,x2 ,y2))\n               ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)\n                     (zerop others))\n                (let ((temps (loop repeat n collect (gensym))))\n                  `(let ,(loop for i below n\n                               collect (list (nth i temps) (arg i)))\n                     (distance\n                       ,@(loop for i below n\n                               append (list (key i) (nth i temps)))))))\n               (t form))))))\n\u2192 DISTANCE\n (dolist (form\n           '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))\n             (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))\n             (distance :x1 (setq x 7) :y1 (incf x))\n             (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))\n             (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)\n             (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)\n             (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))\n   (print (funcall (compiler-macro-function 'distance) form nil)))\n\\OUT (LET ((#:G6558 (SETQ X 7))\n\\OUT       (#:G6559 (DECF X))\n\\OUT       (#:G6560 (DECF X))\n\\OUT       (#:G6561 (DECF X)))\n\\OUT   (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561)) \n\\OUT (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X)) \n\\OUT (LET ((#:G6567 (SETQ X 7))\n\\OUT       (#:G6568 (INCF X)))\n\\OUT   (DISTANCE :X1 #:G6567 :Y1 #:G6568)) \n\\OUT (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X)) \n\\OUT (DISTANCE-POSITIONAL A1 B1 A2 B2) \n\\OUT (DISTANCE-POSITIONAL A1 B1 A2 B2) \n\\OUT (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2) \n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro mac1 (a b) \"Mac1 multiplies and adds\" \n            `(+ ,a (* ,b 3))) \u2192 MAC1 \n (mac1 4 5) \u2192 19 \n (documentation 'mac1 'function) \u2192 \"Mac1 multiplies and adds\" \n (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) \u2192 MAC2 \n (mac2 6) \u2192 (6 T 3 NIL NIL) \n (mac2 6 3 8) \u2192 (6 T 3 T (8)) \n (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))\n    `'(,r ,a ,b ,c ,d ,x)) \u2192 MAC3 \n (mac3 1 6 :d 8 :c 9 :d 10) \u2192 ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10)) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defmacro halibut ((mouth eye1 eye2)\n%                    ((fin1 length1) (fin2 length2))\n%                    tail)\n% ...)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (halibut (m (car eyes) (cdr eyes))\n%          ((f1 (count-scales f1)) (f2 (count-scales f2)))\n%          my-favorite-tail) \u2192 NIL\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (halibut (m (car eyes) (cdr eyes))\n%          ((f1) (f2 (count-scales f2)))\n%          my-favorite-tail)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (halibut my-favorite-head\n%          ((f1 (count-scales f1)) (f2 (count-scales f2)))\n%          my-favorite-tail)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defmacro halibut ((&whole head mouth eye1 eye2)\n%                    ((fin1 length1) (fin2 length2))\n%                    tail)\n% ...)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (halibut (m (car eyes) (cdr eyes))\n%          ((f1 (count-scales f1)) (f2 (count-scales f2)))\n%          my-favorite-tail) \u2192 NIL\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defmacro arithmetic-if (test neg-form zero-form pos-form)\n%   (let ((var (gensym)))\n%     `(let ((,var ,test))\n%        (cond ((< ,var 0) ,neg-form)\n%            ((= ,var 0) ,zero-form)\n%            (t ,pos-form))))) \u2192 ARITHMETIC-IF\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (lambda (calling-form environment)\n%   (declare (ignore environment))\n%   (let ((var (gensym)))\n%     (list 'let\n%           (list (list 'var (cadr calling-form)))\n%           (list 'cond\n%                 (list (list '< var '0) (caddr calling-form))\n%                 (list (list '= var '0) (cadddr calling-form))\n%                 (list 't (fifth calling-form))))))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (arithmetic-if (- x 4.0)\n%%                (- x)\n%%                (error "Strange zero")\n%%                x)\n%%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (let ((g407 (- x 4.0)))\n%   (cond ((< g407 0) (- x))\n%         ((= g407 0) (error "Strange zero"))\n%         (t x)))\n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defmacro arithmetic-if (test neg-form &optional zero-form pos-form)\n%   (let ((var (gensym)))\n%     \\bq(let ((,var ,test))\n%        (cond ((< ,var 0) ,neg-form)\n%              ((= ,var 0) ,zero-form)\n%              (t ,pos-form)))))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (arithmetic-if (- x 4.0) (print x))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (let ((g408 (- x 4.0)))\n%   (cond ((< g408 0) (print x))\n%         ((= g408 0) nil)\n%         (t nil)))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro loser (x &optional (a b &rest c) &rest z)\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro loser (x &optional ((a b &rest c)) &rest z)\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loser (car pool) ((+ x 1)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro dm1a (&whole x) `',x)\n (macroexpand '(dm1a))  \u2192 (QUOTE (DM1A))\n (macroexpand '(dm1a a)) is an error.\n \n (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))\n (macroexpand '(dm1b))  is an error.\n (macroexpand '(dm1b q))  \u2192 (QUOTE ((DM1B Q) Q NIL))\n (macroexpand '(dm1b q r)) \u2192 (QUOTE ((DM1B Q R) Q R))\n (macroexpand '(dm1b q r s)) is an error.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))\n (macroexpand '(dm2a x y)) \u2192 (QUOTE (FORM (DM2A X Y) A X B Y))\n (dm2a x y) \u2192 (FORM (DM2A X Y) A X B Y)\n\n (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5)) \n                 &body f &environment env)\n   ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))\n ;Note that because backquote is involved, implementations may differ\n ;slightly in the nature (though not the functionality) of the expansion.\n (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))\n \u2192 (LIST* '(DM2B X1 (((INCF X2) X3 X4))\n                   X5 X6)\n            X1\n            '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),\n     T\n (let ((x1 5))\n   (macrolet ((segundo (x) `(cadr ,x)))\n     (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))\n \u2192 ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)\n      5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro macfun (x) '(macro-function 'macfun)) \u2192 MACFUN \n (not (macro-function 'macfun)) \u2192 NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (macrolet ((foo (&environment env)\n               (if (macro-function 'bar env)\n                  ''yes\n                  ''no)))\n    (list (foo)\n          (macrolet ((bar () :beep))\n             (foo))))\n \n\u2192 (NO YES)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (macro-function symbol) fn)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro alpha (x y) `(beta ,x ,y)) \u2192 ALPHA\n (defmacro beta (x y) `(gamma ,x ,y)) \u2192 BETA\n (defmacro delta (x y) `(gamma ,x ,y)) \u2192 EPSILON\n (defmacro expand (form &environment env)\n   (multiple-value-bind (expansion expanded-p)\n       (macroexpand form env)\n     `(values ',expansion ',expanded-p))) \u2192 EXPAND\n (defmacro expand-1 (form &environment env)\n   (multiple-value-bind (expansion expanded-p)\n       (macroexpand-1 form env)\n     `(values ',expansion ',expanded-p))) \u2192 EXPAND-1\n\\medbreak\n;; Simple examples involving just the global environment\n (macroexpand-1 '(alpha a b)) \u2192 (BETA A B), true\n (expand-1 (alpha a b)) \u2192 (BETA A B), true\n (macroexpand '(alpha a b)) \u2192 (GAMMA A B), true\n (expand (alpha a b)) \u2192 (GAMMA A B), true\n (macroexpand-1 'not-a-macro) \u2192 NOT-A-MACRO, false\n (expand-1 not-a-macro) \u2192 NOT-A-MACRO, false\n (macroexpand '(not-a-macro a b)) \u2192 (NOT-A-MACRO A B), false\n (expand (not-a-macro a b)) \u2192 (NOT-A-MACRO A B), false\n\\medbreak\n;; Examples involving lexical environments\n (macrolet ((alpha (x y) `(delta ,x ,y)))\n   (macroexpand-1 '(alpha a b))) \u2192 (BETA A B), true\n (macrolet ((alpha (x y) `(delta ,x ,y)))\n   (expand-1 (alpha a b))) \u2192 (DELTA A B), true\n (macrolet ((alpha (x y) `(delta ,x ,y)))\n   (macroexpand '(alpha a b))) \u2192 (GAMMA A B), true\n (macrolet ((alpha (x y) `(delta ,x ,y)))\n   (expand (alpha a b))) \u2192 (GAMMA A B), true\n (macrolet ((beta (x y) `(epsilon ,x ,y)))\n   (expand (alpha a b))) \u2192 (EPSILON A B), true\n (let ((x (list 1 2 3)))\n   (symbol-macrolet ((a (first x)))\n     (expand a))) \u2192 (FIRST X), true\n (let ((x (list 1 2 3)))\n   (symbol-macrolet ((a (first x)))\n     (macroexpand 'a))) \u2192 A, false\n (symbol-macrolet ((b (alpha x y)))\n   (expand-1 b)) \u2192 (ALPHA X Y), true\n (symbol-macrolet ((b (alpha x y)))\n   (expand b)) \u2192 (GAMMA X Y), true\n (symbol-macrolet ((b (alpha x y))\n                   (a b))\n   (expand-1 a)) \u2192 B, true\n (symbol-macrolet ((b (alpha x y))\n                   (a b))\n   (expand a)) \u2192 (GAMMA X Y), true\n\\medbreak\n;; Examples of shadowing behavior\n (flet ((beta (x y) (+ x y)))\n   (expand (alpha a b))) \u2192 (BETA A B), true\n (macrolet ((alpha (x y) `(delta ,x ,y)))\n   (flet ((alpha (x y) (+ x y)))\n     (expand (alpha a b)))) \u2192 (ALPHA A B), false\n (let ((x (list 1 2 3)))\n   (symbol-macrolet ((a (first x)))\n     (let ((a x))\n       (expand a)))) \u2192 A, false\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defvar *things* (list 'alpha 'beta 'gamma)) \u2192 *THINGS*\n\n(define-symbol-macro thing1 (first *things*)) \u2192 THING1\n(define-symbol-macro thing2 (second *things*)) \u2192 THING2\n(define-symbol-macro thing3 (third *things*)) \u2192 THING3\n\nthing1 \u2192 ALPHA\n(setq thing1 'ONE) \u2192 ONE\n*things* \u2192 (ONE BETA GAMMA)\n(multiple-value-setq (thing2 thing3) (values 'two 'three)) \u2192 TWO\nthing3 \u2192 THREE\n*things* \u2192 (ONE TWO THREE)\n\n(list thing2 (let ((thing2 2)) thing2)) \u2192 (TWO 2)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; The following is equivalent to\n;;;   (list 'foo (let ((x 'bar)) x)),\n;;; not\n;;;   (list 'foo (let (('foo 'bar)) 'foo))\n (symbol-macrolet ((x 'foo))\n   (list x (let ((x 'bar)) x))) \n\u2192 (foo bar)\n\\NV (foo foo) \n \n (symbol-macrolet ((x '(foo x)))\n   (list x))\n\u2192 ((FOO X))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun hook (expander form env)\n    (format t \"Now expanding: ~S~%\" form)\n    (funcall expander form env)) \u2192 HOOK \n (defmacro machook (x y) `(/ (+ ,x ,y) 2)) \u2192 MACHOOK \n (macroexpand '(machook 1 2)) \u2192 (/ (+ 1 2) 2), true \n (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))\n\\OUT Now expanding (MACHOOK 1 2) \n\u2192 (/ (+ 1 2) 2), true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun declare-variable-types-globally (type vars)\n   (proclaim `(type ,type ,@vars))\n   type)\n\n ;; Once this form is executed, the dynamic variable *TOLERANCE*\n ;; must always contain a float.\n (declare-variable-types-globally 'float '(*tolerance*))\n\u2192 FLOAT\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(proclaim '(special *x*))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (eval-when (:execute :compile-toplevel :load-toplevel)\n   (proclaim '(special *x*)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun nonsense (k x z)\n   (foo z x)                     ;First call to foo\n   (let ((j (foo k x))           ;Second call to foo\n         (x (* k k)))\n     (declare (inline foo) (special x z))\n     (foo x j z)))               ;Third call to foo\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f ()\n   (let ((x (list 1 2 3)))\n     (declare (dynamic-extent x))\n         ...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun g (x) (declare (dynamic-extent x)) ...)\n (defun f () (g (list 1 2 3)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (declaim (inline g))\n (defun g (x) (declare (dynamic-extent x)) ...)\n (defun f () (g (list 1 2 3)))\n \n (defun f ()\n   (flet ((g (x) (declare (dynamic-extent x)) ...))\n     (g (list 1 2 3))))\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (&rest x)\n   (declare (dynamic-extent x))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x (list 'a1 'b1 'c1))\n       (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))\n   (declare (dynamic-extent x y))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; In this example, the implementation is permitted to stack allocate\n;; the list that is bound to X.\n (let ((x (list 1 2 3)))\n   (declare (dynamic-extent x))\n   (print x)\n   :done)\n\\OUT (1 2 3)\n\u2192 :DONE\n \n;; In this example, the list to be bound to L can be stack-allocated.\n (defun zap (x y z)\n   (do ((l (list x y z) (cdr l)))\n       ((null l))\n     (declare (dynamic-extent l))\n     (prin1 (car l)))) \u2192 ZAP\n (zap 1 2 3)\n\\OUT 123\n\u2192 NIL\n\n;; Some implementations might open-code LIST-ALL-PACKAGES in a way\n;; that permits using stack allocation of the list to be bound to L.\n (do ((l (list-all-packages) (cdr l)))\n     ((null l))\n   (declare (dynamic-extent l))\n   (let ((name (package-name (car l))))\n     (when (string-search "COMMON-LISP" name) (print name))))\n\\OUT "COMMON-LISP"\n\\OUT "COMMON-LISP-USER"\n\u2192 NIL\n\n;; Some implementations might have the ability to stack allocate \n;; rest lists.  A declaration such as the following should be a cue\n;; to such implementations that stack-allocation of the rest list\n;; would be desirable.\n (defun add (&rest x)\n   (declare (dynamic-extent x))\n   (apply #\'+ x)) \u2192 ADD\n (add 1 2 3) \u2192 6\n\n (defun zap (n m)\n   ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).\n   ;; It may be slow, but with a good compiler at least it\n   ;; doesn\'t waste much heap storage.  :-\\}\n   (let ((a (make-array n)))\n     (declare (dynamic-extent a))\n     (dotimes (i n) \n       (declare (dynamic-extent i))\n       (setf (aref a i) (random (+ i 1))))\n     (aref a m))) \u2192 ZAP\n (< (zap 5 3) 3) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (length (list (let ((x (list 1 2 3)))  ; Invalid\n                (declare (dynamic-extent x))\n                x)))\n\n (progn (let ((x (list 1 2 3)))  ; Invalid\n          (declare (dynamic-extent x))\n          x)\n        nil)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x y)\n   (declare (type fixnum x y))\n   (let ((z (+ x y)))\n     (declare (type fixnum z))\n     z)) \u2192 F\n (f 1 2) \u2192 3\n ;; The previous definition of F is equivalent to\n (defun f (x y)\n   ;; This declaration is a shorthand form of the TYPE declaration\n   (declare (fixnum x y))\n   ;; To declare the type of a return value, it's not necessary to\n   ;; create a named variable.  A THE special form can be used instead.\n   (the fixnum (+ x y))) \u2192 F\n (f 1 2) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))\n (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))\n  \n (defun frob (an-array)\n   (declare (type (array (signed-byte 5) 1) an-array))\n   (setf (aref an-array 1) 31)\n   (setf (aref an-array 2) 127)\n   (setf (aref an-array 3) (* 2 (aref an-array 3)))\n   (let ((foo 0))\n     (declare (type (signed-byte 5) foo))\n     (setf foo (aref an-array 0))))\n  \n (frob *one-array*)\n (frob *another-array*)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun frob (an-array)\n   (setf (the (signed-byte 5) (aref an-array 1)) 31)\n   (setf (the (signed-byte 5) (aref an-array 2)) 127)\n   (setf (the (signed-byte 5) (aref an-array 3))\n         (* 2 (the (signed-byte 5) (aref an-array 3))))\n   (let ((foo 0))\n     (declare (type (signed-byte 5) foo))\n     (setf foo (the (signed-byte 5) (aref an-array 0)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun bump-counters (counters)\n   (declare (type (array fixnum *) bump-counters))\n   (dotimes (i (length counters))\n     (incf (aref counters i))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x y) (declare (fixnum x y)) (+ x y))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x y)\n   (declare (fixnum x y))\n   (the fixnum (+ x y)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x y)\n   (declare (fixnum x y z))\n   (the fixnum (+ x y z)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x y)\n   (declare (fixnum x y z))\n   (the fixnum (+ (the fixnum (+ x y)) z)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (declaim (inline f))\n (defun f ...)\n (declaim (notinline f))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; The globally defined function DISPATCH should be open-coded,\n ;; if the implementation supports inlining, unless a NOTINLINE \n ;; declaration overrides this effect.\n (declaim (inline dispatch))\n (defun dispatch (x) (funcall (get (car x) 'dispatch) x))\n ;; Here is an example where inlining would be encouraged.\n (defun top-level-1 () (dispatch (read-command)))\n ;; Here is an example where inlining would be prohibited.\n (defun top-level-2 ()\n   (declare (notinline dispatch))\n   (dispatch (read-command)))\n ;; Here is an example where inlining would be prohibited.\n (declaim (notinline dispatch))\n (defun top-level-3 () (dispatch (read-command)))\n ;; Here is an example where inlining would be encouraged.\n (defun top-level-4 () \n   (declare (inline dispatch))\n   (dispatch (read-command)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (declare (ftype (function (integer list) t) ith)\n          (ftype (function (number) float) sine cosine))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (declaim (declaration author target-language target-machine))\n (declaim (target-language ada))\n (declaim (target-machine IBM-650))\n (defun strangep (x)\n   (declare (author "Harry Tweeker"))\n   (member x \'(strange weird odd peculiar)))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun often-used-subroutine (x y)\n   (declare (optimize (safety 2)))\n   (error-check x y)\n   (hairy-setup x)\n   (do ((i 0 (+ i 1))\n        (z x (cdr z)))\n       ((null z))\n     ;; This inner loop really needs to burn.\n     (declare (optimize speed))\n     (declare (fixnum i))\n     ))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun hack (thing *mod*)    ;The binding of the parameter\n   (declare (special *mod*))  ; *mod* is visible to hack1,\n   (hack1 (car thing)))       ; but not that of thing.\n (defun hack1 (arg)\n   (declare (special *mod*))  ;Declare references to *mod*\n                              ;within hack1 to be special.\n   (if (atom arg) *mod*\n       (cons (hack1 (car arg)) (hack1 (cdr arg)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (declaim (special x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun example (x) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun declare-eg (y)                 ;this y is special\n (declare (special y))\n (let ((y t))                         ;this y is lexical\n      (list y\n            (locally (declare (special y)) y)))) ;this y refers to the\n                                                 ;special binding of y\n\u2192 DECLARE-EG \n (declare-eg nil) \u2192 (T NIL) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(setf (symbol-value 'x) 6)\n(defun foo (x)                         ;a lexical binding of x\n  (print x)\n  (let ((x (1+ x)))                    ;a special binding of x\n    (declare (special x))              ;and a lexical reference\n    (bar))\n  (1+ x))\n(defun bar () \n  (print (locally (declare (special x))\n           x)))\n(foo 10) \n\\OUT 10\n\\OUT 11\n\u2192 11\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(setf (symbol-value 'x) 6)\n(defun bar (x y)            ;[1] 1st occurrence of x\n  (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence\n        (x y))              ;[3] 3rd occurrence of x\n    (declare (special x))\n    (list old-x x)))\n(bar 'first 'second) \u2192 (FIRST SECOND)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun few (x &optional (y *foo*))\n   (declare (special *foo*))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (declaim (special prosp)) \u2192 implementation-dependent\n (setq prosp 1 reg 1) \u2192 1\n (let ((prosp 2) (reg 2))         ;the binding of prosp is special\n    (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,\n    (list prosp reg))             ;whereas the variable reg is lexical\n\u2192 (3 2)\n (list prosp reg) \u2192 (1 3)\n\n (declaim (special x))          ;x is always special.\n (defun example (x y)                                 \n   (declare (special y))\n   (let ((y 3) (x (* x 2)))\n     (print (+ y (locally (declare (special y)) y)))\n     (let ((y 4)) (declare (special y)) (foo x)))) \u2192 EXAMPLE\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun sample-function (y)  ;this y is regarded as special\n   (declare (special y))                                \n   (let ((y t))              ;this y is regarded as lexical\n     (list y\n           (locally (declare (special y))\n             ;; this next y is regarded as special\n             y))))\n\u2192 SAMPLE-FUNCTION\n (sample-function nil) \u2192 (T NIL) \n (setq x '(1 2 3) y '(4 . 5)) \u2192 (4 . 5)\n\n;;; The following declarations are not notably useful in specific.\n;;; They just offer a sample of valid declaration syntax using LOCALLY.\n (locally (declare (inline floor) (notinline car cdr))\n          (declare (optimize space))\n    (floor (car x) (cdr y))) \u2192 0, 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; This example shows a definition of a function that has a particular set\n;;; of OPTIMIZE settings made locally to that definition.\n (locally (declare (optimize (safety 3) (space 3) (speed 0)))\n   (defun frob (w x y &optional (z (foo x y)))\n     (mumble x y z w)))\n\u2192 FROB\n\n;;; This is like the previous example, except that the optimize settings\n;;; remain in effect for subsequent definitions in the same compilation unit.\n (declaim (optimize (safety 3) (space 3) (speed 0)))\n (defun frob (w x y &optional (z (foo x y)))\n   (mumble x y z w))\n\u2192 FROB\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (the type exp) \n% \\EQ \n%  (let ((#:g0001 exp))\n%    (declare (type type #:g0001))\n%    #:g0001)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (the symbol (car (list (gensym)))) \u2192 #:G9876\n (the fixnum (+ 5 7)) \u2192 12\n (the (values) (truncate 3.2 2)) \u2192 1, 1.2\n (the integer (truncate 3.2 2)) \u2192 1, 1.2\n (the (values integer) (truncate 3.2 2)) \u2192 1, 1.2\n (the (values integer float) (truncate 3.2 2))   \u2192 1, 1.2\n (the (values integer float symbol) (truncate 3.2 2)) \u2192 1, 1.2\n (the (values integer float symbol t null list) \n      (truncate 3.2 2)) \u2192 1, 1.2\n (let ((i 100))\n    (declare (fixnum i))\n    (the fixnum (1+ i))) \u2192 101\n (let* ((x (list 'a 'b 'c))\n        (y 5))\n    (setf (the fixnum (car x)) y)\n    x) \u2192 (5 B C)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (the (values integer integer) (floor x y))\n (the (values string t)\n      (gethash the-key the-string-table))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (special-operator-p 'if) \u2192 T\n (special-operator-p 'car) \u2192 NIL\n (special-operator-p 'one) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (constantp 1) \u2192 T\n (constantp 'temp) \u2192 NIL\n (constantp ''temp)) \u2192 T\n (defconstant this-is-a-constant 'never-changing) \u2192 THIS-IS-A-CONSTANT \n (constantp 'this-is-a-constant) \u2192 T\n (constantp \"temp\") \u2192 T\n (setq a 6) \u2192 6 \n (constantp a) \u2192 T\n (constantp '(sin pi)) \u2192 implementation-dependent\n (constantp '(car '(x))) \u2192 implementation-dependent\n (constantp '(eql x x)) \u2192 implementation-dependent\n (constantp '(typep x 'nil)) \u2192 implementation-dependent\n (constantp '(typep x 't)) \u2192 implementation-dependent\n (constantp '(values this-is-a-constant)) \u2192 implementation-dependent\n (constantp '(values 'x 'y)) \u2192 implementation-dependent\n (constantp '(let ((a '(a b c))) (+ (length a) 6))) \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; An example involving version numbers.  Note that the precise nature of\n;; the truename is implementation-dependent while the file is still open.\n (with-open-file (stream ">vistor>test.text.newest")\n   (values (pathname stream)\n           (truename stream)))\n\u2192 #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"\nOR=> #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"\nOR=> #P"S:>vistor>test.text.newest", #P"S:>vistor>_temp_._temp_.1"\n\n;; In this case, the file is closed when the truename is tried, so the\n;; truename information is reliable.\n (with-open-file (stream ">vistor>test.text.newest")\n   (close stream)\n   (values (pathname stream)\n           (truename stream)))\n\u2192 #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"\n\n;; An example involving TOP-20\'s implementation-dependent concept \n;; of logical devices -- in this case, "DOC:" is shorthand for\n;; "PS:<DOCUMENTATION>" ...\n (with-open-file (stream "CMUC::DOC:DUMPER.HLP")\n   (values (pathname stream)\n           (truename stream)))\n\u2192 #P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (stream ">relativity>general.text")\n   (file-author s))\n\u2192 "albert"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (s "noel.text" \n                    :direction :output :if-exists :error)\n   (format s "~&Dear Santa,~2%I was good this year.  ~\n                Please leave lots of toys.~2%Love, Sue~\n             ~2%attachments: milk, cookies~%")\n   (truename s))\n\u2192 #P"CUPID:/susan/noel.text"\n (with-open-file (s "noel.text")\n   (file-write-date s))\n\u2192 2902600800\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; An example involving logical pathnames.\n (with-open-file (stream "sys:chemistry;lead.text"\n                         :direction :output :if-exists :error)\n   (princ "eureka" stream)\n   (values (pathname stream) (truename stream)))\n\u2192 #P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"\n (rename-file "sys:chemistry;lead.text" "gold.text")\n\u2192 #P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",\n   #P"Q:>sys>chem>lead.text.1",\n   #P"Q:>sys>chem>gold.text.1"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (s "delete-me.text" :direction :output :if-exists :error))\n\u2192 NIL\n (setq p (probe-file "delete-me.text")) \u2192 #P"R:>fred>delete-me.text.1"\n (delete-file p) \u2192 T\n (probe-file "delete-me.text") \u2192 NIL\n (with-open-file (s "delete-me.text" :direction :output :if-exists :error)\n   (delete-file s))\n\u2192 T\n (probe-file "delete-me.text") \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq f '+) \u2192 +\n (apply f '(1 2)) \u2192 3\n (setq f #'-) \u2192 #<FUNCTION ->\n (apply f '(1 2)) \u2192 -1\n (apply #'max 3 5 '(2 7 3)) \u2192 7\n (apply 'cons '((+ 2 3) 4)) \u2192 ((+ 2 3) . 4)\n (apply #'+ '()) \u2192 0\n\n (defparameter *some-list* '(a b c))\n (defun strange-test (&rest x) (eq x *some-list*))\n (apply #'strange-test *some-list*) \u2192 implementation-dependent\n\n (defun bad-boy (&rest x) (rplacd x 'y))\n (bad-boy 'a 'b 'c) has undefined consequences.\n (apply #'bad-boy *some-list*) has undefined consequences.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (size &rest keys &key double &allow-other-keys)\n   (let ((v (apply #'make-array size :allow-other-keys t keys)))\n     (if double (concatenate (type-of v) v v) v)))\n (foo 4 :initial-contents '(a b c d) :double t)\n    \u2192 #(A B C D A B C D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lambda \\param{lambda-list}\n   {\\DeclsAndDoc}\n   (block \\param{block-name} \\starparam{form}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun recur (x)\n  (when (> x 0)\n    (recur (1- x)))) \u2192 RECUR \n (defun ex (a b &optional c (d 66) &rest keys &key test (start 0))\n    (list a b c d keys test start)) \u2192 EX \n (ex 1 2) \u2192 (1 2 NIL 66 NIL NIL 0)\n (ex 1 2 3 4 :test \'equal :start 50) \n\u2192 (1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)\n (ex :test 1 :start 2) \u2192 (:TEST 1 :START 2 NIL NIL 0)\n\n ;; This function assumes its callers have checked the types of the\n ;; arguments, and authorizes the compiler to build in that assumption.\n (defun discriminant (a b c)\n   (declare (number a b c))\n   "Compute the discriminant for a quadratic equation."\n   (- (* b b) (* 4 a c))) \u2192 DISCRIMINANT\n (discriminant 1 2/3 -2) \u2192 76/9\n\n ;; This function assumes its callers have not checked the types of the\n ;; arguments, and performs explicit type checks before making any assumptions. \n (defun careful-discriminant (a b c)\n   "Compute the discriminant for a quadratic equation."\n   (check-type a number)\n   (check-type b number)\n   (check-type c number)\n   (locally (declare (number a b c))\n     (- (* b b) (* 4 a c)))) \u2192 CAREFUL-DISCRIMINANT\n (careful-discriminant 1 2/3 -2) \u2192 76/9\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (fboundp 'car) \u2192 T\n (fboundp 'nth-value) \u2192 NIL\n (fboundp 'with-open-file) \u2192 T\n (fboundp 'unwind-protect) \u2192 T\n (defun my-function (x) x) \u2192 MY-FUNCTION\n (fboundp 'my-function) \u2192 T\n (let ((saved-definition (symbol-function 'my-function)))\n   (unwind-protect (progn (fmakunbound 'my-function)\n                          (fboundp 'my-function))\n     (setf (symbol-function 'my-function) saved-definition)))\n\u2192 NIL\n (fboundp 'my-function) \u2192 T\n (defmacro my-macro (x) `',x) \u2192 MY-MACRO\n (fboundp 'my-macro) \u2192 T\n (fmakunbound 'my-function) \u2192 MY-FUNCTION\n (fboundp 'my-function) \u2192 NIL\n (flet ((my-function (x) x))\n   (fboundp 'my-function)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(if (fboundp x) (symbol-function x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun add-some (x) (+ x 19)) \u2192 ADD-SOME\n (fboundp 'add-some) \u2192 T\n (flet ((add-some (x) (+ x 37)))\n    (fmakunbound 'add-some)\n    (add-some 1)) \u2192 38\n (fboundp 'add-some) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (x flag)\n   (macrolet ((fudge (z)\n                 ;The parameters x and flag are not accessible\n                 ; at this point; a reference to flag would be to\n                 ; the global variable of that name.\n                 \\bq\\ (if flag (* ,z ,z) ,z)))\n    ;The parameters x and flag are accessible here.\n     (+ x\n        (fudge x)\n        (fudge (+ x 1)))))\n \\EQ\n (defun foo (x flag)\n   (+ x\n      (if flag (* x x) x)\n      (if flag (* (+ x 1) (+ x 1)) (+ x 1))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (flet ((+ (&rest args) 'crossed-out)) (+ 1 2 3)) \u2192 CROSSED-OUT\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (flet ((flet1 (n) (+ n n)))\n    (flet ((flet1 (n) (+ 2 (flet1 n))))\n      (flet1 2))) \u2192 6\n\n (defun dummy-function () 'top-level) \u2192 DUMMY-FUNCTION \n (funcall #'dummy-function) \u2192 TOP-LEVEL \n (flet ((dummy-function () 'shadow)) \n      (funcall #'dummy-function)) \u2192 SHADOW \n (eq (funcall #'dummy-function) (funcall 'dummy-function))\n\u2192 T \n (flet ((dummy-function () 'shadow))\n   (eq (funcall #'dummy-function)\n       (funcall 'dummy-function)))\n\u2192 NIL \n\n (defun recursive-times (k n)\n   (labels ((temp (n) \n              (if (zerop n) 0 (+ k (temp (1- n))))))\n     (temp n))) \u2192 RECURSIVE-TIMES\n (recursive-times 2 3) \u2192 6\n\n (defmacro mlets (x &environment env) \n    (let ((form `(babbit ,x)))\n      (macroexpand form env))) \u2192 MLETS\n (macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) \u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (flet ((safesqrt (x) (sqrt (abs x))))\n  ;; The safesqrt function is used in two places.\n   (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))\n\u2192 3.291173\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun integer-power (n k)     \n   (declare (integer n))         \n   (declare (type (integer 0 *) k))\n   (labels ((expt0 (x k a)\n              (declare (integer x a) (type (integer 0 *) k))\n              (cond ((zerop k) a)\n                    ((evenp k) (expt1 (* x x) (floor k 2) a))\n                    (t (expt0 (* x x) (floor k 2) (* x a)))))\n            (expt1 (x k a)\n              (declare (integer x a) (type (integer 0 *) k))\n              (cond ((evenp k) (expt1 (* x x) (floor k 2) a))\n                    (t (expt0 (* x x) (floor k 2) (* x a))))))\n    (expt0 n k 1))) \u2192 INTEGER-POWER\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun example (y l)\n   (flet ((attach (x)\n            (setq l (append l (list x)))))\n     (declare (inline attach))\n     (dolist (x y)\n       (unless (null (cdr x))\n         (attach x)))\n     l))\n\n (example '((a apple apricot) (b banana) (c cherry) (d) (e))\n          '((1) (2) (3) (4 2) (5) (6 3 2)))\n\u2192 ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall #'+ 1 2 3) \u2192 6\n (funcall 'car '(1 2 3)) \u2192 1\n (funcall 'position 1 '(1 2 3 2 1) :start 1) \u2192 4\n (cons 1 2) \u2192 (1 . 2)\n (flet ((cons (x y) `(kons ,x ,y)))\n   (let ((cons (symbol-function '+)))\n     (funcall #'cons\n              (funcall 'cons 1 2)\n              (funcall cons 1 2))))\n\u2192 (KONS (1 . 2) 3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall \\param{function} \\param{arg1} \\param{arg2} ...)\n \\EQ (apply \\param{function} \\param{arg1} \\param{arg2} ... nil)\n \\EQ (apply \\param{function} (list \\param{arg1} \\param{arg2} ...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun adder (x) (function (lambda (y) (+ x y))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq add3 (adder 3))\n (funcall add3 5) \u2192 8\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (function-lambda-expression #'(lambda (x) x))\n\u2192 NIL, false, NIL\nOR=> NIL, true, NIL\nOR=> (LAMBDA (X) X), true, NIL\nOR=> (LAMBDA (X) X), false, NIL\n\n (function-lambda-expression\n    (funcall #'(lambda () #'(lambda (x) x))))\n\u2192 NIL, false, NIL\nOR=> NIL, true, NIL\nOR=> (LAMBDA (X) X), true, NIL\nOR=> (LAMBDA (X) X), false, NIL\n \n (function-lambda-expression \n    (funcall #'(lambda (x) #'(lambda () x)) nil))\n\u2192 NIL, true, NIL\nOR=> (LAMBDA () X), true, NIL\n\\NV NIL, false, NIL\n\\NV (LAMBDA () X), false, NIL\n  \n (flet ((foo (x) x))\n   (setf (symbol-function 'bar) #'foo)\n   (function-lambda-expression #'bar))\n\u2192 NIL, false, NIL\nOR=> NIL, true, NIL\nOR=> (LAMBDA (X) (BLOCK FOO X)), true, NIL\nOR=> (LAMBDA (X) (BLOCK FOO X)), false, FOO\nOR=> (SI::BLOCK-LAMBDA FOO (X) X), false, FOO\n \n (defun foo ()\n   (flet ((bar (x) x))\n     #'bar))\n (function-lambda-expression (foo))\n\u2192 NIL, false, NIL\nOR=> NIL, true, NIL\nOR=> (LAMBDA (X) (BLOCK BAR X)), true, NIL\nOR=> (LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)\nOR=> (LAMBDA (X) (BLOCK BAR X)), false, \"BAR in FOO\"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (functionp 'append) \u2192 NIL\n (functionp #'append) \u2192 T\n (functionp (symbol-function 'append)) \u2192 T\n (flet ((f () 1)) (functionp #'f)) \u2192 T\n (functionp (compile nil '(lambda () 259))) \u2192 T\n (functionp nil) \u2192 NIL\n (functionp 12) \u2192 NIL\n (functionp '(lambda (x) (* x x))) \u2192 NIL\n (functionp #'(lambda (x) (* x x))) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (functionp \\param{object}) \\EQ (typep \\param{object} 'function)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun f (x) x) \u2192 F\n (compiled-function-p #'f)\n\u2192 NIL\nOR=> true\n (compiled-function-p 'f) \u2192 NIL\n (compile 'f) \u2192 F\n (compiled-function-p #'f) \u2192 T\n (compiled-function-p 'f) \u2192 NIL\n (compiled-function-p (compile nil '(lambda (x) x)))\n\u2192 T\n (compiled-function-p #'(lambda (x) x))\n\u2192 NIL\nOR=> true\n (compiled-function-p '(lambda (x) x)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (compiled-function-p \\param{object}) \\EQ (typep \\param{object} 'compiled-function)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (declaim (special \\i{name}))\n%  (setf (symbol-value '\\i{name}) \\i{initial-value})\n%  (setf (documentation '\\i{name} 'variable) '\\i{documentation})\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (symbol-value '\\i{name}) \\i{initial-value})\n (setf (documentation '\\i{name} 'variable) '\\i{documentation})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defconstant this-is-a-constant 'never-changing \"for a test\") \u2192 THIS-IS-A-CONSTANT\nthis-is-a-constant \u2192 NEVER-CHANGING\n (documentation 'this-is-a-constant 'variable) \u2192 \"for a test\"\n (constantp 'this-is-a-constant) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defparameter *p* 1) \u2192 *P*\n *p* \u2192 1\n (constantp '*p*) \u2192 NIL\n (setq *p* 2) \u2192 2\n (defparameter *p* 3) \u2192 *P*\n *p* \u2192 3\n\n (defvar *v* 1) \u2192 *V*\n *v* \u2192 1\n (constantp '*v*) \u2192 NIL\n (setq *v* 2) \u2192 2\n (defvar *v* 3) \u2192 *V*\n *v* \u2192 2\n\n (defun foo ()\n   (let ((*p* 'p) (*v* 'v))\n     (bar))) \u2192 FOO\n (defun bar () (list *p* *v*)) \u2192 BAR\n (foo) \u2192 (P V)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defvar *the-interesting-numbers* '())\n (defmacro define-interesting-number (name n)\n   `(progn (defvar ,name ,n)\n           (pushnew ,name *the-interesting-numbers*)\n           ',name))\n (define-interesting-number *my-height* 168) ;cm\n (define-interesting-number *my-weight* 13)  ;stones\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defparameter *default-beep-count* 3)\n (defun beep (&optional (n *default-beep-count*))\n   (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro defparameter (name initial-value \n                         &optional (documentation nil documentation-p))\n   `(progn (declaim (special ,name))\n           (setf (symbol-value ',name) ,initial-value)\n           ,(when documentation-p\n              `(setf (documentation ',name 'variable) ',documentation))\n           ',name))\n (defmacro defvar (name &optional\n                        (initial-value nil initial-value-p)\n                        (documentation nil documentation-p))\n   `(progn (declaim (special ,name))\n           ,(when initial-value-p\n              `(unless (boundp ',name)\n                 (setf (symbol-value ',name) ,initial-value)))\n           ,(when documentation-p\n              `(setf (documentation ',name 'variable) ',documentation))\n           ',name))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun iota (n) (loop for i from 1 to n collect i))       ;helper\n (destructuring-bind ((a &optional (b 'bee)) one two three)\n     `((alpha) ,@(iota 3))\n   (list a b three two one)) \u2192 (ALPHA BEE 3 2 1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((\\param{var1} \\param{init-form-1})\n       (\\param{var2} \\param{init-form-2})\n       ...\n       (\\param{varm} \\param{init-form-m}))\n   \\param{declaration1}\n   \\param{declaration2}\n   ...\n   \\param{declarationp}\n   \\param{form1}\n   \\param{form2}\n   ...\n   \\param{formn})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let* ((\\param{var1} \\param{init-form-1})\n        (\\param{var2} \\param{init-form-2})\n        ...\n        (\\param{varm} \\param{init-form-m}))\n   \\param{declaration1}\n   \\param{declaration2}\n   ...\n   \\param{declarationp}\n   \\param{form1}\n   \\param{form2}\n   ...\n   \\param{formn})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (locally (declare (special x) (float y)) \n%   (let ((x 5) (y 10)) \n%     (print (+ x y))))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a \'top) \u2192 TOP\n (defun dummy-function () a) \u2192 DUMMY-FUNCTION\n (let ((a \'inside) (b a))\n    (format nil "~S ~S ~S" a b (dummy-function))) \u2192 "INSIDE TOP TOP" \n (let* ((a \'inside) (b a))\n    (format nil "~S ~S ~S" a b (dummy-function))) \u2192 "INSIDE INSIDE TOP" \n (let ((a \'inside) (b a))\n    (declare (special a))\n    (format nil "~S ~S ~S" a b (dummy-function))) \u2192 "INSIDE TOP INSIDE"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let (x)\n   (declare (integer x))\n   (setq x (gcd y z))\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq *x* 1) \u2192 1\n (progv '(*x*) '(2) *x*) \u2192 2\n *x* \u2192 1\n\nAssuming *x* is not globally special,\n\n (let ((*x* 3)) \n    (progv '(*x*) '(4) \n      (list *x* (symbol-value '*x*)))) \u2192 (3 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; A simple use of SETQ to establish values for variables.\n (setq a 1 b 2 c 3) \u2192 3\n a \u2192 1\n b \u2192 2\n c \u2192 3\n\n ;; Use of SETQ to update values by sequential assignment.\n (setq a (1+ b) b (1+ a) c (+ a b)) \u2192 7\n a \u2192 3\n b \u2192 4\n c \u2192 7\n\n ;; This illustrates the use of SETQ on a symbol macro.\n (let ((x (list 10 20 30)))\n   (symbol-macrolet ((y (car x)) (z (cadr x)))\n     (setq y (1+ z) z (1+ y))\n     (list x y z)))\n\u2192 ((21 22 30) 21 22)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; A simple use of PSETQ to establish values for variables.\n ;; As a matter of style, many programmers would prefer SETQ \n ;; in a simple situation like this where parallel assignment\n ;; is not needed, but the two have equivalent effect.\n (psetq a 1 b 2 c 3) \u2192 NIL\n a \u2192 1\n b \u2192 2\n c \u2192 3\n\n ;; Use of PSETQ to update values by parallel assignment.\n ;; The effect here is very different than if SETQ had been used.\n (psetq a (1+ b) b (1+ a) c (+ a b)) \u2192 NIL\n a \u2192 3\n b \u2192 2\n c \u2192 3\n\n ;; Use of PSETQ on a symbol macro.\n (let ((x (list 10 20 30)))\n   (symbol-macrolet ((y (car x)) (z (cadr x)))\n     (psetq y (1+ z) z (1+ y))\n     (list x y z)))\n\u2192 ((21 11 30) 21 11)\n\n ;; Use of parallel assignment to swap values of A and B.\n (let ((a 1) (b 2))\n   (psetq a b  b a)\n   (values a b))\n\u2192 2, 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (block loser\n%    (catch 'stuff\n%       (mapcar #'(lambda (x) (if (numberp x)\n%                                 (hairyfun x)\n%                                 (return-from loser \\nil)))\n%                 items)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block empty) \u2192 NIL\n (block whocares (values 1 2) (values 3 4)) \u2192 3, 4\n (let ((x 1)) \n   (block stop (setq x 2) (return-from stop) (setq x 3))\n   x) \u2192 2\n (block early (return-from early (values 1 2)) (values 3 4)) \u2192 1, 2\n (block outer (block inner (return-from outer 1)) 2) \u2192 1\n (block twin (block twin (return-from twin 1)) 2) \u2192 2\n ;; Contrast behavior of this example with corresponding example of CATCH.\n (block b\n   (flet ((b1 () (return-from b 1)))\n     (block b (b1) (print 'unreachable))\n     2)) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) \u2192 3\n (catch 'dummy-tag 1 2 3 4) \u2192 4\n (defun throw-back (tag) (throw tag t)) \u2192 THROW-BACK\n (catch 'dummy-tag (throw-back 'dummy-tag) 2) \u2192 T\n\n ;; Contrast behavior of this example with corresponding example of BLOCK.\n (catch 'c\n   (flet ((c1 () (throw 'c 1)))\n     (catch 'c (c1) (print 'unreachable))\n     2)) \u2192 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (tagbody\n   (setq val 2)\n   (go lp)\n   (incf val 3)\n   lp (incf val 4)) \u2192 NIL\n val \u2192 6 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((a nil)) \n   (tagbody t (setq a #'(lambda () (go t))))\n   (funcall a))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall (block nil\n            (tagbody a (return #'(lambda () (go a))))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block alpha (return-from alpha) 1) \u2192 NIL\n (block alpha (return-from alpha 1) 2) \u2192 1\n (block alpha (return-from alpha (values 1 2)) 3) \u2192 1, 2\n (let ((a 0))\n    (dotimes (i 10) (incf a) (when (oddp i) (return)))\n    a) \u2192 2\n (defun temp (x)\n    (if x (return-from temp 'dummy))\n    44) \u2192 TEMP\n (temp nil) \u2192 44\n (temp t) \u2192 DUMMY\n (block out\n   (flet ((exit (n) (return-from out n)))\n     (block out (exit 1)))\n   2) \u2192 1\n (block nil   \n   (unwind-protect (return-from nil 1)\n     (return-from nil 2)))\n\u2192 2\n (dolist (flag '(nil t))\n   (block nil\n     (let ((x 5))\n       (declare (special x))\n       (unwind-protect (return-from nil)\n         (print x))))\n   (print 'here))\n\\OUT 5\n\\OUT HERE\n\\OUT 5\n\\OUT HERE\n\u2192 NIL\n (dolist (flag '(nil t))\n   (block nil\n     (let ((x 5))\n       (declare (special x))\n       (unwind-protect\n           (if flag (return-from nil))\n         (print x))))\n   (print 'here))\n\\OUT 5\n\\OUT HERE\n\\OUT 5\n\\OUT HERE\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall (block nil #'(lambda () (return-from nil)))) is an error.\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block nil (return) 1) \u2192 NIL\n (block nil (return 1) 2) \u2192 1\n (block nil (return (values 1 2)) 3) \u2192 1, 2\n (block nil (block alpha (return 1) 2)) \u2192 1\n (block alpha (block nil (return 1)) 2) \u2192 2\n (block nil (block nil (return 1) 2)) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (return) \\EQ (return-from nil)\n (return \\param{form}) \\EQ (return-from nil \\param{form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let (val)\n    (tagbody\n      (setq val 1)\n      (go point-a)\n      (incf val 16)\n     point-c\n      (incf val 04)\n      (go point-b)\n      (incf val 32)\n     point-a\n      (incf val 02)\n      (go point-c)\n      (incf val 64)\n     point-b\n      (incf val 08))\n    val)\n\u2192 15\n (defun f1 (flag)\n   (let ((n 1))\n     (tagbody \n       (setq n (f2 flag #'(lambda () (go out))))\n      out\n       (prin1 n))))\n\u2192 F1\n (defun f2 (flag escape)\n   (if flag (funcall escape) 2))\n\u2192 F2\n (f1 nil)\n\\OUT 2\n\u2192 NIL\n (f1 t)\n\\OUT 1\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (catch 'result\n    (setq i 0 j 0)\n    (loop (incf j 3) (incf i)\n          (if (= i 3) (throw 'result (values i j))))) \u2192 3, 9\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (catch nil \n   (unwind-protect (throw nil 1)\n     (throw nil 2))) \u2192 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (catch 'a\n   (catch 'b\n     (unwind-protect (throw 'a 1)\n       (throw 'b 2))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (catch 'foo\n         (format t \"The inner catch returns ~s.~%\"\n                 (catch 'foo\n                     (unwind-protect (throw 'foo :first-throw)\n                         (throw 'foo :second-throw))))\n         :outer-catch)\n\\OUT The inner catch returns :SECOND-THROW\n\u2192 :OUTER-CATCH\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (catch 'foo\n%    (catch 'bar\n%        (unwind-protect (throw 'foo 3)\n%          (throw 'bar 4)\n%          (print 'xxx))))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (tagbody\n   (let ((x 3))\n     (unwind-protect\n       (if (numberp x) (go out))\n       (print x)))\n  out\n   ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun dummy-function (x)\n    (setq state 'running)\n    (unless (numberp x) (throw 'abort 'not-a-number))\n    (setq state (1+ x))) \u2192 DUMMY-FUNCTION\n (catch 'abort (dummy-function 1)) \u2192 2\n state \u2192 2\n (catch 'abort (dummy-function 'trash)) \u2192 NOT-A-NUMBER\n state \u2192 RUNNING\n (catch 'abort (unwind-protect (dummy-function 'trash) \n                  (setq state 'aborted))) \u2192 NOT-A-NUMBER\n state \u2192 ABORTED\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (unwind-protect\n   (progn (incf *access-count*)\n          (perform-access))\n   (decf *access-count*))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((old-count *access-count*))\n   (unwind-protect\n     (progn (incf *access-count*)\n            (perform-access))\n     (setq *access-count* old-count)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; The following returns 2.\n (block nil   \n   (unwind-protect (return 1)\n     (return 2)))\n \n;;; The following has undefined consequences.\n (block a    \n   (block b\n     (unwind-protect (return-from a 1)\n       (return-from b 2))))\n \n;;; The following returns 2.\n (catch nil \n   (unwind-protect (throw nil 1)\n     (throw nil 2)))\n \n;;; The following has undefined consequences because the catch of B is \n;;; passed over by the first THROW, hence portable programs must assume \n;;; its dynamic extent is terminated.  The binding of the catch tag is not\n;;; yet disestablished and therefore it is the target of the second throw.\n (catch 'a\n   (catch 'b\n     (unwind-protect (throw 'a 1)\n       (throw 'b 2))))\n \n;;; The following prints \"The inner catch returns :SECOND-THROW\"\n;;; and then returns :OUTER-CATCH.\n (catch 'foo\n         (format t \"The inner catch returns ~s.~%\"\n                 (catch 'foo\n                     (unwind-protect (throw 'foo :first-throw)\n                         (throw 'foo :second-throw))))\n         :outer-catch)\n \n \n;;; The following returns 10. The inner CATCH of A is passed over, but \n;;; because that CATCH is disestablished before the THROW to A is executed,\n;;; it isn't seen.\n (catch 'a\n   (catch 'b\n     (unwind-protect (1+ (catch 'a (throw 'b 1)))\n       (throw 'a 10))))\n \n \n;;; The following has undefined consequences because the extent of\n;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)\n;;; commences.\n (catch 'foo\n   (catch 'bar\n       (unwind-protect (throw 'foo 3)\n         (throw 'bar 4)\n         (print 'xxx))))\n \n \n;;; The following returns 4; XXX is not printed.\n;;; The (THROW 'FOO ...) has no effect on the scope of the BAR\n;;; catch tag or the extent of the (CATCH 'BAR ...) exit.\n (catch 'bar\n   (catch 'foo\n       (unwind-protect (throw 'foo 3)\n         (throw 'bar 4)\n         (print 'xxx))))\n \n \n;;; The following prints 5.\n (block nil\n   (let ((x 5))\n     (declare (special x))\n     (unwind-protect (return)\n       (print x))))          \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" nil \u2192 NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (not nil) \u2192 T\n (not '()) \u2192 T\n (not (integerp 'sss)) \u2192 T\n (not (integerp 1)) \u2192 NIL\n (not 3.7) \u2192 NIL\n (not 'apple) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (not x) \\EQ (null x)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" t \u2192 T \n (eq t 't) \u2192 T\n (find-class 't) \u2192 #<CLASS T 610703333>\n (case 'a (a 1) (t 2)) \u2192 1\n (case 'b (a 1) (t 2)) \u2192 2\n (prin1 'hello t)\n\\OUT HELLO\n\u2192 HELLO\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (eq \'a \'b) \u2192 NIL\n (eq \'a \'a) \u2192 T\n (eq 3 3)\n\u2192 T\nOR=> false\n (eq 3 3.0) \u2192 NIL\n (eq 3.0 3.0)\n\u2192 T\nOR=> false\n (eq #c(3 -4) #c(3 -4))\n\u2192 T\nOR=> false\n (eq #c(3 -4.0) #c(3 -4)) \u2192 NIL\n (eq (cons \'a \'b) (cons \'a \'c)) \u2192 NIL\n (eq (cons \'a \'b) (cons \'a \'b)) \u2192 NIL\n (eq \'(a . b) \'(a . b))\n\u2192 T\nOR=> false\n (progn (setq x (cons \'a \'b)) (eq x x)) \u2192 T\n (progn (setq x \'(a . b)) (eq x x)) \u2192 T\n (eq #\\A #\\A)\n\u2192 T\nOR=> false\n (let ((x "Foo")) (eq x x)) \u2192 T\n (eq "Foo" "Foo")\n\u2192 T\nOR=> false\n (eq "Foo" (copy-seq "Foo")) \u2192 NIL\n (eq "FOO" "foo") \u2192 NIL\n (eq "string-seq" (copy-seq "string-seq")) \u2192 NIL\n (let ((x 5)) (eq x x))\n\u2192 T\nOR=> false\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (eql 'a 'b) \u2192 NIL\n (eql 'a 'a) \u2192 T\n (eql 3 3) \u2192 T\n (eql 3 3.0) \u2192 NIL\n (eql 3.0 3.0) \u2192 T\n (eql #c(3 -4) #c(3 -4)) \u2192 T\n (eql #c(3 -4.0) #c(3 -4)) \u2192 NIL\n (eql (cons 'a 'b) (cons 'a 'c)) \u2192 NIL\n (eql (cons 'a 'b) (cons 'a 'b)) \u2192 NIL\n (eql '(a . b) '(a . b))\n\u2192 T\nOR=> false\n (progn (setq x (cons 'a 'b)) (eql x x)) \u2192 T\n (progn (setq x '(a . b)) (eql x x)) \u2192 T\n (eql #\\A #\\A) \u2192 T\n (eql \"Foo\" \"Foo\")\n\u2192 T\nOR=> false\n (eql \"Foo\" (copy-seq \"Foo\")) \u2192 NIL\n (eql \"FOO\" \"foo\") \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (equal \'a \'b) \u2192 NIL\n (equal \'a \'a) \u2192 T\n (equal 3 3) \u2192 T\n (equal 3 3.0) \u2192 NIL\n (equal 3.0 3.0) \u2192 T\n (equal #c(3 -4) #c(3 -4)) \u2192 T\n (equal #c(3 -4.0) #c(3 -4)) \u2192 NIL\n (equal (cons \'a \'b) (cons \'a \'c)) \u2192 NIL\n (equal (cons \'a \'b) (cons \'a \'b)) \u2192 T\n (equal #\\A #\\A) \u2192 T\n (equal #\\A #\\a) \u2192 NIL\n (equal "Foo" "Foo") \u2192 T\n (equal "Foo" (copy-seq "Foo")) \u2192 T\n (equal "FOO" "foo") \u2192 NIL\n (equal "This-string" "This-string") \u2192 T\n (equal "This-string" "this-string") \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (equalp 'a 'b) \u2192 NIL\n (equalp 'a 'a) \u2192 T\n (equalp 3 3) \u2192 T\n (equalp 3 3.0) \u2192 T\n (equalp 3.0 3.0) \u2192 T\n (equalp #c(3 -4) #c(3 -4)) \u2192 T\n (equalp #c(3 -4.0) #c(3 -4)) \u2192 T\n (equalp (cons 'a 'b) (cons 'a 'c)) \u2192 NIL\n (equalp (cons 'a 'b) (cons 'a 'b)) \u2192 T\n (equalp #\\A #\\A) \u2192 T\n (equalp #\\A #\\a) \u2192 T\n (equalp \"Foo\" \"Foo\") \u2192 T\n (equalp \"Foo\" (copy-seq \"Foo\")) \u2192 T\n (equalp \"FOO\" \"foo\") \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq array1 (make-array 6 :element-type 'integer\n                            :initial-contents '(1 1 1 3 5 7))) \n\u2192 #(1 1 1 3 5 7)\n (setq array2 (make-array 8 :element-type 'integer\n                            :initial-contents '(1 1 1 3 5 7 2 6)\n                            :fill-pointer 6))\n\u2192 #(1 1 1 3 5 7)\n (equalp array1 array2) \u2192 T\n (setq vector1 (vector 1 1 1 3 5 7)) \u2192 #(1 1 1 3 5 7)\n (equalp array1 vector1) \u2192 T \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (identity 101) \u2192 101\n (mapcan #'identity (list (list 1 2 3) '(4 5 6))) \u2192 (1 2 3 4 5 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun identity (x) x)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (funcall (complement #'zerop) 1) \u2192 T\n (funcall (complement #'characterp) #\\A) \u2192 NIL\n (funcall (complement #'member) 'a '(a b c)) \u2192 NIL\n (funcall (complement #'member) 'd '(a b c)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (complement \\i{x}) \\EQ #'(lambda (&rest arguments) (not (apply \\i{x} arguments)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(\\i{xxx}-if-not \\i{f} . \\i{arguments}) \\EQ (\\i{xxx}-if (complement \\i{f}) . \\i{arguments})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find-if-not #'zerop '(0 0 3)) \\EQ\n (find-if (complement #'zerop) '(0 0 3)) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mapcar (constantly 3) '(a b c d)) \u2192 (3 3 3 3)\n (defmacro with-vars (vars &body forms)\n   `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))\n\u2192 WITH-VARS\n (macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))\n\u2192 ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun constantly (object)\n   #'(lambda (&rest arguments) object))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (every #'characterp \"abc\") \u2192 T\n (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) \u2192 T\n (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) \u2192 NIL\n (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) \u2192 T \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (notany \\param{predicate} \\starparam{sequence}) \\EQ (not (some \\param{predicate} \\starparam{sequence}))\n (notevery \\param{predicate} \\starparam{sequence}) \\EQ (not (every \\param{predicate} \\starparam{sequence}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (if (and (>= n 0)\n          (< n (length a-simple-vector))\n          (eq (elt a-simple-vector n) \'foo))\n     (princ "Foo!"))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq temp1 1 temp2 1 temp3 1) \u2192 1 \n (and (incf temp1) (incf temp2) (incf temp3)) \u2192 2 \n (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) \u2192 T\n (decf temp3) \u2192 1 \n (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) \u2192 NIL \n (and (eql temp1 temp2) (eql temp2 temp3)) \u2192 T\n (and) \u2192 T \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (and \\param{form}) \\EQ \\param{form}\n% (and \\param{form1} \\param{form2} ...) \\EQ (when \\param{form1} (and \\param{form2} ...))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (and \\param{form}) \\EQ (let () \\param{form})\n (and \\param{form1} \\param{form2} ...) \\EQ (when \\param{form1} (and \\param{form2} ...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun select-options ()\n   (cond ((= a 1) (setq a 2))\n         ((= a 2) (setq a 3))\n         ((and (= a 3) (floor a 2)))\n         (t (floor a 3)))) \u2192 SELECT-OPTIONS\n (setq a 1) \u2192 1\n (select-options) \u2192 2\n a \u2192 2\n (select-options) \u2192 3\n a \u2192 3\n (select-options) \u2192 1\n (setq a 5) \u2192 5\n (select-options) \u2192 1, 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (if t 1) \u2192 1\n (if nil 1 2) \u2192 2 \n (defun test ()\n   (dolist (truth-value '(t nil 1 (a b c)))\n     (if truth-value (print 'true) (print 'false))\n     (prin1 truth-value))) \u2192 TEST\n (test)\n\\OUT TRUE T\n\\OUT FALSE NIL\n\\OUT TRUE 1\n\\OUT TRUE (A B C)\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (if \\param{test-form} \\param{then-form} \\param{else-form})\n \\EQ (cond (\\param{test-form} \\param{then-form}) (t \\param{else-form}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (or) \u2192 NIL \n (setq temp0 nil temp1 10 temp2 20 temp3 30) \u2192 30\n (or temp0 temp1 (setq temp2 37)) \u2192 10\n temp2 \u2192 20\n (or (incf temp1) (incf temp2) (incf temp3)) \u2192 11\n temp1 \u2192 11\n temp2 \u2192 20\n temp3 \u2192 30\n (or (values) temp1) \u2192 11\n (or (values temp1 temp2) temp3) \u2192 11\n (or temp0 (values temp1 temp2)) \u2192 11, 20\n (or (values temp0 temp1) (values temp2 temp3)) \u2192 20, 30\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (when t 'hello) \u2192 HELLO\n (unless t 'hello) \u2192 NIL\n (when nil 'hello) \u2192 NIL\n (unless nil 'hello) \u2192 HELLO\n (when t) \u2192 NIL\n (unless nil) \u2192 NIL\n (when t (prin1 1) (prin1 2) (prin1 3))\n\\OUT 123\n\u2192 3\n (unless t (prin1 1) (prin1 2) (prin1 3)) \u2192 NIL\n (when nil (prin1 1) (prin1 2) (prin1 3)) \u2192 NIL\n (unless nil (prin1 1) (prin1 2) (prin1 3))\n\\OUT 123\n\u2192 3\n (let ((x 3))\n   (list (when (oddp x) (incf x) (list x))\n         (when (oddp x) (incf x) (list x))\n         (unless (oddp x) (incf x) (list x))\n         (unless (oddp x) (incf x) (list x))\n         (if (oddp x) (incf x) (list x)) \n         (if (oddp x) (incf x) (list x)) \n         (if (not (oddp x)) (incf x) (list x)) \n         (if (not (oddp x)) (incf x) (list x))))\n\u2192 ((4) NIL (5) NIL 6 (6) 7 (7))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (when \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (and \\param{test} (progn \\plus{\\curly{\\param{form}}}))\n (when \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (cond (\\param{test} \\plus{\\curly{\\param{form}}}))\n (when \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (if \\param{test} (progn \\plus{\\curly{\\param{form}}}) nil)\n (when \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (unless (not \\param{test}) \\plus{\\curly{\\param{form}}})\n (unless \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (cond ((not \\param{test}) \\plus{\\curly{\\param{form}}}))\n (unless \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (if \\param{test} nil (progn \\plus{\\curly{\\param{form}}}))\n (unless \\param{test} \\plus{\\curly{\\param{form}}}) \\EQ (when (not \\param{test}) \\plus{\\curly{\\param{form}}})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (dolist (k '(1 2 3 :four #\\v () t 'other))\n    (format t \"~S \"\n       (case k ((1 2) 'clause1)\n               (3 'clause2)\n               (nil 'no-keys-so-never-seen)\n               ((nil) 'nilslot)\n               ((:four #\\v) 'clause4)\n               ((t) 'tslot)\n               (otherwise 'others)))) \n\\OUT CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS \n\u2192 NIL\n (defun add-em (x) (apply #'+ (mapcar #'decode x)))\n\u2192 ADD-EM\n (defun decode (x)\n   (ccase x\n     ((i uno) 1)\n     ((ii dos) 2)\n     ((iii tres) 3)\n     ((iv cuatro) 4)))\n\u2192 DECODE\n (add-em '(uno iii)) \u2192 4\n (add-em '(uno iiii))\n\\OUT Error: The value of X, IIII, is not I, UNO, II, DOS, III,\n\\OUT        TRES, IV, or CUATRO.\n\\OUT  1: Supply a value to use instead.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Value to evaluate and use for X: \\IN{'IV}\n\u2192 5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(case \\param{test-key}\n  \\star{\\curly{((\\starparam{key}) \\starparam{form})}})\n\\EQ\n(let ((#1=#:g0001 \\param{test-key}))\n  (cond \\star{\\curly{((member #1# '(\\starparam{key})) \\starparam{form})}}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';;; (Note that the parts of this example which use TYPE-OF \n;;;  are implementation-dependent.)\n (defun what-is-it (x)\n   (format t "~&~S is ~A.~%"\n           x (typecase x\n               (float "a float")\n               (null "a symbol, boolean false, or the empty list")\n               (list "a list")\n               (t (format nil "a(n) ~(~A~)" (type-of x))))))\n\u2192 WHAT-IS-IT\n (map \'nil #\'what-is-it \'(nil (a b) 7.0 7 box))\n\\OUT NIL is a symbol, boolean false, or the empty list.\n\\OUT (A B) is a list.\n\\OUT 7.0 is a float.\n\\OUT 7 is a(n) integer.\n\\OUT BOX is a(n) symbol.\n\u2192 NIL\n (setq x 1/3)\n\u2192 1/3\n (ctypecase x\n     (integer (* x 4))\n     (symbol  (symbol-value x)))\n\\OUT Error: The value of X, 1/3, is neither an integer nor a symbol.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Use value: \\IN{3.7}\n\\OUT Error: The value of X, 3.7, is neither an integer nor a symbol.\n\\OUT To continue, type :CONTINUE followed by an option number:\n\\OUT  1: Specify a value to use instead.\n\\OUT  2: Return to Lisp Toplevel.\n\\OUT Debug> \\IN{:CONTINUE 1}\n\\OUT Use value: \\IN{12}\n\u2192 48\n x \u2192 12\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(typecase \\param{test-key}\n  \\star{\\curly{(\\param{type} \\starparam{form})}})\n\\EQ\n(let ((#1=#:g0001 \\param{test-key}))\n  (cond \\star{\\curly{((typep #1# '\\param{type}) \\starparam{form})}}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-bind (f r) \n     (floor 130 11)\n   (list f r)) \u2192 (11 9)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-bind (\\starparam{var}) \\param{values-form} \\starparam{form})\n \\EQ (multiple-value-call #'(lambda (&optional \\starparam{var} &rest #1=#:ignore)\n                             (declare (ignore #1#))\n                             \\starparam{form})\n                         \\param{values-form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-call #'list 1 '/ (values 2 3) '/ (values) '/ (floor 2.5))\n\u2192 (1 / 2 3 / / 2 0.5)\n (+ (floor 5 3) (floor 19 4)) \\EQ (+ 1 4)\n\u2192 5\n (multiple-value-call #'+ (floor 5 3) (floor 19 4)) \\EQ (+ 1 2 4 3)\n\u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-list (floor -3 4)) \u2192 (-1 1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-list form) \\EQ (multiple-value-call #'list form)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq temp '(1 2 3)) \u2192 (1 2 3)\n (multiple-value-prog1\n    (values-list temp)\n    (setq temp nil)\n    (values-list temp)) \u2192 1, 2, 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-setq (\\i{symbol}\\subOne ... \\i{symbol}\\subN) \\i{value-producing-form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (values (setf (values \\i{symbol}\\subOne ... \\i{symbol}\\subN) \\i{value-producing-form}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-setq (quotient remainder) (truncate 3.2 2)) \u2192 1\n quotient \u2192 1\n remainder \u2192 1.2\n (multiple-value-setq (a b c) (values 1 2)) \u2192 1\n a \u2192 1\n b \u2192 2\n c \u2192 NIL\n (multiple-value-setq (a b) (values 4 5 6)) \u2192 4\n a \u2192 4\n b \u2192 5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (values) \u2192 \\novalues\n (values 1) \u2192 1\n (values 1 2) \u2192 1, 2\n (values 1 2 3) \u2192 1, 2, 3\n (values (values 1 2 3) 4 5) \u2192 1, 4, 5\n (defun polar (x y)\n   (values (sqrt (+ (* x x) (* y y))) (atan y x))) \u2192 POLAR\n (multiple-value-bind (r theta) (polar 3.0 4.0)\n   (vector r theta))\n\u2192 #(5.0 0.927295)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (x y)\n   (floor (+ x y) y)) \u2192 FOO\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun foo (x y)\n   (values (floor (+ x y) y))) \u2192 FOO\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (values-list nil) \u2192 \\novalues\n (values-list '(1)) \u2192 1\n (values-list '(1 2)) \u2192 1, 2\n (values-list '(1 2 3)) \u2192 1, 2, 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (values-list \\param{list}) \\EQ (apply #'values \\param{list})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nth-value 0 (values 'a 'b)) \u2192 A\n (nth-value 1 (values 'a 'b)) \u2192 B\n (nth-value 2 (values 'a 'b)) \u2192 NIL\n (let* ((x 83927472397238947423879243432432432)\n        (y 32423489732)\n        (a (nth-value 1 (floor x y)))\n        (b (mod x y)))\n   (values a b (= a b)))\n\u2192 3332987528, 3332987528, true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (nth-value \\param{n} \\param{form}) \\EQ (nth \\param{n} (multiple-value-list \\param{form}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))\n       \\starparam{declaration}\n       statement1\n  tag1\n       statement2\n       statement3\n       statement4\n  tag2\n       statement5\n       ...\n       )\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(prog* ((y z) (x (car y)))\n       (return x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a 1) \u2192 1\n (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) \u2192 /=\n (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) \u2192 =\n (prog () 'no-return-value) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun king-of-confusion (w)\n   "Take a cons of two lists and make a list of conses.\n    Think of this function as being like a zipper."\n   (prog (x y z)          ;Initialize x, y, z to NIL\n        (setq y (car w) z (cdr w))\n    loop\n        (cond ((null y) (return x))\n              ((null z) (go err)))\n    rejoin\n        (setq x (cons (cons (car y) (car z)) x))\n        (setq y (cdr y) z (cdr z))\n        (go loop)\n    err\n        (cerror "Will self-pair extraneous items"\n                "Mismatch - gleep!  ~S" y)\n        (setq z y)\n        (go rejoin))) \u2192 KING-OF-CONFUSION \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun prince-of-clarity (w)\n   "Take a cons of two lists and make a list of conses.\n    Think of this function as being like a zipper."\n   (do ((y (car w) (cdr y))\n        (z (cdr w) (cdr z))\n        (x \'\\empty (cons (cons (car y) (car z)) x)))\n       ((null y) x)\n     (when (null z)\n       (cerror "Will self-pair extraneous items"\n              "Mismatch - gleep!  ~S" y)\n       (setq z y)))) \u2192 PRINCE-OF-CLARITY \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (prog \\param{variable-list} \\param{declaration} . \\param{body})\n    \\EQ (block nil (let \\param{variable-list} \\param{declaration} (tagbody . \\param{body})))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq temp 1) \u2192 1\n (prog1 temp (print temp) (incf temp) (print temp))\n\\OUT 1\n\\OUT 2\n\u2192 1\n (prog1 temp (setq temp nil)) \u2192 2\n temp \u2192 NIL\n (prog1 (values 1 2 3) 4) \u2192 1 \n (setq temp (list 'a 'b 'c))\n (prog1 (car temp) (setf (car temp) 'alpha)) \u2192 A\n temp \u2192 (ALPHA B C)\n (flet ((swap-symbol-values (x y)\n          (setf (symbol-value x) \n                (prog1 (symbol-value y)\n                       (setf (symbol-value y) (symbol-value x))))))\n   (let ((*foo* 1) (*bar* 2))\n     (declare (special *foo* *bar*))\n     (swap-symbol-values '*foo* '*bar*)\n     (values *foo* *bar*)))\n\u2192 2, 1\n (setq temp 1) \u2192 1\n (prog2 (incf temp) (incf temp) (incf temp)) \u2192 3\n temp \u2192 4\n (prog2 1 (values 2 3 4) 5) \u2192 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (prog1 \\starparam{form}) \\EQ (values (multiple-value-prog1 \\starparam{form}))\n% (prog2 \\param{form1} \\starparam{form}) \\EQ (progn \\param{form1} (prog1 \\starparam{form}))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (prog1 \\starparam{form}) \\EQ (values (multiple-value-prog1 \\starparam{form}))\n (prog2 \\param{form1} \\starparam{form}) \\EQ (let () \\param{form1} (prog1 \\starparam{form}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (progn) \u2192 NIL\n (progn 1 2 3) \u2192 3\n (progn (values 1 2 3)) \u2192 1, 2, 3\n (setq a 1) \u2192 1\n (if a\n      (progn (setq a nil) 'here)\n      (progn (setq a t) 'there)) \u2192 HERE\n a \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmacro \\param{name} (reference . \\param{lambda-list})\n   \\param{documentation}\n   \\bq(setf ,reference\n          (\\param{function} ,reference ,\\i{arg1} ,\\i{arg2} ...)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (define-modify-macro appendf (&rest args) \n    append \"Append onto list\") \u2192 APPENDF\n (setq x '(a b c) y x) \u2192 (A B C)\n (appendf x '(d e f) '(1 2 3)) \u2192 (A B C D E F 1 2 3)\n x \u2192 (A B C D E F 1 2 3)\n y \u2192 (A B C)\n (define-modify-macro new-incf (&optional (delta 1)) +)\n (define-modify-macro unionf (other-set &rest keywords) union)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defsetf access-fn update-fn \\lbracket\\ doc-string\\rbracket)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defsetf access-fn lambda-list (store-variable) . body)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defsetf symbol-value set)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defsetf car rplaca)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) \u2192 MIDDLEGUY\n (defun set-middleguy (x v)\n    (unless (null x)\n      (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))\n    v) \u2192 SET-MIDDLEGUY\n (defsetf middleguy set-middleguy) \u2192 MIDDLEGUY\n (setq a (list 'a 'b 'c 'd)\n       b (list 'x)\n       c (list 1 2 3 (list 4 5 6) 7 8 9)) \u2192 (1 2 3 (4 5 6) 7 8 9)\n (setf (middleguy a) 3) \u2192 3\n (setf (middleguy b) 7) \u2192 7\n (setf (middleguy (middleguy c)) 'middleguy-symbol) \u2192 MIDDLEGUY-SYMBOL\n a \u2192 (A 3 C D)\n b \u2192 (7)\n c \u2192 (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defsetf subseq (sequence start &optional end) (new-sequence)\n   `(progn (replace ,sequence ,new-sequence\n                    :start1 ,start :end1 ,end)\n           ,new-sequence)) \u2192 SUBSEQ\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defvar *xy* (make-array '(10 10)))\n (defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) \u2192 XY\n (defun set-xy (new-value &key ((x x) 0) ((y y) 0))\n   (setf (aref *xy* x y) new-value)) \u2192 SET-XY\n (defsetf xy (&key ((x x) 0) ((y y) 0)) (store)\n   `(set-xy ,store 'x ,x 'y ,y)) \u2192 XY\n (get-setf-expansion '(xy a b))\n\u2192 (#:t0 #:t1),\n   (a b),\n   (#:store),\n   ((lambda (&key ((x #:x)) ((y #:y))) \n      (set-xy #:store 'x #:x 'y #:y))\n    #:t0 #:t1),\n   (xy #:t0 #:t1)\n (xy 'x 1) \u2192 NIL\n (setf (xy 'x 1) 1) \u2192 1\n (xy 'x 1) \u2192 1\n (let ((a 'x) (b 'y))\n   (setf (xy a 1 b 2) 3)\n   (setf (xy b 5 a 9) 14))\n\u2192 14\n (xy 'y 0 'x 1) \u2192 1\n (xy 'x 1 'y 2) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun lastguy (x) (car (last x))) \u2192 LASTGUY\n (define-setf-expander lastguy (x &environment env)\n   \"Set the last element in a list to the given value.\"\n   (multiple-value-bind (dummies vals newval setter getter)\n       (get-setf-expansion x env)\n     (let ((store (gensym)))\n       (values dummies\n               vals\n               `(,store)\n               `(progn (rplaca (last ,getter) ,store) ,store)\n               `(lastguy ,getter))))) \u2192 LASTGUY\n (setq a (list 'a 'b 'c 'd)\n       b (list 'x)\n       c (list 1 2 3 (list 4 5 6))) \u2192 (1 2 3 (4 5 6))\n (setf (lastguy a) 3) \u2192 3\n (setf (lastguy b) 7) \u2192 7\n (setf (lastguy (lastguy c)) 'lastguy-symbol) \u2192 LASTGUY-SYMBOL\n a \u2192 (A B C 3)\n b \u2192 (7)\n c \u2192 (1 2 3 (4 5 LASTGUY-SYMBOL))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';;; Setf expander for the form (LDB bytespec int).\n;;; Recall that the int form must itself be suitable for SETF.\n (define-setf-expander ldb (bytespec int &environment env)\n   (multiple-value-bind (temps vals stores\n                          store-form access-form)\n       (get-setf-expansion int env);Get setf expansion for int.\n     (let ((btemp (gensym))     ;Temp var for byte specifier.\n           (store (gensym))     ;Temp var for byte to store.\n           (stemp (first stores))) ;Temp var for int to store.\n       (if (cdr stores) (error "Can\'t expand this."))\n;;; Return the setf expansion for LDB as five values.\n       (values (cons btemp temps)       ;Temporary variables.\n               (cons bytespec vals)     ;Value forms.\n               (list store)             ;Store variables.\n               \\bq(let ((,stemp (dpb ,store ,btemp ,access-form)))\n                  ,store-form\n                  ,store)               ;Storing form.\n               \\bq(ldb ,btemp ,access-form) ;Accessing form.\n              ))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get-setf-expansion 'x)\n\u2192 NIL, NIL, (#:G0001), (SETQ X #:G0001), X \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (define-setf-expander multivalue (x)\n%      (values '() '() `(,(gensym) ,(gensym)) `(setq ,x 3) '4))\n% \u2192 MULTIVALUE\n%  (get-setf-expansion '(multivalue dummy-symbol))\n% \u2192 NIL, NIL, (#:G0002 #:G0003), (SETQ DUMMY-SYMBOL 3), 4\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; This macro is like POP \n\n (defmacro xpop (place &environment env)\n   (multiple-value-bind (dummies vals new setter getter)\n                        (get-setf-expansion place env)\n      `(let* (,@(mapcar #'list dummies vals) (,(car new) ,getter))\n         (if (cdr new) (error \"Can't expand this.\"))\n         (prog1 (car ,(car new))\n                (setq ,(car new) (cdr ,(car new)))\n                ,setter))))\n \n (defsetf frob (x) (value) \n     `(setf (car ,x) ,value)) \u2192 FROB\n;;; The following is an error; an error might be signaled at macro expansion time\n (flet ((frob (x) (cdr x)))  ;Invalid\n   (xpop (frob z)))\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (defmacro setf (reference value)\n%   (multiple-value-bind (vars vals stores store-form access-form)\n%       (get-setf-expansion reference)\n%     (declare (ignore access-form))\n%     \\bq(let* ,(mapcar #'list\n%                    (append vars stores)\n%                    (append vals (list value)))\n%        ,store-form)))\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf place-1 newvalue-1\n       place-2 newvalue-2\n       ...\n       place-N newvalue-N)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (progn (setf place-1 newvalue-1)\n        (setf place-2 newvalue-2)\n        ...\n        (setf place-N newvalue-N))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (cons 'a 'b) y (list 1 2 3)) \u2192 (1 2 3) \n (setf (car x) 'x (cadr y) (car x) (cdr x) y) \u2192 (1 X 3) \n x \u2192 (X 1 X 3) \n y \u2192 (1 X 3) \n (setq x (cons 'a 'b) y (list 1 2 3)) \u2192 (1 2 3) \n (psetf (car x) 'x (cadr y) (car x) (cdr x) y) \u2192 NIL \n x \u2192 (X 1 A 3) \n y \u2192 (1 A 3) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (list 1 2 3) y 'trash) \u2192 TRASH\n (shiftf y x (cdr x) '(hi there)) \u2192 TRASH\n x \u2192 (2 3)\n y \u2192 (1 HI THERE)\n\n (setq x (list 'a 'b 'c)) \u2192 (A B C)\n (shiftf (cadr x) 'z) \u2192 B\n x \u2192 (A Z C)\n (shiftf (cadr x) (cddr x) 'q) \u2192 Z\n x \u2192 (A (C) . Q)\n (setq n 0) \u2192 0\n (setq x (list 'a 'b 'c 'd)) \u2192 (A B C D)\n (shiftf (nth (setq n (+ n 1)) x) 'z) \u2192 B\n x \u2192 (A Z C D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((var1 \\param{place1})\n       (var2 \\param{place2})\n       ...\n       (varn \\param{placen})\n       (var0 \\param{newvalue}))\n   (setf \\param{place1} var2)\n   (setf \\param{place2} var3)\n   ...\n   (setf \\param{placen} var0)\n   var1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq n 0) \u2192 0\n (setq x (list 'a 'b 'c 'd)) \u2192 (A B C D)\n (prog1 (nth (setq n (+ n 1)) x)\n        (setf (nth (setq n (+ n 1)) x) 'z)) \u2192 B\n x \u2192 (A B Z D)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((n 0)\n        (x (list 'a 'b 'c 'd 'e 'f 'g)))\n    (rotatef (nth (incf n) x)\n             (nth (incf n) x)\n             (nth (incf n) x))\n    x) \u2192 (A C D B E F G)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (psetf \\param{place1} \\param{place2}\n        \\param{place2} \\param{place3}\n        ...\n        \\param{placen} \\param{place1})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 46142754>\n (setf (gethash "one" table) 1) \u2192 1\n (gethash "one" table) \u2192 NIL, false\n (setq table (make-hash-table :test \'equal)) \u2192 #<HASH-TABLE EQUAL 0/139 46145547>\n (setf (gethash "one" table) 1) \u2192 1\n (gethash "one" table) \u2192 1, T\n (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7) \n\u2192 #<HASH-TABLE EQL 0/120 46156620>\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32511220>\n (hash-table-p table) \u2192 T\n (hash-table-p 37) \u2192 NIL\n (hash-table-p '((a . 1) (b . 2))) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (hash-table-p \\param{object}) \\EQ (typep \\param{object} 'hash-table)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32115135>\n (hash-table-count table) \u2192 0\n (setf (gethash 57 table) "fifty-seven") \u2192 "fifty-seven"\n (hash-table-count table) \u2192 1\n (dotimes (i 100) (setf (gethash i table) i)) \u2192 NIL\n (hash-table-count table) \u2192 100\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (hash-table-count \\param{table}) \\EQ\n (loop for value being the hash-values of \\param{table} count t) \\EQ\n (let ((total 0))\n   (maphash #'(lambda (key value)\n                (declare (ignore key value))\n                (incf total))\n            \\param{table})\n   total)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq table (make-hash-table :size 100 :rehash-size 1.4))\n\u2192 #<HASH-TABLE EQL 0/100 2556371>\n (hash-table-rehash-size table) \u2192 1.4\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq table (make-hash-table :size 100 :rehash-threshold 0.5))\n\u2192 #<HASH-TABLE EQL 0/100 2562446>\n (hash-table-rehash-threshold table) \u2192 0.5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32206334>\n (gethash 1 table) \u2192 NIL, false\n (gethash 1 table 2) \u2192 2, false\n (setf (gethash 1 table) "one") \u2192 "one"\n (setf (gethash 2 table "two") "two") \u2192 "two"\n (gethash 1 table) \u2192 "one", true\n (gethash 2 table) \u2192 "two", true\n (gethash nil table) \u2192 NIL, false\n (setf (gethash nil table) nil) \u2192 NIL \n (gethash nil table) \u2192 NIL, true\n (defvar *counters* (make-hash-table)) \u2192 *COUNTERS*\n (gethash \'foo *counters*) \u2192 NIL, false\n (gethash \'foo *counters* 0) \u2192 0, false\n (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) \u2192 HOW-MANY\n (defun count-it (obj) (incf (how-many obj))) \u2192 COUNT-IT\n (dolist (x \'(bar foo foo bar bar baz)) (count-it x))\n (how-many \'foo) \u2192 2\n (how-many \'bar) \u2192 3\n (how-many \'quux) \u2192 0\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32115666>\n (setf (gethash 100 table) "C") \u2192 "C"\n (gethash 100 table) \u2192 "C", true\n (remhash 100 table) \u2192 T\n (gethash 100 table) \u2192 NIL, false\n (remhash 100 table) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32304110>\n (dotimes (i 10) (setf (gethash i table) i)) \u2192 NIL\n (let ((sum-of-squares 0))\n    (maphash #'(lambda (key val) \n                 (let ((square (* val val)))\n                   (incf sum-of-squares square)\n                   (setf (gethash key table) square)))\n             table)\n    sum-of-squares) \u2192 285\n (hash-table-count table) \u2192 10\n (maphash #'(lambda (key val)\n               (when (oddp val) (remhash key table)))\n           table) \u2192 NIL\n (hash-table-count table) \u2192 5\n (maphash #'(lambda (k v) (print (list k v))) table)\n(0 0) \n(8 64) \n(2 4) \n(6 36) \n(4 16) \n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test-hash-table-iterator (hash-table)\n   (let ((all-entries '())\n         (generated-entries '())\n         (unique (list nil)))\n     (maphash #'(lambda (key value) (push (list key value) all-entries))\n              hash-table)\n     (with-hash-table-iterator (generator-fn hash-table)\n       (loop     \n         (multiple-value-bind (more? key value) (generator-fn)\n           (unless more? (return))\n           (unless (eql value (gethash key hash-table unique))\n             (error \"Key ~S not found for value ~S\" key value))\n           (push (list key value) generated-entries))))\n     (unless (= (length all-entries)\n                (length generated-entries)\n                (length (union all-entries generated-entries\n                               :key #'car :test (hash-table-test hash-table))))\n       (error \"Generated entries and Maphash entries don't correspond\"))\n     t))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun maphash (function hash-table)\n   (with-hash-table-iterator (next-entry hash-table)\n     (loop (multiple-value-bind (more key value) (next-entry)\n             (unless more (return nil))\n             (funcall function key value)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32004073>\n (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) \u2192 NIL\n (hash-table-count table) \u2192 100\n (gethash 57 table) \u2192 "fifty-seven", true\n (clrhash table) \u2192 #<HASH-TABLE EQL 0/120 32004073>\n (hash-table-count table) \u2192 0\n (gethash 57 table) \u2192 NIL, false\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (= (sxhash (list \'list "ab")) (sxhash (list \'list "ab"))) \u2192 T\n (= (sxhash "a") (sxhash (make-string 1 :initial-element #\\a))) \u2192 T\n (let ((r (make-random-state)))\n   (= (sxhash r) (sxhash (make-random-state r))))\n\u2192 implementation-dependent\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (do ((temp-one 1 (1+ temp-one))\n       (temp-two 0 (1- temp-two)))\n      ((> (- temp-one temp-two) 5) temp-one)) \u2192 4\n\n (do ((temp-one 1 (1+ temp-one))\n       (temp-two 0 (1+ temp-one)))     \n      ((= 3 temp-two) temp-one)) \u2192 3\n\n (do* ((temp-one 1 (1+ temp-one))\n        (temp-two 0 (1+ temp-one)))\n       ((= 3 temp-two) temp-one)) \u2192 2                     \n\n (do ((j 0 (+ j 1)))\n     (nil)                       ;Do forever.\n   (format t "~%Input ~D:" j)\n   (let ((item (read)))\n     (if (null item) (return)   ;Process items until NIL seen.\n         (format t "~&Output ~D: ~S" j item))))\n\\OUT Input 0: \\IN{banana}\n\\OUT Output 0: BANANA\n\\OUT Input 1: \\IN{(57 boxes)}\n\\OUT Output 1: (57 BOXES)\n\\OUT Input 2: \\IN{NIL}\n\u2192 NIL\n\n (setq a-vector (vector 1 nil 3 nil))\n (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.\n      (n (array-dimension a-vector 0)))\n     ((= i n))\n   (when (null (aref a-vector i))\n     (setf (aref a-vector i) 0))) \u2192 NIL\na-vector \u2192 #(1 0 3 0)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (do ((x e (cdr x))\n      (oldx x x))\n     ((null x))\n   body)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (do ((x foo (cdr x))\n      (y bar (cdr y))\n      (z '() (cons (f (car x) (car y)) z)))\n     ((or (null x) (null y))\n      (nreverse z)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun list-reverse (list)\n        (do ((x list (cdr x))\n             (y '() (cons (car x) y)))\n            ((endp x) y)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun ribcage-lookup (sym ribcage)           \n        (do ((r ribcage (cdr r)))\n            ((null r) nil)\n          (do ((s (caar r) (cdr s))\n               (v (cdar r) (cdr v))) \n              ((null s))\n            (when (eq (car s) sym)\n              (return-from ribcage-lookup (car v)))))) \u2192 RIBCAGE-LOOKUP\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (block nil        \n   (let ((var1 init1)\n         (var2 init2)\n         ...\n         (varn initn))\n     \\i{declarations}\n     (loop (when end-test (return (progn . result)))\n           (tagbody . tagbody)\n           (psetq var1 step1\n                  var2 step2\n                  ...\n                  varn stepn))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (dotimes (temp-one 10 temp-one)) \u2192 10\n (setq temp-two 0) \u2192 0\n (dotimes (temp-one 10 t) (incf temp-two)) \u2192 T\n temp-two \u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';;; True if the specified subsequence of the string is a\n;;; palindrome (reads the same forwards and backwards).\n (defun palindromep (string \\optional\n                           (start 0)\n                           (end (length string)))\n   (dotimes (k (floor (- end start) 2) t)\n    (unless (char-equal (char string (+ start k))\n                        (char string (- end k 1)))\n      (return nil))))\n (palindromep "Able was I ere I saw Elba") \u2192 T\n (palindromep "A man, a plan, a canal--Panama!") \u2192 NIL\n (remove-if-not #\'alpha-char-p          ;Remove punctuation.\n               "A man, a plan, a canal--Panama!")\n\u2192 "AmanaplanacanalPanama"\n (palindromep\n  (remove-if-not #\'alpha-char-p\n                "A man, a plan, a canal--Panama!")) \u2192 T\n (palindromep\n  (remove-if-not\n   #\'alpha-char-p\n   "Unremarkable was I ere I saw Elba Kramer, nu?")) \u2192 T\n (palindromep\n  (remove-if-not\n   #\'alpha-char-p\n   "A man, a plan, a cat, a ham, a yak,\n                  a yam, a hat, a canal--Panama!")) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq temp-two '()) \u2192 NIL\n (dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two)) \u2192 (4 3 2 1)\n\n (setq temp-two 0) \u2192 0\n (dolist (temp-one '(1 2 3 4)) (incf temp-two)) \u2192 NIL\n temp-two \u2192 4\n\n (dolist (x '(a b c d)) (prin1 x) (princ \" \")) \n\\OUT A B C D \n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; An example of the simple form of LOOP.\n (defun sqrt-advisor ()\n   (loop (format t "~&Number: ")\n         (let ((n (parse-integer (read-line) :junk-allowed t)))\n           (when (not n) (return))\n           (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))\n\u2192 SQRT-ADVISOR\n (sqrt-advisor)\n\\OUT Number: \\IN{5\\CRLF}\n\\OUT The square root of 5 is 2.236068.\n\\OUT Number: \\IN{4\\CRLF}\n\\OUT The square root of 4 is 2.\n\\OUT Number: \\IN{done\\CRLF}\n\u2192 NIL\n\n;; An example of the extended form of LOOP.\n (defun square-advisor ()\n   (loop as n = (progn (format t "~&Number: ")\n                       (parse-integer (read-line) :junk-allowed t))\n         while n\n         do (format t "~&The square of ~D is ~D.~%" n (* n n))))\n\u2192 SQUARE-ADVISOR\n (square-advisor)\n\\OUT Number: \\IN{4\\CRLF}\n\\OUT The square of 4 is 16.\n\\OUT Number: \\IN{23\\CRLF}\n\\OUT The square of 23 is 529.\n\\OUT Number: \\IN{done\\CRLF}\n\u2192 NIL\n\n;; Another example of the extended form of LOOP.\n (loop for n from 1 to 10\n       when (oddp n)\n         collect n)\n\u2192 (1 3 5 7 9)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (loop \\starparam{compound-form}) \\EQ (loop do \\starparam{compound-form})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Terminate the loop, but return the accumulated count.\n (loop for i in \'(1 2 3 stop-here 4 5 6)\n       when (symbolp i) do (loop-finish)\n       count i)\n\u2192 3\n \n;; The preceding loop is equivalent to:\n (loop for i in \'(1 2 3 stop-here 4 5 6)\n       until (symbolp i)\n       count i)\n\u2192 3\n\n;; While LOOP-FINISH can be used can be used in a variety of \n;; situations it is really most needed in a situation where a need\n;; to exit is detected at other than the loop\'s `top level\'\n;; (where UNTIL or WHEN often work just as well), or where some \n;; computation must occur between the point where a need to exit is\n;; detected and the point where the exit actually occurs.  For example:\n (defun tokenize-sentence (string)\n   (macrolet ((add-word (wvar svar)\n                `(when ,wvar\n                   (push (coerce (nreverse ,wvar) \'string) ,svar)\n                   (setq ,wvar nil))))\n     (loop with word = \'() and sentence = \'() and endpos = nil\n           for i below (length string)\n           do (let ((char (aref string i)))\n                (case char\n                  (#\\Space (add-word word sentence))\n                  (#\\. (setq endpos (1+ i)) (loop-finish))\n                  (otherwise (push char word))))\n           finally (add-word word sentence)\n                   (return (values (nreverse sentence) endpos)))))\n\u2192 TOKENIZE-SENTENCE\n \n (tokenize-sentence "this is a sentence. this is another sentence.")\n\u2192 ("this" "is" "a" "sentence"), 19\n \n (tokenize-sentence "this is a sentence")\n\u2192 ("this" "is" "a" "sentence"), NIL\n\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (loop (loop-finish))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (loop do (loop (loop-finish)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (max 3) \u2192 3 \n (min 3) \u2192 3\n (max 6 12) \u2192 12 \n (min 6 12) \u2192 6\n (max -6 -12) \u2192 -6 \n (min -6 -12) \u2192 -12\n (max 1 3 2 -7) \u2192 3 \n (min 1 3 2 -7) \u2192 -7\n (max -2 3 0 7) \u2192 7 \n (min -2 3 0 7) \u2192 -2\n (max 5.0 2) \u2192 5.0 \n (min 5.0 2)\n\u2192 2\nOR=> 2.0\n (max 3.0 7 1)\n\u2192 7\nOR=> 7.0 \n (min 3.0 7 1)\n\u2192 1\nOR=> 1.0\n (max 1.0s0 7.0d0) \u2192 7.0d0\n (min 1.0s0 7.0d0)\n\u2192 1.0s0\nOR=> 1.0d0\n (max 3 1 1.0s0 1.0d0)\n\u2192 3\nOR=> 3.0d0\n (min 3 1 1.0s0 1.0d0)\n\u2192 1\nOR=> 1.0s0 \nOR=> 1.0d0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (minusp -1) \u2192 T\n (plusp 0) \u2192 NIL\n (plusp least-positive-single-float) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (zerop 0) \u2192 T\n (zerop 1) \u2192 NIL\n (zerop -0.0) \u2192 T\n (zerop 0/100) \u2192 T\n (zerop #c(0 0.0)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (zerop \\param{number}) \\EQ (= \\param{number} 0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (floor 3/2) \u2192 1, 1/2\n (ceiling 3 2) \u2192 2, -1\n (ffloor 3 2) \u2192 1.0, 1\n (ffloor -4.7) \u2192 -5.0, 0.3\n (ffloor 3.5d0) \u2192 3.0d0, 0.5d0\n (fceiling 3/2) \u2192 2.0, -1/2\n (truncate 1) \u2192 1, 0\n (truncate .5) \u2192 0, 0.5\n (round .5) \u2192 0, 0.5\n (ftruncate -7 2) \u2192 -3.0, -1\n (fround -7 2) \u2192 -4.0, 1\n (dolist (n '(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))\n   (format t \"~&~4,1@F ~2,' D ~2,' D ~2,' D ~2,' D\"\n           n (floor n) (ceiling n) (truncate n) (round n)))\n\\OUT +2.6  2  3  2  3\n\\OUT +2.5  2  3  2  2\n\\OUT +2.4  2  3  2  2\n\\OUT +0.7  0  1  0  1\n\\OUT +0.3  0  1  0  0\n\\OUT -0.3 -1  0  0  0\n\\OUT -0.7 -1  0  0 -1\n\\OUT -2.4 -3 -2 -2 -2\n\\OUT -2.5 -3 -2 -2 -2\n\\OUT -2.6 -3 -2 -2 -3\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (floor 5 2) \u2192 2, 1\n (floor (/ 5 2)) \u2192 2, 1/2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (sin 0) \u2192 0.0\n (cos 0.7853982) \u2192 0.707107\n (tan #c(0 1)) \u2192 #C(0.0 0.761594)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (asin 0) \u2192 0.0 \n (acos #c(0 1))  \u2192 #C(1.5707963267948966 -0.8813735870195432)\n (/ (atan 1 (sqrt 3)) 6)  \u2192 0.087266 \n (atan #c(0 2)) \u2192 #C(-1.5707964 0.54930615)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; In each of the following computations, the precision depends \n ;; on the implementation.  Also, if `long float' is treated by \n ;; the implementation as equivalent to some other float format \n ;; (e.g., `double float') the exponent marker might be the marker\n ;; for that equivalent (e.g., `D' instead of `L').\n pi \u2192 3.141592653589793L0\n (cos pi) \u2192 -1.0L0\n\n (defun sin-of-degrees (degrees)\n   (let ((x (if (floatp degrees) degrees (float degrees pi))))\n     (sin (* x (/ (float pi x) 180)))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (sinh 0) \u2192 0.0 \n (cosh (complex 0 -1)) \u2192 #C(0.540302 -0.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (*) \u2192 1\n (* 3 5) \u2192 15\n (* 1.0 #c(22 33) 55/98) \u2192 #C(12.346938775510203 18.520408163265305)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (+) \u2192 0\n (+ 1) \u2192 1\n (+ 31/100 69/100) \u2192 1\n (+ 1/5 0.8) \u2192 1.0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (- 55.55) \u2192 -55.55\n (- #c(3 -5)) \u2192 #C(-3 5)\n (- 0) \u2192 0\n (eql (- 0.0) -0.0) \u2192 T\n (- #c(100 45) #c(0 45)) \u2192 100\n (- 10 1 2 3 4) \u2192 0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (/ 12 4) \u2192 3\n (/ 13 4) \u2192 13/4\n (/ -8) \u2192 -1/8\n (/ 3 4 5) \u2192 3/20\n (/ 0.5) \u2192 2.0\n (/ 20 5) \u2192 4\n (/ 5 20) \u2192 1/4\n (/ 60 -2 3 5.0) \u2192 -2.0\n (/ 2 #c(2 2)) \u2192 #C(1/2 -1/2)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (1+ 99) \u2192 100 \n (1- 100) \u2192 99 \n (1+ (complex 0.0)) \u2192 #C(1.0 0.0) \n (1- 5/3) \u2192 2/3 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (1+ \\param{number}) \\EQ (+ \\param{number} 1)\n (1- \\param{number}) \\EQ (- \\param{number} 1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (abs 0) \u2192 0\n (abs 12/13) \u2192 12/13\n (abs -1.09) \u2192 1.09\n (abs #c(5.0 -5.0)) \u2192 7.071068\n (abs #c(5 5)) \u2192 7.071068\n (abs #c(3/5 4/5)) \u2192 1 or approximately 1.0\n (eql (abs -0.0) -0.0) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (evenp 0) \u2192 T\n (oddp 10000000000000000000000) \u2192 NIL\n (oddp -1) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (evenp \\param{integer}) \\EQ (not (oddp \\param{integer}))\n (oddp \\param{integer})  \\EQ (not (evenp \\param{integer}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (expt x 0) \\EQ (coerce 1 (type-of x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (exp 0) \u2192 1.0\n (exp 1) \u2192 2.718282\n (exp (log 5)) \u2192 5.0 \n (expt 2 8) \u2192 256\n (expt 4 .5) \u2192 2.0\n (expt #c(0 1) 2) \u2192 -1\n (expt #c(2 2) 3) \u2192 #C(-16 16)\n (expt #c(2 2) 4) \u2192 -64 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (exp (/ (* 2 pi #c(0 1)) 3)))         ;exp(2.pi.i/3)\n (expt x 3) \u2192 1 ;except for round-off error\n (sqrt (expt x 3)) \u2192 1 ;except for round-off error\n (expt x 3/2) \u2192 -1 ;except for round-off error\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (gcd) \u2192 0\n (gcd 60 42) \u2192 6\n (gcd 3333 -33 101) \u2192 1\n (gcd 3333 -33 1002001) \u2192 11\n (gcd 91 -49) \u2192 7\n (gcd 63 -42 35) \u2192 7\n (gcd 5) \u2192 5\n (gcd -4) \u2192 4\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (gcd b c ... z) \\EQ (gcd (gcd a b) c ... z)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq n 0)\n (incf n) \u2192 1      \n n \u2192 1\n (decf n 3) \u2192 -2   \n n \u2192 -2\n (decf n -5) \u2192 3      \n (decf n) \u2192 2      \n (incf n 0.5) \u2192 2.5\n (decf n) \u2192 1.5\n n \u2192 1.5\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setf \\param{place} (+ \\param{place} \\param{delta}))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lcm a b) \\EQ (/ (abs (* a b)) (gcd a b))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lcm a 0) \\EQ (lcm 0 a) \\EQ 0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lcm a b c ... z) \\EQ (lcm (lcm a b) c ... z)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lcm 10) \u2192 10\n (lcm 25 30) \u2192 150\n (lcm -24 18 10) \u2192 360\n (lcm 14 35) \u2192 70\n (lcm 0 5) \u2192 0\n (lcm 1 2 3 4 5 6) \u2192 60\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (log -1.0) \\EQ (complex 0.0 (float pi 0.0))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (log \\param{complex})\n%  \\EQ (+ (log (abs \\param{complex})) (* (phase \\param{complex}) #c(0 1)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(log \\i{x}) \\EQ (complex (log (abs \\i{x})) (phase \\i{x}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (log \\param{base} \\param{number})\n \\EQ (/ (log \\param{number}) (log \\param{base}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (log 100 10)\n\u2192 2.0\n\u2192 2\n (log 100.0 10) \u2192 2.0\n (log #c(0 1) #c(0 -1))\n\u2192 #C(-1.0 0.0)\nOR=> #C(-1 0)\n (log 8.0 2) \u2192 3.0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (log #c(-16 16) #c(2 2)) \u2192 3 or approximately #c(3.0 0.0)\n                               or approximately 3.0 (unlikely)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rem -1 5) \u2192 -1\n (mod -1 5) \u2192 4\n (mod 13 4) \u2192 1\n (rem 13 4) \u2192 1\n (mod -13 4) \u2192 3\n (rem -13 4) \u2192 -1\n (mod 13 -4) \u2192 -3\n (rem 13 -4) \u2192 1\n (mod -13 -4) \u2192 -1\n (rem -13 -4) \u2192 -1\n (mod 13.4 1) \u2192 0.4\n (rem 13.4 1) \u2192 0.4\n (mod -13.4 1) \u2192 0.6\n (rem -13.4 1) \u2192 -0.4\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (signum 0) \u2192 0\n (signum 99) \u2192 1\n (signum 4/5) \u2192 1\n (signum -99/100) \u2192 -1\n (signum 0.0) \u2192 0.0\n (signum #c(0 33)) \u2192 #C(0.0 1.0)\n (signum #c(7.5 10.0)) \u2192 #C(0.6 0.8)\n (signum #c(0.0 -14.7)) \u2192 #C(0.0 -1.0)\n (eql (signum -0.0) -0.0) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (signum x) \\EQ (if (zerop x) x (/ x (abs x)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (sqrt 9.0) \u2192 3.0\n (sqrt -9.0) \u2192 #C(0.0 3.0)\n (isqrt 9) \u2192 3\n (sqrt 12) \u2192 3.4641016\n (isqrt 12) \u2192 3\n (isqrt 300) \u2192 17\n (isqrt 325) \u2192 18\n (sqrt 25)\n\u2192 5\nOR=> 5.0\n (isqrt 25) \u2192 5\n (sqrt -1) \u2192 #C(0.0 1.0)\n (sqrt #c(0 2)) \u2192 #C(1.0 1.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (isqrt x) \\EQ (values (floor (sqrt x))) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let* ((rs1 (make-random-state nil))\n        (rs2 (make-random-state t))\n        (rs3 (make-random-state rs2))\n        (rs4 nil))\n   (list (loop for i from 1 to 10 \n               collect (random 100)\n               when (= i 5)\n                do (setq rs4 (make-random-state)))\n         (loop for i from 1 to 10 collect (random 100 rs1))\n         (loop for i from 1 to 10 collect (random 100 rs2))\n         (loop for i from 1 to 10 collect (random 100 rs3))\n         (loop for i from 1 to 10 collect (random 100 rs4))))\n\u2192 ((29 25 72 57 55 68 24 35 54 65)\n    (29 25 72 57 55 68 24 35 54 65)\n    (93 85 53 99 58 62 2 23 23 59)\n    (93 85 53 99 58 62 2 23 23 59)\n    (68 24 35 54 65 54 55 50 59 49))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (<= 0 (random 1000) 1000) \u2192 T\n (let ((state1 (make-random-state))\n       (state2 (make-random-state)))\n   (= (random 1000 state1) (random 1000 state2))) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (random-state-p *random-state*) \u2192 T\n (random-state-p (make-random-state)) \u2192 T\n (random-state-p 'test-function) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (random-state-p \\param{object}) \\EQ (typep \\param{object} 'random-state)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (random-state-p *random-state*) \u2192 T\n (setq snap-shot (make-random-state))\n ;; The series from any given point is random,\n ;; but if you backtrack to that point, you get the same series.\n (list (loop for i from 1 to 10 collect (random))\n       (let ((*random-state* snap-shot))\n         (loop for i from 1 to 10 collect (random)))\n       (loop for i from 1 to 10 collect (random))\n       (let ((*random-state* snap-shot))\n         (loop for i from 1 to 10 collect (random))))\n\u2192 ((19 16 44 19 96 15 76 96 13 61)\n    (19 16 44 19 96 15 76 96 13 61)\n    (16 67 0 43 70 79 58 5 63 50)\n    (16 67 0 43 70 79 58 5 63 50))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (numberp 12) \u2192 T\n (numberp (expt 2 130)) \u2192 T\n (numberp #c(5/3 7.2)) \u2192 T\n (numberp nil) \u2192 NIL\n (numberp (cons 1 2)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (numberp \\param{object}) \\EQ (typep \\param{object} 'number)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cis 0) \u2192 #C(1.0 0.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (complex 0) \u2192 0\n (complex 0.0) \u2192 #C(0.0 0.0)\n (complex 1 1/2) \u2192 #C(1 1/2)\n (complex 1 .99) \u2192 #C(1.0 0.99)\n (complex 3/2 0.0) \u2192 #C(1.5 0.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  #c(a b) \\EQ #.(complex a b)\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (complexp 1.2d2) \u2192 NIL\n (complexp #c(5/3 7.2)) \u2192 T\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (complexp \\param{object}) \\EQ (typep \\param{object} 'complex)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (conjugate #c(0 -1)) \u2192 #C(0 1)\n (conjugate #c(1 1)) \u2192 #C(1 -1)\n (conjugate 1.5) \u2192 1.5\n (conjugate #C(3/5 4/5)) \u2192 #C(3/5 -4/5)\n (conjugate #C(0.0D0 -1.0D0)) \u2192 #C(0.0D0 1.0D0)\n (conjugate 3.7) \u2192 3.7\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (conjugate z) \\EQ (complex (realpart z) (- (imagpart z)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (phase 1) \u2192 0.0s0\n (phase 0) \u2192 0.0s0\n (phase (cis 30)) \u2192 -1.4159266\n (phase #c(0 1)) \u2192 1.5707964\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (realpart #c(23 41)) \u2192 23\n (imagpart #c(23 41.0)) \u2192 41.0\n (realpart #c(23 41.0)) \u2192 23.0\n (imagpart 23.0) \u2192 0.0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (realp 12) \u2192 T\n (realp #c(5/3 7.2)) \u2192 NIL\n (realp nil) \u2192 NIL\n (realp (cons 1 2)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (realp \\param{object}) \\EQ (typep \\param{object} 'real)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (numerator 1/2) \u2192 1\n (denominator 12/36) \u2192 3\n (numerator -1) \u2192 -1\n (denominator (/ -33)) \u2192 33\n (numerator (/ 8 -6)) \u2192 -4\n (denominator (/ 8 -6)) \u2192 3\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (gcd (numerator x) (denominator x)) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rational 0) \u2192 0\n (rationalize -11/100) \u2192 -11/100\n (rational .1) \u2192 13421773/134217728 ;implementation-dependent\n (rationalize .1) \u2192 1/10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (float (rational x) x) \\EQ x\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (float (rationalize x) x) \\EQ x\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rationalp 12) \u2192 T\n (rationalp 6/5) \u2192 T\n (rationalp 1.212) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (rationalp \\param{object}) \\EQ (typep \\param{object} 'rational)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ash 16 1) \u2192 32\n (ash 16 0) \u2192 16\n (ash 16 -1) \u2192 8\n (ash -100000000000000000000000000000000 -100) \u2192 -79\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp \\param{j} (ash \\param{n} \\param{k}))\n \\EQ (and (>= \\param{j} \\param{k}) (logbitp (- \\param{j} \\param{k}) \\param{n}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (integer-length 0) \u2192 0\n (integer-length 1) \u2192 1\n (integer-length 3) \u2192 2\n (integer-length 4) \u2192 3\n (integer-length 7) \u2192 3\n (integer-length -1) \u2192 0\n (integer-length -4) \u2192 2\n (integer-length -7) \u2192 3\n (integer-length -8) \u2192 3\n (integer-length (expt 2 9)) \u2192 10\n (integer-length (1- (expt 2 9))) \u2192 9\n (integer-length (- (expt 2 9))) \u2192 9\n (integer-length (- (1+ (expt 2 9)))) \u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun integer-length (integer)\n  (ceiling (log (if (minusp integer)\n                    (- integer)\n                    (1+ integer))\n                2)))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (integerp 1) \u2192 T\n (integerp (expt 2 130)) \u2192 T\n (integerp 6/5) \u2192 NIL\n (integerp nil) \u2192 NIL\n\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (integerp \\param{object}) \\EQ (typep \\param{object} 'integer)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (parse-integer "123") \u2192 123, 3\n (parse-integer "123" :start 1 :radix 5) \u2192 13, 3\n (parse-integer "no-integer" :junk-allowed t) \u2192 NIL, 0\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (boole boole-ior 1 16) \u2192 17\n (boole boole-and -2 5) \u2192 4\n (boole boole-eqv 17 15) \u2192 -31\n\n;;; These examples illustrate the result of applying BOOLE and each\n;;; of the possible values of OP to each possible combination of bits.\n (progn\n   (format t \"~&Results of (BOOLE <op> #b0011 #b0101) ...~\n           ~%---Op-------Decimal-----Binary----Bits---~%\")\n   (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1\n                     boole-andc2 boole-c1   boole-c2   boole-clr\n                     boole-eqv   boole-ior  boole-nand boole-nor\n                     boole-orc1  boole-orc2 boole-set  boole-xor))\n     (let ((result (boole (symbol-value symbol) #b0011 #b0101)))\n       (format t \"~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~%\" \n               symbol result (logand result #b1111)))))\n\\OUT Results of (BOOLE <op> #b0011 #b0101) ...\n\\OUT ---Op-------Decimal-----Binary----Bits---\n\\OUT  BOOLE-1       3          11    ...0011\n\\OUT  BOOLE-2       5         101    ...0101\n\\OUT  BOOLE-AND     1           1    ...0001\n\\OUT  BOOLE-ANDC1   4         100    ...0100\n\\OUT  BOOLE-ANDC2   2          10    ...0010\n\\OUT  BOOLE-C1     -4        -100    ...1100\n\\OUT  BOOLE-C2     -6        -110    ...1010\n\\OUT  BOOLE-CLR     0           0    ...0000\n\\OUT  BOOLE-EQV    -7        -111    ...1001\n\\OUT  BOOLE-IOR     7         111    ...0111\n\\OUT  BOOLE-NAND   -2         -10    ...1110\n\\OUT  BOOLE-NOR    -8       -1000    ...1000\n\\OUT  BOOLE-ORC1   -3         -11    ...1101\n\\OUT  BOOLE-ORC2   -5        -101    ...1011\n\\OUT  BOOLE-SET    -1          -1    ...1111\n\\OUT  BOOLE-XOR     6         110    ...0110\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (boole boole-and x y) \\EQ (logand x y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; The order of the values in this `table' are such that\n;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n\n (defconstant boole-n-vector\n    (vector boole-clr   boole-and  boole-andc1 boole-2\n            boole-andc2 boole-1    boole-xor   boole-ior\n            boole-nor   boole-eqv  boole-c1    boole-orc1\n            boole-c2    boole-orc2 boole-nand  boole-set))\n\u2192 BOOLE-N-VECTOR\n (proclaim '(inline boole-n))\n\u2192 implementation-dependent\n (defun boole-n (n integer &rest more-integers)\n   (apply #'boole (elt boole-n-vector n) integer more-integers))\n\u2192 BOOLE-N\n (boole-n #b0111 5 3) \u2192 7\n (boole-n #b0001 5 3) \u2192 1\n (boole-n #b1101 5 3) \u2192 -3\n (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))\n\u2192 (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (boole boole-ior 1 16) \u2192 17\n (boole boole-and -2 5) \u2192 4\n (boole boole-eqv 17 15) \u2192 -31\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logior 1 2 4 8) \u2192 15\n (logxor 1 3 7 15) \u2192 10\n (logeqv) \u2192 -1\n (logand 16 31) \u2192 16\n (lognot 0) \u2192 -1\n (lognot 1) \u2192 -2\n (lognot -1) \u2192 0\n (lognot (1+ (lognot 1000))) \u2192 999\n\n;;; In the following example, m is a mask.  For each bit in\n;;; the mask that is a 1, the corresponding bits in x and y are\n;;; exchanged.  For each bit in the mask that is a 0, the \n;;; corresponding bits of x and y are left unchanged.\n (flet ((show (m x y)\n          (format t \"~%m = #o~6,'0O~%x = #o~6,'0O~%y = #o~6,'0O~%\"\n                  m x y)))\n   (let ((m #o007750)\n         (x #o452576)\n         (y #o317407))\n     (show m x y)\n     (let ((z (logand (logxor x y) m)))\n       (setq x (logxor z x))\n       (setq y (logxor z y))\n       (show m x y))))\n\\OUT m = #o007750\n\\OUT x = #o452576\n\\OUT y = #o317407\n\\OUT \n\\OUT m = #o007750\n\\OUT x = #o457426\n\\OUT y = #o312557\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (lognand \\param{n1} \\param{n2}) \\EQ (lognot (logand \\param{n1} \\param{n2}))\n (lognor \\param{n1} \\param{n2}) \\EQ (lognot (logior \\param{n1} \\param{n2}))\n (logandc1 \\param{n1} \\param{n2}) \\EQ (logand (lognot \\param{n1}) \\param{n2})\n (logandc2 \\param{n1} \\param{n2}) \\EQ (logand \\param{n1} (lognot \\param{n2}))\n (logiorc1 \\param{n1} \\param{n2}) \\EQ (logior (lognot \\param{n1}) \\param{n2})\n (logiorc2 \\param{n1} \\param{n2}) \\EQ (logior \\param{n1} (lognot \\param{n2}))\n (logbitp \\param{j} (lognot \\param{x})) \\EQ (not (logbitp \\param{j} \\param{x}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp 1 1) \u2192 NIL\n (logbitp 0 1) \u2192 T\n (logbitp 3 10) \u2192 T\n (logbitp 1000000 -1) \u2192 T\n (logbitp 2 6) \u2192 T\n (logbitp 0 6) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp \\param{k} \\param{n}) \\EQ (ldb-test (byte 1 \\param{k}) \\param{n})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logcount 0) \u2192 0\n (logcount -1) \u2192 0\n (logcount 7) \u2192 3\n (logcount  13) \u2192 3 ;Two's-complement binary: ...0001101\n (logcount -13) \u2192 2 ;Two's-complement binary: ...1110011\n (logcount  30) \u2192 4 ;Two's-complement binary: ...0011110\n (logcount -30) \u2192 4 ;Two's-complement binary: ...1100010\n (logcount (expt 2 100)) \u2192 1\n (logcount (- (expt 2 100))) \u2192 100\n (logcount (- (1+ (expt 2 100)))) \u2192 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"    (logcount \\param{x})\n \\EQ (logcount (- (+ \\param{x} 1)))\n \\EQ (logcount (lognot \\param{x}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logtest 1 7) \u2192 T\n (logtest 1 2) \u2192 NIL\n (logtest -2 -1) \u2192 T\n (logtest 0 -1) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logtest \\param{x} \\param{y}) \\EQ (not (zerop (logand \\param{x} \\param{y})))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq b (byte 100 200)) \u2192 #<BYTE-SPECIFIER size 100 position 200>\n (byte-size b) \u2192 100\n (byte-position b) \u2192 200\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (byte-size (byte \\param{j} \\param{k})) \\EQ \\param{j}\n (byte-position (byte \\param{j} \\param{k})) \\EQ \\param{k}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb (byte 0 3) #o7777) \u2192 0\n (dpb #o7777 (byte 0 3) 0) \u2192 0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (deposit-field 7 (byte 2 1) 0) \u2192 6\n (deposit-field -1 (byte 4 0) 0) \u2192 15\n (deposit-field 0 (byte 2 1) -3) \u2192 -7\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp \\param{j} (deposit-field \\param{m} (byte \\param{s} \\param{p}) \\param{n}))\n \\EQ (if (and (>= \\param{j} \\param{p}) (< \\param{j} (+ \\param{p} \\param{s})))\n        (logbitp \\param{j} \\param{m})\n        (logbitp \\param{j} \\param{n}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (dpb 1 (byte 1 10) 0) \u2192 1024\n (dpb -2 (byte 2 10) 0) \u2192 2048\n (dpb 1 (byte 2 10) 2048) \u2192 1024\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp \\param{j} (dpb \\param{m} (byte \\param{s} \\param{p}) \\param{n}))\n \\EQ (if (and (>= \\param{j} \\param{p}) (< \\param{j} (+ \\param{p} \\param{s})))\n        (logbitp (- \\param{j} \\param{p}) \\param{m})\n        (logbitp \\param{j} \\param{n}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (dpb \\param{x} (byte 0 \\param{y}) \\param{z}) \u2192 \\param{z}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb (byte 2 1) 10) \u2192 1\n (setq a (list 8)) \u2192 (8)\n (setf (ldb (byte 2 1) (car a)) 1) \u2192 1\n a \u2192 (10)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (logbitp \\param{j} (ldb (byte \\param{s} \\param{p}) \\param{n}))\n    \\EQ (and (< \\param{j} \\param{s}) (logbitp (+ \\param{j} \\param{p}) \\param{n}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb (byte 0 \\param{x}) \\param{y}) \u2192 0\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb-test (byte 4 1) 16) \u2192 T\n (ldb-test (byte 3 1) 16) \u2192 NIL\n (ldb-test (byte 3 2) 16) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb-test bytespec n) \\EQ\n (not (zerop (ldb bytespec n))) \\EQ\n (logtest (ldb bytespec -1) n)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mask-field (byte 1 5) -1) \u2192 32\n (setq a 15) \u2192 15\n (mask-field (byte 2 0) a) \u2192 3\n a \u2192 15\n (setf (mask-field (byte 2 0) a) 1) \u2192 1\n a \u2192 13\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ldb \\param{bs} (mask-field \\param{bs} \\param{n})) \\EQ (ldb \\param{bs} \\param{n})\n (logbitp \\param{j} (mask-field (byte \\param{s} \\param{p}) \\param{n}))\n   \\EQ (and (>= \\param{j} \\param{p}) (< \\param{j} \\param{s}) (logbitp \\param{j} \\param{n}))\n (mask-field \\param{bs} \\param{n}) \\EQ (logand \\param{n} (dpb -1 \\param{bs} 0))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-bind (signif expon sign)\n                      (integer-decode-float f)\n   (scale-float (float signif f) expon)) \\EQ (abs f)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; Note that since the purpose of this functionality is to expose\n ;; details of the implementation, all of these examples are necessarily\n ;; very implementation-dependent.  Results may vary widely.\n ;; Values shown here are chosen consistently from one particular implementation.\n (decode-float .5) \u2192 0.5, 0, 1.0\n (decode-float 1.0) \u2192 0.5, 1, 1.0\n (scale-float 1.0 1) \u2192 2.0\n (scale-float 10.01 -2) \u2192 2.5025\n (scale-float 23.0 0) \u2192 23.0\n (float-radix 1.0) \u2192 2\n (float-sign 5.0) \u2192 1.0\n (float-sign -5.0) \u2192 -1.0\n (float-sign 0.0) \u2192 1.0\n (float-sign 1.0 0.0) \u2192 0.0\n (float-sign 1.0 -10.0) \u2192 10.0\n (float-sign -1.0 10.0) \u2192 -10.0\n (float-digits 1.0) \u2192 24\n (float-precision 1.0) \u2192 24\n (float-precision least-positive-single-float) \u2192 1\n (integer-decode-float 1.0) \u2192 8388608, -23, 1\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-bind (signif expon sign)\n                      (decode-float f)\n   (scale-float signif expon))\n\\EQ (abs f)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (multiple-value-bind (signif expon sign)\n                      (decode-float f)\n   (* (scale-float signif expon) sign))\n\\EQ f\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (float 0) \u2192 0.0\n (float 1 .5) \u2192 1.0\n (float 1.0) \u2192 1.0\n (float 1/2) \u2192 0.5\n\u2192 1.0d0\nOR=> 1.0\n (eql (float 1.0 1.0d0) 1.0d0) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (floatp 1.2d2) \u2192 T\n (floatp 1.212) \u2192 T\n (floatp 1.2s2) \u2192 T\n (floatp (expt 2 130)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (floatp \\param{object}) \\EQ (typep \\param{object} 'float)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod gf1 ((a integer) &optional (b 2)\n                 &key (c 3) ((:dee d) 4) e ((eff f)))\n   (list a b c d e f))\n\u2192 #<STANDARD-METHOD GF1 (INTEGER) 36324653>\n (find-method #'gf1 '() (list (find-class 'integer))) \n\u2192 #<STANDARD-METHOD GF1 (INTEGER) 36324653>\n (function-keywords *)\n\u2192 (:C :DEE :E EFF), false\n (defmethod gf2 ((a integer))\n   (list a b c d e f))\n\u2192 #<STANDARD-METHOD GF2 (INTEGER) 42701775>\n (function-keywords (find-method #'gf1 '() (list (find-class 'integer))))\n\u2192 (), false\n (defmethod gf3 ((a integer) &key b c d &allow-other-keys)\n   (list a b c d e f))\n (function-keywords *)\n\u2192 (:B :C :D), true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  \n (defclass position () ())\n \n (defclass x-y-position (position)\n     ((x :initform 0 :accessor position-x)\n      (y :initform 0 :accessor position-y)))\n \n;;; It turns out polar coordinates are used more than Cartesian \n;;; coordinates, so the representation is altered and some new\n;;; accessor methods are added.\n \n (defmethod update-instance-for-redefined-class :before\n    ((pos x-y-position) added deleted plist &key)\n   ;; Transform the x-y coordinates to polar coordinates\n   ;; and store into the new slots.\n   (let ((x (getf plist 'x))\n         (y (getf plist 'y)))\n     (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))\n           (position-theta pos) (atan y x))))\n  \n (defclass x-y-position (position)\n     ((rho :initform 0 :accessor position-rho)\n      (theta :initform 0 :accessor position-theta)))\n  \n;;; All instances of the old x-y-position class will be updated\n;;; automatically.\n \n;;; The new representation is given the look and feel of the old one.\n \n (defmethod position-x ((pos x-y-position))  \n    (with-slots (rho theta) pos (* rho (cos theta))))\n \n (defmethod (setf position-x) (new-x (pos x-y-position))\n    (with-slots (rho theta) pos\n      (let ((y (position-y pos)))\n        (setq rho (sqrt (+ (* new-x new-x) (* y y)))\n              theta (atan y new-x))\n        new-x)))\n \n (defmethod position-y ((pos x-y-position))\n    (with-slots (rho theta) pos (* rho (sin theta))))\n \n (defmethod (setf position-y) (new-y (pos x-y-position))\n    (with-slots (rho theta) pos\n      (let ((x (position-x pos)))\n        (setq rho (sqrt (+ (* x x) (* new-y new-y)))\n              theta (atan new-y x))\n        new-y)))\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" \n (defclass position () ())\n  \n (defclass x-y-position (position)\n     ((x :initform 0 :initarg :x)\n      (y :initform 0 :initarg :y)))\n  \n (defclass rho-theta-position (position)\n     ((rho :initform 0)\n      (theta :initform 0)))\n  \n (defmethod update-instance-for-different-class :before ((old x-y-position) \n                                                         (new rho-theta-position)\n                                                         &key)\n   ;; Copy the position information from old to new to make new\n   ;; be a rho-theta-position at the same position as old.\n   (let ((x (slot-value old 'x))\n         (y (slot-value old 'y)))\n     (setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y)))\n           (slot-value new 'theta) (atan y x))))\n  \n;;; At this point an instance of the class x-y-position can be\n;;; changed to be an instance of the class rho-theta-position using\n;;; change-class:\n \n (setq p1 (make-instance 'x-y-position :x 2 :y 0))\n  \n (change-class p1 'rho-theta-position)\n  \n;;; The result is that the instance bound to p1 is now an instance of\n;;; the class rho-theta-position.   The update-instance-for-different-class\n;;; method performed the initialization of the rho and theta slots based\n;;; on the value of the x and y slots, which were maintained by\n;;; the old instance.\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (slot-missing (class-of \\i{instance})\n               \\i{instance}\n               \\i{slot-name}\n               'slot-boundp)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(slot-missing (class-of \\i{instance})\n              \\i{instance}\n              \\i{slot-name}\n              'slot-makunbound)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass foo () \n   ((a :accessor foo-a :initarg :a :initform 1)\n    (b :accessor foo-b :initarg :b)\n    (c :accessor foo-c :initform 3)))\n\u2192 #<STANDARD-CLASS FOO 244020371>\n (setq foo1 (make-instance 'foo :a 'one :b 'two))\n\u2192 #<FOO 36325624>\n (slot-value foo1 'a) \u2192 ONE\n (slot-value foo1 'b) \u2192 TWO\n (slot-value foo1 'c) \u2192 3\n (setf (slot-value foo1 'a) 'uno) \u2192 UNO\n (slot-value foo1 'a) \u2192 UNO\n (defmethod foo-method ((x foo))\n   (slot-value x 'a))\n\u2192 #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>\n (foo-method foo1) \u2192 UNO\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (slot-missing (class-of \\i{instance})\n               \\i{instance}\n               \\i{slot-name}\n               'slot-value)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (slot-missing (class-of \\i{instance})\n               \\i{instance}\n               \\i{slot-name}\n               'setf\n               \\i{new-value})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod some-gf :before ((a integer)) a)\n\u2192 #<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>\n (method-qualifiers *) \u2192 (:BEFORE)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass obj ()\n    ((x :initarg :x :reader obj-x)\n     (y :initarg :y :reader obj-y)\n     (dist :accessor obj-dist)))\n\u2192 #<STANDARD-CLASS OBJ 250020030>\n (defmethod shared-initialize :after ((self obj) slot-names &rest keys)\n   (declare (ignore slot-names keys))\n   (unless (slot-boundp self 'dist)\n     (setf (obj-dist self)\n           (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))\n\u2192 #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>\n (defmethod make-load-form ((self obj) &optional environment)\n   (declare (ignore environment))\n   ;; Note that this definition only works because X and Y do not\n   ;; contain information which refers back to the object itself.\n   ;; For a more general solution to this problem, see revised example below.\n   `(make-instance ',(class-of self)\n                   :x ',(obj-x self) :y ',(obj-y self)))\n\u2192 #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>\n (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) \u2192 #<OBJ 26274136>\n (obj-dist obj1) \u2192 5.0\n (make-load-form obj1) \u2192 (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" ;; Redefine method defined above.\n (defmethod make-load-form ((self obj) &optional environment)\n    (make-load-form-saving-slots self\n                                 :slot-names '(x y)\n                                 :environment environment))\n\u2192 #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>\n ;; Try MAKE-LOAD-FORM on object created above.\n (make-load-form obj1)\n\u2192 (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),\n    (PROGN\n      (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)\n      (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)\n      (INITIALIZE-INSTANCE '#<OBJ 26274136>))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass my-frob ()\n    ((name :initarg :name :reader my-name)))\n (defmethod make-load-form ((self my-frob) &optional environment)\n   (declare (ignore environment))\n   `(find-my-frob ',(my-name self) :if-does-not-exist :create))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass tree-with-parent () ((parent :accessor tree-parent)\n                                (children :initarg :children)))\n (defmethod make-load-form ((x tree-with-parent) &optional environment)\n   (declare (ignore environment))\n   (values\n     ;; creation form\n     `(make-instance ',(class-of x) :children ',(slot-value x 'children))\n     ;; initialization form\n     `(setf (tree-parent ',x) ',(slot-value x 'parent))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct my-struct a b c)\n (defmethod make-load-form ((s my-struct) &optional environment)\n    (make-load-form-saving-slots s :environment environment))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass thing ()\n           ((x :initarg :x :accessor thing-x)\n            (y :initarg :y :accessor thing-y)))\n\u2192 #<STANDARD-CLASS THING 250020173>\n (defmethod (setf thing-x) :before (new-x (thing thing))\n   (format t \"~&Changing X from ~D to ~D in ~S.~%\"\n           (thing-x thing) new-x thing))\n (setq thing1 (make-instance 'thing :x 1 :y 2)) \u2192 #<THING 43135676>\n (setq thing2 (make-instance 'thing :x 7 :y 8)) \u2192 #<THING 43147374>\n (with-accessors ((x1 thing-x) (y1 thing-y))\n                 thing1\n   (with-accessors ((x2 thing-x) (y2 thing-y))\n                   thing2\n     (list (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2))\n           (setq x1 (+ y1 x2))\n           (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2))\n           (setf (thing-x thing2) (list x1))\n           (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2)))))\n\\OUT Changing X from 1 to 9 in #<THING 43135676>.\n\\OUT Changing X from 7 to (9) in #<THING 43147374>.\n\u2192 ((1 1 2 2 7 7 8 8)\n     9\n     (9 9 2 2 7 7 8 8) \n     (9)\n     (9 9 2 2 (9) (9) 8 8))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defclass thing ()\n           ((x :initarg :x :accessor thing-x)\n            (y :initarg :y :accessor thing-y)))\n\u2192 #<STANDARD-CLASS THING 250020173>\n (defmethod (setf thing-x) :before (new-x (thing thing))\n   (format t \"~&Changing X from ~D to ~D in ~S.~%\"\n           (thing-x thing) new-x thing))\n (setq thing (make-instance 'thing :x 0 :y 1)) \u2192 #<THING 62310540>\n (with-slots (x y) thing (incf x) (incf y)) \u2192 2\n (values (thing-x thing) (thing-y thing)) \u2192 1, 2\n (setq thing1 (make-instance 'thing :x 1 :y 2)) \u2192 #<THING 43135676>\n (setq thing2 (make-instance 'thing :x 7 :y 8)) \u2192 #<THING 43147374>\n (with-slots ((x1 x) (y1 y))\n             thing1\n   (with-slots ((x2 x) (y2 y))\n               thing2\n     (list (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2))\n           (setq x1 (+ y1 x2))\n           (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2))\n           (setf (thing-x thing2) (list x1))\n           (list x1 (thing-x thing1) y1 (thing-y thing1)\n                 x2 (thing-x thing2) y2 (thing-y thing2)))))\n\\OUT Changing X from 7 to (9) in #<THING 43147374>.\n\u2192 ((1 1 2 2 7 7 8 8)\n     9\n     (9 9 2 2 7 7 8 8) \n     (9)\n     (9 9 2 2 (9) (9) 8 8))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;; Examples of the short form of define-method-combination\n \n (define-method-combination and :identity-with-one-argument t) \n  \n (defmethod func and ((x class1) y) ...)\n \n;;; The equivalent of this example in the long form is:\n \n (define-method-combination and \n         (&optional (order :most-specific-first))\n         ((around (:around))\n          (primary (and) :order order :required t))\n   (let ((form (if (rest primary)\n                   `(and ,@(mapcar #'(lambda (method)\n                                       `(call-method ,method))\n                                   primary))\n                   `(call-method ,(first primary)))))\n     (if around\n         `(call-method ,(first around)\n                       (,@(rest around)\n                        (make-method ,form)))\n         form)))\n  \n;;; Examples of the long form of define-method-combination\n \n;The default method-combination technique\n (define-method-combination standard ()\n         ((around (:around))\n          (before (:before))\n          (primary () :required t)\n          (after (:after)))\n   (flet ((call-methods (methods)\n            (mapcar #'(lambda (method)\n                        `(call-method ,method))\n                    methods)))\n     (let ((form (if (or before after (rest primary))\n                     `(multiple-value-prog1\n                        (progn ,@(call-methods before)\n                               (call-method ,(first primary)\n                                            ,(rest primary)))\n                        ,@(call-methods (reverse after)))\n                     `(call-method ,(first primary)))))\n       (if around\n           `(call-method ,(first around)\n                         (,@(rest around)\n                          (make-method ,form)))\n           form))))\n  \n;A simple way to try several methods until one returns non-nil\n (define-method-combination or ()\n         ((methods (or)))\n   `(or ,@(mapcar #'(lambda (method)\n                      `(call-method ,method))\n                  methods)))\n  \n;A more complete version of the preceding\n (define-method-combination or \n         (&optional (order ':most-specific-first))\n         ((around (:around))\n          (primary (or)))\n   ;; Process the order argument\n   (case order\n     (:most-specific-first)\n     (:most-specific-last (setq primary (reverse primary)))\n     (otherwise (method-combination-error \"~S is an invalid order.~@\n     :most-specific-first and :most-specific-last are the possible values.\"\n                                          order)))\n   ;; Must have a primary method\n   (unless primary\n     (method-combination-error \"A primary method is required.\"))\n   ;; Construct the form that calls the primary methods\n   (let ((form (if (rest primary)\n                   `(or ,@(mapcar #'(lambda (method)\n                                      `(call-method ,method))\n                                  primary))\n                   `(call-method ,(first primary)))))\n     ;; Wrap the around methods around that form\n     (if around\n         `(call-method ,(first around)\n                       (,@(rest around)\n                        (make-method ,form)))\n         form)))\n  \n;The same thing, using the :order and :required keyword options\n (define-method-combination or \n         (&optional (order ':most-specific-first))\n         ((around (:around))\n          (primary (or) :order order :required t))\n   (let ((form (if (rest primary)\n                   `(or ,@(mapcar #'(lambda (method)\n                                      `(call-method ,method))\n                                  primary))\n                   `(call-method ,(first primary)))))\n     (if around\n         `(call-method ,(first around)\n                       (,@(rest around)\n                        (make-method ,form)))\n         form)))\n  \n;This short-form call is behaviorally identical to the preceding\n (define-method-combination or :identity-with-one-argument t)\n \n;Order methods by positive integer qualifiers\n;:around methods are disallowed to keep the example small\n (define-method-combination example-method-combination ()\n         ((methods positive-integer-qualifier-p))\n   `(progn ,@(mapcar #'(lambda (method)\n                         `(call-method ,method))\n                     (stable-sort methods #'<\n                       :key #'(lambda (method)\n                                (first (method-qualifiers method)))))))\n \n (defun positive-integer-qualifier-p (method-qualifiers)\n   (and (= (length method-qualifiers) 1)\n        (typep (first method-qualifiers) '(integer 0 *))))\n  \n;;; Example of the use of :arguments\n (define-method-combination progn-with-lock ()\n         ((methods ()))\n   (:arguments object)\n   `(unwind-protect\n        (progn (lock (object-lock ,object))\n               ,@(mapcar #'(lambda (method)\n                             `(call-method ,method))\n                         methods))\n      (unlock (object-lock ,object))))\n  \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod some-operation ((a integer) (b float)) (list a b))\n\u2192 #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>\n (find-method #'some-operation '() (mapcar #'find-class '(integer float)))\n\u2192 #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>\n (find-method #'some-operation '() (mapcar #'find-class '(integer integer)))\n\\OUT Error: No matching method\n (find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (class-of 'fred) \u2192 #<BUILT-IN-CLASS SYMBOL 610327300>\n (class-of 2/3) \u2192 #<BUILT-IN-CLASS RATIO 610326642>\n \n (defclass book () ()) \u2192 #<STANDARD-CLASS BOOK 33424745>\n (class-of (make-instance 'book)) \u2192 #<STANDARD-CLASS BOOK 33424745>\n \n (defclass novel (book) ()) \u2192 #<STANDARD-CLASS NOVEL 33424764>\n (class-of (make-instance 'novel)) \u2192 #<STANDARD-CLASS NOVEL 33424764>\n\n (defstruct kons kar kdr) \u2192 KONS\n (class-of (make-kons :kar 3 :kdr 4)) \u2192 #<STRUCTURE-CLASS KONS 250020317>\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (make-package \'temp :use nil) \u2192 #<PACKAGE "TEMP">\n (use-package \'temp) \u2192 T\n (intern "TEMP-SYM" \'temp) \u2192 TEMP::TEMP-SYM, NIL\n (find-symbol "TEMP-SYM") \u2192 NIL, NIL\n (export (find-symbol "TEMP-SYM" \'temp) \'temp) \u2192 T\n (find-symbol "TEMP-SYM") \u2192 TEMP-SYM, :INHERITED\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (find-symbol "NEVER-BEFORE-USED") \u2192 NIL, NIL\n (find-symbol "NEVER-BEFORE-USED") \u2192 NIL, NIL\n (intern "NEVER-BEFORE-USED") \u2192 NEVER-BEFORE-USED, NIL\n (intern "NEVER-BEFORE-USED") \u2192 NEVER-BEFORE-USED, :INTERNAL\n (find-symbol "NEVER-BEFORE-USED") \u2192 NEVER-BEFORE-USED, :INTERNAL\n (find-symbol "never-before-used") \u2192 NIL, NIL\n (find-symbol "CAR" \'common-lisp-user) \u2192 CAR, :INHERITED\n (find-symbol "CAR" \'common-lisp) \u2192 CAR, :EXTERNAL\n (find-symbol "NIL" \'common-lisp-user) \u2192 NIL, :INHERITED\n (find-symbol "NIL" \'common-lisp) \u2192 NIL, :EXTERNAL\n (find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use \'())\n                           (intern "NIL" "JUST-TESTING")))\n\u2192 JUST-TESTING::NIL, :INTERNAL\n (export \'just-testing::nil \'just-testing)\n (find-symbol "NIL" \'just-testing) \u2192 JUST-TESTING:NIL, :EXTERNAL\n (find-symbol "NIL" "KEYWORD")\n\u2192 NIL, NIL\nOR=> :NIL, :EXTERNAL\n (find-symbol (symbol-name :nil) "KEYWORD") \u2192 :NIL, :EXTERNAL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (find-package \'common-lisp) \u2192 #<PACKAGE "COMMON-LISP">\n (find-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (find-package \'not-there) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find-all-symbols 'car)\n\u2192 (CAR)\nOR=> (CAR VEHICLES:CAR)\nOR=> (VEHICLES:CAR CAR)\n (intern \"CAR\" (make-package 'temp :use nil)) \u2192 TEMP::CAR, NIL\n (find-all-symbols 'car)\n\u2192 (TEMP::CAR CAR)\nOR=> (CAR TEMP::CAR)\nOR=> (TEMP::CAR CAR VEHICLES:CAR)\nOR=> (CAR TEMP::CAR VEHICLES:CAR)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (import 'common-lisp::car (make-package 'temp :use nil)) \u2192 T\n (find-symbol \"CAR\" 'temp) \u2192 CAR, :INTERNAL\n (find-symbol \"CDR\" 'temp) \u2192 NIL, NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((before (list-all-packages)))\n    (make-package \'temp)\n    (set-difference (list-all-packages) before)) \u2192 (#<PACKAGE "TEMP">)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (make-package \'temporary :nicknames \'("TEMP")) \u2192 #<PACKAGE "TEMPORARY">\n (rename-package \'temp \'ephemeral) \u2192 #<PACKAGE "EPHEMERAL">\n (package-nicknames (find-package \'ephemeral)) \u2192 ()\n (find-package \'temporary) \u2192 NIL\n (rename-package \'ephemeral \'temporary \'(temp fleeting))\n\u2192 #<PACKAGE "TEMPORARY">\n (package-nicknames (find-package \'temp)) \u2192 ("TEMP" "FLEETING")\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (package-shadowing-symbols (make-package 'temp)) \u2192 NIL\n (find-symbol 'car 'temp) \u2192 CAR, :INHERITED\n (shadow 'car 'temp) \u2192 T\n (find-symbol 'car 'temp) \u2192 TEMP::CAR, :INTERNAL\n (package-shadowing-symbols 'temp) \u2192 (TEMP::CAR)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-package 'test-1) \u2192 #<PACKAGE \"TEST-1\">\n (intern \"TEST\" (find-package 'test-1)) \u2192 TEST-1::TEST, NIL\n (shadow 'test-1::test (find-package 'test-1)) \u2192 T\n (shadow 'TEST (find-package 'test-1)) \u2192 T\n (assert (not (null (member 'test-1::test (package-shadowing-symbols\n                                            (find-package 'test-1))))))\n \n (make-package 'test-2) \u2192 #<PACKAGE \"TEST-2\">\n (intern \"TEST\" (find-package 'test-2)) \u2192 TEST-2::TEST, NIL\n (export 'test-2::test (find-package 'test-2)) \u2192 T\n (use-package 'test-2 (find-package 'test-1))    ;should not error\n \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (setq sym (intern "CONFLICT")) \u2192 CONFLICT\n (intern "CONFLICT" (make-package \'temp)) \u2192 TEMP::CONFLICT, NIL\n (package-shadowing-symbols \'temp) \u2192 NIL\n (shadowing-import sym \'temp) \u2192 T \n (package-shadowing-symbols \'temp) \u2192 (CONFLICT)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq *foo-package* (make-package "FOO" :use nil))\n (setq *foo-symbol*  (intern "FOO" *foo-package*))\n (export *foo-symbol* *foo-package*)\n\n (setq *bar-package* (make-package "BAR" :use \'("FOO")))\n (setq *bar-symbol*  (intern "BAR" *bar-package*))\n (export *foo-symbol* *bar-package*)\n (export *bar-symbol* *bar-package*)\n\n (setq *baz-package* (make-package "BAZ" :use \'("BAR")))\n\n (symbol-package *foo-symbol*) \u2192 #<PACKAGE "FOO">\n (symbol-package *bar-symbol*) \u2192 #<PACKAGE "BAR">\n\n (prin1-to-string *foo-symbol*) \u2192 "FOO:FOO"\n (prin1-to-string *bar-symbol*) \u2192 "BAR:BAR"\n\n (find-symbol "FOO" *bar-package*) \u2192 FOO:FOO, :EXTERNAL\n\n (find-symbol "FOO" *baz-package*) \u2192 FOO:FOO, :INHERITED\n (find-symbol "BAR" *baz-package*) \u2192 BAR:BAR, :INHERITED\n\n (packagep *foo-package*) \u2192 T\n (packagep *bar-package*) \u2192 T\n (packagep *baz-package*) \u2192 T\n\n (package-name *foo-package*) \u2192 "FOO"\n (package-name *bar-package*) \u2192 "BAR"\n (package-name *baz-package*) \u2192 "BAZ"\n\n (package-use-list *foo-package*) \u2192 ()\n (package-use-list *bar-package*) \u2192 (#<PACKAGE "FOO">)\n (package-use-list *baz-package*) \u2192 (#<PACKAGE "BAR">)\n\n (package-used-by-list *foo-package*) \u2192 (#<PACKAGE "BAR">)\n (package-used-by-list *bar-package*) \u2192 (#<PACKAGE "BAZ">)\n (package-used-by-list *baz-package*) \u2192 ()\n\n (delete-package *bar-package*)\n\\OUT Error: Package BAZ uses package BAR.\n\\OUT If continued, BAZ will be made to unuse-package BAR,\n\\OUT and then BAR will be deleted.\n\\OUT Type :CONTINUE to continue.\n\\OUT Debug> \\IN{:CONTINUE}\n\u2192 T\n\n (symbol-package *foo-symbol*) \u2192 #<PACKAGE "FOO">\n (symbol-package *bar-symbol*) is unspecified\n\n (prin1-to-string *foo-symbol*) \u2192 "FOO:FOO"\n (prin1-to-string *bar-symbol*) is unspecified\n\n (find-symbol "FOO" *bar-package*) is unspecified\n\n (find-symbol "FOO" *baz-package*) \u2192 NIL, NIL\n (find-symbol "BAR" *baz-package*) \u2192 NIL, NIL\n\n (packagep *foo-package*) \u2192 T\n (packagep *bar-package*) \u2192 T\n (packagep *baz-package*) \u2192 T\n\n (package-name *foo-package*) \u2192 "FOO"\n (package-name *bar-package*) \u2192 NIL\n (package-name *baz-package*) \u2192 "BAZ"\n\n (package-use-list *foo-package*) \u2192 ()\n (package-use-list *bar-package*) is unspecified\n (package-use-list *baz-package*) \u2192 ()\n\n (package-used-by-list *foo-package*) \u2192 ()\n (package-used-by-list *bar-package*) is unspecified\n (package-used-by-list *baz-package*) \u2192 ()\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (make-package \'temporary :nicknames \'("TEMP" "temp")) \u2192 #<PACKAGE "TEMPORARY">\n (make-package "OWNER" :use \'("temp")) \u2192 #<PACKAGE "OWNER">\n (package-used-by-list \'temp) \u2192 (#<PACKAGE "OWNER">)\n (package-use-list \'owner) \u2192 (#<PACKAGE "TEMPORARY">)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test-package-iterator (package)\n   (unless (packagep package)\n     (setq package (find-package package)))\n   (let ((all-entries '())\n         (generated-entries '()))\n     (do-symbols (x package) \n       (multiple-value-bind (symbol accessibility) \n           (find-symbol (symbol-name x) package)\n         (push (list symbol accessibility) all-entries)))\n     (with-package-iterator (generator-fn package \n                             :internal :external :inherited)\n       (loop     \n         (multiple-value-bind (more? symbol accessibility pkg)\n             (generator-fn)\n           (unless more? (return))\n           (let ((l (multiple-value-list (find-symbol (symbol-name symbol) \n                                                      package))))\n             (unless (equal l (list symbol accessibility))\n               (error \"Symbol ~S not found as ~S in package ~A [~S]\"\n                      symbol accessibility (package-name package) l))\n             (push l generated-entries)))))\n     (unless (and (subsetp all-entries generated-entries :test #'equal)\n                  (subsetp generated-entries all-entries :test #'equal))\n      (error \"Generated entries and Do-Symbols entries don't correspond\"))\n     t))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun print-all-symbols () \n   (with-package-iterator (next-symbol (list-all-packages)\n                           :internal :external)\n     (loop\n       (multiple-value-bind (more? symbol) (next-symbol)\n         (if more? \n            (print symbol)\n            (return))))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (export (intern "CONTRABAND" (make-package \'temp)) \'temp) \u2192 T\n (find-symbol "CONTRABAND") \u2192 NIL, NIL \n (use-package \'temp) \u2192 T \n (find-symbol "CONTRABAND") \u2192 CONTRABAND, :INHERITED\n (unexport \'contraband \'temp) \u2192 T\n (find-symbol "CONTRABAND") \u2192 NIL, NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (setq temps-unpack (intern "UNPACK" (make-package \'temp))) \u2192 TEMP::UNPACK \n (unintern temps-unpack \'temp) \u2192 T\n (find-symbol "UNPACK" \'temp) \u2192 NIL, NIL \n temps-unpack \u2192 #:UNPACK \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (export (intern "SHOES" (make-package \'temp)) \'temp) \u2192 T\n (find-symbol "SHOES") \u2192 NIL, NIL\n (use-package \'temp) \u2192 T\n (find-symbol "SHOES") \u2192 SHOES, :INHERITED\n (find (find-package \'temp) (package-use-list \'common-lisp-user)) \u2192 #<PACKAGE "TEMP">\n (unuse-package \'temp) \u2192 T\n (find-symbol "SHOES") \u2192 NIL, NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (export (intern "LAND-FILL" (make-package \'trash)) \'trash) \u2192 T\n (find-symbol "LAND-FILL" (make-package \'temp)) \u2192 NIL, NIL\n (package-use-list \'temp) \u2192 (#<PACKAGE "TEMP">)\n (use-package \'trash \'temp) \u2192 T\n (package-use-list \'temp) \u2192 (#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)\n (find-symbol "LAND-FILL" \'temp) \u2192 TRASH:LAND-FILL, :INHERITED\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defpackage "MY-PACKAGE"\n   (:nicknames "MYPKG" "MY-PKG")\n   (:use "COMMON-LISP")\n   (:shadow "CAR" "CDR")\n   (:shadowing-import-from "VENDOR-COMMON-LISP"  "CONS")\n   (:import-from "VENDOR-COMMON-LISP"  "GC")\n   (:export "EQ" "CONS" "FROBOLA")\n   )\n \n \n (defpackage my-package\n   (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case\n   (:use common-lisp)          ; conversion on symbols\n   (:shadow CAR :cdr #:cons)                              \n   (:export "CONS")            ; this is the shadowed one.\n   )\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defpackage my-package\n   (:use common-lisp your-package)    ;requires your-package to exist first\n   (:export "MY-FUN"))                \n (defpackage your-package\n   (:use common-lisp)\n   (:import-from my-package "MY-FUN") ;requires my-package to exist first\n   (:export "MY-FUN"))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-package 'temp :use nil) \u2192 #<PACKAGE \"TEMP\">\n (intern \"SHY\" 'temp) \u2192 TEMP::SHY, NIL ;SHY will be an internal symbol\n                                         ;in the package TEMP\n (export (intern \"BOLD\" 'temp) 'temp)  \u2192 T  ;BOLD will be external  \n (let ((lst ()))\n   (do-symbols (s (find-package 'temp)) (push s lst))\n   lst)\n\u2192 (TEMP::SHY TEMP:BOLD)\nOR=> (TEMP:BOLD TEMP::SHY)\n (let ((lst ()))\n   (do-external-symbols (s (find-package 'temp) lst) (push s lst))\n   lst) \n\u2192 (TEMP:BOLD)\n (let ((lst ()))                                                     \n   (do-all-symbols (s lst)\n     (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))\n   lst)\n\u2192 (TEMP::SHY TEMP:BOLD)\nOR=> (TEMP:BOLD TEMP::SHY)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (intern "Never-Before") \u2192 |Never-Before|, NIL\n (intern "Never-Before") \u2192 |Never-Before|, :INTERNAL \n (intern "NEVER-BEFORE" "KEYWORD") \u2192 :NEVER-BEFORE, NIL\n (intern "NEVER-BEFORE" "KEYWORD") \u2192 :NEVER-BEFORE, :EXTERNAL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (package-name *package*) \u2192 "COMMON-LISP-USER"\n (package-name (symbol-package :test)) \u2192 "KEYWORD"\n (package-name (find-package \'common-lisp)) \u2192 "COMMON-LISP"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defvar *foo-package* (make-package "FOO"))\n (rename-package "FOO" "FOO0")\n (package-name *foo-package*) \u2192 "FOO0"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (package-nicknames (make-package \'temporary\n                                   :nicknames \'("TEMP" "temp")))\n\u2192 ("temp" "TEMP") \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (package-shadowing-symbols (make-package 'temp)) \u2192 ()\n (shadow 'cdr 'temp) \u2192 T\n (package-shadowing-symbols 'temp) \u2192 (TEMP::CDR)\n (intern \"PILL\" 'temp) \u2192 TEMP::PILL, NIL\n (shadowing-import 'pill 'temp) \u2192 T\n (package-shadowing-symbols 'temp) \u2192 (PILL TEMP::CDR)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (package-use-list (make-package \'temp)) \u2192 (#<PACKAGE "COMMON-LISP">)\n (use-package \'common-lisp-user \'temp) \u2192 T\n (package-use-list \'temp) \u2192 (#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (package-used-by-list (make-package 'temp)) \u2192 ()\n (make-package 'trash :use '(temp)) \u2192 #<PACKAGE \"TRASH\">\n (package-used-by-list 'temp) \u2192 (#<PACKAGE \"TRASH\">)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (packagep *package*) \u2192 T \n (packagep 'common-lisp) \u2192 NIL \n (packagep (find-package 'common-lisp)) \u2192 T \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (packagep \\param{object}) \\EQ (typep \\param{object} 'package)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "COMMON-LISP-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n *package* \u2192 #<PACKAGE "COMMON-LISP-USER">\n (make-package "SAMPLE-PACKAGE" :use \'("COMMON-LISP"))\n\u2192 #<PACKAGE "SAMPLE-PACKAGE">\n (list \n   (symbol-package\n     (let ((*package* (find-package \'sample-package)))\n       (setq *some-symbol* (read-from-string "just-testing"))))\n   *package*)\n\u2192 (#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)\n (list (symbol-package (read-from-string "just-testing"))\n       *package*)\n\u2192 (#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)\n (eq \'foo (intern "FOO")) \u2192 T\n (eq \'foo (let ((*package* (find-package \'sample-package)))\n            (intern "FOO")))\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (package-error-package \n   (make-condition \'package-error\n     :package (find-package "COMMON-LISP")))\n\u2192 #<Package "COMMON-LISP">\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; There is a great degree of variability permitted here.  The next\n ;; several examples are intended to illustrate just a few of the many\n ;; possibilities.  Whether the name is canonicalized to a particular\n ;; case (either upper or lower) depends on both the file system and the\n ;; implementation since two different implementations using the same\n ;; file system might differ on many issues.  How information is stored\n ;; internally (and possibly presented in #S notation) might vary,\n ;; possibly requiring `accessors\' such as PATHNAME-NAME to perform case\n ;; conversion upon access.  The format of a namestring is dependent both\n ;; on the file system and the implementation since, for example, one\n ;; implementation might include the host name in a namestring, and\n ;; another might not.  #S notation would generally only be used in a\n ;; situation where no appropriate namestring could be constructed for use\n ;; with #P.\n (setq p1 (pathname "test"))\n\u2192 #P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)\nOR=> #P"VANILLA:test"   ; without case canonicalization (e.g., Unix)\nOR=> #P"test"\nOR=> #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")\nOR=> #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")\n (setq p2 (pathname "test"))\n\u2192 #P"CHOCOLATE:TEST"\nOR=> #P"VANILLA:test"\nOR=> #P"test"\nOR=> #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")\nOR=> #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")\n (pathnamep p1) \u2192 T\n (eq p1 (pathname p1)) \u2192 T\n (eq p1 p2)\n\u2192 T\nOR=> false\n (with-open-file (stream "test" :direction :output)\n   (pathname stream))\n\u2192 #P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; Implementation A -- an implementation with access to a single\n ;;  Unix file system.  This implementation happens to never display\n ;;  the `host\' information in a namestring, since there is only one host. \n (make-pathname :directory \'(:absolute "public" "games")\n                :name "chess" :type "db")\n\u2192 #P"/public/games/chess.db" \n\\medbreak\n ;; Implementation B -- an implementation with access to one or more\n ;;  VMS file systems.  This implementation displays `host\' information\n ;;  in the namestring only when the host is not the local host.\n ;;  It uses a double colon to separate a host name from the host\'s local\n ;;  file name.\n (make-pathname :directory \'(:absolute "PUBLIC" "GAMES")\n                :name "CHESS" :type "DB")\n\u2192 #P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB" \n (make-pathname :host "BOBBY"\n                :directory \'(:absolute "PUBLIC" "GAMES")\n                :name "CHESS" :type "DB")\n\u2192 #P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB" \n\\medbreak\n ;; Implementation C -- an implementation with simultaneous access to\n ;;  multiple file systems from the same Lisp image.  In this \n ;;  implementation, there is a convention that any text preceding the\n ;;  first colon in a pathname namestring is a host name.\n (dolist (case \'(:common :local))\n   (dolist (host \'("MY-LISPM" "MY-VAX" "MY-UNIX"))\n     (print (make-pathname :host host :case case\n                           :directory \'(:absolute "PUBLIC" "GAMES")\n                           :name "CHESS" :type "DB"))))\n\\OUT #P"MY-LISPM:>public>games>chess.db"\n\\OUT #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"\n\\OUT #P"MY-UNIX:/public/games/chess.db"\n\\OUT #P"MY-LISPM:>public>games>chess.db" \n\\OUT #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB" \n\\OUT #P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB" \n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq q "test")  \u2192 "test"\n (pathnamep q) \u2192 NIL\n (setq q (pathname "test"))\n\u2192 #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL\n       :VERSION NIL)\n (pathnamep q) \u2192 T \n (setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))\n\u2192 #P"SYS:SITE;FOO.SYSTEM"\n (pathnamep q) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pathnamep \\param{object}) \\EQ (typep \\param{object} 'pathname)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq q (make-pathname :host "KATHY"\n                        :directory "CHAPMAN" \n                        :name "LOGIN" :type "COM"))\n\u2192 #P"KATHY::[CHAPMAN]LOGIN.COM"\n (pathname-host q) \u2192 "KATHY"\n (pathname-name q) \u2192 "LOGIN"\n (pathname-type q) \u2192 "COM"\n\n ;; Because namestrings are used, the results shown in the remaining\n ;; examples are not necessarily the only possible results.  Mappings\n ;; from namestring representation to pathname representation are \n ;; dependent both on the file system involved and on the implementation\n ;; (since there may be several implementations which can manipulate the\n ;; the same file system, and those implementations are not constrained\n ;; to agree on all details). Consult the documentation for each\n ;; implementation for specific information on how namestrings are treated\n ;; that implementation.\n\n ;; VMS\n (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))\n\u2192 (:ABSOLUTE "FOO" "BAR")\n (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)\n\u2192 (:ABSOLUTE "FOO" "BAR")\n\n ;; Unix\n (pathname-directory "foo.l") \u2192 NIL\n (pathname-device "foo.l") \u2192 :UNSPECIFIC\n (pathname-name "foo.l") \u2192 "foo"\n (pathname-name "foo.l" :case :local) \u2192 "foo"\n (pathname-name "foo.l" :case :common) \u2192 "FOO"\n (pathname-type "foo.l") \u2192 "l"\n (pathname-type "foo.l" :case :local) \u2192 "l"\n (pathname-type "foo.l" :case :common) \u2192 "L"\n (pathname-type "foo") \u2192 :UNSPECIFIC\n (pathname-type "foo" :case :common) \u2192 :UNSPECIFIC\n (pathname-type "foo.") \u2192 ""\n (pathname-type "foo." :case :common) \u2192 ""\n (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)\n\u2192 (:ABSOLUTE "foo" "bar")\n (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)\n\u2192 (:ABSOLUTE "FOO" "BAR")\n (pathname-directory (parse-namestring "../baz.lisp"))\n\u2192 (:RELATIVE :UP)\n (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))\n\u2192 (:ABSOLUTE "foo" "BAR" :UP "Mum")\n (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)\n\u2192 (:ABSOLUTE "FOO" "bar" :UP "Mum")\n (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))\n\u2192 (:ABSOLUTE "foo" :WILD "bar")\n (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)\n\u2192 (:ABSOLUTE "FOO" :WILD "BAR")\n\n ;; Symbolics LMFS\n (pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))\n\u2192 (:ABSOLUTE "foo" :WILD-INFERIORS "bar")\n (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))\n\u2192 (:ABSOLUTE "foo" :WILD "bar")\n (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)\n\u2192 (:ABSOLUTE "FOO" :WILD "BAR")\n (pathname-device (parse-namestring ">foo>baz.lisp")) \u2192 :UNSPECIFIC\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (translate-logical-pathname "hacks:weather;barometer.lisp.newest")\n\\OUT Error: The logical host HACKS is not defined.\n (load-logical-pathname-translations "HACKS")\n\\OUT ;; Loading SYS:SITE;HACKS.TRANSLATIONS\n\\OUT ;; Loading done.\n\u2192 T\n (translate-logical-pathname "hacks:weather;barometer.lisp.newest")\n\u2192 #P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"\n (load-logical-pathname-translations "HACKS")\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;;;A very simple example of setting up a logical pathname host.  No\n ;;;translations are necessary to get around file system restrictions, so\n ;;;all that is necessary is to specify the root of the physical directory\n ;;;tree that contains the logical file system.\n ;;;The namestring syntax on the right-hand side is implementation-dependent.\n (setf (logical-pathname-translations "foo")\n       \'(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))\n\\smallbreak \n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "foo:bar;baz;mum.quux.3")\n\u2192 #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"\n\\medbreak \n ;;;A more complex example, dividing the files among two file servers\n ;;;and several different directories.  This Unix doesn\'t support\n ;;;:WILD-INFERIORS in the directory, so each directory level must\n ;;;be translated individually.  No file name or type translations\n ;;;are required except for .MAIL to .MBX.\n ;;;The namestring syntax on the right-hand side is implementation-dependent.\n (setf (logical-pathname-translations "prog")\n       \'(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")\n         ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")\n         ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")\n         ("EXPERIMENTAL;DOCUMENTATION;*.*.*"\n                                  "MY-VAX:SYS$DISK:[JOE.DOC]")\n         ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")\n         ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))\n\\smallbreak\n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "prog:mail;save;ideas.mail.3")\n\u2192 #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"\n\\medbreak\n ;;;Example translations for a program that uses three files main.lisp,\n ;;;auxiliary.lisp, and documentation.lisp.  These translations might be\n ;;;supplied by a software supplier as examples.\n\\smallbreak\n ;;;For Unix with long file names\n (setf (logical-pathname-translations "prog")\n       \'(("CODE;*.*.*"             "/lib/prog/")))\n\\smallbreak\n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "prog:code;documentation.lisp")\n\u2192 #P"/lib/prog/documentation.lisp"\n\\smallbreak\n ;;;For Unix with 14-character file names, using .lisp as the type\n (setf (logical-pathname-translations "prog")\n       \'(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")\n         ("CODE;*.*.*"             "/lib/prog/")))\n\n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "prog:code;documentation.lisp")\n\u2192 #P"/lib/prog/docum.lisp"\n\\medbreak\n ;;;For Unix with 14-character file names, using .l as the type\n ;;;The second translation shortens the compiled file type to .b\n (setf (logical-pathname-translations "prog")\n       `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))\n         (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))\n                                   ,(logical-pathname "PROG:**;*.B.*"))\n         ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")\n         ("CODE;*.*.*"             "/lib/prog/")))\n\\smallbreak\n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "prog:code;documentation.lisp")\n\u2192 #P"/lib/prog/documentatio.l"\n\\medbreak\n ;;;For a Cray with 6 character names and no directories, types, or versions.\n (setf (logical-pathname-translations "prog")\n       (let ((l \'(("MAIN" "PGMN")\n                  ("AUXILIARY" "PGAUX")\n                  ("DOCUMENTATION" "PGDOC")))\n             (logpath (logical-pathname "prog:code;"))\n             (phypath (pathname "XXX")))\n         (append\n           ;; Translations for source files\n           (mapcar #\'(lambda (x)\n                       (let ((log (first x))\n                             (phy (second x)))\n                         (list (make-pathname :name log\n                                              :type "LISP"\n                                              :version :wild\n                                              :defaults logpath)\n                               (make-pathname :name phy\n                                              :defaults phypath))))\n                   l)\n           ;; Translations for compiled files\n           (mapcar #\'(lambda (x)\n                       (let* ((log (first x))\n                              (phy (second x))\n                              (com (compile-file-pathname\n                                     (make-pathname :name log\n                                                    :type "LISP"\n                                                    :version :wild\n                                                    :defaults logpath))))\n                         (setq phy (concatenate \'string phy "B"))\n                         (list com\n                               (make-pathname :name phy\n                                              :defaults phypath))))\n                   l))))\n\n ;;;Sample use of that logical pathname.  The return value\n ;;;is implementation-dependent.          \n (translate-logical-pathname "prog:code;documentation.lisp")\n\u2192 #P"PGDOC"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; This example illustrates a possible usage for a hypothetical Lisp running on a\n ;; DEC TOPS-20 file system.  Since pathname conventions vary between Lisp \n ;; implementations and host file system types, it is not possible to provide a\n ;; general-purpose, conforming example.\n *default-pathname-defaults* \u2192 #P"PS:<FRED>"\n (merge-pathnames (make-pathname :name "CALENDAR"))\n\u2192 #P"PS:<FRED>CALENDAR"\n (let ((*default-pathname-defaults* (pathname "<MARY>")))\n   (merge-pathnames (make-pathname :name "CALENDAR")))\n\u2192 #P"<MARY>CALENDAR"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (merge-pathnames (enough-namestring pathname defaults) defaults)\n\\EQ (merge-pathnames (parse-namestring pathname nil defaults) defaults)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (namestring "getty")            \n\u2192 "getty"\n (setq q (make-pathname :host "kathy" \n                         :directory \n                           (pathname-directory *default-pathname-defaults*)\n                         :name "getty")) \n\u2192 #S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY \\i{directory-name} \n       :NAME "getty" :TYPE NIL :VERSION NIL)\n (file-namestring q) \u2192 "getty"\n (directory-namestring q) \u2192 \\i{directory-name}\n (host-namestring q) \u2192 "kathy" \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;;;Using Unix syntax and the wildcard conventions used by the\n ;;;particular version of Unix on which this example was created:\n (namestring\n   (translate-pathname "/usr/dmr/hacks/frob.l"\n                       "/usr/d*/hacks/*.l"\n                       "/usr/d*/backup/hacks/backup-*.*"))\n\u2192 "/usr/dmr/backup/hacks/backup-frob.l"\n (namestring\n   (translate-pathname "/usr/dmr/hacks/frob.l"\n                       "/usr/d*/hacks/fr*.l"\n                       "/usr/d*/backup/hacks/backup-*.*"))\n\u2192 "/usr/dmr/backup/hacks/backup-ob.l"\n \n ;;;This is similar to the above example but uses two different hosts,\n ;;;U: which is a Unix and V: which is a VMS.  Note the translation\n ;;;of file type and alphabetic case conventions.\n (namestring\n   (translate-pathname "U:/usr/dmr/hacks/frob.l"\n                       "U:/usr/d*/hacks/*.l"\n                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))\n\u2192 "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"\n (namestring\n   (translate-pathname "U:/usr/dmr/hacks/frob.l"\n                       "U:/usr/d*/hacks/fr*.l"\n                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))\n\u2192 "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq q (parse-namestring "test"))  \n\u2192 #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" \n       :TYPE NIL :VERSION NIL)\n (pathnamep q) \u2192 T\n (parse-namestring "test") \n\u2192 #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"\n       :TYPE NIL :VERSION NIL), 4\n (setq s (open \\i{xxx})) \u2192 #<Input File Stream...>\n (parse-namestring s) \n\u2192 #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME \\i{xxx} \n       :TYPE NIL :VERSION NIL), 0\n (parse-namestring "test" nil nil :start 2 :end 4 )\n \u2192 #S(PATHNAME ...), 15\n (parse-namestring "foo.lisp")\n\u2192 #P"foo.lisp"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;;;The following examples are not portable.  They are written to run\n ;;;with particular file systems and particular wildcard conventions.\n ;;;Other implementations will behave differently.  These examples are\n ;;;intended to be illustrative, not to be prescriptive.\n \n (wild-pathname-p (make-pathname :name :wild)) \u2192 T\n (wild-pathname-p (make-pathname :name :wild) :name) \u2192 T\n (wild-pathname-p (make-pathname :name :wild) :type) \u2192 NIL\n (wild-pathname-p (pathname "s:>foo>**>")) \u2192 T ;Lispm\n (wild-pathname-p (pathname :name "F*O")) \u2192 T ;Most places\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;; The results of the following five forms are all implementation-dependent.\n ;; The second item in particular is shown with multiple results just to \n ;; emphasize one of many particular variations which commonly occurs.\n (pathname-name (translate-pathname "foobar" "foo*" "*baz")) \u2192 "barbaz"\n (pathname-name (translate-pathname "foobar" "foo*" "*"))\n\u2192 "foobar"\nOR=> "bar"\n (pathname-name (translate-pathname "foobar" "*"    "foo*")) \u2192 "foofoobar"\n (pathname-name (translate-pathname "bar"    "*"    "foo*")) \u2192 "foobar"\n (pathname-name (translate-pathname "foobar" "foo*" "baz*")) \u2192 "bazbar"\n\n (defun translate-logical-pathname-1 (pathname rules)\n   (let ((rule (assoc pathname rules :test #\'pathname-match-p)))\n     (unless rule (error "No translation rule for ~A" pathname))\n     (translate-pathname pathname (first rule) (second rule))))\n (translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"\n                       \'(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")\n                         ("FOO:CODE;"          "MY-UNIX:/lib/foo/")\n                         ("FOO:PATCHES;*;"     "MY-UNIX:/lib/foo/patch/*/")))\n\u2192 #P"MY-UNIX:/lib/foo/basic.l"\n\n;;;This example assumes one particular set of wildcard conventions\n;;;Not all file systems will run this example exactly as written\n (defun rename-files (from to)\n   (dolist (file (directory from))\n     (rename-file file (translate-pathname file from to))))\n (rename-files "/usr/me/*.lisp" "/dev/her/*.l")\n   ;Renames /usr/me/init.lisp to /dev/her/init.l\n (rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")\n   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp\n   ;In some file systems the result might be /sys/pcl/5-may/low.lisp\n (rename-files "/usr/me/pcl*/*" "/sys/library/*/")\n   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp\n   ;In some file systems the result might be /sys/library/5-may/low.lisp\n (rename-files "/usr/me/foo.bar" "/usr/me2/")\n   ;Renames /usr/me/foo.bar to /usr/me2/foo.bar\n (rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe\'s-*-rec.text")\n   ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe\'s-lamb-rec.text\n   ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe\'s-pork-rec.text\n   ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe\'s-veg-rec.text\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (append (pathname-directory \\param{default-pathname})\n         (cdr  ;remove :relative from the front\n           (pathname-directory \\param{pathname})))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (merge-pathnames "CMUC::FORMAT"\n                  "CMUC::PS:<LISPIO>.FASL")\n\u2192 #P"CMUC::PS:<LISPIO>FORMAT.FASL.0"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  #'(lambda (*standard-output* &rest arguments)\n      (apply #'format t \\i{control-string} arguments)\n      \\i{arguments-tail})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%((formatter \"~&~A~A\") *standard-output* 'a 'b 'c)\n%\\OUT AB\n%\u2192 (C)\n\n```lisp\n(funcall (formatter \"~&~A~A\") *standard-output* 'a 'b 'c)\n\\OUT AB\n\u2192 (C)\n\n(format t (formatter \"~&~A~A\") 'a 'b 'c)\n\\OUT AB\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(let ((*print-pretty* t))\n  (write object :stream s))\n\\EQ (funcall (pprint-dispatch object) s object)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(progn (princ "Roads ") \n       (pprint-tabular *standard-output* \'(elm main maple center) nil nil 8))\nRoads ELM     MAIN\n      MAPLE   CENTER\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))\n  (declare (ignore at-sign-p))\n  (when (null tabsize) (setq tabsize 16))\n  (pprint-logical-block (s list :prefix (if colon-p "(" "")\n                                :suffix (if colon-p ")" ""))\n    (pprint-exit-if-list-exhausted)\n    (loop (write (pprint-pop) :stream s)\n          (pprint-exit-if-list-exhausted)\n          (write-char #\\Space s)\n          (pprint-tab :section-relative 0 tabsize s)\n          (pprint-newline :fill s))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defmethod print-object ((obj airplane) stream)\n   (print-unreadable-object (obj stream :type t :identity t)\n     (princ (tail-number obj) stream)))\n\n (prin1-to-string my-airplane)\n\u2192 "#<Airplane NW0773 36000123135>"\nOR=> "#<FAA:AIRPLANE NW0773 17>"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (cons \\param{car-type} \\param{cdr-type})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (princ character output-stream) \\EQ (write-char character output-stream)\n%\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (prin1 object output-stream)\n\\EQ (write object :stream output-stream :escape t)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (princ object output-stream)\n\\EQ (write object stream output-stream :escape nil :readably nil)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (print object output-stream)\n\\EQ (progn (terpri output-stream)\n           (write object :stream output-stream\n                         :escape t)\n           (write-char #\\space output-stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (pprint object output-stream)\n\\EQ (write object :stream output-stream :escape t :pretty t)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (prin1-to-string "abc") \u2192 "\\"abc\\""\n (princ-to-string "abc") \u2192 "abc"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (write-to-string \\param{object} \\star{\\curly{\\param{key} \\param{argument}}})\n\\EQ (with-output-to-string (#1=#:string-stream) \n     (write object :stream #1# \\star{\\curly{\\param{key} \\param{argument}}}))\n\n (princ-to-string \\param{object})\n\\EQ (with-output-to-string (string-stream)\n     (princ \\param{object} string-stream))\n\n (prin1-to-string \\param{object})\n\\EQ (with-output-to-string (string-stream)\n     (prin1 \\param{object} string-stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((*print-base* 24.) (*print-radix* t)) \n   (print 23.))\n\\OUT #24rN\n\u2192 23\n (setq *print-base* 10) \u2192 10\n (setq *print-radix* nil) \u2192 NIL                                          \n (dotimes (i 35)\n    (let ((*print-base* (+ i 2)))           ;print the decimal number 40 \n      (write 40)                            ;in each base from 2 to 36\n      (if (zerop (mod i 10)) (terpri) (format t " "))))\n\\OUT 101000\n\\OUT 1111 220 130 104 55 50 44 40 37 34\n\\OUT 31 2C 2A 28 26 24 22 20 1J 1I\n\\OUT 1H 1G 1F 1E 1D 1C 1B 1A 19 18\n\\OUT 17 16 15 14 \n\u2192 NIL\n (dolist (pb \'(2 3 8 10 16))               \n    (let ((*print-radix* t)                 ;print the integer 10 and \n          (*print-base* pb))                ;the ratio 1/10 in bases 2, \n     (format t "~&~S  ~S~%" 10 1/10)))        ;3, 8, 10, 16\n\\OUT #b1010  #b1/1010\n\\OUT #3r101  #3r1/101\n\\OUT #o12  #o1/12\n\\OUT 10.  #10r1/10\n\\OUT #xA  #x1/A\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test-print-case ()\n   (dolist (*print-case* '(:upcase :downcase :capitalize))\n     (format t \"~&~S ~S~%\" 'this-and-that '|And-something-elSE|)))\n\u2192 TEST-PC\n;; Although the choice of which characters to escape is specified by\n;; *PRINT-CASE*, the choice of how to escape those characters \n;; (i.e., whether single escapes or multiple escapes are used)\n;; is implementation-dependent.  The examples here show two of the\n;; many valid ways in which escaping might appear.\n (test-print-case) ;Implementation A\n\\OUT THIS-AND-THAT |And-something-elSE|\n\\OUT this-and-that a\\n\\d-\\s\\o\\m\\e\\t\\h\\i\\n\\g-\\e\\lse\n\\OUT This-And-That A\\n\\d-\\s\\o\\m\\e\\t\\h\\i\\n\\g-\\e\\lse\n\u2192 NIL\n (test-print-case) ;Implementation B\n\\OUT THIS-AND-THAT |And-something-elSE|\n\\OUT this-and-that a|nd-something-el|se\n\\OUT This-And-That A|nd-something-el|se\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((a (list 1 2 3)))\n   (setf (cdddr a) a)\n   (let ((*print-circle* t))\n     (write a)\n     :done))\n\\OUT #1=(1 2 3 . #1#)\n\u2192 :DONE\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((*print-escape* t)) (write #\\a))\n\\OUT #\\a\n\u2192 #\\a\n (let ((*print-escape* nil)) (write #\\a))\n\\OUT a\n\u2192 #\\a\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((*print-gensym* nil))\n   (print (gensym)))\n\\OUT G6040 \n\u2192 #:G6040\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a \'(1 (2 (3 (4 (5 (6))))))) \u2192 (1 (2 (3 (4 (5 (6))))))\n (dotimes (i 8) \n   (let ((*print-level* i)) \n     (format t "~&~D -- ~S~%" i a)))\n\\OUT 0 -- #\n\\OUT 1 -- (1 #)\n\\OUT 2 -- (1 (2 #))\n\\OUT 3 -- (1 (2 (3 #)))\n\\OUT 4 -- (1 (2 (3 (4 #))))\n\\OUT 5 -- (1 (2 (3 (4 (5 #)))))\n\\OUT 6 -- (1 (2 (3 (4 (5 (6))))))\n\\OUT 7 -- (1 (2 (3 (4 (5 (6))))))\n\u2192 NIL\n\\medbreak\n (setq a \'(1 2 3 4 5 6)) \u2192 (1 2 3 4 5 6)\n (dotimes (i 7) \n   (let ((*print-length* i)) \n     (format t "~&~D -- ~S~%" i a))) \n\\OUT 0 -- (...)\n\\OUT 1 -- (1 ...)\n\\OUT 2 -- (1 2 ...)\n\\OUT 3 -- (1 2 3 ...)\n\\OUT 4 -- (1 2 3 4 ...)\n\\OUT 5 -- (1 2 3 4 5 6)\n\\OUT 6 -- (1 2 3 4 5 6)\n\u2192 NIL\n\\medbreak\n(dolist (level-length \'((0 1) (1 1) (1 2) (1 3) (1 4) \n                        (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))\n (let ((*print-level*  (first  level-length))\n       (*print-length* (second level-length)))\n   (format t "~&~D ~D -- ~S~%"\n           *print-level* *print-length* \n           \'(if (member x y) (+ (car x) 3) \'(foo . #(a b c d "Baz"))))))\n\\OUT 0 1 -- #\n\\OUT 1 1 -- (IF ...)\n\\OUT 1 2 -- (IF # ...)\n\\OUT 1 3 -- (IF # # ...)\n\\OUT 1 4 -- (IF # # #)\n\\OUT 2 1 -- (IF ...)\n\\OUT 2 2 -- (IF (MEMBER X ...) ...)\n\\OUT 2 3 -- (IF (MEMBER X Y) (+ # 3) ...)\n\\OUT 3 2 -- (IF (MEMBER X ...) ...)\n\\OUT 3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)\n\\OUT 3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) \'(FOO . #(A B C D ...)))\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((*print-right-margin* 25) (*print-lines* 3))\n   (pprint '(progn (setq a 1 b 2 c 3 d 4))))\n\\OUT (PROGN (SETQ A 1\n\\OUT              B 2\n\\OUT              C 3 ..))\n\u2192 \\novalues\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq *print-pretty* 'nil) \u2192 NIL\n (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil)\n\\OUT (LET ((A 1) (B 2) (C 3)) (+ A B C))\n\u2192 NIL\n (let ((*print-pretty* t))\n   (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil))\n\\OUT (LET ((A 1)\n\\OUT       (B 2)\n\\OUT       (C 3))\n\\OUT   (+ A B C))\n\u2192 NIL\n;; Note that the first two expressions printed by this next form\n;; differ from the second two only in whether escape characters are printed.\n;; In all four cases, extra whitespace is inserted by the pretty printer.\n (flet ((test (x)\n          (let ((*print-pretty* t))\n            (print x)\n            (format t \"~%~S \" x)\n            (terpri) (princ x) (princ \" \")\n            (format t \"~%~A \" x))))\n  (test '#'(lambda () (list \"a\" #\\b 'c #'d))))\n\\OUT #'(LAMBDA ()\n\\OUT     (LIST \"a\" #\\b 'C #'D))\n\\OUT #'(LAMBDA ()\n\\OUT     (LIST \"a\" #\\b 'C #'D))\n\\OUT #'(LAMBDA ()\n\\OUT     (LIST a b 'C #'D)) \n\\OUT #'(LAMBDA ()\n\\OUT     (LIST a b 'C #'D))\n\u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (let ((x (list \"a\" '\\a (gensym) '((a (b (c))) d e f g)))\n       (*print-escape* nil)\n       (*print-gensym* nil)\n       (*print-level* 3)\n       (*print-length* 3))\n   (write x)\n   (let ((*print-readably* t))\n     (terpri)\n     (write x)\n     :done))\n\\OUT (a a G4581 ((A #) D E ...))\n\\OUT (\"a\" |a| #:G4581 ((A (B (C))) D E F G))\n\u2192 :DONE\n\n;; This is setup code is shared between the examples\n;; of three hypothetical implementations which follow.\n (setq table (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32005763> \n (setf (gethash table 1) 'one) \u2192 ONE\n (setf (gethash table 2) 'two) \u2192 TWO\n\n;; Implementation A\n (let ((*print-readably* t)) (print table))\n Error: Can't print #<HASH-TABLE EQL 0/120 32005763> readably.\n\n;; Implementation B\n;; No standardized #S notation for hash tables is defined, \n;; but there might be an implementation-defined notation.\n (let ((*print-readably* t)) (print table))\n\\OUT #S(HASH-TABLE :TEST EQL :SIZE 120 :CONTENTS (1 ONE 2 TWO))\n\u2192 #<HASH-TABLE EQL 0/120 32005763>\n\n;; Implementation C\n;; Note that #. notation can only be used if *READ-EVAL* is true.\n;; If *READ-EVAL* were false, this same implementation might have to\n;; signal an error unless it had yet another printing strategy to fall\n;; back on.\n (let ((*print-readably* t)) (print table))\n\\OUT #.(LET ((HASH-TABLE (MAKE-HASH-TABLE)))\n\\OUT     (SETF (GETHASH 1 HASH-TABLE) ONE)\n\\OUT     (SETF (GETHASH 2 HASH-TABLE) TWO)\n\\OUT     HASH-TABLE)\n\u2192 #<HASH-TABLE EQL 0/120 32005763>\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq zvar 123) \u2192 123\n (set-syntax-from-char #\\z #\\' (setq table2 (copy-readtable))) \u2192 T\n zvar \u2192 123\n (copy-readtable table2 *readtable*) \u2192 #<READTABLE 614000277>\n zvar \u2192 VAR\n (setq *readtable* (copy-readtable)) \u2192 #<READTABLE 46210223>\n zvar \u2192 VAR\n (setq *readtable* (copy-readtable nil)) \u2192 #<READTABLE 46302670>\n zvar \u2192 123\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(setq *readtable* (copy-readtable nil))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(setq *readtable* (copy-readtable))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(let ((*readtable* (copy-readtable))) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get-macro-character #\\lbr) \u2192 NIL, false\n (make-dispatch-macro-character #\\lbr) \u2192 T\n (not (get-macro-character #\\lbr)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (read)\n\\OUT \\IN{\'a}\n\u2192 (QUOTE A)\n (with-input-from-string (is " ") (read is nil \'the-end)) \u2192 THE-END\n (defun skip-then-read-char (s c n)\n    (if (char= c #\\{) (read s t nil t) (read-preserving-whitespace s))\n    (read-char-no-hang s)) \u2192 SKIP-THEN-READ-CHAR\n (let ((*readtable* (copy-readtable nil)))\n    (set-dispatch-macro-character #\\# #\\{ #\'skip-then-read-char)\n    (set-dispatch-macro-character #\\# #\\} #\'skip-then-read-char)\n    (with-input-from-string (is "#\\{123 x #\\}123 y")\n      (format t "~S ~S" (read is) (read is)))) \u2192 #\\x, #\\Space, NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun slash-reader (stream char)\n   (declare (ignore char))\n   `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)\n                   then (progn (read-char stream t nil t)\n                               (read-preserving-whitespace stream t nil t))\n                   collect dir\n                   while (eql (peek-char nil stream nil nil t) #\\/))))\n (set-macro-character #\\/ #'slash-reader)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (zyedh /usr/games/zork /usr/games/boggle)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (zyedh (path usr games zork) (path usr games boggle))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (zyedh (path usr games zork usr games boggle))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (read-delimited-list #\\rbracket) 1 2 3 4 5 6 \\rbracket\n\u2192 (1 2 3 4 5 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #\\{p q z a\\}  reads as  ((p q) (p z) (p a) (q z) (q a) (z a))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun |#\\{-reader| (stream char arg)\n   (declare (ignore char arg))\n   (mapcon #'(lambda (x)\n              (mapcar #'(lambda (y) (list (car x) y)) (cdr x)))\n          (read-delimited-list #\\} stream t))) \u2192 |#\\{-reader|\n\n (set-dispatch-macro-character #\\# #\\{ #'|#\\{-reader|) \u2192 T \n (set-macro-character #\\} (get-macro-character #\\) \\nil))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-macro-character #\\} (get-macro-character #\\) \\nil))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" #\\{ p q z a\\}\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (read-from-string " 1 3 5" t nil :start 2) \u2192 3, 5\n (read-from-string "(a b c)") \u2192 (A B C), 7\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (readtablep *readtable*) \u2192 T\n (readtablep (copy-readtable)) \u2192 T\n (readtablep '*readtable*) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (readtablep \\param{object}) \\EQ (typep \\param{object} 'readtable) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get-dispatch-macro-character #\\# #\\{) \u2192 NIL\n (set-dispatch-macro-character #\\# #\\{        ;dispatch on #\\{\n    #'(lambda(s c n)\n        (let ((list (read s nil (values) t)))  ;list is object after #n\\{\n          (when (consp list)                   ;return nth element of list\n            (unless (and n (< 0 n (length list))) (setq n 0))\n            (setq list (nth n list)))\n         list))) \u2192 T\n #\\{(1 2 3 4) \u2192 1\n #3\\{(0 1 2 3) \u2192 3\n #\\{123 \u2192 123\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(defun |#$-reader| (stream subchar arg)\n   (declare (ignore subchar arg))\n   (list 'dollars (read stream t nil t))) \u2192 |#$-reader|\n (set-dispatch-macro-character #\\# #\\$ #'|#\\$-reader|) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (get-dispatch-macro-character #\\# #\\{) \u2192 NIL \n% (unless (get-dispatch-macro-character #\\# #\\x)\n%      (warn "Hexadecimal input (#x<ddd>) is disabled")) \u2192 NIL \n% (let ((previous-fun (get-dispatch-macro-character #\\# #\\{)))\n%      (when previous-fun\n%        (set-dispatch-macro-character #\\# #\\{\n%          #\'(lambda (stream char arg)\n%               (setq stream *debug-io*)\n%               (when *debug-macro-chars*\n%                  (format *trace-output* \n%                         "~&Occurrence of ~C~C on stream ~S"\n%                                         #\\# #\\{ stream))\n%              (list (funcall previous-fun stream char)))))) \u2192 NIL \n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get-macro-character #\\lbr) \u2192 NIL, false\n (not (get-macro-character #\\;)) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun single-quote-reader (stream char)\n   (declare (ignore char))\n   (list 'quote (read stream t nil t))) \u2192 SINGLE-QUOTE-READER\n (set-macro-character #\\' #'single-quote-reader) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun semicolon-reader (stream char)\n   (declare (ignore char))\n   ;; First swallow the rest of the current input line.\n   ;; End-of-file is acceptable for terminating the comment.\n   (do () ((char= (read-char stream nil #\\Newline t) #\\Newline)))\n   ;; Return zero values.\n   (values)) \u2192 SEMICOLON-READER\n (set-macro-character #\\; #'semicolon-reader) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (set-syntax-from-char #\\7 #\\;) \u2192 T\n 123579 \u2192 1235\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (with-open-file (file pathname :direction :output)\n   (with-standard-io-syntax\n     (print data file)))\n\n;;; ... Later, in another Lisp:\n\n (with-open-file (file pathname :direction :input)\n   (with-standard-io-syntax\n     (setq data (read file))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (dotimes (i 6)\n   (let ((*read-base* (+ 10. i)))\n     (let ((object (read-from-string "(\\\\\\DAD DAD |BEE| BEE 123. 123)")))\n       (print (list *read-base* object)))))\n\\OUT (10 (DAD DAD BEE BEE 123 123))\n\\OUT (11 (DAD DAD BEE BEE 123 146))\n\\OUT (12 (DAD DAD BEE BEE 123 171))\n\\OUT (13 (DAD DAD BEE BEE 123 198))\n\\OUT (14 (DAD 2701 BEE BEE 123 227))\n\\OUT (15 (DAD 3088 BEE 2699 123 258))\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((*read-default-float-format* \'double-float))\n   (read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))\n\u2192 (1.0   1.0   1.0   1.0 1.0   1.0)   ;Implementation has float format F.\n\u2192 (1.0   1.0   1.0s0 1.0 1.0   1.0)   ;Implementation has float formats S and F.\n\u2192 (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.\n\u2192 (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.\n\u2192 (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.\n\u2192 (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (let ((*read-suppress* t))\n%    (dotimes (i 4)\n%      (format t "~&input here> ")\n%      (format t "~&parsed as: ~S~%" (read))))\n% \\OUT input here> 101\n% \\OUT parsed as: NIL\n% \\OUT input here> (#\\a :test)\n% \\OUT parsed as: (NIL NIL)\n% \\OUT input here> \'("xyz" #(a b c))\n% \\OUT parsed as: (QUOTE ("xyz" #(NIL NIL NIL)))\n% \\OUT input here> (list 1 2 \'3)\n% \\OUT parsed as: (NIL NIL NIL (QUOTE NIL))\n% \u2192 NIL\n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((*read-suppress* t))\n   (mapcar #\'read-from-string\n           \'("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"\n             "#.(PRINT \'FOO)" "#3AHELLO" "#S(INTEGER)"\n             "#*ABC" "#\\GARBAGE" "#RALPHA" "#3R444")))\n\u2192 (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (readtablep *readtable*) \u2192 T\n (setq zvar 123) \u2192 123\n (set-syntax-from-char #\\z #\\' (setq table2 (copy-readtable))) \u2192 T\n zvar \u2192 123\n (setq *readtable* table2) \u2192 #<READTABLE>\n zvar \u2192 VAR\n (setq *readtable* (copy-readtable nil)) \u2192 #<READTABLE>\n zvar \u2192 123\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq str "a string") \u2192 "a string"\n (equalp str (copy-seq str)) \u2192 T\n (eql str (copy-seq str)) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (copy-seq x) \\EQ (subseq x 0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq str (copy-seq "0123456789")) \u2192 "0123456789"\n (elt str 6) \u2192 #\\6\n (setf (elt str 0) #\\#) \u2192 #\\#\n str \u2192 "#123456789"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (fill (list 0 1 2 3 4 5) '(444)) \u2192 ((444) (444) (444) (444) (444) (444))\n (fill (copy-seq \"01234\") #\\e :start 3) \u2192 \"012ee\"\n (setq x (vector 'a 'b 'c 'd 'e)) \u2192 #(A B C D E)\n (fill x 'z :start 1 :end 3) \u2192 #(A Z Z D E)\n x \u2192 #(A Z Z D E)\n (fill x 'p) \u2192 #(P P P P P)\n x \u2192 #(P P P P P)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-sequence 'list 0) \u2192 ()\n (make-sequence 'string 26 :initial-element #\\.) \n\u2192 \"..........................\"\n (make-sequence '(vector double-float) 2\n                :initial-element 1d0)\n\u2192 #(1.0d0 1.0d0)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-sequence '(vector * 2) 3) should signal an error\n (make-sequence '(vector * 4) 3) should signal an error\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-sequence 'string 5) \\EQ (make-string 5)               \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq str "012345") \u2192 "012345"\n (subseq str 2) \u2192 "2345"\n (subseq str 3 5) \u2192 "34"\n (setf (subseq str 4) "abc") \u2192 "abc"\n str \u2192 "0123ab"\n (setf (subseq str 0 2) "A") \u2192 "A"\n str \u2192 "A123ab"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (map \'string #\'(lambda (x y)\n                  (char "01234567890ABCDEF" (mod (+ x y) 16)))\n       \'(1 2 3 4)\n       \'(10 9 8 7)) \u2192 "AAAA"\n (setq seq \'("lower" "UPPER" "" "123")) \u2192 ("lower" "UPPER" "" "123")\n (map nil #\'nstring-upcase seq) \u2192 NIL\n seq \u2192 ("LOWER" "UPPER" "" "123")\n (map \'list #\'- \'(1 2 3 4)) \u2192 (-1 -2 -3 -4)\n (map \'string\n      #\'(lambda (x) (if (oddp x) #\\1 #\\0))\n      \'(1 2 3 4)) \u2192 "1010"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (map \'(vector * 4) #\'cons "abc" "de") should signal an error\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq a (list 1 2 3 4) b (list 10 10 10 10)) \u2192 (10 10 10 10)\n (map-into a #'+ a b) \u2192 (11 12 13 14)\n a \u2192 (11 12 13 14)\n b \u2192 (10 10 10 10)\n (setq k '(one two three)) \u2192 (ONE TWO THREE)\n (map-into a #'cons k a) \u2192 ((ONE . 11) (TWO . 12) (THREE . 13) 14)\n (map-into a #'gensym) \u2192 (#:G9090 #:G9091 #:G9092 #:G9093)\n a \u2192 (#:G9090 #:G9091 #:G9092 #:G9093)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun map-into (result-sequence function &rest sequences)\n   (loop for index below (apply #'min \n                                (length result-sequence)\n                                (mapcar #'length sequences))\n         do (setf (elt result-sequence index)\n                  (apply function\n                         (mapcar #'(lambda (seq) (elt seq index))\n                                 sequences))))\n   result-sequence)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (reduce #'* '(1 2 3 4 5)) \u2192 120\n (reduce #'append '((1) (2)) :initial-value '(i n i t)) \u2192 (I N I T 1 2)\n (reduce #'append '((1) (2)) :from-end t                  \n                             :initial-value '(i n i t)) \u2192 (1 2 I N I T) \n (reduce #'- '(1 2 3 4)) \\EQ (- (- (- 1 2) 3) 4) \u2192 -8\n (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.\n\\EQ (- 1 (- 2 (- 3 4))) \u2192 -2\n (reduce #'+ '()) \u2192 0\n (reduce #'+ '(3)) \u2192 3\n (reduce #'+ '(foo)) \u2192 FOO\n (reduce #'list '(1 2 3 4)) \u2192 (((1 2) 3) 4)\n (reduce #'list '(1 2 3 4) :from-end t) \u2192 (1 (2 (3 4)))\n (reduce #'list '(1 2 3 4) :initial-value 'foo) \u2192 ((((foo 1) 2) 3) 4)\n (reduce #'list '(1 2 3 4)\n        :from-end t :initial-value 'foo) \u2192 (1 (2 (3 (4 foo))))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (count #\\a \"how many A's are there in here?\") \u2192 2\n (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) \u2192 2\n (count-if #'upper-case-p \"The Crying of Lot 49\" :start 4) \u2192 2 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (length "abc") \u2192 3\n (setq str (make-array \'(3) :element-type \'character \n                            :initial-contents "abc"\n                            :fill-pointer t)) \u2192 "abc"\n (length str) \u2192 3\n (setf (fill-pointer str) 2) \u2192 2\n (length str) \u2192 2\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq str "abc") \u2192 "abc"\n (reverse str) \u2192 "cba"\n str \u2192 "abc"\n (setq str (copy-seq str)) \u2192 "abc"\n (nreverse str) \u2192 "cba"\n str \u2192 implementation-dependent\n (setq l (list 1 2 3)) \u2192 (1 2 3)\n (nreverse l) \u2192 (3 2 1)\n l \u2192 implementation-dependent\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq tester (copy-seq "lkjashd")) \u2192 "lkjashd"\n (sort tester #\'char-lessp) \u2192 "adhjkls"\n (setq tester (list \'(1 2 3) \'(4 5 6) \'(7 8 9))) \u2192 ((1 2 3) (4 5 6) (7 8 9))\n (sort tester #\'> :key #\'car)  \u2192 ((7 8 9) (4 5 6) (1 2 3)) \n (setq tester (list 1 2 3 4 5 6 7 8 9 0)) \u2192 (1 2 3 4 5 6 7 8 9 0)\n (stable-sort tester #\'(lambda (x y) (and (oddp x) (evenp y))))\n\u2192 (1 3 5 7 9 2 4 6 8 0)\n (sort (setq committee-data\n             (vector (list (list "JonL" "White") "Iteration")\n                     (list (list "Dick" "Waters") "Iteration")\n                     (list (list "Dick" "Gabriel") "Objects")\n                     (list (list "Kent" "Pitman") "Conditions")\n                     (list (list "Gregor" "Kiczales") "Objects")\n                     (list (list "David" "Moon") "Objects")\n                     (list (list "Kathy" "Chapman") "Editorial")\n                     (list (list "Larry" "Masinter") "Cleanup")\n                     (list (list "Sandra" "Loosemore") "Compiler")))\n       #\'string-lessp :key #\'cadar)\n\u2192 #((("Kathy" "Chapman") "Editorial")\n     (("Dick" "Gabriel") "Objects")\n     (("Gregor" "Kiczales") "Objects")\n     (("Sandra" "Loosemore") "Compiler")\n     (("Larry" "Masinter") "Cleanup")\n     (("David" "Moon") "Objects")\n     (("Kent" "Pitman") "Conditions")\n     (("Dick" "Waters") "Iteration")\n     (("JonL" "White") "Iteration"))\n ;; Note that individual alphabetical order within `committees\'\n ;; is preserved.\n (setq committee-data \n       (stable-sort committee-data #\'string-lessp :key #\'cadr))\n\u2192 #((("Larry" "Masinter") "Cleanup")\n     (("Sandra" "Loosemore") "Compiler")\n     (("Kent" "Pitman") "Conditions")\n     (("Kathy" "Chapman") "Editorial")\n     (("Dick" "Waters") "Iteration")\n     (("JonL" "White") "Iteration")\n     (("Dick" "Gabriel") "Objects")\n     (("Gregor" "Kiczales") "Objects")\n     (("David" "Moon") "Objects"))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (find #\\d \"here are some letters that can be looked at\" :test #'char>)\n\u2192 #\\Space \n (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) \u2192 3\n (find-if-not #'complexp                                    \n             '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))\n             :start 2) \u2192 NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (find item sequence ...)\n%  \\EQ (elt sequence (position item sequence ...))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (position #\\a \"baobab\" :from-end t) \u2192 4\n (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) \u2192 2\n (position 595 '()) \u2192 NIL\n (position-if-not #'integerp '(1 2 3 4 5.0)) \u2192 4 \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (search \"dog\" \"it's a dog's life\") \u2192 7\n (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) \u2192 2\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (mismatch \"abcd\" \"ABCDE\" :test #'char-equal) \u2192 4\n (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) \u2192 3\n (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) \u2192 NIL\n (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) \u2192 NIL \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (min (- \\i{end1} \\i{start1}) (- \\i{end2} \\i{start2}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4) \n\u2192 "abcd456hij"\n (setq lst "012345678") \u2192 "012345678"\n (replace lst lst :start1 2 :start2 0) \u2192 "010123456"\n lst \u2192 "010123456"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (substitute #\\. #\\SPACE \"0 2 4 6\") \u2192 \"0.2.4.6\"\n (substitute 9 4 '(1 2 4 1 3 4 5)) \u2192 (1 2 9 1 3 9 5)\n (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) \u2192 (1 2 9 1 3 4 5)\n (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)\n\u2192 (1 2 4 1 3 9 5)\n (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) \u2192 (9 9 4 9 3 4 5)\n\n (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)\n\u2192 ((1) (2) (3) 0)\n (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) \u2192 (9 2 4 9 9 4 9)\n (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)\n\u2192 (1 2 4 1 3 9 5)\n\n (setq some-things (list 'a 'car 'b 'cdr 'c)) \u2192 (A CAR B CDR C)\n (nsubstitute-if \"function was here\" #'fboundp some-things\n                 :count 1 :from-end t) \u2192 (A CAR B \"function was here\" C)\n some-things \u2192 (A CAR B \"function was here\" C)\n (setq alpha-tester (copy-seq \"ab \")) \u2192 \"ab \"\n (nsubstitute-if-not #\\z #'alpha-char-p alpha-tester) \u2192 \"abz\"\n alpha-tester \u2192 \"abz\"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun test-it (fn)\n   (let ((x (cons 'b nil)))\n     (rplacd x x)\n     (funcall fn 'a 'b x :count 1)))\n (test-it #'substitute) \u2192 (A . #1=(B . #1#))\n (test-it #'nsubstitute) \u2192 (A . #1#)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'(concatenate \'string "all" " " "together" " " "now") \u2192 "all together now"\n(concatenate \'list "ABC" \'(d e f) #(1 2 3) #*1011)\n\u2192 (#\\A #\\B #\\C D E F 1 2 3 1 0 1 1)\n(concatenate \'list) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'  (concatenate \'(vector * 2) "a" "bc") should signal an error\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq test1 (list 1 3 4 6 7))\n (setq test2 (list 2 5 8))\n (merge 'list test1 test2 #'<) \u2192 (1 2 3 4 5 6 7 8)\n (setq test1 (copy-seq \"BOY\"))\n (setq test2 (copy-seq :nosy\"))\n (merge 'string test1 test2 #'char-lessp) \u2192 \"BnOosYy\"\n (setq test1 (vector ((red . 1) (blue . 4))))\n (setq test2 (vector ((yellow . 2) (green . 7))))\n (merge 'vector test1 test2 #'< :key #'cdr) \n\u2192 #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7)) \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (delete nil \\i{sequence}\n             :test #'(lambda (ignore \\i{item}) (funcall \\i{test} \\i{item}))\n             ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (remove 4 '(1 3 4 5 9)) \u2192 (1 3 5 9)\n (remove 4 '(1 2 4 1 3 4 5)) \u2192 (1 2 1 3 5)\n (remove 4 '(1 2 4 1 3 4 5) :count 1) \u2192 (1 2 1 3 4 5)\n (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) \u2192 (1 2 4 1 3 5)\n (remove 3 '(1 2 4 1 3 4 5) :test #'>) \u2192 (4 3 4 5)\n (setq lst '(list of four elements)) \u2192 (LIST OF FOUR ELEMENTS)\n (setq lst2 (copy-seq lst)) \u2192 (LIST OF FOUR ELEMENTS)\n (setq lst3 (delete 'four lst)) \u2192 (LIST OF ELEMENTS)\n (equal lst lst2) \u2192 NIL\n (remove-if #'oddp '(1 2 4 1 3 4 5)) \u2192 (2 4 4)\n (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) \n\u2192 (1 2 4 1 3 5)\n (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)\n\u2192 (1 2 3 4 5 6 8)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete 4 tester) \u2192 (1 2 1 3 5)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete 4 tester :count 1) \u2192 (1 2 1 3 4 5)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete 4 tester :count 1 :from-end t) \u2192 (1 2 4 1 3 5)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete 3 tester :test #'>) \u2192 (4 3 4 5)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete-if #'oddp tester) \u2192 (2 4 4)\n (setq tester (list 1 2 4 1 3 4 5)) \u2192 (1 2 4 1 3 4 5)\n (delete-if #'evenp tester :count 1 :from-end t) \u2192 (1 2 4 1 3 5)    \n (setq tester (list 1 2 3 4 5 6)) \u2192 (1 2 3 4 5 6) \n (delete-if #'evenp tester) \u2192 (1 3 5) \n tester \u2192 implementation-dependent\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq foo (list 'a 'b 'c)) \u2192 (A B C)\n (setq bar (cdr foo)) \u2192 (B C)\n (setq foo (delete 'b foo)) \u2192 (A C)\n bar \u2192 ((C)) or ...\n (eq (cdr foo) (car bar)) \u2192 T or ...\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (remove-duplicates \"aBcDAbCd\" :test #'char-equal :from-end t) \u2192 \"aBcD\"\n (remove-duplicates '(a b c b d d e)) \u2192 (A C B D E)\n (remove-duplicates '(a b c b d d e) :from-end t) \u2192 (A B C D E)\n (remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A))\n     :test #'char-equal :key #'cadr) \u2192 ((BAR #\\%) (BAZ #\\A))\n (remove-duplicates '((foo #\\a) (bar #\\%) (baz #\\A)) \n     :test #'char-equal :key #'cadr :from-end t) \u2192 ((FOO #\\a) (BAR #\\%))\n (setq tester (list 0 1 2 3 4 5 6))\n (delete-duplicates tester :key #'oddp :start 1 :end 6) \u2192 (0 4 5 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (input-stream-p *standard-input*) \u2192 T\n (input-stream-p *terminal-io*) \u2192 T\n (input-stream-p (make-string-output-stream)) \u2192 NIL\n\n (output-stream-p *standard-output*) \u2192 T\n (output-stream-p *terminal-io*) \u2192 T\n (output-stream-p (make-string-input-stream "jr")) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (when (> measured limit)\n   (let ((error (round (* (- measured limit) 100)\n                       limit)))\n     (unless (if (interactive-stream-p *query-io*)\n                 (yes-or-no-p "The frammis is out of tolerance by ~D%.~@\n                               Is it safe to proceed? " error)\n                 (< error 15))  ;15% is acceptable\n       (error "The frammis is out of tolerance by ~D%." error))))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (open-stream-p *standard-input*) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Note that the stream must accomodate at least the specified type,\n;; but might accomodate other types.  Further note that even if it does\n;; accomodate exactly the specified type, the type might be specified in\n;; any of several ways.\n (with-open-file (s "test" :element-type \'(integer 0 1)\n                           :if-exists :error\n                           :direction :output)\n   (stream-element-type s))\n\u2192 INTEGER\nOR=> (UNSIGNED-BYTE 16)\nOR=> (UNSIGNED-BYTE 8)\nOR=> BIT\nOR=> (UNSIGNED-BYTE 1)\nOR=> (INTEGER 0 1)\nOR=> (INTEGER 0 (2))\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (streamp *terminal-io*) \u2192 T\n (streamp 1) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (streamp \\param{object}) \\EQ (typep \\param{object} 'stream)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (s "temp-bytes" \n                     :direction :output\n                     :element-type \'unsigned-byte)\n    (write-byte 101 s)) \u2192 101\n (with-open-file (s "temp-bytes" :element-type \'unsigned-byte)\n    (format t "~S ~S" (read-byte s) (read-byte s nil \'eof)))\n\\OUT 101 EOF\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (s "temp-bytes" \n                    :direction :output\n                    :element-type \'unsigned-byte)\n    (write-byte 101 s)) \u2192 101\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-input-from-string (input-stream "    1 2 3 4 5")\n    (format t "~S ~S ~S" \n            (peek-char t input-stream)\n            (peek-char #\\4 input-stream)\n            (peek-char nil input-stream)))\n\\OUT #\\1 #\\4 #\\4\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-input-from-string (is "0123")\n    (do ((c (read-char is) (read-char is nil \'the-end)))\n        ((not (characterp c)))\n     (format t "~S " c)))\n\\OUT #\\0 #\\1 #\\2 #\\3\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; This code assumes an implementation in which a newline is not\n;; required to terminate input from the console.\n (defun test-it ()\n   (unread-char (read-char))\n   (list (read-char-no-hang) \n         (read-char-no-hang) \n         (read-char-no-hang)))\n\u2192 TEST-IT\n;; Implementation A, where a Newline is not required to terminate\n;; interactive input on the console.\n (test-it)\n\\OUT \\IN{a}\n\u2192 (#\\a NIL NIL)\n;; Implementation B, where a Newline is required to terminate\n;; interactive input on the console, and where that Newline remains\n;; on the input stream.\n (test-it)\n\\OUT \\IN{a\\CRLF}\n\u2192 (#\\a #\\Newline NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-output-to-string (s)\n    (write-string "some text" s)\n    (terpri s)\n    (terpri s)\n    (write-string "more text" s))\n\u2192 "some text\n\nmore text"\n (with-output-to-string (s)\n    (write-string "some text" s)\n    (fresh-line s)\n    (fresh-line s)\n    (write-string "more text" s))\n\u2192 "some text\nmore text"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (write-char #\\Newline output-stream)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-input-from-string (is "0123")\n    (dotimes (i 6)\n      (let ((c (read-char is)))\n        (if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))\n\\OUT 0 #\\0\n\\OUT 2 #\\1\n\\OUT 4 #\\2\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (write-char #\\a)\n\\OUT a\n\u2192 #\\a\n (with-output-to-string (s) \n   (write-char #\\a s)\n   (write-char #\\Space s)\n   (write-char #\\b s))\n\u2192 "a b"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a "line 1\n line2")\n\u2192 "line 1\n line2"\n (read-line (setq input-stream (make-string-input-stream a)))\n\u2192 "line 1", false\n (read-line input-stream)\n\u2192 "line2", true\n (read-line input-stream nil nil)\n\u2192 NIL, true\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (prog1 (write-string "books" nil :end 4) (write-string "worms"))\n\\OUT bookworms\n\u2192 "books"\n (progn (write-char #\\*)\n        (write-line "test12" *standard-output* :end 5) \n        (write-line "*test2")\n        (write-char #\\*)\n        nil)\n\\OUT *test1\n\\OUT *test2\n\\OUT *\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (write-string string)\n\\EQ (dotimes (i (length string)\n      (write-char (char string i)))\n\n (write-line string)\n\\EQ (prog1 (write-string string) (terpri))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defvar *data* (make-array 15 :initial-element nil))\n (values (read-sequence *data* (make-string-input-stream "test string")) *data*)\n \u2192 11, #(#\\t #\\e #\\s #\\t #\\Space #\\s #\\t #\\r #\\i #\\n #\\g NIL NIL NIL NIL)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (write-sequence "bookworms" *standard-output* :end 4)\n \\OUT book\n \u2192 "bookworms"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (s "decimal-digits.text" \n                    :direction :output :if-exists :error)\n   (princ "0123456789" s)\n   (truename s))\n\u2192 #P"A:>Joe>decimal-digits.text.1"\n (with-open-file (s "decimal-digits.text")\n   (file-length s))\n\u2192 10\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun tester ()\n   (let ((noticed '()) file-written)\n     (flet ((notice (x) (push x noticed) x))\n       (with-open-file (s \"test.bin\" \n                          :element-type '(unsigned-byte 8)\n                          :direction :output\n                          :if-exists :error)\n          (notice (file-position s)) ;1\n          (write-byte 5 s) \n          (write-byte 6 s)\n          (let ((p (file-position s)))\n            (notice p) ;2\n            (notice (when p (file-position s (1- p))))) ;3\n          (write-byte 7 s)\n          (notice (file-position s)) ;4\n          (setq file-written (truename s)))\n        (with-open-file (s file-written\n                           :element-type '(unsigned-byte 8)\n                           :direction :input)\n          (notice (file-position s)) ;5\n          (let ((length (file-length s)))\n            (notice length) ;6\n            (when length\n              (dotimes (i length)\n                (notice (read-byte s)))))) ;7,...\n        (nreverse noticed))))\n\u2192 tester\n (tester)\n\u2192 (0 2 T 2 0 2 5 7)\nOR=> (0 2 NIL 3 0 3 5 6 7)\nOR=> (NIL NIL NIL NIL NIL NIL)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (open \\i{filespec} :direction :probe)  \u2192 #<Closed Probe File Stream...>\n%  (setq q (merge-pathnames (user-homedir-pathname) "test"))\n% \u2192 #<PATHNAME :HOST NIL :DEVICE \\i{device-name} :DIRECTORY \\i{directory-name}\n%     :NAME "test" :TYPE NIL :VERSION :NEWEST>\n%  (open \\i{filespec} :if-does-not-exist :create) \u2192 #<Input File Stream...>\n%  (setq s (open \\i{filespec} :direction :probe)) \u2192 #<Closed Probe File Stream...>\n%  (truename s) \u2192 #<PATHNAME :HOST NIL :DEVICE \\i{device-name} :DIRECTORY\n%     \\i{directory-name} :NAME \\i{filespec} :TYPE \\i{extension} :VERSION 1>\n%  (open s :direction :output :if-exists nil) \u2192 NIL \n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (open \\i{filespec} :direction :probe)  \u2192 #<Closed Probe File Stream...>\n (setq q (merge-pathnames (user-homedir-pathname) "test"))\n\u2192 #<PATHNAME :HOST NIL :DEVICE \\i{device-name} :DIRECTORY \\i{directory-name}\n    :NAME "test" :TYPE NIL :VERSION :NEWEST>\n (open \\i{filespec} :if-does-not-exist :create) \u2192 #<Input File Stream...>\n (setq s (open \\i{filespec} :direction :probe)) \u2192 #<Closed Probe File Stream...>\n (truename s) \u2192 #<PATHNAME :HOST NIL :DEVICE \\i{device-name} :DIRECTORY\n    \\i{directory-name} :NAME \\i{filespec} :TYPE \\i{extension} :VERSION 1>\n (open s :direction :output :if-exists nil) \u2192 NIL \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-file (stream "test" :direction :output)\n   (stream-external-format stream))\n\u2192 :DEFAULT\nOR=> :ISO8859/1-1987\nOR=> (:ASCII :SAIL)\nOR=> ACME::PROPRIETARY-FILE-FORMAT-17\nOR=> #<FILE-FORMAT :ISO646-1983 2343673>\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq p (merge-pathnames "test"))\n\u2192 #<PATHNAME :HOST NIL :DEVICE \\i{device-name} :DIRECTORY \\i{directory-name}\n    :NAME "test" :TYPE NIL :VERSION :NEWEST>\n (with-open-file (s p :direction :output :if-exists :supersede)\n    (format s "Here are a couple~%of test data lines~%")) \u2192 NIL\n (with-open-file (s p)\n    (do ((l (read-line s) (read-line s nil \'eof)))\n        ((eq l \'eof) "Reached end of file.")\n     (format t "~&*** ~A~%" l)))\n\\OUT *** Here are a couple\n\\OUT *** of test data lines\n\u2192 "Reached end of file."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (with-open-file (ifile name :direction :input)\n%   (with-open-file (ofile (merge-pathname-defaults ifile\n%                                                   nil\n%                                                   "out")\n%                          :direction :output\n%                          :if-exists :supersede)\n%     (transduce-file ifile ofile)))\n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Normally one would not do this intentionally because it is\n;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL\n;; that this doesn\'t happen to you accidentally...\n (with-open-file (foo "no-such-file" :if-does-not-exist nil)\n   (read foo))\n\\OUT \\IN{hello?}\n\u2192 HELLO? ;This value was read from the terminal, not a file!\n\n;; Here\'s another bug to avoid...\n (with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)\n   (format foo "Hello"))\n\u2192 "Hello" ;FORMAT got an argument of NIL!\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq s (make-broadcast-stream)) \u2192 #<BROADCAST-STREAM>\n (close s) \u2192 T\n (output-stream-p s) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-open-stream (s (make-string-input-stream "1 2 3 4"))\n    (+ (read s) (read s) (read s))) \u2192 6\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (progn (unread-char (read-char)) (list (listen) (read-char)))\n\\OUT \\IN{1}\n\u2192 (T #\\1)\n (progn (clear-input) (listen))\n\u2192 NIL ;Unless you're a very fast typist!\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";; The exact I/O behavior of this example might vary from implementation\n;; to implementation depending on the kind of interactive buffering that\n;; occurs.  (The call to SLEEP here is intended to help even out the \n;; differences in implementations which do not do line-at-a-time buffering.)\n\n(defun read-sleepily (&optional (clear-p nil) (zzz 0))\n  (list (progn (print '>) (read))\n        ;; Note that input typed within the first ZZZ seconds \n        ;; will be discarded.\n        (progn (print '>) \n               (if zzz (sleep zzz))\n               (print '>>)\n               (if clear-p (clear-input))\n               (read))))\n\n(read-sleepily)\n\\OUT > \\IN{10}\n\\OUT >\n\\OUT >> \\IN{20}\n\u2192 (10 20)\n\n(read-sleepily t)\n\\OUT > \\IN{10}\n\\OUT >\n\\OUT >> \\IN{20}\n\u2192 (10 20)\n\n(read-sleepily t 10)\n\\OUT > \\IN{10}\n\\OUT > \\IN{20}  ; Some implementations won't echo typeahead here.\n\\OUT >> \\IN{30}\n\u2192 (10 30)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';; Implementation A\n (progn (princ "am i seen?") (clear-output))\n\u2192 NIL\n\n;; Implementation B\n (progn (princ "am i seen?") (clear-output))\n\\OUT am i seen?\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (y-or-n-p "(t or nil) given by")\n\\OUT (t or nil) given by (Y or N) \\IN{Y}\n\u2192 T\n (yes-or-no-p "a ~S message" \'frightening) \n\\OUT a FRIGHTENING message (Yes or No) \\IN{no}\n\u2192 NIL\n (y-or-n-p "Produce listing file?") \n\\OUT Produce listing file?\n\\OUT Please respond with Y or N. \\IN{n}\n\u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a-stream (make-string-input-stream "a-stream")\n        b-stream (make-string-input-stream "b-stream"))\n\u2192 #<String Input Stream> \n (setq s-stream (make-synonym-stream \'c-stream))\n\u2192 #<SYNONYM-STREAM for C-STREAM> \n (setq c-stream a-stream)\n\u2192 #<String Input Stream> \n (read s-stream) \u2192 A-STREAM\n (setq c-stream b-stream)\n\u2192 #<String Input Stream> \n (read s-stream) \u2192 B-STREAM\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a-stream (make-string-output-stream)\n        b-stream (make-string-output-stream)) \u2192 #<String Output Stream>\n (format (make-broadcast-stream a-stream b-stream)\n          "this will go to both streams") \u2192 NIL\n (get-output-stream-string a-stream) \u2192 "this will go to both streams"\n (get-output-stream-string b-stream) \u2192 "this will go to both streams"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-output-to-string (out)\n    (with-input-from-string (in "input...")\n      (let ((two (make-two-way-stream in out)))\n        (format two "output...")\n        (setq what-is-read (read two))))) \u2192 "output..."\n what-is-read \u2192 INPUT... \n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((out (make-string-output-stream)))\n    (with-open-stream \n        (s (make-echo-stream\n            (make-string-input-stream "this-is-read-and-echoed")\n            out))\n      (read s)\n      (format s " * this-is-direct-output")\n      (get-output-stream-string out)))\n\u2192 "this-is-read-and-echoed * this-is-direct-output"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (read (make-concatenated-stream\n         (make-string-input-stream "1")\n         (make-string-input-stream "2"))) \u2192 12\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq a-stream (make-string-output-stream)\n        a-string "abcdefghijklm") \u2192 "abcdefghijklm"\n (write-string a-string a-stream) \u2192 "abcdefghijklm"\n (get-output-stream-string a-stream) \u2192 "abcdefghijklm"\n (get-output-stream-string a-stream) \u2192 ""\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((string-stream (make-string-input-stream "1 one ")))\n   (list (read string-stream nil nil)\n         (read string-stream nil nil)\n         (read string-stream nil nil)))\n\u2192 (1 ONE NIL)\n\n (read (make-string-input-stream "prefixtargetsuffix" 6 12)) \u2192 TARGET\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (let ((s (make-string-output-stream)))\n   (write-string "testing... " s)\n   (prin1 1234 s)\n   (get-output-stream-string s))\n\u2192 "testing... 1234"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-input-from-string (s "XXX1 2 3 4xxx"\n                             :index ind\n                             :start 3 :end 10)\n    (+ (read s) (read s) (read s))) \u2192 6\n ind \u2192 9\n (with-input-from-string (s "Animal Crackers" :index j :start 6)\n   (read s)) \u2192 CRACKERS\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq fstr (make-array \'(0) :element-type \'base-char\n                             :fill-pointer 0 :adjustable t)) \u2192 ""\n (with-output-to-string (s fstr)\n    (format s "here\'s some output")\n    (input-stream-p s)) \u2192 NIL\n fstr \u2192 "here\'s some output"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% %  (with-output-to-string (out)\n% %    (with-input-from-string (in "enter > ")\n% %      (let ((two-way (make-two-way-stream in out)))\n% %        (setq *debug-io* two-way)))) \u2192 ""           \n% %  *debug-io* \u2192 #<TWO-WAY-STREAM>\n% % \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (with-output-to-string (*error-output*)\n%    (warn "this string is sent to *error-output*"))\n%  \u2192 "Warning: this string is sent to *error-output*\n% " ;The exact format of this string is implementation-dependent.\n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (with-input-from-string (*standard-input* "1001")\n%     (+ 990 (read))) \u2192 1991                       \n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (progn (setq out (with-output-to-string (*standard-output*)\n%                      (print "print and format t send things to")\n%                      (format t "*standard-output* now going to a string")))\n%         :done)\n% \u2192 :DONE\n%  out\n% \u2192 "\n% \\"print and format t send things to\\" *standard-output* now going to a string"\n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))\n% \u2192 FACT\n%  (trace fact)\n% \u2192 (FACT)\n% ;; Of course, the format of traced output is implementation-dependent.\n%  (with-output-to-string (*trace-output*)\n%    (fact 3)) \n% \u2192 "\n% 1 Enter FACT 3\n% | 2 Enter FACT 2\n% |   3 Enter FACT 1\n% |   3 Exit FACT 1\n% | 2 Exit FACT 2\n% 1 Exit FACT 6"\n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (progn (prin1 'foo) (prin1 'bar *terminal-io*))\n% \\OUT FOOBAR\n% \u2192 BAR\n%  (with-output-to-string (*standard-output*)\n%    (prin1 'foo) \n%    (prin1 'bar *terminal-io*))\n% \\OUT BAR\n% \u2192 \"FOO\"\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-output-to-string (*error-output*)\n   (warn "this string is sent to *error-output*"))\n \u2192 "Warning: this string is sent to *error-output*\n" ;The exact format of this string is implementation-dependent.\n\\medbreak\n (with-input-from-string (*standard-input* "1001")\n    (+ 990 (read))) \u2192 1991                       \n\\medbreak\n (progn (setq out (with-output-to-string (*standard-output*)\n                     (print "print and format t send things to")\n                     (format t "*standard-output* now going to a string")))\n        :done)\n\u2192 :DONE\n out\n\u2192 "\n\\"print and format t send things to\\" *standard-output* now going to a string"\n\\medbreak\n (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))\n\u2192 FACT\n (trace fact)\n\u2192 (FACT)\n;; Of course, the format of traced output is implementation-dependent.\n (with-output-to-string (*trace-output*)\n   (fact 3)) \n\u2192 "\n1 Enter FACT 3\n| 2 Enter FACT 2\n|   3 Enter FACT 1\n|   3 Exit FACT 1\n| 2 Exit FACT 2\n1 Exit FACT 6"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (progn (prin1 'foo) (prin1 'bar *terminal-io*))\n\\OUT FOOBAR\n\u2192 BAR\n (with-output-to-string (*standard-output*)\n   (prin1 'foo) \n   (prin1 'bar *terminal-io*))\n\\OUT BAR\n\u2192 \"FOO\"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (with-input-from-string (s "(FOO")\n   (handler-case (read s)\n     (end-of-file (c)\n       (format nil "~&End of file on ~S." (stream-error-stream c)))))\n"End of file on #<String Stream>."\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (simple-string-p "aaaaaa") \u2192 T\n (simple-string-p (make-array 6 \n                              :element-type \'character \n                              :fill-pointer t)) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (simple-string-p \\param{object}) \\EQ (typep \\param{object} 'simple-string)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq my-simple-string (make-string 6 :initial-element #\\A)) \u2192 "AAAAAA"\n (schar my-simple-string 4) \u2192 #\\A\n (setf (schar my-simple-string 4) #\\B) \u2192 #\\B\n my-simple-string \u2192 "AAAABA"\n (setq my-filled-string\n       (make-array 6 :element-type \'character\n                     :fill-pointer 5\n                     :initial-contents my-simple-string))\n\u2192 "AAAAB"\n (char my-filled-string 4) \u2192 #\\B\n (char my-filled-string 5) \u2192 #\\A\n (setf (char my-filled-string 3) #\\C) \u2192 #\\C\n (setf (char my-filled-string 5) #\\D) \u2192 #\\D\n (setf (fill-pointer my-filled-string) 6) \u2192 6\n my-filled-string \u2192 "AAACBD"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (char s j) \\EQ (aref (the string s) j)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (string "already a string") \u2192 "already a string"\n (string \'elm) \u2192 "ELM"\n (string #\\c) \u2192 "c"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (string-upcase "abcde") \u2192 "ABCDE"\n (string-upcase "Dr. Livingston, I presume?")\n\u2192 "DR. LIVINGSTON, I PRESUME?"\n (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)\n\u2192 "Dr. LiVINGston, I presume?"\n (string-downcase "Dr. Livingston, I presume?")\n\u2192 "dr. livingston, i presume?"\n\n (string-capitalize "elm 13c arthur;fig don\'t") \u2192 "Elm 13c Arthur;Fig Don\'T"\n (string-capitalize " hello ") \u2192 " Hello "\n (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")\n\u2192  "Occluded Casements Forestall Inadvertent Defenestration"\n (string-capitalize \'kludgy-hash-search) \u2192 "Kludgy-Hash-Search"\n (string-capitalize "DON\'T!") \u2192 "Don\'T!"    ;not "Don\'t!"\n (string-capitalize "pipe 13a, foo16c") \u2192 "Pipe 13a, Foo16c"\n\n (setq str (copy-seq "0123ABCD890a")) \u2192 "0123ABCD890a"\n (nstring-downcase str :start 5 :end 7) \u2192 "0123AbcD890a"\n str \u2192 "0123AbcD890a"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (string-trim "abc" "abcaakaaakabcaaa") \u2192 "kaaak"\n (string-trim \'(#\\Space #\\Tab #\\Newline) " garbanzo beans\n        ") \u2192 "garbanzo beans"\n (string-trim " (*)" " ( *three (silly) words* ) ")\n\u2192 "three (silly) words"\n\n (string-left-trim "abc" "labcabcabc") \u2192 "labcabcabc"\n (string-left-trim " (*)" " ( *three (silly) words* ) ")\n\u2192 "three (silly) words* ) "\n\n (string-right-trim " (*)" " ( *three (silly) words* ) ") \n\u2192 " ( *three (silly) words"\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (not (= (- end1 start1) (- end2 start2)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (string= "foo" "foo") \u2192 T\n (string= "foo" "Foo") \u2192 NIL\n (string= "foo" "bar") \u2192 NIL\n (string= "together" "frog" :start1 1 :end1 3 :start2 2) \u2192 T\n (string-equal "foo" "Foo") \u2192 T\n (string= "abcd" "01234abcd9012" :start2 5 :end2 9) \u2192 T\n (string< "aaaa" "aaab") \u2192 3\n (string>= "aaaaa" "aaaa") \u2192 4\n (string-not-greaterp "Abcde" "abcdE") \u2192 5\n (string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7\n                                      :start2 2 :end2 6) \u2192 6\n (string-not-equal "AAAA" "aaaA") \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (stringp "aaaaaa") \u2192 T\n (stringp #\\a) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (stringp \\param{object}) \\EQ (typep \\param{object} 'string)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (make-string 10 :initial-element #\\5) \u2192 "5555555555"\n (length (make-string 10)) \u2192 10\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defstruct person (name 007 :type string)) \n (make-person :name "James")\n (make-person)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct ship\n   (x-position 0.0 :type short-float)\n   (y-position 0.0 :type short-float)\n   (x-velocity 0.0 :type short-float)\n   (y-velocity 0.0 :type short-float)\n   (mass *default-ship-mass* :type short-float :read-only t))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (defstruct door knob-color width material) \u2192 DOOR\n%  (setq my-door (make-door :knob-color 'red :width 5.0)) \n% \u2192 #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)\n%  (door-width my-door) \u2192 5.0\n%  (setf (door-width my-door) 43.7)\n%  (door-width my-door) \u2192 43.7\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (door (:conc-name dr-)) knob-color width material) \u2192 DOOR\n (setq my-door (make-door :knob-color 'red :width 5.0)) \n\u2192 #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)\n (dr-width my-door) \u2192 5.0\n (setf (dr-width my-door) 43.7) \u2192 43.7\n (dr-width my-door) \u2192 43.7\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (\\param{copier-name} x) = (copy-structure (the \\param{structure-name} x))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct person name age sex)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (astronaut (:include person)\n                       (:conc-name astro-))\n    helmet-size\n    (favorite-beverage 'tang))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x (make-astronaut :name 'buzz\n                         :age 45.\n                         :sex t\n                         :helmet-size 17.5))\n (person-name x) \u2192 BUZZ\n (astro-name x) \u2192 BUZZ\n (astro-favorite-beverage x) \u2192 TANG\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (reduce #'+ astros :key #'person-age) ; obtains the total of the ages \n                                       ; of the possibly empty\n                                       ; sequence of astros\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep (make-astronaut) 'person) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (:include \\param{included-structure-name} \\starparam{slot-description})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (astronaut (:include person (age 45)))\n    helmet-size\n    (favorite-beverage 'tang))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (binop (:type list) :named (:initial-offset 2))\n   (operator '? :type symbol)   \n   operand-1\n   operand-2) \u2192 BINOP\n (defstruct (annotated-binop (:type list)\n                             (:initial-offset 3)\n                             (:include binop))\n  commutative associative identity) \u2192 ANNOTATED-BINOP\n (make-annotated-binop :operator '*\n                       :operand-1 'x\n                       :operand-2 5\n                       :commutative t\n                       :associative t\n                       :identity 1)\n   \u2192 (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (binop (:type list) (:initial-offset 2))\n   (operator '? :type symbol)\n   operand-1\n   operand-2) \u2192 BINOP\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-binop :operator '+ :operand-1 'x :operand-2 5)\n\u2192 (NIL NIL + X 5)\n (make-binop :operand-2 4 :operator '*)\n\u2192 (NIL NIL * NIL 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (binop (:type list) :named (:initial-offset 2))\n   (operator '? :type symbol)\n   operand-1\n   operand-2) \u2192 BINOP\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-binop :operator '+ :operand-1 'x :operand-2 5) \u2192 (NIL NIL BINOP + X 5)\n (make-binop :operand-2 4 :operator '*) \u2192 (NIL NIL BINOP * NIL 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (binop (:type list))\n   (operator '? :type symbol)\n   operand-1\n   operand-2) \u2192 BINOP\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-binop :operator '+ :operand-1 'x :operand-2 5) \u2192 (+ X 5)  \n (make-binop :operand-2 4 :operator '*) \u2192 (* NIL 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (binop (:type list) :named)\n   (operator '? :type symbol)\n   operand-1\n   operand-2) \u2192 BINOP\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (make-binop :operator '+ :operand-1 'x :operand-2 5) \u2192 (BINOP + X 5)\n (make-binop :operand-2 4 :operator '*) \u2192 (BINOP * NIL 4)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun binop-p (x)\n   (and (consp x) (eq (car x) 'binop))) \u2192 BINOP-P\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod print-object ((object \\param{structure-name}) stream)\n   (funcall (function \\param{printer-name}) object stream \\metaparam{current-print-depth}))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defmethod print-object ((object \\param{structure-name}) stream)\n   (funcall (function \\param{printer-name}) object stream))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct (quux (:type list) :named) x y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (deftype quux () '(satisfies quux-p))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep (make-quux) 'quux)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep (list 'quux nil nil) 'quux)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defstruct ship\n   x-position\n   y-position\n   x-velocity\n   y-velocity\n   mass)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq ship2 (make-ship))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq ship2 (make-ship :mass *default-ship-mass*\n                        :x-position 0\n                        :y-position 0))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (ship-x-position ship2) 100)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:";;;\n;;; Example 1\n;;; define town structure type\n;;; area, watertowers, firetrucks, population, elevation are its components\n;;;\n (defstruct town\n             area\n             watertowers\n             (firetrucks 1 :type fixnum)    ;an initialized slot\n             population \n             (elevation 5128 :read-only t)) ;a slot that can't be changed\n\u2192 TOWN\n;create a town instance\n (setq town1 (make-town :area 0 :watertowers 0)) \u2192 #S(TOWN...)\n;town's predicate recognizes the new instance\n (town-p town1) \u2192 T\n;new town's area is as specified by make-town\n (town-area town1) \u2192 0\n;new town's elevation has initial value\n (town-elevation town1) \u2192 5128\n;setf recognizes reader function\n (setf (town-population town1) 99) \u2192 99\n (town-population town1) \u2192 99\n;copier function makes a copy of town1\n (setq town2 (copy-town town1)) \u2192 #S(TOWN...)\n (= (town-population town1) (town-population town2))  \u2192 T\n;since elevation is a read-only slot, its value can be set only\n;when the structure is created\n (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))\n\u2192 #S(TOWN...)\n;;;\n;;; Example 2\n;;; define clown structure type\n;;; this structure uses a nonstandard prefix\n;;;\n (defstruct (clown (:conc-name bozo-))\n             (nose-color 'red)         \n             frizzy-hair-p polkadots) \u2192 CLOWN\n (setq funny-clown (make-clown)) \u2192 #S(CLOWN)\n;use non-default reader name\n (bozo-nose-color funny-clown) \u2192 RED        \n (defstruct (klown (:constructor make-up-klown) ;similar def using other\n             (:copier clone-klown)              ;customizing keywords\n             (:predicate is-a-bozo-p))\n             nose-color frizzy-hair-p polkadots) \u2192 klown\n;custom constructor now exists\n (fboundp 'make-up-klown) \u2192 T\n;;;\n;;; Example 3\n;;; define a vehicle structure type\n;;; then define a truck structure type that includes \n;;; the vehicle structure\n;;;\n (defstruct vehicle name year (diesel t :read-only t)) \u2192 VEHICLE\n (defstruct (truck (:include vehicle (year 79)))\n             load-limit                          \n             (axles 6)) \u2192 TRUCK\n (setq x (make-truck :name 'mac :diesel t :load-limit 17))\n\u2192 #S(TRUCK...)\n;vehicle readers work on trucks\n (vehicle-name x)\n\u2192 MAC\n;default taken from :include clause \n (vehicle-year x)\n\u2192 79 \n (defstruct (pickup (:include truck))     ;pickup type includes truck\n             camper long-bed four-wheel-drive) \u2192 PICKUP\n (setq x (make-pickup :name 'king :long-bed t)) \u2192 #S(PICKUP...)\n;:include default inherited\n (pickup-year x) \u2192 79\n;;;\n;;; Example 4\n;;; use of BOA constructors\n;;;\n (defstruct (dfs-boa                      ;BOA constructors\n               (:constructor make-dfs-boa (a b c)) \n               (:constructor create-dfs-boa\n                 (a &optional b (c 'cc) &rest d &aux e (f 'ff))))\n             a b c d e f) \u2192 DFS-BOA\n;a, b, and c set by position, and the rest are uninitialized\n (setq x (make-dfs-boa 1 2 3)) \u2192 #(DFS-BOA...)\n (dfs-boa-a x) \u2192 1\n;a and b set, c and f defaulted\n (setq x (create-dfs-boa 1 2)) \u2192 #(DFS-BOA...)\n (dfs-boa-b x) \u2192 2\n (eq (dfs-boa-c x) 'cc) \u2192 T\n;a, b, and c set, and the rest are collected into d\n (setq x (create-dfs-boa 1 2 3 4 5 6)) \u2192 #(DFS-BOA...)\n (dfs-boa-d x) \u2192 (4 5 6)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (symbolp 'elephant) \u2192 T\n (symbolp 12) \u2192 NIL\n (symbolp nil) \u2192 T\n (symbolp '()) \u2192 T\n (symbolp :test) \u2192 T\n (symbolp \"hello\") \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (symbolp \\param{object}) \\EQ (typep \\param{object} 'symbol)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (keywordp 'elephant) \u2192 NIL\n (keywordp 12) \u2192 NIL\n (keywordp :test) \u2192 T\n (keywordp ':test) \u2192 T\n (keywordp nil) \u2192 NIL\n (keywordp :nil) \u2192 T\n (keywordp '(:test)) \u2192 NIL\n (keywordp \"hello\") \u2192 NIL\n (keywordp \":hello\") \u2192 NIL\n (keywordp '&optional) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq temp-string "temp") \u2192 "temp"\n (setq temp-symbol (make-symbol temp-string)) \u2192 #:|temp|\n (symbol-name temp-symbol) \u2192 "temp"\n (eq (symbol-name temp-symbol) temp-string) \u2192 implementation-dependent\n (find-symbol "temp") \u2192 NIL, NIL\n (eq (make-symbol temp-string) (make-symbol temp-string)) \u2192 NIL\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq fred 'fred-smith) \u2192 FRED-SMITH\n (setf (symbol-value fred) 3) \u2192 3\n (setq fred-clone-1a (copy-symbol fred nil)) \u2192 #:FRED-SMITH\n (setq fred-clone-1b (copy-symbol fred nil)) \u2192 #:FRED-SMITH\n (setq fred-clone-2a (copy-symbol fred t))   \u2192 #:FRED-SMITH\n (setq fred-clone-2b (copy-symbol fred t))   \u2192 #:FRED-SMITH\n (eq fred fred-clone-1a) \u2192 NIL\n (eq fred-clone-1a fred-clone-1b) \u2192 NIL\n (eq fred-clone-2a fred-clone-2b) \u2192 NIL\n (eq fred-clone-1a fred-clone-2a) \u2192 NIL\n (symbol-value fred) \u2192 3\n (boundp fred-clone-1a) \u2192 NIL\n (symbol-value fred-clone-2a) \u2192 3\n (setf (symbol-value fred-clone-2a) 4) \u2192 4\n (symbol-value fred) \u2192 3\n (symbol-value fred-clone-2a) \u2192 4\n (symbol-value fred-clone-2b) \u2192 3\n (boundp fred-clone-1a) \u2192 NIL\n (setf (symbol-function fred) #'(lambda (x) x)) \u2192 #<FUNCTION anonymous>\n (fboundp fred) \u2192 T\n (fboundp fred-clone-1a) \u2192 NIL\n (fboundp fred-clone-2a) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"% (copy-symbol \\param{x} nil) \\EQ (make-symbol (symbol-name \\param{x}))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (setq sym1 (gensym)) \u2192 #:G3142\n (symbol-package sym1) \u2192 NIL\n (setq sym2 (gensym 100)) \u2192 #:G100\n (setq sym3 (gensym 100)) \u2192 #:G100\n (eq sym2 sym3) \u2192 NIL\n (find-symbol "G100") \u2192 NIL, NIL\n (gensym "T") \u2192 #:T3143\n (gensym) \u2192 #:G3144\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (gentemp) \u2192 T1298\n (gentemp "FOO") \u2192 FOO1299\n (find-symbol "FOO1300") \u2192 NIL, NIL\n (gentemp "FOO") \u2192 FOO1300\n (find-symbol "FOO1300") \u2192 FOO1300, :INTERNAL\n (intern "FOO1301") \u2192 FOO1301, :INTERNAL\n (gentemp "FOO") \u2192 FOO1302\n (gentemp) \u2192 T1303\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (symbol-function 'car) \u2192 #<FUNCTION CAR>\n (symbol-function 'twice) is an error   ;because TWICE isn't defined.\n (defun twice (n) (* n 2)) \u2192 TWICE\n (symbol-function 'twice) \u2192 #<FUNCTION TWICE>\n (list (twice 3)\n       (funcall (function twice) 3)\n       (funcall (symbol-function 'twice) 3))\n\u2192 (6 6 6)\n (flet ((twice (x) (list x x)))\n   (list (twice 3)\n         (funcall (function twice) 3)\n         (funcall (symbol-function 'twice) 3)))\n\u2192 ((3 3) (3 3) 6)   \n (setf (symbol-function 'twice) #'(lambda (x) (list x x)))\n\u2192 #<FUNCTION anonymous>\n (list (twice 3)\n       (funcall (function twice) 3)\n       (funcall (symbol-function 'twice) 3))\n\u2192 ((3 3) (3 3) (3 3))\n (fboundp 'defun) \u2192 T\n (symbol-function 'defun)\n\u2192 implementation-dependent\n (functionp (symbol-function 'defun))\n\u2192 implementation-dependent\n (defun symbol-function-or-nil (symbol)\n   (if (and (fboundp symbol) \n            (not (macro-function symbol))\n            (not (special-operator-p symbol)))\n       (symbol-function symbol)\n       nil)) \u2192 SYMBOL-FUNCTION-OR-NIL\n (symbol-function-or-nil 'car) \u2192 #<FUNCTION CAR>\n (symbol-function-or-nil 'defun) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(symbol-function \\param{symbol}) \\EQ (fdefinition \\param{symbol})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (symbol-name \'temp) \u2192 "TEMP" \n (symbol-name :start) \u2192 "START"\n (symbol-name (gensym)) \u2192 "G1234" ;for example\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (in-package "CL-USER") \u2192 #<PACKAGE "COMMON-LISP-USER">\n (symbol-package \'car) \u2192 #<PACKAGE "COMMON-LISP">\n (symbol-package \'bus) \u2192 #<PACKAGE "COMMON-LISP-USER">\n (symbol-package :optional) \u2192 #<PACKAGE "KEYWORD">\n ;; Gensyms are uninterned, so have no home package.\n (symbol-package (gensym)) \u2192 NIL\n (make-package \'pk1) \u2192 #<PACKAGE "PK1">\n (intern "SAMPLE1" "PK1") \u2192 PK1::SAMPLE1, NIL\n (export (find-symbol "SAMPLE1" "PK1") "PK1") \u2192 T\n (make-package \'pk2 :use \'(pk1)) \u2192 #<PACKAGE "PK2">\n (find-symbol "SAMPLE1" "PK2") \u2192 PK1:SAMPLE1, :INHERITED\n (symbol-package \'pk1::sample1) \u2192 #<PACKAGE "PK1">\n (symbol-package \'pk2::sample1) \u2192 #<PACKAGE "PK1">\n (symbol-package \'pk1::sample2) \u2192 #<PACKAGE "PK1">\n (symbol-package \'pk2::sample2) \u2192 #<PACKAGE "PK2">\n ;; The next several forms create a scenario in which a symbol\n ;; is not really uninterned, but is "apparently uninterned",\n ;; and so SYMBOL-PACKAGE still returns NIL.\n (setq s3 \'pk1::sample3) \u2192 PK1::SAMPLE3\n (import s3 \'pk2) \u2192 T\n (unintern s3 \'pk1) \u2192 T\n (symbol-package s3) \u2192 NIL\n (eq s3 \'pk2::sample3) \u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq sym (gensym)) \u2192 #:G9723\n (symbol-plist sym) \u2192 ()\n (setf (get sym 'prop1) 'val1) \u2192 VAL1\n (symbol-plist sym) \u2192 (PROP1 VAL1)\n (setf (get sym 'prop2) 'val2) \u2192 VAL2\n (symbol-plist sym) \u2192 (PROP2 VAL2 PROP1 VAL1)\n (setf (symbol-plist sym) (list 'prop3 'val3)) \u2192 (PROP3 VAL3)\n (symbol-plist sym) \u2192 (PROP3 VAL3)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (symbol-value 'a) 1) \u2192 1\n (symbol-value 'a) \u2192 1\n ;; SYMBOL-VALUE cannot see lexical variables.\n (let ((a 2)) (symbol-value 'a)) \u2192 1\n (let ((a 2)) (setq a 3) (symbol-value 'a)) \u2192 1\n ;; SYMBOL-VALUE can see dynamic variables.\n (let ((a 2)) \n   (declare (special a)) \n   (symbol-value 'a)) \u2192 2\n (let ((a 2)) \n   (declare (special a)) \n   (setq a 3)\n   (symbol-value 'a)) \u2192 3\n (let ((a 2))\n   (setf (symbol-value 'a) 3)\n   a) \u2192 2\n a \u2192 3\n (symbol-value 'a) \u2192 3\n (let ((a 4))\n   (declare (special a))\n   (let ((b (symbol-value 'a)))\n     (setf (symbol-value 'a) 5)\n     (values a b))) \u2192 5, 4\n a \u2192 3\n (symbol-value :any-keyword) \u2192 :ANY-KEYWORD\n (symbol-value 'nil) \u2192 NIL\n (symbol-value '()) \u2192 NIL\n ;; The precision of this next one is implementation-dependent.\n (symbol-value 'pi) \u2192 3.141592653589793d0  \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun make-person (first-name last-name)\n   (let ((person (gensym "PERSON")))\n     (setf (get person \'first-name) first-name)\n     (setf (get person \'last-name) last-name)\n     person)) \u2192 MAKE-PERSON\n (defvar *john* (make-person "John" "Dow")) \u2192 *JOHN*\n *john* \u2192 #:PERSON4603\n (defvar *sally* (make-person "Sally" "Jones")) \u2192 *SALLY*\n (get *john* \'first-name) \u2192 "John"\n (get *sally* \'last-name) \u2192 "Jones"\n (defun marry (man woman married-name)\n   (setf (get man \'wife) woman)\n   (setf (get woman \'husband) man)\n   (setf (get man \'last-name) married-name)\n   (setf (get woman \'last-name) married-name)\n   married-name) \u2192 MARRY\n (marry *john* *sally* "Dow-Jones") \u2192 "Dow-Jones"\n (get *john* \'last-name) \u2192 "Dow-Jones"\n (get (get *john* \'wife) \'first-name) \u2192 "Sally"\n (symbol-plist *john*)\n\u2192 (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")\n (defmacro age (person &optional (default \'\'thirty-something)) \n   `(get ,person \'age ,default)) \u2192 AGE\n (age *john*) \u2192 THIRTY-SOMETHING\n (age *john* 20) \u2192 20\n (setf (age *john*) 25) \u2192 25\n (age *john*) \u2192 25\n (age *john* 20) \u2192 25\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (get x y) \\EQ (getf (symbol-plist x) y)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (get 'clyde 'species) \u2192 NIL\n%  (setf (get 'clyde 'species) 'elephant) \u2192 elephant\n%  (get 'clyde 'species) \u2192 ELEPHANT\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (push item (get sym 'token-stack '(initial-item)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setf (get sym 'token-stack '(initial-item))\n%        (cons item (get sym 'token-stack '(initial-item))))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (setf (get sym 'token-stack)\n%        (cons item (get sym 'token-stack '(initial-item))))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (remprop \\i{x} \\i{y}) \\EQ (remf (symbol-plist \\i{x}) \\i{y})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq test (make-symbol \"PSEUDO-PI\")) \u2192 #:PSEUDO-PI\n (symbol-plist test) \u2192 ()\n (setf (get test 'constant) t) \u2192 T\n (setf (get test 'approximation) 3.14) \u2192 3.14\n (setf (get test 'error-range) 'noticeable) \u2192 NOTICEABLE\n (symbol-plist test) \n\u2192 (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)\n (setf (get test 'approximation) nil) \u2192 NIL\n (symbol-plist test) \n\u2192 (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)\n (get test 'approximation) \u2192 NIL\n (remprop test 'approximation) \u2192 T\n (get test 'approximation) \u2192 NIL\n (symbol-plist test)\n\u2192 (ERROR-RANGE NOTICEABLE CONSTANT T)\n (remprop test 'approximation) \u2192 NIL\n (symbol-plist test)\n\u2192 (ERROR-RANGE NOTICEABLE CONSTANT T)\n (remprop test 'error-range) \u2192 T\n (setf (get test 'approximation) 3) \u2192 3\n (symbol-plist test)\n\u2192 (APPROXIMATION 3 CONSTANT T)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setq x 1) \u2192 1\n (boundp 'x) \u2192 T\n (makunbound 'x) \u2192 X\n (boundp 'x) \u2192 NIL\n (let ((x 2)) (boundp 'x)) \u2192 NIL\n (let ((x 2)) (declare (special x)) (boundp 'x)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (symbol-value 'a) 1)\n (boundp 'a) \u2192 T\n a \u2192 1\n (makunbound 'a) \u2192 A\n (boundp 'a) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"(set \\param{symbol} \\param{value}) \\EQ (setf (symbol-value \\param{symbol}) \\param{value})\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (setf (symbol-value 'n) 1) \u2192 1\n (set 'n 2) \u2192 2\n (symbol-value 'n) \u2192 2\n (let ((n 3))\n   (declare (special n))\n   (setq n (+ n 1))\n   (setf (symbol-value 'n) (* n 10))\n   (set 'n (+ (symbol-value 'n) n))\n   n) \u2192 80\n n \u2192 2\n (let ((n 3))\n   (setq n (+ n 1))\n   (setf (symbol-value 'n) (* n 10))\n   (set 'n (+ (symbol-value 'n) n))\n   n) \u2192 4\n n \u2192 44\n (defvar *n* 2)\n (let ((*n* 3))\n   (setq *n* (+ *n* 1))\n   (setf (symbol-value '*n*) (* *n* 10))\n   (set '*n* (+ (symbol-value '*n*) *n*))\n   *n*) \u2192 80\n  *n* \u2192 2\n (defvar *even-count* 0) \u2192 *EVEN-COUNT*\n (defvar *odd-count* 0) \u2192 *ODD-COUNT*\n (defun tally-list (list)\n   (dolist (element list)\n     (set (if (evenp element) '*even-count* '*odd-count*)\n          (+ element (if (evenp element) *even-count* *odd-count*)))))\n (tally-list '(1 9 4 3 2 7)) \u2192 NIL\n *even-count* \u2192 6\n *odd-count* \u2192 20\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';Establish a data file...\n (with-open-file (str "data.in" :direction :output :if-exists :error)\n   (print 1 str) (print \'(setq a 888) str) t)\n\u2192 T\n (load "data.in") \u2192 T\n a \u2192 888\n (load (setq p (merge-pathnames "data.in")) :verbose t)\n; Loading contents of file /fred/data.in\n; Finished loading /fred/data.in\n\u2192 T\n (load p :print t) \n; Loading contents of file /fred/data.in\n;  1\n;  888\n; Finished loading /fred/data.in\n\u2192 T\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' ;----[Begin file SETUP]----\n (in-package "MY-STUFF")\n (defmacro compile-truename () `\',*compile-file-truename*)\n (defvar *my-compile-truename* (compile-truename) "Just for debugging.")\n (defvar *my-load-pathname* *load-pathname*)\n (defun load-my-system ()\n   (dolist (module-name \'("FOO" "BAR" "BAZ"))\n     (load (merge-pathnames module-name *my-load-pathname*))))\n ;----[End of file SETUP]----\n\n \n (load "SETUP")\n (load-my-system)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (with-compilation-unit (:override nil) ...)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:' (defun compile-files (&rest files)\n   (with-compilation-unit ()\n     (mapcar #\'(lambda (file) (compile-file file)) files)))\n\n (compile-files "A" "B" "C")\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'%  ;;;; New and improved lisp init file for I. Newton\n% \n%  ;;; Set up the CL-USER package the way I like it.\n%  (require "CALCULUS")     ; I use CALCULUS a lot. Load it.\n%  (use-package "CALCULUS") ; Get easy access to exported symbols.\n% \n%  (require "NEWTONIAN-MECHANICS") ;Ditto for NEWTONIAN-MECHANICS\n%  (use-package "NEWTONIAN-MECHANICS")\n% \n%  ;;; Ignore that Relativity stuff until they\'ve got it debugged better.\n%  ;(require "RELATIVITY")\n% \n%  ;;; These are worth loading, but I\'ll use qualified names, such\n%  ;;; as PHLOGISTON:MAKE-FIRE-BOTTLE, to get any symbols I might need.\n%  (require "PHLOGISTON")\n%  (require "ALCHEMY")\n% \n%  (provide "NEWTON-PERSONAL-PREFERENCES")\n% \n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:';;; This illustrates a nonportable use of REQUIRE, because it\n;;; depends on the implementation-dependent file-loading mechanism.\n\n(require "CALCULUS")\n\n;;; This use of REQUIRE is nonportable because of the literal \n;;; physical pathname.  \n\n(require "CALCULUS" "/usr/lib/lisp/calculus")\n\n;;; One form of portable usage involves supplying a logical pathname,\n;;; with appropriate translations defined elsewhere.\n\n(require "CALCULUS" "lib:calculus")\n\n;;; Another form of portable usage involves using a variable or\n;;; table lookup function to determine the pathname, which again\n;;; must be initialized elsewhere.\n\n(require "CALCULUS" *calculus-module-pathname*)\n\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (function ((integer 0) &key (:initial-element t)) list)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ftype (function (arg0-type arg1-type ...) val-type) f))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)\n                  (and val-type1 val-type2)) \n        f))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"%  (deftype standard-char () '(and character (satisfies standard-char-p)))\n% \n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (coerce '(a b c) 'vector) \u2192 #(A B C)\n (coerce 'a 'character) \u2192 #\\A\n (coerce 4.56 'complex) \u2192 #C(4.56 0.0)\n (coerce 4.5s0 'complex) \u2192 #C(4.5s0 0.0s0)\n (coerce 7/2 'complex) \u2192 7/2\n (coerce 0 'short-float) \u2192 0.0s0\n (coerce 3.5L0 'float) \u2192 3.5L0\n (coerce 7/2 'float) \u2192 3.5\n (coerce (cons 1 2) t) \u2192 (1 . 2)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (coerce '(a b c) '(vector * 4))\n (coerce #(a b c) '(vector * 4))\n (coerce '(a b c) '(vector * 2))\n (coerce #(a b c) '(vector * 2))\n (coerce \"foo\" '(string 2))\n (coerce #(#\\a #\\b #\\c) '(string 2))\n (coerce '(0 1) '(simple-bit-vector 3))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (coerce x 't) \\EQ (identity x) \\EQ x\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun equidimensional (a)\n   (or (< (array-rank a) 2)\n       (apply #'= (array-dimensions a)))) \u2192 EQUIDIMENSIONAL\n (deftype square-matrix (&optional type size)\n   `(and (array ,type (,size ,size))\n         (satisfies equidimensional))) \u2192 SQUARE-MATRIX\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep '(array T1) '(array T2)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (upgraded-array-element-type 'T1)  and\n (upgraded-array-element-type 'T2)  \n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep '(complex T1) '(complex T2)) \u2192 T, true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep '(complex single-float) '(complex float))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep '(array single-float) '(array float))\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep 'compiled-function 'function) \u2192 T, true\n (subtypep 'null 'list) \u2192 T, true\n (subtypep 'null 'symbol) \u2192 T, true\n (subtypep 'integer 'string) \u2192 NIL, true\n (subtypep '(satisfies dummy) nil) \u2192 NIL, implementation-dependent\n (subtypep '(integer 1 3) '(integer 1 4)) \u2192 T, true\n (subtypep '(integer (0) (0)) 'nil) \u2192 T, true\n (subtypep 'nil '(integer (0) (0))) \u2192 T, true\n (subtypep '(integer (0) (0)) '(member)) \u2192 T, true ;or false, false\n (subtypep '(member) 'nil) \u2192 T, true ;or false, false\n (subtypep 'nil '(member)) \u2192 T, true ;or false, false\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))\n            (array-element-type (make-array 0 :element-type '<aet-y>)))\n\u2192 T, true\n \n  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))\n            (array-element-type (make-array 0 :element-type '<aet-x>)))\n\u2192 T, true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep '(array <aet-x>) '(array <aet-y>)) \u2192 T, true\n (subtypep '(array <aet-y>) '(array <aet-x>)) \u2192 T, true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (subtypep (type-of \\param{object}) (class-of \\param{object})) \u2192 T, true\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:'% (type-of "abc") \u2192 SIMPLE-STRING\n% (type-of "abc") \u2192 STRING\n% (type-of "abc") \u2192 ARRAY\n%\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (type-of 'a) \u2192 SYMBOL          \n (type-of '(1 . 2))\n\u2192 CONS\nOR=> (CONS FIXNUM FIXNUM)\n (type-of #c(0 1))\n\u2192 COMPLEX\nOR=> (COMPLEX INTEGER)\n (defstruct temp-struct x y z) \u2192 TEMP-STRUCT\n (type-of (make-temp-struct)) \u2192 TEMP-STRUCT\n (type-of \"abc\")\n\u2192 STRING\nOR=> (STRING 3)\n (subtypep (type-of \"abc\") 'string) \u2192 T, true\n (type-of (expt 2 40))\n\u2192 BIGNUM\nOR=> INTEGER\nOR=> (INTEGER 1099511627776 1099511627776)\nOR=> SYSTEM::TWO-WORD-BIGNUM\nOR=> FIXNUM\n (subtypep (type-of 112312) 'integer) \u2192 T, true\n (defvar *foo* (make-array 5 :element-type t)) \u2192 *FOO*\n (class-name (class-of *foo*)) \u2192 VECTOR\n (type-of *foo*)\n\u2192 VECTOR\nOR=> (VECTOR T 5)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep realpart 'type-specifier)\n (typep imagpart 'type-specifier)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep 12 'integer) \u2192 T\n (typep (1+ most-positive-fixnum) 'fixnum) \u2192 NIL\n (typep nil t) \u2192 T\n (typep nil nil) \u2192 NIL\n (typep 1 '(mod 2)) \u2192 T\n (typep #c(1 1) '(complex (eql 1))) \u2192 T\n;; To understand this next example, you might need to refer to\n;; \\secref\\RuleOfCanonRepForComplexRationals.\n (typep #c(0 0) '(complex (eql 0))) \u2192 NIL\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (upgraded-array-element-type 'A\\sssx)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (upgraded-array-element-type 'A\\sssy)\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (typep (make-array 0 :element-type 'A\\sssx) '(array A\\sssx)) \u2192 T\n (typep (make-array 0 :element-type 'A\\sssy) '(array A\\sssy)) \u2192 T\n (typep (make-array 0 :element-type 'A\\sssx) '(array A\\sssy)) \u2192 T\n (typep (make-array 0 :element-type 'A\\sssy) '(array A\\sssx)) \u2192 T\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:"\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp",children:" (defun fix-digits (condition)\n   (check-type condition type-error)\n   (let* ((digits '(zero one two three four\n                   five six seven eight nine))\n         (val (position (type-error-datum condition) digits)))\n     (if (and val (subtypep 'fixnum (type-error-expected-type condition)))\n         (store-value 7))))\n \n (defun foo (x)\n   (handler-bind ((type-error #'fix-digits))\n     (check-type x number)\n     (+ x 3)))\n \n (foo 'seven)\n\u2192 10\n\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp..."})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-lisp{\\screen!}",children:"\\def\n"})})]})}function p(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},11151:(n,e,a)=>{a.d(e,{Z:()=>i,a:()=>l});var s=a(67294);const t={},r=s.createContext(t);function l(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);