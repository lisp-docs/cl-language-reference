"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[81033],{4236:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>x,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var i=r(85893),s=r(11151);function t(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"Symbol"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"{declaration-specifier}"}),"*"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Arguments:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"declaration-specifier"}),"\u2014a ",(0,i.jsx)(n.em,{children:"declaration specifier"})," ; not evaluated."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"}),", sometimes called a ",(0,i.jsx)(n.em,{children:"declaration"}),", can occur only at the beginning of the bodies of certain ",(0,i.jsx)(n.em,{children:"forms"}),"; that is, it may be preceded only by other ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expressions"}),", or by a ",(0,i.jsx)(n.em,{children:"documentation string"})," if the context permits."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"})," can occur in a ",(0,i.jsx)(n.em,{children:"lambda expression"})," or in any of the ",(0,i.jsx)(n.em,{children:"forms"})," listed in Figure 3\u201323."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"declare"})}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"defgeneric do-external-symbols prog"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"define-compiler-macro do-symbols prog*"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"define-method-combination dolist restart-case define-setf-expander dotimes symbol-macrolet defmacro flet with-accessors defmethod handler-case with-hash-table-iterator defsetf labels with-input-from-string deftype let with-open-file defun let* with-open-stream destructuring-bind locally with-output-to-string do macrolet with-package-iterator do* multiple-value-bind with-slots"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"do-all-symbols pprint-logical-block"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 3\u201323. Standardized Forms In Which Declarations Can Occur"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"})," can only occur where specified by the syntax of these ",(0,i.jsx)(n.em,{children:"forms"}),". The consequences of attempting to evaluate a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"})," are undefined. In situations where such ",(0,i.jsx)(n.em,{children:"expressions"})," can appear, explicit checks are made for their presence and they are never actually evaluated; it is for this reason that they are called \u201c",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expressions"}),"\u201d rather than \u201c",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"forms"}),".\u201d"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Macro forms"})," cannot expand into declarations; ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expressions"})," must appear as actual ",(0,i.jsx)(n.em,{children:"subexpressions"})," of the ",(0,i.jsx)(n.em,{children:"form"})," to which they refer."]}),"\n",(0,i.jsxs)(n.p,{children:["Figure 3\u201324 shows a list of ",(0,i.jsx)(n.em,{children:"declaration identifiers"})," that can be used with ",(0,i.jsx)(n.strong,{children:"declare"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["|",(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"dynamic-extent ignore optimize"})," "]}),(0,i.jsxs)("p",{children:[(0,i.jsx)(n.strong,{children:"ftype inline special"})," "]}),(0,i.jsx)("p",{children:(0,i.jsx)(n.strong,{children:"ignorable notinline type"})}),"|"]}),"\n",(0,i.jsx)(n.p,{children:"| :- |"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 3\u201324. Local Declaration Specifiers"})}),"\n",(0,i.jsxs)(n.p,{children:["An implementation is free to support other (",(0,i.jsx)(n.em,{children:"implementation-defined"}),") ",(0,i.jsx)(n.em,{children:"declaration identifiers"})," as well. ",(0,i.jsx)(n.strong,{children:"Examples:"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"\n(defun nonsense (k x z) \n  (foo z x) ;First call to foo \n  (let ((j (foo k x)) ;Second call to foo \n\t(x (\\* k k))) \n    (declare (inline foo) (special x z)) \n    (foo x j z))) ;Third call to foo \nIn this example, the **inline** declaration applies only to the third call to foo, but not to the first or second ones. The **special** declaration of x causes **let** to make a dynamic *binding* for x, and \nEvaluation and \n\n\ncauses the reference to x in the body of **let** to be a dynamic reference. The reference to x in the second call to foo is a local reference to the second parameter of nonsense. The reference to x in the first call to foo is a local reference, not a **special** one. The **special** declaration of z causes the \nreference to z in the third call to foo to be a dynamic reference; it does not refer to the parameter to nonsense named z, because that parameter *binding* has not been declared to be **special**. (The **special** declaration of z does not appear in the body of **defun**, but in an inner *form*, and therefore does not a\u21b5ect the *binding* of the *parameter* .) \n\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(n.p,{children:["The consequences of trying to use a ",(0,i.jsx)(n.strong,{children:"declare"})," ",(0,i.jsx)(n.em,{children:"expression"})," as a ",(0,i.jsx)(n.em,{children:"form"})," to be ",(0,i.jsx)(n.em,{children:"evaluated"})," are undefined."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"proclaim"}),", Section 4.2.3 (Type Specifiers), ",(0,i.jsx)(n.strong,{children:"declaration"}),", ",(0,i.jsx)(n.strong,{children:"dynamic-extent"}),", ",(0,i.jsx)(n.strong,{children:"ftype"}),", ",(0,i.jsx)(n.strong,{children:"ignorable"}),", ",(0,i.jsx)(n.strong,{children:"ignore"}),", ",(0,i.jsx)(n.strong,{children:"inline"}),", ",(0,i.jsx)(n.strong,{children:"notinline"}),", ",(0,i.jsx)(n.strong,{children:"optimize"}),", ",(0,i.jsx)(n.strong,{children:"type"})]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}const o={},a="declare",l={id:"chap-3/d-i-dictionary/declare",title:"declare",description:"Expanded Reference: declare",source:"@site/docs/chap-3/d-i-dictionary/declare.md",sourceDirName:"chap-3/d-i-dictionary",slug:"/chap-3/d-i-dictionary/declare",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/declare",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-3/d-i-dictionary/declare.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"declaration",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/declaration"},next:{title:"define-compiler-macro",permalink:"/cl-language-reference/docs/chap-3/d-i-dictionary/definecompilermacro"}},d={},h=[{value:"Expanded Reference: declare",id:"expanded-reference-declare",level:2}];function p(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"declare",children:"declare"}),"\n","\n","\n",(0,i.jsx)(c,{}),"\n",(0,i.jsx)(n.h2,{id:"expanded-reference-declare",children:"Expanded Reference: declare"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"(declare )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>c});var i=r(67294);const s={},t=i.createContext(s);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);