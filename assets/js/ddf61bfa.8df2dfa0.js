"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[33890],{40849:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>Q,contentTitle:()=>H,default:()=>U,frontMatter:()=>M,metadata:()=>V,toc:()=>T});var n=t(85893),s=t(11151);function o(e){return(0,n.jsx)(n.Fragment,{})}function r(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(o,{...e})}):o()}function c(e){const i={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["Figure 18\u20131 lists some ",(0,n.jsx)(i.em,{children:"defined names"})," that are applicable to ",(0,n.jsx)(i.em,{children:"hash tables"}),". The following rules apply to ",(0,n.jsx)(i.em,{children:"hash tables"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 A ",(0,n.jsx)(i.em,{children:"hash table"})," can only associate one value with a given key. If an attempt is made to add a second value for a given key, the second value will replace the first. Thus, adding a value to a ",(0,n.jsx)(i.em,{children:"hash table"})," is a destructive operation; the ",(0,n.jsx)(i.em,{children:"hash table"})," is modified."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 There are four kinds of ",(0,n.jsx)(i.em,{children:"hash tables"}),": those whose keys are compared with ",(0,n.jsx)(t,{term:"eq",children:(0,n.jsx)("b",{children:"eq"})}),", those whose keys are compared with ",(0,n.jsx)(t,{term:"eql",children:(0,n.jsx)("b",{children:"eql"})}),", those whose keys are compared with ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),", and those whose keys are compared with ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 ",(0,n.jsx)(i.em,{children:"Hash tables"})," are created by ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})}),". ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})})," is used to look up a key and find the associated value. New entries are added to ",(0,n.jsx)(i.em,{children:"hash tables"})," using ",(0,n.jsx)(t,{term:"setf",children:(0,n.jsx)("b",{children:"setf"})})," with ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})}),". ",(0,n.jsx)(t,{term:"remhash",children:(0,n.jsx)("b",{children:"remhash"})})," is used to remove an entry. For example:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-lisp",children:"(setq a (make-hash-table)) \u2192 #<HASH-TABLE EQL 0/120 32536573>\n(setf (gethash \u2019color a) \u2019brown) \u2192 BROWN\n(setf (gethash \u2019name a) \u2019fred) \u2192 FRED\n(gethash \u2019color a) \u2192 BROWN, *true*\n(gethash \u2019name a) \u2192 FRED, *true*\n(gethash \u2019pointy a) \u2192 NIL, *false*\n"})}),"\n",(0,n.jsxs)(i.p,{children:["In this example, the symbols color and name are being used as keys, and the symbols brown and fred are being used as the associated values. The ",(0,n.jsx)(i.em,{children:"hash table"})," has two items in it, one of which associates from color to brown, and the other of which associates from name to fred."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 A key or a value may be any ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["\u2013 The existence of an entry in the ",(0,n.jsx)(i.em,{children:"hash table"})," can be determined from the ",(0,n.jsx)(i.em,{children:"secondary value"})," returned by ",(0,n.jsx)(t,{term:"gethash",children:(0,n.jsx)("b",{children:"gethash"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["|",(0,n.jsxs)("p",{children:[(0,n.jsx)(i.strong,{children:"clrhash hash-table-p remhash gethash make-hash-table sxhash"})," "]}),"\n",(0,n.jsx)("p",{children:(0,n.jsx)(i.strong,{children:"hash-table-count maphash"})}),"|"]}),"\n",(0,n.jsx)(i.p,{children:"| :- |"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Figure 18\u20131. Hash-table defined names"})}),"\n",(0,n.jsx)(i.p,{children:"Hash"})]})}function a(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}function l(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["The function supplied as the ",":test"," argument to ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})})," specifies the \u2018equivalence test\u2019 for the ",(0,n.jsx)(i.em,{children:"hash table"})," it creates."]}),"\n",(0,n.jsxs)(i.p,{children:["An ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," is \u2018visibly modified\u2019 with regard to an equivalence test if there exists some set of ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," (or potential ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"objects"})}),") which are equivalent to the ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," before the modification but are no longer equivalent afterwards."]}),"\n",(0,n.jsxs)(i.p,{children:["If an ",(0,n.jsx)(i.em,{children:"object O"}),(0,n.jsx)("sub",{children:"1"})," is used as a key in a ",(0,n.jsx)(i.em,{children:"hash table H"})," and is then visibly modified with regard to the equivalence test of ",(0,n.jsx)(i.em,{children:"H"}),", then the consequences are unspecified if ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"}),", or any ",(0,n.jsx)(i.em,{children:"object O"}),(0,n.jsx)("sub",{children:"2"})," equivalent to ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," under the equivalence test (either before or after the modification), is used as a key in further operations on ",(0,n.jsx)(i.em,{children:"H"}),". The consequences of using ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," as a key are unspecified even if ",(0,n.jsx)(i.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," is visibly"]}),"\n",(0,n.jsx)(i.p,{children:"modified and then later modified again in such a way as to undo the visible modification."}),"\n",(0,n.jsxs)(i.p,{children:["Following are specifications of the modifications which are visible to the equivalence tests which must be supported by ",(0,n.jsx)(i.em,{children:"hash tables"}),". The modifications are described in terms of modification of components, and are defined recursively. Visible modifications of components of the ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," are visible modifications of the ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}function d(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["No ",(0,n.jsx)(i.em,{children:"standardized function"})," is provided that is capable of visibly modifying an ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"object"})})," with regard to ",(0,n.jsx)(t,{term:"eq",children:(0,n.jsx)("b",{children:"eq"})})," or ",(0,n.jsx)(t,{term:"eql",children:(0,n.jsx)("b",{children:"eql"})}),"."]})}function p(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function j(e){const i={p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),", the rules for visible modification of ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modification of Objects with respect to EQ and EQL)."]})}function m(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(j,{...e})}):j(e)}function x(e){const i={p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["Any visible change to the ",(0,n.jsx)(t,{term:"car",children:(0,n.jsx)("i",{children:"car"})})," or the ",(0,n.jsx)(t,{term:"cdr",children:(0,n.jsx)("i",{children:"cdr"})})," of a ",(0,n.jsx)(t,{term:"cons",children:(0,n.jsx)("i",{children:"cons"})})," is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),"."]})}function f(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(x,{...e})}):x(e)}function b(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["For a ",(0,n.jsx)(t,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," of ",(0,n.jsx)(t,{term:"type",children:(0,n.jsx)("i",{children:"type"})})," ",(0,n.jsx)(t,{term:"bit-vector",children:(0,n.jsx)("b",{children:"bit-vector"})})," or of ",(0,n.jsx)(t,{term:"type",children:(0,n.jsx)("i",{children:"type"})})," ",(0,n.jsx)(t,{term:"string",children:(0,n.jsx)("b",{children:"string"})}),", any visible change to an ",(0,n.jsx)(i.em,{children:"active element"})," of the ",(0,n.jsx)(t,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," , or to the ",(0,n.jsx)(t,{term:"length",children:(0,n.jsx)("i",{children:"length"})})," of the ",(0,n.jsx)(t,{term:"vector",children:(0,n.jsx)("i",{children:"vector"})})," (if it is ",(0,n.jsx)(i.em,{children:"actually adjustable"})," or has a ",(0,n.jsx)(i.em,{children:"fill pointer"})," ) is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equal",children:(0,n.jsx)("b",{children:"equal"})}),"."]})}function u(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(b,{...e})}):b(e)}function v(e){const i={p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),", the rules for visible modification of ",(0,n.jsx)(t,{term:"object",children:(0,n.jsx)("i",{children:"objects"})})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modification of Objects with respect to EQUAL)."]})}function g(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(v,{...e})}):v(e)}function w(e){const i={p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["Any visible change to a ",(0,n.jsx)(t,{term:"slot",children:(0,n.jsx)("i",{children:"slot"})})," of a ",(0,n.jsx)(t,{term:"structure",children:(0,n.jsx)("i",{children:"structure"})})," is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})}function y(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(w,{...e})}):w(e)}function k(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(i.p,{children:["In an ",(0,n.jsx)(t,{term:"array",children:(0,n.jsx)("i",{children:"array"})}),", any visible change to an ",(0,n.jsx)(i.em,{children:"active element"}),", to the ",(0,n.jsx)(i.em,{children:"fill pointer"})," (if the ",(0,n.jsx)(t,{term:"array",children:(0,n.jsx)("i",{children:"array"})})," can and does have one), or to the ",(0,n.jsx)(t,{term:"dimension",children:(0,n.jsx)("i",{children:"dimensions"})})," (if the ",(0,n.jsx)(t,{term:"array",children:(0,n.jsx)("i",{children:"array"})})," is ",(0,n.jsx)(i.em,{children:"actually adjustable"}),") is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})}function q(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(k,{...e})}):k(e)}function E(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["In a ",(0,n.jsx)(i.em,{children:"hash table"}),", any visible change to the count of entries in the ",(0,n.jsx)(i.em,{children:"hash table"}),", to the keys, or to the values associated with the keys is considered a visible modification with regard to ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Note that the visibility of modifications to the keys depends on the equivalence test of the ",(0,n.jsx)(i.em,{children:"hash table"}),", not on the specification of ",(0,n.jsx)(t,{term:"equalp",children:(0,n.jsx)("b",{children:"equalp"})}),"."]})]})}function L(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(E,{...e})}):E(e)}function C(e){const i={em:"em",p:"p",...(0,s.a)(),...e.components},{ClLinks:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:[(0,n.jsx)(t,{term:"implementation",children:(0,n.jsx)("i",{children:"Implementations"})})," that extend the language by providing additional mutator functions (or additional behavior for existing mutator functions) must document how the use of these extensions interacts with equivalence tests and ",(0,n.jsx)(i.em,{children:"hash table"})," searches."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(t,{term:"implementation",children:(0,n.jsx)("i",{children:"Implementations"})})," that extend the language by defining additional acceptable equivalence tests for ",(0,n.jsx)(i.em,{children:"hash tables"})," (allowing additional values for the ",":test"," argument to ",(0,n.jsx)(t,{term:"make-hash-table",children:(0,n.jsx)("b",{children:"make-hash-table"})}),") must document the visible components of these tests."]}),"\n",(0,n.jsx)(i.p,{children:"Hash"})]})}function A(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(C,{...e})}):C(e)}const M={title:"18.1 Hash Table Concepts"},H="18.1 Hash Table Concepts",V={id:"chap-18/bi-b-hash-table-concepts",title:"18.1 Hash Table Concepts",description:"18.1.1 Hash",source:"@site/docs/chap-18/bi-b-hash-table-concepts.md",sourceDirName:"chap-18",slug:"/chap-18/bi-b-hash-table-concepts",permalink:"/cl-language-reference/chap-18/bi-b-hash-table-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-18/bi-b-hash-table-concepts.md",tags:[],version:"current",frontMatter:{title:"18.1 Hash Table Concepts"},sidebar:"tutorialSidebar",previous:{title:"18. Hash Tables",permalink:"/cl-language-reference/category/18-hash-tables"},next:{title:"18.2 Hash Tables Dictionary",permalink:"/cl-language-reference/category/182-hash-tables-dictionary"}},Q={},T=[{value:"18.1.1 Hash",id:"1811-hash",level:2},{value:"18.1.2 Modifying Hash Table Keys",id:"1812-modifying-hash-table-keys",level:2},{value:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL",id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",level:3},{value:"18.1.2.2 Visible Modification of Objects with respect to EQUAL",id:"18122-visible-modification-of-objects-with-respect-to-equal",level:3},{value:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL",id:"181221-visible-modification-of-conses-with-respect-to-equal",level:4},{value:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL",id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",level:4},{value:"18.1.2.3 Visible Modification of Objects with respect to EQUALP",id:"18123-visible-modification-of-objects-with-respect-to-equalp",level:3},{value:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP",id:"181231-visible-modification-of-structures-with-respect-to-equalp",level:4},{value:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP",id:"181232-visible-modification-of-arrays-with-respect-to-equalp",level:4},{value:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP",id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",level:4},{value:"18.1.2.4 Visible Modifications by Language Extensions",id:"18124-visible-modifications-by-language-extensions",level:3}];function O(e){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"181-hash-table-concepts",children:"18.1 Hash Table Concepts"}),"\n","\n",(0,n.jsx)(r,{}),"\n",(0,n.jsx)(i.h2,{id:"1811-hash",children:"18.1.1 Hash"}),"\n","\n",(0,n.jsx)(a,{}),"\n",(0,n.jsx)(i.h2,{id:"1812-modifying-hash-table-keys",children:"18.1.2 Modifying Hash Table Keys"}),"\n","\n",(0,n.jsx)(h,{}),"\n",(0,n.jsx)(i.h3,{id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"}),"\n","\n",(0,n.jsx)(p,{}),"\n",(0,n.jsx)(i.h3,{id:"18122-visible-modification-of-objects-with-respect-to-equal",children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"}),"\n","\n",(0,n.jsx)(m,{}),"\n",(0,n.jsx)(i.h4,{id:"181221-visible-modification-of-conses-with-respect-to-equal",children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"}),"\n","\n",(0,n.jsx)(f,{}),"\n",(0,n.jsx)(i.h4,{id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"}),"\n","\n",(0,n.jsx)(u,{}),"\n",(0,n.jsx)(i.h3,{id:"18123-visible-modification-of-objects-with-respect-to-equalp",children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"}),"\n","\n",(0,n.jsx)(g,{}),"\n",(0,n.jsx)(i.h4,{id:"181231-visible-modification-of-structures-with-respect-to-equalp",children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"}),"\n","\n",(0,n.jsx)(y,{}),"\n",(0,n.jsx)(i.h4,{id:"181232-visible-modification-of-arrays-with-respect-to-equalp",children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"}),"\n","\n",(0,n.jsx)(q,{}),"\n",(0,n.jsx)(i.h4,{id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"}),"\n","\n",(0,n.jsx)(L,{}),"\n",(0,n.jsx)(i.h3,{id:"18124-visible-modifications-by-language-extensions",children:"18.1.2.4 Visible Modifications by Language Extensions"}),"\n","\n","\n",(0,n.jsx)(A,{})]})}function U(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(O,{...e})}):O(e)}},11151:(e,i,t)=>{t.d(i,{Z:()=>c,a:()=>r});var n=t(67294);const s={},o=n.createContext(s);function r(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);