"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[12770],{5829:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>N,contentTitle:()=>D,default:()=>U,frontMatter:()=>F,metadata:()=>o,toc:()=>L});const o=JSON.parse('{"id":"chap-1/b-f-conformance","title":"1.5 Conformance","description":"1.5.1 Conforming Implementations","source":"@site/docs/chap-1/b-f-conformance.md","sourceDirName":"chap-1","slug":"/chap-1/b-f-conformance","permalink":"/cl-language-reference/chap-1/b-f-conformance","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-1/b-f-conformance.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"1.5 Conformance"},"sidebar":"tutorialSidebar","previous":{"title":"1.4 Definitions","permalink":"/cl-language-reference/chap-1/b-e-definitions"},"next":{"title":"1.6 Language Extensions","permalink":"/cl-language-reference/chap-1/b-g-language-extensions"}}');var i=t(74848),r=t(28453);function s(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(n.p,{children:["This standard presents the syntax and semantics to be implemented by a ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," (and its accompanying documentation). In addition, it imposes requirements on ",(0,i.jsx)(t,{styled:!0,term:"conforming program",children:(0,i.jsx)("i",{children:"conforming programs"})}),"."]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}function c(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall adhere to the requirements outlined in this section."]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function d(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall accept all features (including deprecated features) of the language specified in this standard, with the meanings defined in this standard."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall not require the inclusion of substitute or additional language elements in code in order to accomplish a feature of the language that is specified in this standard."]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function p(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall be accompanied by a document that provides a definition of all ",(0,i.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,i.jsx)("i",{children:"implementation-defined"})})," aspects of the language defined by this specification."]}),"\n",(0,i.jsxs)(n.p,{children:["In addition, a ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," is encouraged (but not required) to document items in this standard that are identified as ",(0,i.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,i.jsx)("i",{children:"implementation-dependent"})}),", although in some cases such documentation might simply identify the item as \u201cundefined.\u201d"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}function f(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall be accompanied by a document that separately describes any features accepted by the ",(0,i.jsx)(t,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," that are not specified in this standard, but that do not cause any ambiguity or contradiction when added to the language standard. Such extensions shall be described as being \u201cextensions to Common Lisp as specified by ANSI \u27e8standard number \u27e9.\u201d"]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}function x(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall treat exceptional situations in a manner consistent with this specification."]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}function j(e){const n={p:"p",...(0,r.R)(),...e.components};return(0,i.jsx)(n.p,{children:"If more than one passage in this specification appears to apply to the same situation but in conflicting ways, the passage that appears to describe the situation in the most specific way (not necessarily the passage that provides the most constrained kind of error detection) takes precedence."})}function y(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(j,{...e})}):j(e)}function b(e){const n={code:"code",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lisp",children:"Suppose that function foo is a member of a set *S* of *functions* that operate on numbers. Suppose that one passage states that an error must be signaled if any *function* in *S* is ever given an argument of 17. Suppose that an apparently conflicting passage states that the consequences are undefined if foo receives an argument of 17. Then the second passage (the one specifically about foo) would dominate because the description of the situational context is the most specific, and it would not be required that foo signal an error on an argument of 17 even though other functions in the set *S* would be required to do so. \n"})})}function w(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}function v(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})})," shall produce a conformance statement as a consequence of using the implementation, or that statement shall be included in the accompanying documentation. If the implementation conforms in all respects with this standard, the conformance statement shall be"]}),"\n",(0,i.jsx)(n.p,{children:"\u201c\u27e8Implementation\u27e9 conforms with the requirements of ANSI \u27e8standard number \u27e9\u201d"}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(t,{styled:!0,term:"implementation",children:(0,i.jsx)("i",{children:"implementation"})})," conforms with some but not all of the requirements of this standard, then the conformance statement shall be"]}),"\n",(0,i.jsx)(n.p,{children:"\u201c\u27e8Implementation\u27e9 conforms with the requirements of ANSI \u27e8standard number \u27e9 with the following exceptions: \u27e8reference to or complete list of the requirements of the standard with which the implementation does not conform\u27e9.\u201d"})]})}function R(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}function E(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Code conforming with the requirements of this standard shall adhere to the following:"}),"\n",(0,i.jsxs)(n.p,{children:["1. ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"Conforming code"})})," shall use only those features of the language syntax and semantics that are either specified in this standard or defined using the extension mechanisms specified in the standard."]}),"\n",(0,i.jsxs)(n.p,{children:["2. ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"Conforming code"})})," may use ",(0,i.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,i.jsx)("i",{children:"implementation-dependent"})})," features and values, but shall not rely upon any particular interpretation of these features and values other than those that are discovered by the execution of ",(0,i.jsx)(t,{styled:!0,term:"code",children:(0,i.jsx)("i",{children:"code"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["3. ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"Conforming code"})})," shall not depend on the consequences of undefined or unspecified situations."]}),"\n",(0,i.jsxs)(n.p,{children:["4. ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"Conforming code"})})," does not use any constructions that are prohibited by the standard. 5. ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"Conforming code"})})," does not depend on extensions included in an implementation."]})]})}function C(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(E,{...e})}):E(e)}function T(e){const n={p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"conforming code"})})," may rely on particular ",(0,i.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,i.jsx)("i",{children:"implementation-defined"})})," values or features. Also note that the requirements for ",(0,i.jsx)(t,{styled:!0,term:"conforming code",children:(0,i.jsx)("i",{children:"conforming code"})})," and ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementations"})})," do not require that the results produced by conforming code always be the same when processed by a ",(0,i.jsx)(t,{styled:!0,term:"conforming implementation",children:(0,i.jsx)("i",{children:"conforming implementation"})}),". The results may be the same, or they may differ."]}),"\n",(0,i.jsxs)(n.p,{children:["Conforming code may run in all conforming implementations, but might have allowable ",(0,i.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,i.jsx)("i",{children:"implementation-defined"})})," behavior that makes it non-portable code. For example, the following are examples of ",(0,i.jsx)(t,{styled:!0,term:"form",children:(0,i.jsx)("i",{children:"forms"})})," that are conforming, but that might return different ",(0,i.jsx)(t,{styled:!0,term:"value",children:(0,i.jsx)("i",{children:"values"})})," in different implementations:"]}),"\n",(0,i.jsx)(n.p,{children:"(evenp most-positive-fixnum) \u2192 implementation-dependent"}),"\n",(0,i.jsx)(n.p,{children:"(random) \u2192 implementation-dependent"}),"\n",(0,i.jsx)(n.p,{children:"(> lambda-parameters-limit 93) \u2192 implementation-dependent"}),"\n",(0,i.jsx)(n.p,{children:"(char-name #\\A) \u2192 implementation-dependent"})]})}function k(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(T,{...e})}):T(e)}function G(e){const n={p:"p",...(0,r.R)(),...e.components},{DictionaryLink:t,GlossaryTerm:o}=n;return t||q("DictionaryLink",!0),o||q("GlossaryTerm",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Use of #+ and #- does not automatically disqualify a program from being conforming. A program which uses #+ and #- is considered conforming if there is no set of ",(0,i.jsx)(o,{styled:!0,term:"feature",children:(0,i.jsx)("i",{children:"features"})})," in which the program would not be conforming. Of course, ",(0,i.jsx)(o,{styled:!0,term:"conforming program",children:(0,i.jsx)("i",{children:"conforming programs"})})," are not necessarily working programs. The following program is conforming:"]}),"\n",(0,i.jsx)(n.p,{children:"(defun foo ()"}),"\n",(0,i.jsxs)(n.p,{children:["#+ACME (acme",":initialize-something",")"]}),"\n",(0,i.jsx)(n.p,{children:"(print \u2019hello-there))"}),"\n",(0,i.jsxs)(n.p,{children:["However, this program might or might not work, depending on whether the presence of the feature ACME really implies that a function named acme",":initialize-something"," is present in the environment. In effect, using #+ or #- in a ",(0,i.jsx)(o,{styled:!0,term:"conforming program",children:(0,i.jsx)("i",{children:"conforming program"})})," means that the variable ",(0,i.jsx)(t,{styled:!0,term:"features",children:(0,i.jsx)("b",{children:"*features*"})})," becomes just one more piece of input data to that program. Like any other data coming into a program, the"]}),"\n",(0,i.jsx)(n.p,{children:"programmer is responsible for assuring that the program does not make unwarranted assumptions on the basis of input data."})]})}function S(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(G,{...e})}):G(e)}function q(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function A(e){const n={em:"em",p:"p",...(0,r.R)(),...e.components},{GlossaryTerm:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Portable code"})," is written using only ",(0,i.jsx)(t,{styled:!0,term:"standard character",children:(0,i.jsx)("i",{children:"standard characters"})}),"."]})}function I(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(A,{...e})}):A(e)}const F={title:"1.5 Conformance"},D="1.5 Conformance",N={},L=[{value:"1.5.1 Conforming Implementations",id:"151-conforming-implementations",level:2},{value:"1.5.1.1 Required Language Features",id:"1511-required-language-features",level:3},{value:"1.5.1.2 Documentation of Implementation",id:"1512-documentation-of-implementation",level:3},{value:"1.5.1.3 Documentation of Extensions",id:"1513-documentation-of-extensions",level:3},{value:"1.5.1.4 Treatment of Exceptional Situations",id:"1514-treatment-of-exceptional-situations",level:3},{value:"1.5.1.4.1 Resolution of Apparent Conflicts in Exceptional Situations",id:"15141-resolution-of-apparent-conflicts-in-exceptional-situations",level:4},{value:"1.5.1.4.1.1 Examples of Resolution of Apparent Conflicts in Exceptional Situations",id:"151411-examples-of-resolution-of-apparent-conflicts-in-exceptional-situations",level:5},{value:"1.5.1.5 Conformance Statement",id:"1515-conformance-statement",level:3},{value:"1.5.2 Conforming Programs",id:"152-conforming-programs",level:2},{value:"1.5.2.1 Use of Implementation",id:"1521-use-of-implementation",level:3},{value:"1.5.2.1.1 Use of Read",id:"15211-use-of-read",level:4},{value:"1.5.2.2 Character Set for Portable Code",id:"1522-character-set-for-portable-code",level:3}];function P(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"15-conformance",children:"1.5 Conformance"})}),"\n","\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(n.h2,{id:"151-conforming-implementations",children:"1.5.1 Conforming Implementations"}),"\n","\n",(0,i.jsx)(l,{}),"\n",(0,i.jsx)(n.h3,{id:"1511-required-language-features",children:"1.5.1.1 Required Language Features"}),"\n","\n",(0,i.jsx)(m,{}),"\n",(0,i.jsx)(n.h3,{id:"1512-documentation-of-implementation",children:"1.5.1.2 Documentation of Implementation"}),"\n","\n",(0,i.jsx)(h,{}),"\n",(0,i.jsx)(n.h3,{id:"1513-documentation-of-extensions",children:"1.5.1.3 Documentation of Extensions"}),"\n","\n",(0,i.jsx)(u,{}),"\n",(0,i.jsx)(n.h3,{id:"1514-treatment-of-exceptional-situations",children:"1.5.1.4 Treatment of Exceptional Situations"}),"\n","\n",(0,i.jsx)(g,{}),"\n",(0,i.jsx)(n.h4,{id:"15141-resolution-of-apparent-conflicts-in-exceptional-situations",children:"1.5.1.4.1 Resolution of Apparent Conflicts in Exceptional Situations"}),"\n","\n",(0,i.jsx)(y,{}),"\n",(0,i.jsx)(n.h5,{id:"151411-examples-of-resolution-of-apparent-conflicts-in-exceptional-situations",children:"1.5.1.4.1.1 Examples of Resolution of Apparent Conflicts in Exceptional Situations"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(n.h3,{id:"1515-conformance-statement",children:"1.5.1.5 Conformance Statement"}),"\n","\n",(0,i.jsx)(R,{}),"\n",(0,i.jsx)(n.h2,{id:"152-conforming-programs",children:"1.5.2 Conforming Programs"}),"\n","\n",(0,i.jsx)(C,{}),"\n",(0,i.jsx)(n.h3,{id:"1521-use-of-implementation",children:"1.5.2.1 Use of Implementation"}),"\n","\n",(0,i.jsx)(k,{}),"\n",(0,i.jsx)(n.h4,{id:"15211-use-of-read",children:"1.5.2.1.1 Use of Read"}),"\n","\n",(0,i.jsx)(S,{}),"\n",(0,i.jsx)(n.h3,{id:"1522-character-set-for-portable-code",children:"1.5.2.2 Character Set for Portable Code"}),"\n","\n",(0,i.jsx)(I,{})]})}function U(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(P,{...e})}):P(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);