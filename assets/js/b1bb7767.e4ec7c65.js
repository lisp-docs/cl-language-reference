"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[69627],{28678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>o});var s=n(85893),i=n(11151);const a={},r="extract-specializer-names",c={id:"meta-object-protocol/extract-specializer-names",title:"extract-specializer-names",description:"Function EXTRACT-SPECIALIZER-NAMES",source:"@site/docs/meta-object-protocol/extract-specializer-names.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/extract-specializer-names",permalink:"/cl-language-reference/meta-object-protocol/extract-specializer-names",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/extract-specializer-names.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"extract-lambda-list",permalink:"/cl-language-reference/meta-object-protocol/extract-lambda-list"},next:{title:"defmethod expansion",permalink:"/cl-language-reference/meta-object-protocol/fig-defmethod-1"}},l={},o=[];function d(e){const t={code:"code",em:"em",h1:"h1",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"extract-specializer-names",children:"extract-specializer-names"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"Function"})," ",(0,s.jsx)(t.strong,{children:"EXTRACT-SPECIALIZER-NAMES"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"extract-specializer-names"})," ",(0,s.jsx)(t.em,{children:"specialized-lambda-list"})," => ",(0,s.jsx)(t.em,{children:"specializer-names"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Arguments and values:"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"specialized-lambda-list"})," -- A specialized lambda list as accepted by ",(0,s.jsx)(t.code,{children:"defmethod"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.em,{children:"specializer-names"})," -- A list of specializer names."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Description:"})}),"\n",(0,s.jsx)(t.p,{children:"This function takes a specialized lambda list and returns its specializer names. This is a non-destructive operation. Whether the result shares structure with the argument is unspecified. The results are undefined if the result of this function is modified."}),"\n",(0,s.jsxs)(t.p,{children:["The result of this function will be a list with a number of elements equal to the number of required arguments in ",(0,s.jsx)(t.em,{children:"specialized-lambda-list"}),". Specializers are defaulted to the symbol ",(0,s.jsx)(t.code,{children:"t"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If the ",(0,s.jsx)(t.em,{children:"specialized-lambda-list"})," argument does not have legal syntax, an error is signaled. This syntax checking does not check the syntax of the actual specializer names, only the syntax of the lambda list and where the specializers appear."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(t.p,{children:"(extract-specializer-names '((p position)))            ==> (POSITION)"}),"\n",(0,s.jsx)(t.p,{children:"(extract-specializer-names '((p position) x y))        ==> (POSITION T T)"}),"\n",(0,s.jsx)(t.p,{children:"(extract-specializer-names '(a (b (eql x)) c &rest i)) ==> (T (EQL X) T)"})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>r});var s=n(67294);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);