"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[26682],{43046:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>x,contentTitle:()=>m,default:()=>g,frontMatter:()=>j,metadata:()=>f,toc:()=>u});var t=n(85893),c=n(11151);function a(e){const s={a:"a",code:"code",em:"em",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"The inheritance structure of the specified metaobject classes is shown in the table below (FIXME: insert anchor)."}),"\n",(0,t.jsxs)(s.p,{children:["Direct superclass relationships among the specified metaobject classes. The class of every class shown is ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," except for the class ",(0,t.jsx)(s.code,{children:"t"})," which is an instance of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-built-in-class",children:"built-in-class"})," and the classes ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-generic-function",children:"generic-function"})," and ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-generic-function",children:"standard-generic-function"})," which are instances of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"Metaobject Class"}),"\n",(0,t.jsx)(s.p,{children:"Direct Superclasses"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-object"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(t)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"funcallable-standard-object"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-object function)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"metaobject"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-object)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"generic-function"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(metaobject funcallable-standard-object)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-generic-function"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(generic-function)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"method"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(metaobject)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-method"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(method)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-accessor-method"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-method)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-reader-method"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-accessor-method)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-writer-method"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-accessor-method)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"method-combination"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(metaobject)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(metaobject)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"direct-slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(slot-definition)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"effective-slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(slot-definition)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(slot-definition)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-direct-slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-slot-definition direct-slot-definition)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-effective-slot-definition"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(standard-slot-definition effective-slot-definition)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"specializer"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(metaobject)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"eql-specializer"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(specializer)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"class"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(specializer)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"built-in-class"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(class)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"forward-referenced-class"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(class)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"standard-class"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(class)"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"funcallable-standard-class"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"(class)"})}),"\n",(0,t.jsxs)(s.p,{children:["Each class marked with a ``*'' is an ",(0,t.jsx)(s.em,{children:"abstract class"})," and is not intended to be instantiated. The results are undefined if an attempt is made to make an instance of one of these classes with ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The classes ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-direct-slot-definition",children:"standard-direct-slot-definition"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-effective-slot-definition",children:"standard-effective-slot-definition"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-method",children:"standard-method"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-reader-method",children:"standard-reader-method"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-writer-method",children:"standard-writer-method"}),", and ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-generic-function",children:"standard-generic-function"})," are called ",(0,t.jsx)(s.em,{children:"standard metaobject classes"}),". For each kind of metaobject, this is the class the user interface macros presented in the CLOS Specification use by default. These are also the classes on which user specializations are normally based."]}),"\n",(0,t.jsxs)(s.p,{children:["The classes ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-built-in-class",children:"built-in-class"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," and ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-forward-referenced-class",children:"forward-referenced-class"})," are special-purpose class metaobject classes. Built-in classes are instances of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-built-in-class",children:"built-in-class"}),". The class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," provides a special kind of instances described in the section called ``Funcallable Instances.'' When the definition of a class references another class which has not yet been defined, an instance of ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-forward-referenced-class",children:"forward-referenced-class"})," is used as a stand-in until the class is actually defined."]}),"\n",(0,t.jsxs)(s.p,{children:["The class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-object",children:"standard-object"})," is the ",(0,t.jsx)(s.em,{children:"default direct superclass"})," of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),". When an instance of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," is created, and no direct superclasses are explicitly specified, it defaults to the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-object",children:"standard-object"}),". In this way, any behavior associated with the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-object",children:"standard-object"})," will be inherited, directly or indirectly, by all instances of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),". A subclass of ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," may have a different class as its default direct superclass, but that class must be a subclass of the class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-object",children:"standard-object"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The same is true for ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," and ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-object",children:"funcallable-standard-object"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-specializer",children:"specializer"})," captures only the most basic behavior of method specializers, and is not itself intended to be instantiated. The class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-class",children:"class"})," is a direct subclass of ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-specializer",children:"specializer"})," reflecting the property that classes by themselves can be used as method specializers. The class ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-eql-specializer",children:"eql-specializer"})," is used for ",(0,t.jsx)(s.code,{children:"eql"})," specializers."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/meta-object-protocol/implementation-and-user-specialization",children:"Implementation and user specialization."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/meta-object-protocol/restrictions-on-implementations",children:"Restrictions on implementations"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/meta-object-protocol/restrictions-on-portable-programs",children:"Restrictions on portable programs"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Note:"})}),"\n",(0,t.jsxs)(s.p,{children:["Taken literally, this page suggests that the metaclass of ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-object",children:"funcallable-standard-object"})," is ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"}),", but we think that is a mistake, and that the metaclass should be ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," instead."]})]})}function i(e={}){const{wrapper:s}={...(0,c.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function r(e){return(0,t.jsx)(t.Fragment,{})}function o(e={}){const{wrapper:s}={...(0,c.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(r,{...e})}):r()}function l(e){const s={code:"code",del:"del",em:"em",li:"li",p:"p",ul:"ul",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"Implementations are allowed latitude to modify the structure of specified classes and methods. This includes: the interposition of implementation-specific classes; the promotion of specified methods; and the consolidation of two or more specified methods into a single method specialized to interposed classes."}),"\n",(0,t.jsxs)(s.p,{children:["Any such modifications are permitted only so long as for any portable class ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"p"})," that is a subclass of one or more specified classes ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"0"})," ... ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"i"}),", the following conditions are met:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["In the actual class precedence list of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"p"}),", the classes ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"0"})," ... ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"i"})," must appear in the same order as they would have if no implementation-specific modifications had been made."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"The method applicability of any specified generic function must be the same in terms of behavior as it would have been had no implementation-specific changes been made. This includes specified generic functions that have had portable methods added. In this context, the expression ``the same in terms of behavior'' means that methods with the same behavior as those specified are applicable, and in the same order."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["No portable class ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)(s.del,{children:"p"})," may inherit, by virtue of being a direct or indirect subclass of a specified class, any slot for which the name is a symbol accessible in the ",(0,t.jsx)(s.code,{children:"common-lisp-user"})," package or exported by any package defined in the ANSI Common Lisp standard."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Implementations are free to define implementation-specific before- and after-methods on specified generic functions. Implementations are also free to define implementation-specific around-methods with extending behavior."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,c.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}function h(e){const s={a:"a",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"Portable programs are allowed to define subclasses of specified classes, and are permitted to define methods on specified generic functions, with the following restrictions. The results are undefined if any of these restrictions is violated."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Portable programs must not redefine any specified classes, generic functions, methods or method combinations. Any method defined by a portable program on a specified generic function must have at least one specializer that is neither a specified class nor an ",(0,t.jsx)(s.code,{children:"eql"})," specializer whose associated value is an instance of a specified class."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Portable programs may define methods that extend specified methods unless the description of the specified method explicitly prohibits this. Unless there is a specific statement to the contrary, these extending methods must return whatever value was returned by the call to ",(0,t.jsx)(s.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_call_n.htm#call-next-method",children:"call-next-method"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"Portable programs may define methods that override specified methods only when the description of the specified method explicitly allows this. Typically, when a method is allowed to be overridden, a small number of related methods will need to be overridden as well."}),"\n",(0,t.jsxs)(s.p,{children:["An example of this is the specified methods on the generic functions ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/add-dependent",children:"add-dependent"}),", ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/remove-dependent",children:"remove-dependent"}),", and ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/map-dependents",children:"map-dependents"}),". Overriding a specified method on one of these generic functions requires that the corresponding method on the other two generic functions be overridden as well."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Portable methods on specified generic functions specialized to portable metaobject classes must be defined before any instances of those classes (or any subclasses) are created, either directly or indirectly by a call to ",(0,t.jsx)(s.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". Methods can be defined after instances are created by ",(0,t.jsx)(s.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_alloca.htm#allocate-instance",children:"allocate-instance"})," however. Portable metaobject classes cannot be redefined."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Implementation note:"})}),"\n",(0,t.jsx)(s.p,{children:"The purpose of this last restriction is to permit implementations to provide performance optimizations by analyzing, at the time the first instance of a metaobject class is initialized, what portable methods will be applicable to it. This can make it possible to optimize calls to those specified generic functions which would have no applicable portable methods."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Note:"})}),"\n",(0,t.jsx)(s.p,{children:"The specification technology used in this document needs further development. The concepts of object-oriented protocols and subclass specialization are intuitively familiar to programmers of object-oriented systems; the protocols presented here fit quite naturally into this framework. Nonetheless, in preparing this document, we have found it difficult to give specification-quality descriptions of the protocols in a way that makes it clear what extensions users can and cannot write. Object-oriented protocol specification is inherently about specifying leeway, and this seems difficult using current technology."}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,c.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}const j={title:"5.3 Inheritance Structure Of Metaobject Classes"},m=void 0,f={id:"meta-object-protocol/chap-5/5-3-inheritance",title:"5.3 Inheritance Structure Of Metaobject Classes",description:"5.3.1 Implementation And User Specialization",source:"@site/docs/meta-object-protocol/chap-5/5-3-inheritance.md",sourceDirName:"meta-object-protocol/chap-5",slug:"/meta-object-protocol/chap-5/5-3-inheritance",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-3-inheritance",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/chap-5/5-3-inheritance.md",tags:[],version:"current",lastUpdatedBy:"daninus14",frontMatter:{title:"5.3 Inheritance Structure Of Metaobject Classes"},sidebar:"tutorialSidebar",previous:{title:"5.2 Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-2-metaobjects"},next:{title:"5.4 Processing Of The User Interface Macros",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-4-processing"}},x={},u=[{value:"5.3.1 Implementation And User Specialization",id:"531-implementation-and-user-specialization",level:2},{value:"5.3.2 Restrictions On Implementations",id:"532-restrictions-on-implementations",level:3},{value:"5.3.3 Restrictions On Portable Programs",id:"533-restrictions-on-portable-programs",level:3}];function b(e){const s={h2:"h2",h3:"h3",...(0,c.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i,{}),"\n",(0,t.jsx)(s.h2,{id:"531-implementation-and-user-specialization",children:"5.3.1 Implementation And User Specialization"}),"\n","\n",(0,t.jsx)(o,{}),"\n",(0,t.jsx)(s.h3,{id:"532-restrictions-on-implementations",children:"5.3.2 Restrictions On Implementations"}),"\n","\n",(0,t.jsx)(d,{}),"\n",(0,t.jsx)(s.h3,{id:"533-restrictions-on-portable-programs",children:"5.3.3 Restrictions On Portable Programs"}),"\n","\n","\n",(0,t.jsx)(p,{})]})}function g(e={}){const{wrapper:s}={...(0,c.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(b,{...e})}):b(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>r,a:()=>i});var t=n(67294);const c={},a=t.createContext(c);function i(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);