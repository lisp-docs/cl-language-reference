"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[87908],{65055:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var i=t(85893),o=t(11151);const r={title:"Environments"},a=void 0,c={id:"environments/index",title:"Environments",description:"This chapter will discuss the difference between the startup environment, the evaluation environment, the compilation environment, the static lexical environment, and the dynamic environment.",source:"@site/docs/environments/index.md",sourceDirName:"environments",slug:"/environments/",permalink:"/cl-language-reference/environments/",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/environments/index.md",tags:[],version:"current",lastUpdatedBy:"daninus14",frontMatter:{title:"Environments"},sidebar:"tutorialSidebar",previous:{title:"user-homedir-pathname",permalink:"/cl-language-reference/chap-25/cf-c-dictionary/user-homedir-pathname_function"},next:{title:"Environments Dictionary",permalink:"/cl-language-reference/category/environments-dictionary"}},s={},l=[{value:"1 Introduction",id:"1-introduction",level:2},{value:"2 Types of Environment",id:"2-types-of-environment",level:2},{value:"2.1 Run-Time Environment",id:"21-run-time-environment",level:2},{value:"2.2 Compilation Environment",id:"22-compilation-environment",level:2},{value:"2.3 Lexical Environment",id:"23-lexical-environment",level:2}];function h(e){const n={admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",p:"p",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This chapter will discuss the difference between the startup environment, the evaluation environment, the compilation environment, the static lexical environment, and the dynamic environment."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"TODO: This chapter and article are stubs, please contribute by writing anything you can."})}),"\n",(0,i.jsx)(n.h2,{id:"1-introduction",children:"1 Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["The concept of an ",(0,i.jsx)(n.em,{children:"environment"})," is present everywhere in the Common Lisp language.  But it can be confusing, because there are many different types of environments, and several environments of the same type can exist simultaneously.  In this chapter, we describe the different kinds of environment, what different roles they play, and when they are used."]}),"\n",(0,i.jsx)(n.h2,{id:"2-types-of-environment",children:"2 Types of Environment"}),"\n",(0,i.jsx)(n.h2,{id:"21-run-time-environment",children:"2.1 Run-Time Environment"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"run-time environment"})," is an environment relative to which evaluations are performed and the effects of evaluations are stored."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, when a top-level form such as ",(0,i.jsx)(n.code,{children:"(setq y (f x))"})," is evaluated, the current run-time environment is consulted to find a function definition for f and a variable definition for x in order to compute the value of the form ",(0,i.jsx)(n.code,{children:"(f x)"}),".  Then the current run-time environment is consulted again to find a variable definition for y so that the new value of y can be stored in the environment associated with y."]}),"\n",(0,i.jsx)(n.h2,{id:"22-compilation-environment",children:"2.2 Compilation Environment"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"compilation environment"})," is an environment maintained by the file compiler to record definitions found during compilation of a file.  A new compilation environment is created each time a file is compiled, and is valid only for that file.  It is no longer accessible when the compilation of the file terminates."]}),"\n",(0,i.jsx)(n.p,{children:"For example, the macro DEFUN does not define the function at compile time, but the compiler still records the fact that a function with the relevant name has been defined, so that when the name is referred to in a function call later in the file, the compiler can check that a function with that name will exist after the compiled file has been loaded, and it can check that the arguments of the function call are valid, given the lambda list of the DEFUN form."}),"\n",(0,i.jsx)(n.p,{children:'The definitions of many operators, including DEFUN, contain phrases such as "An implementation may choose to store information about the function for the purposes of compile-time error-checking (such as checking the number of arguments on calls), or to enable the function to be expanded inline."  Such phrases implicitly refer to the compilation environment.'}),"\n",(0,i.jsx)(n.h2,{id:"23-lexical-environment",children:"2.3 Lexical Environment"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"lexical environment"})," is an environment maintained by the compiler, and it contains information about lexical definitions that the compiler encounters so that references to such definitions can be checked and connected to the corresponding definition."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, when the compiler processes a form such as ",(0,i.jsx)(n.code,{children:"(block b ... (return-from b 234))"}),", this processing is done relative to a lexical environment.  This lexical environment is augmented with a block definition for b for the purpose of processing the body of the\nBLOCK form.  When the ",(0,i.jsx)(n.code,{children:"(return-from b 234)"})," form is encountered, the compiler consults the lexical environment to verify that b is the name of a block in that environment, and it connects the definition and the reference, so that, at run-time, control is transferred to the correct place as a result of the RETURN-FROM."]}),"\n",(0,i.jsxs)(n.p,{children:["The lexical environment can be thought of a as an ordered sequence of entries where the last entry is the run-time environment from which the compilation was started. It is an ordered sequence, because some lexical forms can ",(0,i.jsx)(n.em,{children:"shadow"})," others.",(0,i.jsx)(n.br,{}),"\n","For example in ",(0,i.jsx)(n.code,{children:"(let ((x 10)) (+ (let ((x 20)) x) x))"}),", there are two references to variables named x, but they refer to different variables.  One occurrence of x is in the body of the innermost LET, so when it is encountered by the compiler, the entry containing the binding ",(0,i.jsx)(n.code,{children:"(x 20)"})," is encountered first, thereby allowing the compiler to resolve x to that definition.  The other occurrence is outside the body of the innermost LET but inside the body of the outermost LET, so when it is encountered by the compiler, the entry containing the binding ",(0,i.jsx)(n.code,{children:"(x 10)"})," is encountered, allowing the compiler to resolve that reference to the relevant binding."]}),"\n",(0,i.jsx)(n.p,{children:"A lexical environment contains definitions of lexical variables introduced by many constructs including LET and LET*.  It contains local functions introduced by FLET and LABELS.  It also contains definitions of blocks, TAGBODY tags, local macros introduced by MACROLET, local symbol macros introduced by SYMBOL-MACROLET."})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var i=t(67294);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);