"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[4445],{4153:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>k,contentTitle:()=>y,default:()=>A,frontMatter:()=>v,metadata:()=>w,toc:()=>I});var t=n(5893),s=n(1151);function a(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.em,{children:"generic function"})," ",(0,t.jsx)(i.strong,{children:"make-instance"})," creates and returns a new ",(0,t.jsx)(i.em,{children:"instance"})," of a ",(0,t.jsx)(i.em,{children:"class"}),". The first argument is a ",(0,t.jsx)(i.em,{children:"class"})," or the ",(0,t.jsx)(i.em,{children:"name"})," of a ",(0,t.jsx)(i.em,{children:"class"}),", and the remaining arguments form an ",(0,t.jsx)(i.em,{children:"initialization argument list"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The initialization of a new ",(0,t.jsx)(i.em,{children:"instance"})," consists of several distinct steps, including the following: combining the explicitly supplied initialization arguments with default values for the unsupplied initialization arguments, checking the validity of the initialization arguments, allocating storage for the ",(0,t.jsx)(i.em,{children:"instance"}),", filling ",(0,t.jsx)(i.em,{children:"slots"})," with values, and executing user-supplied ",(0,t.jsx)(i.em,{children:"methods"})," that perform additional initialization. Each step of ",(0,t.jsx)(i.strong,{children:"make-instance"})," is implemented by a ",(0,t.jsx)(i.em,{children:"generic function"})," to provide a mechanism for customizing that step. In addition, ",(0,t.jsx)(i.strong,{children:"make-instance"})," is itself a ",(0,t.jsx)(i.em,{children:"generic function"})," and thus also can be customized."]}),"\n",(0,t.jsxs)(i.p,{children:["The object system specifies system-supplied primary ",(0,t.jsx)(i.em,{children:"methods"})," for each step and thus specifies a well-defined standard behavior for the entire initialization process. The standard behavior provides four simple mechanisms for controlling initialization:"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Declaring a ",(0,t.jsx)(i.em,{children:"symbol"})," to be an initialization argument for a ",(0,t.jsx)(i.em,{children:"slot"}),". An initialization argument is declared by using the ",":initarg"," slot option to ",(0,t.jsx)(i.strong,{children:"defclass"}),". This provides a mechanism for supplying a value for a ",(0,t.jsx)(i.em,{children:"slot"})," in a call to ",(0,t.jsx)(i.strong,{children:"make-instance"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Supplying a default value form for an initialization argument. Default value forms for initialization arguments are defined by using the ",":default-initargs"," class option to ",(0,t.jsx)(i.strong,{children:"defclass"}),". If an initialization argument is not explicitly provided as an argument to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the default value form is evaluated in the lexical environment of the ",(0,t.jsx)(i.strong,{children:"defclass"})," form that defined it, and the resulting value is used as the value of the initialization argument."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Supplying a default initial value form for a ",(0,t.jsx)(i.em,{children:"slot"}),". A default initial value form for a ",(0,t.jsx)(i.em,{children:"slot"})," is defined by using the ",":initform"," slot option to ",(0,t.jsx)(i.strong,{children:"defclass"}),". If no initialization argument associated with that ",(0,t.jsx)(i.em,{children:"slot"})," is given as an argument to ",(0,t.jsx)(i.strong,{children:"make-instance"})," or is defaulted by ",":default-initargs",", this default initial value form is evaluated in the lexical environment"]}),"\n",(0,t.jsxs)(i.p,{children:["of the ",(0,t.jsx)(i.strong,{children:"defclass"})," form that defined it, and the resulting value is stored in the ",(0,t.jsx)(i.em,{children:"slot"}),". The ",":initform"," form for a ",(0,t.jsx)(i.em,{children:"local slot"})," may be used when creating an ",(0,t.jsx)(i.em,{children:"instance"}),", when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),", or when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to the definition of a different ",(0,t.jsx)(i.em,{children:"class"}),". The ",":initform"," form for a ",(0,t.jsx)(i.em,{children:"shared slot"})," may be used when defining or re-defining the ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Defining ",(0,t.jsx)(i.em,{children:"methods"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," and ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". The slot-filling behavior described above is implemented by a system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," which invokes ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". The ",(0,t.jsx)(i.em,{children:"generic function"})," ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," implements the parts of initialization shared by these four situations: when making an ",(0,t.jsx)(i.em,{children:"instance"}),", when re-initializing an ",(0,t.jsx)(i.em,{children:"instance"}),", when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),", and when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to the definition of a different ",(0,t.jsx)(i.em,{children:"class"}),". The system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," directly implements the slot-filling behavior described above, and ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," simply invokes ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Objects ",(0,t.jsx)(i.strong,{children:"7\u20131"})]})]})}function r(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function l(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["An initialization argument controls ",(0,t.jsx)(i.em,{children:"object"})," creation and initialization. It is often convenient to use keyword ",(0,t.jsx)(i.em,{children:"symbols"})," to name initialization arguments, but the ",(0,t.jsx)(i.em,{children:"name"})," of an initialization argument can be any ",(0,t.jsx)(i.em,{children:"symbol"}),", including ",(0,t.jsx)(i.strong,{children:"nil"}),". An initialization argument can be used in two ways: to fill a ",(0,t.jsx)(i.em,{children:"slot"})," with"]}),"\n",(0,t.jsxs)(i.p,{children:["a value or to provide an argument for an initialization ",(0,t.jsx)(i.em,{children:"method"}),". A single initialization argument can be used for both purposes."]}),"\n",(0,t.jsxs)(i.p,{children:["An ",(0,t.jsx)(i.em,{children:"initialization argument list"})," is a ",(0,t.jsx)(i.em,{children:"property list"})," of initialization argument names and values. Its structure is identical to a ",(0,t.jsx)(i.em,{children:"property list"})," and also to the portion of an argument list processed for ",(0,t.jsx)(i.strong,{children:"&key"})," parameters. As in those lists, if an initialization argument name appears more than once in an initialization argument list, the leftmost occurrence supplies the value and the remaining"]}),"\n",(0,t.jsxs)(i.p,{children:["occurrences are ignored. The arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"})," (after the first argument) form an ",(0,t.jsx)(i.em,{children:"initialization argument list"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["An initialization argument can be associated with a ",(0,t.jsx)(i.em,{children:"slot"}),". If the initialization argument has a value in the ",(0,t.jsx)(i.em,{children:"initialization argument list"}),", the value is stored into the ",(0,t.jsx)(i.em,{children:"slot"})," of the newly created ",(0,t.jsx)(i.em,{children:"object"}),", overriding any ",":initform"," form associated with the ",(0,t.jsx)(i.em,{children:"slot"}),". A single initialization argument can initialize more than one ",(0,t.jsx)(i.em,{children:"slot"}),". An initialization argument that initializes a ",(0,t.jsx)(i.em,{children:"shared slot"})," stores its value into the ",(0,t.jsx)(i.em,{children:"shared slot"}),", replacing any previous value."]}),"\n",(0,t.jsxs)(i.p,{children:["An initialization argument can be associated with a ",(0,t.jsx)(i.em,{children:"method"}),". When an ",(0,t.jsx)(i.em,{children:"object"})," is created and a particular initialization argument is supplied, the ",(0,t.jsx)(i.em,{children:"generic functions"})," ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),", ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),", and ",(0,t.jsx)(i.strong,{children:"allocate-instance"})," are called with that initialization argument\u2019s name and value as a keyword argument pair. If a value for the initialization argument is not supplied in the ",(0,t.jsx)(i.em,{children:"initialization argument list"}),", the ",(0,t.jsx)(i.em,{children:"method"}),"\u2019s ",(0,t.jsx)(i.em,{children:"lambda list"})," supplies a default value."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization arguments are used in four situations: when making an ",(0,t.jsx)(i.em,{children:"instance"}),", when re-initializing an ",(0,t.jsx)(i.em,{children:"instance"}),", when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),", and when updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to the definition of a different ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Because initialization arguments are used to control the creation and initialization of an ",(0,t.jsx)(i.em,{children:"instance"})," of some particular ",(0,t.jsx)(i.em,{children:"class"}),", we say that an initialization argument is \u201can initialization argument for\u201d that ",(0,t.jsx)(i.em,{children:"class"}),"."]})]})}function o(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}function d(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Initialization arguments are checked for validity in each of the four situations that use them. An initialization argument may be valid in one situation and not another. For example, the system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"make-instance"})," defined for the ",(0,t.jsx)(i.em,{children:"class"})," ",(0,t.jsx)(i.strong,{children:"standard-class"})," checks the validity of its initialization arguments and signals an error if an initialization argument is supplied that is not declared as valid in that situation."]}),"\n",(0,t.jsx)(i.p,{children:"There are two means for declaring initialization arguments valid."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Initialization arguments that fill ",(0,t.jsx)(i.em,{children:"slots"})," are declared as valid by the ",":initarg"," slot option to ",(0,t.jsx)(i.strong,{children:"defclass"}),". The ",":initarg"," slot option is inherited from ",(0,t.jsx)(i.em,{children:"superclasses"}),". Thus the set of valid"]}),"\n",(0,t.jsxs)(i.p,{children:["initialization arguments that fill ",(0,t.jsx)(i.em,{children:"slots"})," for a ",(0,t.jsx)(i.em,{children:"class"})," is the union of the initialization arguments that fill ",(0,t.jsx)(i.em,{children:"slots"})," declared as valid by that ",(0,t.jsx)(i.em,{children:"class"})," and its ",(0,t.jsx)(i.em,{children:"superclasses"}),". Initialization arguments that fill ",(0,t.jsx)(i.em,{children:"slots"})," are valid in all four contexts."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Initialization arguments that supply arguments to ",(0,t.jsx)(i.em,{children:"methods"})," are declared as valid by defining those ",(0,t.jsx)(i.em,{children:"methods"}),". The keyword name of each keyword parameter specified in the ",(0,t.jsx)(i.em,{children:"method"}),"\u2019s ",(0,t.jsx)(i.em,{children:"lambda list"})," becomes an initialization argument for all ",(0,t.jsx)(i.em,{children:"classes"})," for which the ",(0,t.jsx)(i.em,{children:"method"})," is applicable. The presence of &allow-other-keys in the ",(0,t.jsx)(i.em,{children:"lambda list"})," of an applicable method disables validity checking of initialization arguments. Thus ",(0,t.jsx)(i.em,{children:"method"})," inheritance controls the set of valid initialization arguments that supply arguments to ",(0,t.jsx)(i.em,{children:"methods"}),". The ",(0,t.jsx)(i.em,{children:"generic functions"})," for which ",(0,t.jsx)(i.em,{children:"method"})," definitions serve to declare initialization arguments valid are as follows:"]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 Making an ",(0,t.jsx)(i.em,{children:"instance"})," of a ",(0,t.jsx)(i.em,{children:"class"}),": ",(0,t.jsx)(i.strong,{children:"allocate-instance"}),", ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),", and"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"shared-initialize"}),". Initialization arguments declared as valid by these ",(0,t.jsx)(i.em,{children:"methods"})," are"]}),"\n",(0,t.jsxs)(i.p,{children:["valid when making an ",(0,t.jsx)(i.em,{children:"instance"})," of a ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 Re-initializing an ",(0,t.jsx)(i.em,{children:"instance"}),": ",(0,t.jsx)(i.strong,{children:"reinitialize-instance"})," and ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". Initializa tion arguments declared as valid by these ",(0,t.jsx)(i.em,{children:"methods"})," are valid when re-initializing an"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"instance"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 Updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),":"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"update-instance-for-redefined-class"})," and ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". Initialization ar"]}),"\n",(0,t.jsxs)(i.p,{children:["guments declared as valid by these ",(0,t.jsx)(i.em,{children:"methods"})," are valid when updating an ",(0,t.jsx)(i.em,{children:"instance"})]}),"\n",(0,t.jsxs)(i.p,{children:["to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["\u2013 Updating an ",(0,t.jsx)(i.em,{children:"instance"})," to conform to the definition of a different ",(0,t.jsx)(i.em,{children:"class"}),":"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"update-instance-for-different-class"})," and ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". Initialization"]}),"\n",(0,t.jsxs)(i.p,{children:["arguments declared as valid by these ",(0,t.jsx)(i.em,{children:"methods"})," are valid when updating an ",(0,t.jsx)(i.em,{children:"instance"})]}),"\n",(0,t.jsxs)(i.p,{children:["to conform to the definition of a different ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The set of valid initialization arguments for a ",(0,t.jsx)(i.em,{children:"class"})," is the set of valid initialization arguments that either fill ",(0,t.jsx)(i.em,{children:"slots"})," or supply arguments to ",(0,t.jsx)(i.em,{children:"methods"}),", along with the predefined initialization argument ",":allow-other-keys",". The default value for ",":allow-other-keys"," is ",(0,t.jsx)(i.strong,{children:"nil"}),". Validity checking of initialization arguments is disabled if the value of the initialization argument ",":allow-other-keys"," is ",(0,t.jsx)(i.em,{children:"true"}),"."]})]})}function c(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function h(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["A default value ",(0,t.jsx)(i.em,{children:"form"})," can be supplied for an initialization argument by using the ",":default-initargs"," ",(0,t.jsx)(i.em,{children:"class"})," option. If an initialization argument is declared valid by some particular ",(0,t.jsx)(i.em,{children:"class"}),", its default value form might be specified by a different ",(0,t.jsx)(i.em,{children:"class"}),". In this case ",":default-initargs"," is used to supply a default value for an inherited initialization argument."]}),"\n",(0,t.jsxs)(i.p,{children:["Objects ",(0,t.jsx)(i.strong,{children:"7\u20133"})]}),"\n",(0,t.jsxs)(i.p,{children:["The ",":default-initargs"," option is used only to provide default values for initialization arguments; it does not declare a ",(0,t.jsx)(i.em,{children:"symbol"})," as a valid initialization argument name. Furthermore, the ",":default-initargs"," option is used only to provide default values for initialization arguments when making an ",(0,t.jsx)(i.em,{children:"instance"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The argument to the ",":default-initargs"," class option is a list of alternating initialization argument names and ",(0,t.jsx)(i.em,{children:"forms"}),". Each ",(0,t.jsx)(i.em,{children:"form"})," is the default value form for the corresponding initialization argument. The default value ",(0,t.jsx)(i.em,{children:"form"})," of an initialization argument is used and evaluated only if that initialization argument does not appear in the arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"})," and is not defaulted by a more specific ",(0,t.jsx)(i.em,{children:"class"}),". The default value ",(0,t.jsx)(i.em,{children:"form"})," is evaluated in the lexical environment of the ",(0,t.jsx)(i.strong,{children:"defclass"})," form that supplied it; the resulting value is used as the initialization argument\u2019s value."]}),"\n",(0,t.jsxs)(i.p,{children:["The initialization arguments supplied to ",(0,t.jsx)(i.strong,{children:"make-instance"})," are combined with defaulted initialization arguments to produce a ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"}),". A ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"})," is a list of alternating initialization argument names and values in which unsupplied initialization arguments are defaulted and in which the explicitly supplied initialization arguments appear earlier"]}),"\n",(0,t.jsxs)(i.p,{children:["in the list than the defaulted initialization arguments. Defaulted initialization arguments are ordered according to the order in the ",(0,t.jsx)(i.em,{children:"class precedence list"})," of the ",(0,t.jsx)(i.em,{children:"classes"})," that supplied the default values."]}),"\n",(0,t.jsxs)(i.p,{children:["There is a distinction between the purposes of the ",":default-initargs"," and the ",":initform"," options with respect to the initialization of ",(0,t.jsx)(i.em,{children:"slots"}),". The ",":default-initargs"," class option provides a mechanism for the user to give a default value ",(0,t.jsx)(i.em,{children:"form"})," for an initialization argument without knowing whether the initialization argument initializes a ",(0,t.jsx)(i.em,{children:"slot"})," or is passed to a ",(0,t.jsx)(i.em,{children:"method"}),". If that initialization argument is not explicitly supplied in a call to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the default value ",(0,t.jsx)(i.em,{children:"form"})," is used, just as if it had been supplied in the call. In contrast, the ",":initform"," slot option provides a mechanism for the user to give a default initial value form for a ",(0,t.jsx)(i.em,{children:"slot"}),". An ",":initform"," form is used to initialize a ",(0,t.jsx)(i.em,{children:"slot"})," only if no initialization argument associated with that ",(0,t.jsx)(i.em,{children:"slot"})," is given as an argument to ",(0,t.jsx)(i.strong,{children:"make-instance"})," or is defaulted by ",":default-initargs","."]}),"\n",(0,t.jsxs)(i.p,{children:["The order of evaluation of default value ",(0,t.jsx)(i.em,{children:"forms"})," for initialization arguments and the order of evaluation of ",":initform"," forms are undefined. If the order of evaluation is important, ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," or ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," ",(0,t.jsx)(i.em,{children:"methods"})," should be used instead."]})]})}function m(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}function u(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The ",":initarg"," slot option may be specified more than once for a given ",(0,t.jsx)(i.em,{children:"slot"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"The following rules specify when initialization arguments may be multiply defined:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A given initialization argument can be used to initialize more than one ",(0,t.jsx)(i.em,{children:"slot"})," if the same initialization argument name appears in more than one ",":initarg"," slot option."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A given initialization argument name can appear in the ",(0,t.jsx)(i.em,{children:"lambda list"})," of more than one initialization ",(0,t.jsx)(i.em,{children:"method"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A given initialization argument name can appear both in an ",":initarg"," slot option and in the ",(0,t.jsx)(i.em,{children:"lambda list"})," of an initialization ",(0,t.jsx)(i.em,{children:"method"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If two or more initialization arguments that initialize the same ",(0,t.jsx)(i.em,{children:"slot"})," are given in the arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the leftmost of these initialization arguments in the ",(0,t.jsx)(i.em,{children:"initialization argument list"})," supplies the value, even if the initialization arguments have different names."]}),"\n",(0,t.jsxs)(i.p,{children:["If two or more different initialization arguments that initialize the same ",(0,t.jsx)(i.em,{children:"slot"})," have default values and none is given explicitly in the arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the initialization argument that appears in a ",":default-initargs"," class option in the most specific of the ",(0,t.jsx)(i.em,{children:"classes"})," supplies the value. If a single ",":default-initargs"," class option specifies two or more initialization arguments that initialize the same ",(0,t.jsx)(i.em,{children:"slot"})," and none is given explicitly in the arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the leftmost in the ",":default-initargs"," class option supplies the value, and the values of the remaining default value ",(0,t.jsx)(i.em,{children:"forms"})," are ignored."]}),"\n",(0,t.jsxs)(i.p,{children:["Initialization arguments given explicitly in the arguments to ",(0,t.jsx)(i.strong,{children:"make-instance"})," appear to the left of defaulted initialization arguments. Suppose that the classes ",(0,t.jsx)(i.em,{children:"C"}),"<sub>1</sub> and ",(0,t.jsx)(i.em,{children:"C"}),"<sub>2</sub> supply the values of defaulted initialization arguments for different ",(0,t.jsx)(i.em,{children:"slots"}),", and suppose that ",(0,t.jsx)(i.em,{children:"C"}),"<sub>1</sub> is more specific than ",(0,t.jsx)(i.em,{children:"C"}),"<sub>2</sub>; then the defaulted initialization argument whose value is supplied by ",(0,t.jsx)(i.em,{children:"C"}),"<sub>1</sub> is to the left of"]}),"\n",(0,t.jsxs)(i.p,{children:["the defaulted initialization argument whose value is supplied by ",(0,t.jsx)(i.em,{children:"C"}),"<sub>2</sub> in the ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"}),". If a single ",":default-initargs"," class option supplies the values of initialization arguments for two different ",(0,t.jsx)(i.em,{children:"slots"}),", the initialization argument whose value is specified farther to the left in the ",":default-initargs"," class option appears farther to the left in the ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["If a ",(0,t.jsx)(i.em,{children:"slot"})," has both an ",":initform"," form and an ",":initarg"," slot option, and the initialization argument is defaulted using ",":default-initargs"," or is supplied to ",(0,t.jsx)(i.strong,{children:"make-instance"}),", the captured ",":initform"," form is neither used nor evaluated."]}),"\n",(0,t.jsx)(i.p,{children:"The following is an example of the above rules:"}),"\n",(0,t.jsxs)(i.p,{children:["(defclass q () ((x ",":initarg"," a)))"]}),"\n",(0,t.jsxs)(i.p,{children:["(defclass r (q) ((x ",":initarg"," b))"]}),"\n",(0,t.jsxs)(i.p,{children:["(",":default-initargs"," a 1 b 2))"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Defaulted"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Form Initialization Argument List Contents of Slot X"})," (make-instance \u2019r) (a 1 b 2) 1"]}),"\n",(0,t.jsx)(i.p,{children:"(make-instance \u2019r \u2019a 3) (a 3 b 2) 3"}),"\n",(0,t.jsx)(i.p,{children:"(make-instance \u2019r \u2019b 4) (b 4 a 1) 4"}),"\n",(0,t.jsx)(i.p,{children:"(make-instance \u2019r \u2019a 1 \u2019a 2) (a 1 a 2 b 2) 1"}),"\n",(0,t.jsxs)(i.p,{children:["Objects ",(0,t.jsx)(i.strong,{children:"7\u20135"})]})]})}function f(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function j(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.em,{children:"generic function"})," ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," is used to fill the ",(0,t.jsx)(i.em,{children:"slots"})," of an ",(0,t.jsx)(i.em,{children:"instance"})," using initialization arguments and ",":initform"," forms when an ",(0,t.jsx)(i.em,{children:"instance"})," is created, when an ",(0,t.jsx)(i.em,{children:"instance"})," is re-initialized, when an ",(0,t.jsx)(i.em,{children:"instance"})," is updated to conform to a redefined ",(0,t.jsx)(i.em,{children:"class"}),", and when an ",(0,t.jsx)(i.em,{children:"instance"})," is updated to conform to a different ",(0,t.jsx)(i.em,{children:"class"}),". It uses standard ",(0,t.jsx)(i.em,{children:"method"})," combination. It takes the following"]}),"\n",(0,t.jsxs)(i.p,{children:["arguments: the ",(0,t.jsx)(i.em,{children:"instance"})," to be initialized, a specification of a set of ",(0,t.jsx)(i.em,{children:"names"})," of ",(0,t.jsx)(i.em,{children:"slots accessible"})," in that ",(0,t.jsx)(i.em,{children:"instance"}),", and any number of initialization arguments. The arguments after the first two must form an ",(0,t.jsx)(i.em,{children:"initialization argument list"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The second argument to ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," may be one of the following:"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," It can be a (possibly empty) ",(0,t.jsx)(i.em,{children:"list"})," of ",(0,t.jsx)(i.em,{children:"slot"})," names, which specifies the set of those ",(0,t.jsx)(i.em,{children:"slot"})," names."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," It can be the symbol ",(0,t.jsx)(i.strong,{children:"t"}),", which specifies the set of all of the ",(0,t.jsx)(i.em,{children:"slots"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["There is a system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," whose first ",(0,t.jsx)(i.em,{children:"parameter specializer"})," is the ",(0,t.jsx)(i.em,{children:"class"})," ",(0,t.jsx)(i.strong,{children:"standard-object"}),". This ",(0,t.jsx)(i.em,{children:"method"})," behaves as follows on each ",(0,t.jsx)(i.em,{children:"slot"}),", whether shared or local:"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," If an initialization argument in the ",(0,t.jsx)(i.em,{children:"initialization argument list"})," specifies a value for that ",(0,t.jsx)(i.em,{children:"slot"}),", that value is stored into the ",(0,t.jsx)(i.em,{children:"slot"}),", even if a value has already been stored in the ",(0,t.jsx)(i.em,{children:"slot"})," before the ",(0,t.jsx)(i.em,{children:"method"})," is run. The affected ",(0,t.jsx)(i.em,{children:"slots"})," are independent of which ",(0,t.jsx)(i.em,{children:"slots"})," are indicated by the second argument to ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," Any ",(0,t.jsx)(i.em,{children:"slots"})," indicated by the second argument that are still unbound at this point are initialized according to their ",":initform"," forms. For any such ",(0,t.jsx)(i.em,{children:"slot"})," that has an ",":initform"," form, that ",(0,t.jsx)(i.em,{children:"form"})," is evaluated in the lexical environment of its defining ",(0,t.jsx)(i.strong,{children:"defclass"})," form and the result is stored into the ",(0,t.jsx)(i.em,{children:"slot"}),". For example, if a ",(0,t.jsx)(i.em,{children:"before method"})," stores a value in the ",(0,t.jsx)(i.em,{children:"slot"}),", the ",":initform"," form will not be used to supply a value for the ",(0,t.jsx)(i.em,{children:"slot"}),". If the second argument specifies a ",(0,t.jsx)(i.em,{children:"name"})," that does not correspond to any ",(0,t.jsx)(i.em,{children:"slots accessible"})," in the ",(0,t.jsx)(i.em,{children:"instance"}),", the results are unspecified."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," The rules mentioned in Section 7.1.4 (Rules for Initialization Arguments) are obeyed."]}),"\n",(0,t.jsxs)(i.p,{children:["The generic function ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," is called by the system-supplied primary ",(0,t.jsx)(i.em,{children:"methods"})," for ",(0,t.jsx)(i.strong,{children:"reinitialize-instance"}),", ",(0,t.jsx)(i.strong,{children:"update-instance-for-different-class"}),", ",(0,t.jsx)(i.strong,{children:"update-instance-for-redefined-class"}),", and ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),". Thus, ",(0,t.jsx)(i.em,{children:"methods"})," can be written for ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," to specify actions that should be taken in all of these contexts."]})]})}function x(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}function g(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.em,{children:"generic function"})," ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," is called by ",(0,t.jsx)(i.strong,{children:"make-instance"})," to initialize a newly created ",(0,t.jsx)(i.em,{children:"instance"}),". It uses ",(0,t.jsx)(i.em,{children:"standard method combination"}),". ",(0,t.jsx)(i.em,{children:"Methods"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," can be defined in order to perform any initialization that cannot be achieved simply by supplying initial values for ",(0,t.jsx)(i.em,{children:"slots"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["During initialization, ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," is invoked after the following actions have been taken:"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," The ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"})," has been computed by combining the supplied ",(0,t.jsx)(i.em,{children:"initialization argument list"})," with any default initialization arguments for the ",(0,t.jsx)(i.em,{children:"class"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," The validity of the ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"})," has been checked. If any of the initialization arguments has not been declared as valid, an error is signaled."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"\u2022"})," A new ",(0,t.jsx)(i.em,{children:"instance"})," whose ",(0,t.jsx)(i.em,{children:"slots"})," are unbound has been created."]}),"\n",(0,t.jsxs)(i.p,{children:["The generic function ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," is called with the new ",(0,t.jsx)(i.em,{children:"instance"})," and the defaulted initialization arguments. There is a system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," whose ",(0,t.jsx)(i.em,{children:"parameter specializer"})," is the ",(0,t.jsx)(i.em,{children:"class"})," ",(0,t.jsx)(i.strong,{children:"standard-object"}),". This ",(0,t.jsx)(i.em,{children:"method"})," calls the generic function ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," to fill in the ",(0,t.jsx)(i.em,{children:"slots"})," according to the initialization arguments and the ",":initform"," forms for the ",(0,t.jsx)(i.em,{children:"slots"}),"; the generic function ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," is called with the following arguments: the ",(0,t.jsx)(i.em,{children:"instance"}),", ",(0,t.jsx)(i.strong,{children:"t"}),", and the defaulted initialization arguments."]}),"\n",(0,t.jsxs)(i.p,{children:["Note that ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," provides the ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"})," in its call to ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),", so the first step performed by the system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," takes into account both the initialization arguments provided in the call to ",(0,t.jsx)(i.strong,{children:"make-instance"})," and the ",(0,t.jsx)(i.em,{children:"defaulted initialization argument list"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Methods"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," can be defined to specify actions to be taken when an ",(0,t.jsx)(i.em,{children:"instance"})," is initialized. If only ",(0,t.jsx)(i.em,{children:"after methods"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," are defined, they will be run after the system-supplied primary ",(0,t.jsx)(i.em,{children:"method"})," for initialization and therefore will not interfere with the default behavior of ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The object system provides two ",(0,t.jsx)(i.em,{children:"functions"})," that are useful in the bodies of ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," methods. The ",(0,t.jsx)(i.em,{children:"function"})," ",(0,t.jsx)(i.strong,{children:"slot-boundp"})," returns a ",(0,t.jsx)(i.em,{children:"generic boolean"})," value that indicates whether a specified ",(0,t.jsx)(i.em,{children:"slot"})," has a value; this provides a mechanism for writing ",(0,t.jsx)(i.em,{children:"after methods"})," for ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," that initialize ",(0,t.jsx)(i.em,{children:"slots"})," only if they have not already been initialized. The ",(0,t.jsx)(i.em,{children:"function"})," ",(0,t.jsx)(i.strong,{children:"slot-makunbound"})," causes the ",(0,t.jsx)(i.em,{children:"slot"})," to have no value."]})]})}function p(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}function z(e){const i={em:"em",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["The generic function ",(0,t.jsx)(i.strong,{children:"make-instance"})," behaves as if it were defined as follows, except that certain optimizations are permitted:"]}),"\n",(0,t.jsx)(i.p,{children:"(defmethod make-instance ((class standard-class) &rest initargs)"}),"\n",(0,t.jsx)(i.p,{children:"..."}),"\n",(0,t.jsx)(i.p,{children:"(let ((instance (apply #\u2019allocate-instance class initargs)))"}),"\n",(0,t.jsx)(i.p,{children:"(apply #\u2019initialize-instance instance initargs)"}),"\n",(0,t.jsx)(i.p,{children:"instance))"}),"\n",(0,t.jsx)(i.p,{children:"(defmethod make-instance ((class-name symbol) &rest initargs)"}),"\n",(0,t.jsx)(i.p,{children:"(apply #\u2019make-instance (find-class class-name) initargs))"}),"\n",(0,t.jsxs)(i.p,{children:["The elided code in the definition of ",(0,t.jsx)(i.strong,{children:"make-instance"})," augments the initargs with any ",(0,t.jsx)(i.em,{children:"defaulted initialization arguments"})," and checks the resulting initialization arguments to determine whether"]}),"\n",(0,t.jsxs)(i.p,{children:["Objects ",(0,t.jsx)(i.strong,{children:"7\u20137"})]}),"\n",(0,t.jsxs)(i.p,{children:["an initialization argument was supplied that neither filled a ",(0,t.jsx)(i.em,{children:"slot"})," nor supplied an argument to an applicable ",(0,t.jsx)(i.em,{children:"method"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The generic function ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," behaves as if it were defined as follows, except that certain optimizations are permitted:"]}),"\n",(0,t.jsx)(i.p,{children:"(defmethod initialize-instance ((instance standard-object) &rest initargs)"}),"\n",(0,t.jsx)(i.p,{children:"(apply #\u2019shared-initialize instance t initargs)))"}),"\n",(0,t.jsx)(i.p,{children:"These procedures can be customized."}),"\n",(0,t.jsxs)(i.p,{children:["Customizing at the Programmer Interface level includes using the ",":initform",", ",":initarg",", and ",":default-initargs"," options to ",(0,t.jsx)(i.strong,{children:"defclass"}),", as well as defining ",(0,t.jsx)(i.em,{children:"methods"})," for ",(0,t.jsx)(i.strong,{children:"make-instance"}),", ",(0,t.jsx)(i.strong,{children:"allocate-instance"}),", and ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),". It is also possible to define ",(0,t.jsx)(i.em,{children:"methods"})," for ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),", which would be invoked by the generic functions ",(0,t.jsx)(i.strong,{children:"reinitialize-instance"}),", ",(0,t.jsx)(i.strong,{children:"update-instance-for-redefined-class"}),", ",(0,t.jsx)(i.strong,{children:"update-instance-for-different-class"}),", and ",(0,t.jsx)(i.strong,{children:"initialize-instance"}),". The meta-object level supports additional customization."]}),"\n",(0,t.jsxs)(i.p,{children:["Implementations are permitted to make certain optimizations to ",(0,t.jsx)(i.strong,{children:"initialize-instance"})," and ",(0,t.jsx)(i.strong,{children:"shared-initialize"}),". The description of ",(0,t.jsx)(i.strong,{children:"shared-initialize"})," in Chapter 7 mentions the possible optimizations."]})]})}function b(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(z,{...e})}):z(e)}const v={title:"7.1 Object Creation and Initialization"},y="7.1 Object Creation and Initialization",w={id:"chap-7/h-b-object-creation-and-initialization",title:"7.1 Object Creation and Initialization",description:"7.1.1 Initialization Arguments",source:"@site/docs/chap-7/h-b-object-creation-and-initialization.md",sourceDirName:"chap-7",slug:"/chap-7/h-b-object-creation-and-initialization",permalink:"/cl-language-reference/docs/chap-7/h-b-object-creation-and-initialization",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-7/h-b-object-creation-and-initialization.md",tags:[],version:"current",frontMatter:{title:"7.1 Object Creation and Initialization"},sidebar:"tutorialSidebar",previous:{title:"7. Objects",permalink:"/cl-language-reference/docs/category/7-objects"},next:{title:"7.2 Changing the Class of an Instance",permalink:"/cl-language-reference/docs/chap-7/h-c-changing-the-class-of-an-instance"}},k={},I=[{value:"7.1.1 Initialization Arguments",id:"711-initialization-arguments",level:2},{value:"7.1.2 Declaring the Validity of Initialization Arguments",id:"712-declaring-the-validity-of-initialization-arguments",level:2},{value:"7.1.3 Defaulting of Initialization Arguments",id:"713-defaulting-of-initialization-arguments",level:2},{value:"7.1.4 Rules for Initialization Arguments",id:"714-rules-for-initialization-arguments",level:2},{value:"7.1.5 Shared",id:"715-shared",level:2},{value:"7.1.6 Initialize",id:"716-initialize",level:2},{value:"7.1.7 Definitions of Make",id:"717-definitions-of-make",level:2}];function T(e){const i={h1:"h1",h2:"h2",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"71-object-creation-and-initialization",children:"7.1 Object Creation and Initialization"}),"\n","\n",(0,t.jsx)(r,{}),"\n",(0,t.jsx)(i.h2,{id:"711-initialization-arguments",children:"7.1.1 Initialization Arguments"}),"\n","\n",(0,t.jsx)(o,{}),"\n",(0,t.jsx)(i.h2,{id:"712-declaring-the-validity-of-initialization-arguments",children:"7.1.2 Declaring the Validity of Initialization Arguments"}),"\n","\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(i.h2,{id:"713-defaulting-of-initialization-arguments",children:"7.1.3 Defaulting of Initialization Arguments"}),"\n","\n",(0,t.jsx)(m,{}),"\n",(0,t.jsx)(i.h2,{id:"714-rules-for-initialization-arguments",children:"7.1.4 Rules for Initialization Arguments"}),"\n","\n",(0,t.jsx)(f,{}),"\n",(0,t.jsx)(i.h2,{id:"715-shared",children:"7.1.5 Shared"}),"\n","\n",(0,t.jsx)(x,{}),"\n",(0,t.jsx)(i.h2,{id:"716-initialize",children:"7.1.6 Initialize"}),"\n","\n",(0,t.jsx)(p,{}),"\n",(0,t.jsx)(i.h2,{id:"717-definitions-of-make",children:"7.1.7 Definitions of Make"}),"\n","\n","\n",(0,t.jsx)(b,{})]})}function A(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(T,{...e})}):T(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>l,a:()=>r});var t=n(7294);const s={},a=t.createContext(s);function r(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);