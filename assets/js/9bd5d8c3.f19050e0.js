"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[30609],{98770:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>x,frontMatter:()=>l,metadata:()=>o,toc:()=>h});var t=r(85893),s=r(11151);function c(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"tree-equal"})," ",(0,t.jsx)(n.em,{children:"Function"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"tree-equal"})," ",(0,t.jsx)(n.em,{children:"tree-1 tree-2"})," &key ",(0,t.jsx)(n.em,{children:"test test-not \u2192 generalized-boolean"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"tree-1"}),"\u2014a ",(0,t.jsx)(n.em,{children:"tree"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"tree-2"}),"\u2014a ",(0,t.jsx)(n.em,{children:"tree"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"test"}),"\u2014a ",(0,t.jsx)(n.em,{children:"designator"})," for a ",(0,t.jsx)(n.em,{children:"function"})," of two ",(0,t.jsx)(n.em,{children:"arguments"})," that returns a ",(0,t.jsx)(n.em,{children:"generalized boolean"}),". ",(0,t.jsx)(n.em,{children:"test-not"}),"\u2014a ",(0,t.jsx)(n.em,{children:"designator"})," for a ",(0,t.jsx)(n.em,{children:"function"})," of two ",(0,t.jsx)(n.em,{children:"arguments"})," that returns a ",(0,t.jsx)(n.em,{children:"generalized boolean"}),". ",(0,t.jsx)(n.em,{children:"generalized-boolean"}),"\u2014a ",(0,t.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"tree-equal"})," tests whether two trees are of the same shape and have the same leaves. ",(0,t.jsx)(n.strong,{children:"tree-equal"})," returns ",(0,t.jsx)(n.em,{children:"true"})," if ",(0,t.jsx)(n.em,{children:"tree-1"})," and ",(0,t.jsx)(n.em,{children:"tree-2"})," are both ",(0,t.jsx)(n.em,{children:"atoms"})," and ",(0,t.jsx)(n.em,{children:"satisfy the test"}),", or if they are both ",(0,t.jsx)(n.em,{children:"conses"})," and the ",(0,t.jsx)(n.em,{children:"car"})," of ",(0,t.jsx)(n.em,{children:"tree-1"})," is ",(0,t.jsx)(n.strong,{children:"tree-equal"})," to the ",(0,t.jsx)(n.em,{children:"car"})," of ",(0,t.jsx)(n.em,{children:"tree-2"})," and the ",(0,t.jsx)(n.em,{children:"cdr"})," of ",(0,t.jsx)(n.em,{children:"tree-1"})," is ",(0,t.jsx)(n.strong,{children:"tree-equal"})," to the ",(0,t.jsx)(n.em,{children:"cdr"})," of ",(0,t.jsx)(n.em,{children:"tree-2"}),". Otherwise, ",(0,t.jsx)(n.strong,{children:"tree-equal"})," returns ",(0,t.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"tree-equal"})," recursively compares ",(0,t.jsx)(n.em,{children:"conses"})," but not any other ",(0,t.jsx)(n.em,{children:"objects"})," that have components."]}),"\n",(0,t.jsxs)(n.p,{children:["The first argument to the ",":test"," or ",":test-not"," function is ",(0,t.jsx)(n.em,{children:"tree-1"})," or a ",(0,t.jsx)(n.em,{children:"car"})," or ",(0,t.jsx)(n.em,{children:"cdr"})," of ",(0,t.jsx)(n.em,{children:"tree-1"}),"; the second argument is ",(0,t.jsx)(n.em,{children:"tree-2"})," or a ",(0,t.jsx)(n.em,{children:"car"})," or ",(0,t.jsx)(n.em,{children:"cdr"})," of ",(0,t.jsx)(n.em,{children:"tree-2"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"\n(setq tree1 \u2019(1 (1 2)) \n      tree2 \u2019(1 (1 2))) \u2192 (1 (1 2)) \n(tree-equal tree1 tree2) \u2192 true \n(eql tree1 tree2) \u2192 false \n(setq tree1 \u2019(\u2019a (\u2019b \u2019c)) \n      tree2 \u2019(\u2019a (\u2019b \u2019c))) \u2192 (\u2019a (\u2019b \u2019c)) \n\u2192 ((QUOTE A) ((QUOTE B) (QUOTE C))) \n(tree-equal tree1 tree2 :test \u2019eq) \u2192 true \n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,t.jsxs)(n.p,{children:["The consequences are undefined if both ",(0,t.jsx)(n.em,{children:"tree-1"})," and ",(0,t.jsx)(n.em,{children:"tree-2"})," are circular."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"equal"}),", Section 3.6 (Traversal Rules and Side Effects)"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",":test-not"," parameter is deprecated."]})]})}function i(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}const l={title:"tree-equal"},a="tree-equal",o={id:"chap-14/be-c-dictionary/tree-equal_function",title:"tree-equal",description:"Expanded Reference: tree-equal",source:"@site/docs/chap-14/be-c-dictionary/tree-equal_function.md",sourceDirName:"chap-14/be-c-dictionary",slug:"/chap-14/be-c-dictionary/tree-equal_function",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/tree-equal_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-14/be-c-dictionary/tree-equal_function.md",tags:[],version:"current",frontMatter:{title:"tree-equal"},sidebar:"tutorialSidebar",previous:{title:"subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/subst_subst-if_subst-if-not_nsubst_nsubst-if_nsubst-if-not_function"},next:{title:"union, nunion",permalink:"/cl-language-reference/docs/chap-14/be-c-dictionary/union_nunion_function"}},d={},h=[{value:"Expanded Reference: tree-equal",id:"expanded-reference-tree-equal",level:2}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"tree-equal",children:"tree-equal"}),"\n","\n","\n",(0,t.jsx)(i,{}),"\n",(0,t.jsx)(n.h2,{id:"expanded-reference-tree-equal",children:"Expanded Reference: tree-equal"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(tree-equal )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>i});var t=r(67294);const s={},c=t.createContext(s);function i(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);