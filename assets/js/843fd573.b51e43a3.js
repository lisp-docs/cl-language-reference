"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[2882],{41292:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>o});var s=t(85893),r=t(11151);function i(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"subtypep"})," ",(0,s.jsx)(n.em,{children:"Function"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"subtypep"})," ",(0,s.jsx)(n.em,{children:"type-1 type-2"})," &optional ",(0,s.jsx)(n.em,{children:"environment \u2192 subtype-p, valid-p"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"type-1"}),"\u2014a ",(0,s.jsx)(n.em,{children:"type specifier"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"type-2"}),"\u2014a ",(0,s.jsx)(n.em,{children:"type specifier"})," ."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"environment"}),"\u2014an ",(0,s.jsx)(n.em,{children:"environment object"}),". The default is ",(0,s.jsx)(n.strong,{children:"nil"}),", denoting the ",(0,s.jsx)(n.em,{children:"null lexical environment"})," and the current ",(0,s.jsx)(n.em,{children:"global environment"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"subtype-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"valid-p"}),"\u2014a ",(0,s.jsx)(n.em,{children:"generalized boolean"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Description:"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.em,{children:"type-1"})," is a ",(0,s.jsx)(n.em,{children:"recognizable subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"}),", the first ",(0,s.jsx)(n.em,{children:"value"})," is ",(0,s.jsx)(n.em,{children:"true"}),". Otherwise, the first ",(0,s.jsx)(n.em,{children:"value"})," is ",(0,s.jsx)(n.em,{children:"false"}),", indicating that either ",(0,s.jsx)(n.em,{children:"type-1"})," is not a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"}),", or else ",(0,s.jsx)(n.em,{children:"type-1"})," is a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"})," but is not a ",(0,s.jsx)(n.em,{children:"recognizable subtype"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A second ",(0,s.jsx)(n.em,{children:"value"})," is also returned indicating the \u2018certainty\u2019 of the first ",(0,s.jsx)(n.em,{children:"value"}),". If this value is ",(0,s.jsx)(n.em,{children:"true"}),", then the first value is an accurate indication of the ",(0,s.jsx)(n.em,{children:"subtype"})," relationship. (The second ",(0,s.jsx)(n.em,{children:"value"})," is always ",(0,s.jsx)(n.em,{children:"true"})," when the first ",(0,s.jsx)(n.em,{children:"value"})," is ",(0,s.jsx)(n.em,{children:"true"}),".)"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"subtypep"})}),"\n",(0,s.jsxs)(n.p,{children:["Figure 4\u20139 summarizes the possible combinations of ",(0,s.jsx)(n.em,{children:"values"})," that might result."]}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsx)(n.strong,{children:"Value 1 Value 2 Meaning"}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"| :- |"}),"\n",(0,s.jsxs)(n.p,{children:["|",(0,s.jsxs)("p",{children:[(0,s.jsx)(n.em,{children:"true true type-1"})," is definitely a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"}),". "]}),(0,s.jsxs)("p",{children:[(0,s.jsx)(n.em,{children:"false true type-1"})," is definitely not a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"}),". ",(0,s.jsx)(n.em,{children:"false false"})," ",(0,s.jsx)(n.strong,{children:"subtypep"})," could not determine the relationship, so ",(0,s.jsx)(n.em,{children:"type-1"})," might or might not be a ",(0,s.jsx)(n.em,{children:"subtype"})," of ",(0,s.jsx)(n.em,{children:"type-2"}),"."]}),"|"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 4\u20139. Result possibilities for subtypep"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"subtypep"})," is permitted to return the ",(0,s.jsx)(n.em,{children:"values false"})," and ",(0,s.jsx)(n.em,{children:"false"})," only when at least one argument involves one of these ",(0,s.jsx)(n.em,{children:"type specifiers"}),": ",(0,s.jsx)(n.strong,{children:"and"}),", ",(0,s.jsx)(n.strong,{children:"eql"}),", the list form of ",(0,s.jsx)(n.strong,{children:"function"}),", ",(0,s.jsx)(n.strong,{children:"member"}),", ",(0,s.jsx)(n.strong,{children:"not"}),", ",(0,s.jsx)(n.strong,{children:"or"}),", ",(0,s.jsx)(n.strong,{children:"satisfies"}),", or ",(0,s.jsx)(n.strong,{children:"values"}),". (A ",(0,s.jsx)(n.em,{children:"type specifier"})," \u2018involves\u2019 such a ",(0,s.jsx)(n.em,{children:"symbol"})," if, after being ",(0,s.jsx)(n.em,{children:"type expanded"}),", it contains that ",(0,s.jsx)(n.em,{children:"symbol"})," in a position that would call for its meaning as a ",(0,s.jsx)(n.em,{children:"type specifier"})," to be used.) One consequence of this is that if neither ",(0,s.jsx)(n.em,{children:"type-1"})," nor ",(0,s.jsx)(n.em,{children:"type-2"})," involves any of these ",(0,s.jsx)(n.em,{children:"type specifiers"}),", then ",(0,s.jsx)(n.strong,{children:"subtypep"})," is obliged to determine the relationship accurately. In particular, ",(0,s.jsx)(n.strong,{children:"subtypep"})," returns the ",(0,s.jsx)(n.em,{children:"values true"})," and ",(0,s.jsx)(n.em,{children:"true"})," if the arguments are ",(0,s.jsx)(n.strong,{children:"equal"})," and do not involve any of these ",(0,s.jsx)(n.em,{children:"type specifiers"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"subtypep"})," never returns a second value of ",(0,s.jsx)(n.strong,{children:"nil"})," when both ",(0,s.jsx)(n.em,{children:"type-1"})," and ",(0,s.jsx)(n.em,{children:"type-2"})," involve only the names in Figure 4\u20132, or names of ",(0,s.jsx)(n.em,{children:"types"})," defined by ",(0,s.jsx)(n.strong,{children:"defstruct"}),", ",(0,s.jsx)(n.strong,{children:"define-condition"}),", or ",(0,s.jsx)(n.strong,{children:"defclass"}),", or ",(0,s.jsx)(n.em,{children:"derived types"})," that expand into only those names. While ",(0,s.jsx)(n.em,{children:"type specifiers"})," listed in Figure 4\u20132 and names of ",(0,s.jsx)(n.strong,{children:"defclass"})," and ",(0,s.jsx)(n.strong,{children:"defstruct"})," can in some cases be implemented as ",(0,s.jsx)(n.em,{children:"derived types"}),", ",(0,s.jsx)(n.strong,{children:"subtypep"})," regards them as primitive."]}),"\n",(0,s.jsxs)(n.p,{children:["The relationships between ",(0,s.jsx)(n.em,{children:"types"})," reflected by ",(0,s.jsx)(n.strong,{children:"subtypep"})," are those specific to the particular implementation. For example, if an implementation supports only a single type of floating-point numbers, in that implementation (subtypep \u2019float \u2019long-float) returns the ",(0,s.jsx)(n.em,{children:"values true"})," and ",(0,s.jsx)(n.em,{children:"true"})," (since the two ",(0,s.jsx)(n.em,{children:"types"})," are identical)."]}),"\n",(0,s.jsxs)(n.p,{children:["For all ",(0,s.jsx)(n.em,{children:"T1"})," and ",(0,s.jsx)(n.em,{children:"T2"})," other than *, (array ",(0,s.jsx)(n.em,{children:"T1"}),") and (array ",(0,s.jsx)(n.em,{children:"T2"}),") are two different ",(0,s.jsx)(n.em,{children:"type spec ifiers"})," that always refer to the same sets of things if and only if they refer to ",(0,s.jsx)(n.em,{children:"arrays"})," of exactly the same specialized representation, ",(0,s.jsx)(n.em,{children:"i.e."}),", if (upgraded-array-element-type \u2019",(0,s.jsx)(n.em,{children:"T1"}),") and (upgraded-array-element-type \u2019",(0,s.jsx)(n.em,{children:"T2"}),") return two different ",(0,s.jsx)(n.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,s.jsx)(n.em,{children:"objects"}),". This is another way of saying that \u2018(array ",(0,s.jsx)(n.em,{children:"type-specifier"}),") and \u2018(array ,(upgraded-array-element-type \u2019",(0,s.jsx)(n.em,{children:"type-specifier"}),")) refer to the same set of specialized ",(0,s.jsx)(n.em,{children:"array"})," representations. For all ",(0,s.jsx)(n.em,{children:"T1"})," and ",(0,s.jsx)(n.em,{children:"T2"})," other than *, the intersection of (array ",(0,s.jsx)(n.em,{children:"T1"}),") and (array ",(0,s.jsx)(n.em,{children:"T2"}),") is the empty set if and only if they refer to ",(0,s.jsx)(n.em,{children:"arrays"})," of different, distinct specialized representations."]}),"\n",(0,s.jsx)(n.p,{children:"Therefore,"}),"\n",(0,s.jsx)(n.p,{children:"(subtypep \u2019(array T1) \u2019(array T2)) \u2192 true"}),"\n",(0,s.jsx)(n.p,{children:"if and only if"}),"\n",(0,s.jsx)(n.p,{children:"(upgraded-array-element-type \u2019T1) and"}),"\n",(0,s.jsx)(n.p,{children:"(upgraded-array-element-type \u2019T2)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"subtypep"})}),"\n",(0,s.jsxs)(n.p,{children:["return two different ",(0,s.jsx)(n.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,s.jsx)(n.em,{children:"objects"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For all type-specifiers ",(0,s.jsx)(n.em,{children:"T1"})," and ",(0,s.jsx)(n.em,{children:"T2"})," other than *,"]}),"\n",(0,s.jsxs)(n.p,{children:["(subtypep \u2019(complex T1) \u2019(complex T2)) \u2192 true, ",(0,s.jsx)(n.em,{children:"true"})]}),"\n",(0,s.jsx)(n.p,{children:"if:"}),"\n",(0,s.jsxs)(n.p,{children:["1. T1 is a ",(0,s.jsx)(n.em,{children:"subtype"})," of T2, or"]}),"\n",(0,s.jsxs)(n.p,{children:["2. (upgraded-complex-part-type \u2019",(0,s.jsx)(n.em,{children:"T1"}),") and (upgraded-complex-part-type \u2019",(0,s.jsx)(n.em,{children:"T2"}),") return two different ",(0,s.jsx)(n.em,{children:"type specifiers"})," that always refer to the same sets of ",(0,s.jsx)(n.em,{children:"objects"}),"; in this case, (complex ",(0,s.jsx)(n.em,{children:"T1"}),") and (complex ",(0,s.jsx)(n.em,{children:"T2"}),") both refer to the same specialized representation."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"values"})," are ",(0,s.jsx)(n.em,{children:"false"})," and ",(0,s.jsx)(n.em,{children:"true"})," otherwise."]}),"\n",(0,s.jsx)(n.p,{children:"The form"}),"\n",(0,s.jsx)(n.p,{children:"(subtypep \u2019(complex single-float) \u2019(complex float))"}),"\n",(0,s.jsxs)(n.p,{children:["must return ",(0,s.jsx)(n.em,{children:"true"})," in all implementations, but"]}),"\n",(0,s.jsx)(n.p,{children:"(subtypep \u2019(array single-float) \u2019(array float))"}),"\n",(0,s.jsxs)(n.p,{children:["returns ",(0,s.jsx)(n.em,{children:"true"})," only in implementations that do not have a specialized ",(0,s.jsx)(n.em,{children:"array"})," representation for ",(0,s.jsx)(n.em,{children:"single floats"})," distinct from that for other ",(0,s.jsx)(n.em,{children:"floats"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"\n(subtypep \u2019compiled-function \u2019function) \u2192 true, *true* \n(subtypep \u2019null \u2019list) \u2192 true, *true* \n(subtypep \u2019null \u2019symbol) \u2192 true, *true* \n(subtypep \u2019integer \u2019string) \u2192 false, *true* \n(subtypep \u2019(satisfies dummy) nil) \u2192 false, *implementation-dependent* \n(subtypep \u2019(integer 1 3) \u2019(integer 1 4)) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019nil) \u2192 true, *true* \n(subtypep \u2019nil \u2019(integer (0) (0))) \u2192 true, *true* \n(subtypep \u2019(integer (0) (0)) \u2019(member)) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019(member) \u2019nil) \u2192 true, *true* ;or *false*, *false* \n(subtypep \u2019nil \u2019(member)) \u2192 true, *true* ;or *false*, *false* \nLet <aet-x> and <aet-y> be two distinct *type specifiers* that do not always refer to the same sets of *objects* in a given implementation, but for which **make-array**, will return an *object* of the same *array type*. \nThus, in each case, \n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-x>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-y>))) \n\u2192 true, *true*  \n\n(subtypep (array-element-type (make-array 0 :element-type \u2019<aet-y>)) \n\t  (array-element-type (make-array 0 :element-type \u2019<aet-x>))) \n\u2192 true, *true* \nIf (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of *objects*, these names should always refer to the same sets of *objects*. That implies that the following set of tests are also true: \n(subtypep \u2019(array <aet-x>) \u2019(array <aet-y>)) \u2192 true, *true* \n(subtypep \u2019(array <aet-y>) \u2019(array <aet-x>)) \u2192 true, *true* \n\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,s.jsx)(n.p,{children:"Section 4.2 (Types)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.p,{children:["The small differences between the ",(0,s.jsx)(n.strong,{children:"subtypep"})," specification for the ",(0,s.jsx)(n.strong,{children:"array"})," and ",(0,s.jsx)(n.strong,{children:"complex"})," types are necessary because there is no creation function for ",(0,s.jsx)(n.em,{children:"complexes"})," which allows the specification of the resultant part type independently of the actual types of the parts. Thus in the case of the ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"complex"}),", the actual type of the parts is referred to, although a ",(0,s.jsx)(n.em,{children:"number"})," can be a member of more than one ",(0,s.jsx)(n.em,{children:"type"}),". For example, 17 is of ",(0,s.jsx)(n.em,{children:"type"})," (mod 18) as well as ",(0,s.jsx)(n.em,{children:"type"})," (mod 256) and ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"integer"}),"; and 2.3f5 is of ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"single-float"})," as well as ",(0,s.jsx)(n.em,{children:"type"})," ",(0,s.jsx)(n.strong,{children:"float"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}const a={title:"subtypep"},c="subtypep",d={id:"chap-4/e-e-dictionary/subtypep_function",title:"subtypep",description:"Expanded Reference: subtypep",source:"@site/docs/chap-4/e-e-dictionary/subtypep_function.md",sourceDirName:"chap-4/e-e-dictionary",slug:"/chap-4/e-e-dictionary/subtypep_function",permalink:"/cl-language-reference/docs/chap-4/e-e-dictionary/subtypep_function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-4/e-e-dictionary/subtypep_function.md",tags:[],version:"current",frontMatter:{title:"subtypep"},sidebar:"tutorialSidebar",previous:{title:"structure-object",permalink:"/cl-language-reference/docs/chap-4/e-e-dictionary/structure-object_class"},next:{title:"t",permalink:"/cl-language-reference/docs/chap-4/e-e-dictionary/t_system-class"}},p={},o=[{value:"Expanded Reference: subtypep",id:"expanded-reference-subtypep",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"subtypep",children:"subtypep"}),"\n","\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(n.h2,{id:"expanded-reference-subtypep",children:"Expanded Reference: subtypep"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lisp",children:"(subtypep )\n"})})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>l});var s=t(67294);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);