"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[3890],{849:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>z,contentTitle:()=>H,default:()=>F,frontMatter:()=>S,metadata:()=>V,toc:()=>Q});var i=n(5893),h=n(1151);function r(e){const s={p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1 Hash Table Concepts"})})}function t(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}function l(e){const s={em:"em",p:"p",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.1 Hash-Table Operations"})}),"\n",(0,i.jsxs)(s.p,{children:["Figure 18\u20131 lists some ",(0,i.jsx)(s.em,{children:"defined names"})," that are applicable to ",(0,i.jsx)(s.em,{children:"hash tables"}),". The following rules apply to ",(0,i.jsx)(s.em,{children:"hash tables"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["\u2013 A ",(0,i.jsx)(s.em,{children:"hash table"})," can only associate one value with a given key. If an attempt is made to add a second value for a given key, the second value will replace the first. Thus, adding a value to a ",(0,i.jsx)(s.em,{children:"hash table"})," is a destructive operation; the ",(0,i.jsx)(s.em,{children:"hash table"})," is modified."]}),"\n",(0,i.jsxs)(s.p,{children:["\u2013 There are four kinds of ",(0,i.jsx)(s.em,{children:"hash tables"}),": those whose keys are compared with ",(0,i.jsx)(s.strong,{children:"eq"}),", those whose keys are compared with ",(0,i.jsx)(s.strong,{children:"eql"}),", those whose keys are compared with ",(0,i.jsx)(s.strong,{children:"equal"}),", and those whose keys are compared with ",(0,i.jsx)(s.strong,{children:"equalp"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["\u2013 ",(0,i.jsx)(s.em,{children:"Hash tables"})," are created by ",(0,i.jsx)(s.strong,{children:"make-hash-table"}),". ",(0,i.jsx)(s.strong,{children:"gethash"})," is used to look up a key and find the associated value. New entries are added to ",(0,i.jsx)(s.em,{children:"hash tables"})," using ",(0,i.jsx)(s.strong,{children:"setf"})," with ",(0,i.jsx)(s.strong,{children:"gethash"}),". ",(0,i.jsx)(s.strong,{children:"remhash"})," is used to remove an entry. For example:"]}),"\n",(0,i.jsxs)(s.p,{children:["(setq a (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32536573>"]}),"\n",(0,i.jsxs)(s.p,{children:["(setf (gethash \u2019color a) \u2019brown) ",(0,i.jsx)(s.em,{children:"\u2192"})," BROWN"]}),"\n",(0,i.jsxs)(s.p,{children:["(setf (gethash \u2019name a) \u2019fred) ",(0,i.jsx)(s.em,{children:"\u2192"})," FRED"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash \u2019color a) ",(0,i.jsx)(s.em,{children:"\u2192"})," BROWN, ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash \u2019name a) ",(0,i.jsx)(s.em,{children:"\u2192"})," FRED, ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash \u2019pointy a) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["In this example, the symbols color and name are being used as keys, and the symbols brown and fred are being used as the associated values. The ",(0,i.jsx)(s.em,{children:"hash table"})," has two items in it, one of which associates from color to brown, and the other of which associates from name to fred."]}),"\n",(0,i.jsxs)(s.p,{children:["\u2013 A key or a value may be any ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["\u2013 The existence of an entry in the ",(0,i.jsx)(s.em,{children:"hash table"})," can be determined from the ",(0,i.jsx)(s.em,{children:"secondary value"})," returned by ",(0,i.jsx)(s.strong,{children:"gethash"}),"."]}),"\n",(0,i.jsx)(s.table,{children:(0,i.jsx)(s.thead,{children:(0,i.jsx)(s.tr,{children:(0,i.jsxs)(s.th,{style:{textAlign:"left"},children:["<p>",(0,i.jsx)(s.strong,{children:"clrhash hash-table-p remhash gethash make-hash-table sxhash"})," </p><p>",(0,i.jsx)(s.strong,{children:"hash-table-count maphash"}),"</p>"]})})})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Figure 18\u20131. Hash-table defined names"})}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u20131"})]})]})}function a(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}function c(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2 Modifying Hash Table Keys"})}),"\n",(0,i.jsxs)(s.p,{children:["The function supplied as the ",":test"," argument to ",(0,i.jsx)(s.strong,{children:"make-hash-table"})," specifies the \u2018equivalence test\u2019 for the ",(0,i.jsx)(s.em,{children:"hash table"})," it creates."]}),"\n",(0,i.jsxs)(s.p,{children:["An ",(0,i.jsx)(s.em,{children:"object"})," is \u2018visibly modified\u2019 with regard to an equivalence test if there exists some set of ",(0,i.jsx)(s.em,{children:"objects"})," (or potential ",(0,i.jsx)(s.em,{children:"objects"}),") which are equivalent to the ",(0,i.jsx)(s.em,{children:"object"})," before the modification but are no longer equivalent afterwards."]}),"\n",(0,i.jsxs)(s.p,{children:["If an ",(0,i.jsx)(s.em,{children:"object O"}),"<sub>1</sub> is used as a key in a ",(0,i.jsx)(s.em,{children:"hash table H"})," and is then visibly modified with regard to the equivalence test of ",(0,i.jsx)(s.em,{children:"H"}),", then the consequences are unspecified if ",(0,i.jsx)(s.em,{children:"O"}),"<sub>1</sub>, or any ",(0,i.jsx)(s.em,{children:"object O"}),"<sub>2</sub> equivalent to ",(0,i.jsx)(s.em,{children:"O"}),"<sub>1</sub> under the equivalence test (either before or after the modification), is used as a key in further operations on ",(0,i.jsx)(s.em,{children:"H"}),". The consequences of using ",(0,i.jsx)(s.em,{children:"O"}),"<sub>1</sub> as a key are unspecified even if ",(0,i.jsx)(s.em,{children:"O"}),"<sub>1</sub> is visibly"]}),"\n",(0,i.jsx)(s.p,{children:"modified and then later modified again in such a way as to undo the visible modification."}),"\n",(0,i.jsxs)(s.p,{children:["Following are specifications of the modifications which are visible to the equivalence tests which must be supported by ",(0,i.jsx)(s.em,{children:"hash tables"}),". The modifications are described in terms of modification of components, and are defined recursively. Visible modifications of components of the ",(0,i.jsx)(s.em,{children:"object"})," are visible modifications of the ",(0,i.jsx)(s.em,{children:"object"}),"."]})]})}function d(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function o(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"})}),"\n",(0,i.jsxs)(s.p,{children:["No ",(0,i.jsx)(s.em,{children:"standardized function"})," is provided that is capable of visibly modifying an ",(0,i.jsx)(s.em,{children:"object"})," with regard to ",(0,i.jsx)(s.strong,{children:"eq"})," or ",(0,i.jsx)(s.strong,{children:"eql"}),"."]})]})}function x(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}function j(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"})}),"\n",(0,i.jsxs)(s.p,{children:["As a consequence of the behavior for ",(0,i.jsx)(s.strong,{children:"equal"}),", the rules for visible modification of ",(0,i.jsx)(s.em,{children:"objects"})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modification of Objects with respect to EQ and EQL)."]})]})}function m(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(j,{...e})}):j(e)}function p(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"})}),"\n",(0,i.jsxs)(s.p,{children:["Any visible change to the ",(0,i.jsx)(s.em,{children:"car"})," or the ",(0,i.jsx)(s.em,{children:"cdr"})," of a ",(0,i.jsx)(s.em,{children:"cons"})," is considered a visible modification with regard to ",(0,i.jsx)(s.strong,{children:"equal"}),"."]})]})}function b(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}function u(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"})}),"\n",(0,i.jsxs)(s.p,{children:["For a ",(0,i.jsx)(s.em,{children:"vector"})," of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"bit-vector"})," or of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"string"}),", any visible change to an ",(0,i.jsx)(s.em,{children:"active element"})," of the ",(0,i.jsx)(s.em,{children:"vector"})," , or to the ",(0,i.jsx)(s.em,{children:"length"})," of the ",(0,i.jsx)(s.em,{children:"vector"})," (if it is ",(0,i.jsx)(s.em,{children:"actually adjustable"})," or has a ",(0,i.jsx)(s.em,{children:"fill pointer"})," ) is considered a visible modification with regard to ",(0,i.jsx)(s.strong,{children:"equal"}),"."]})]})}function f(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}function g(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"})}),"\n",(0,i.jsxs)(s.p,{children:["As a consequence of the behavior for ",(0,i.jsx)(s.strong,{children:"equalp"}),", the rules for visible modification of ",(0,i.jsx)(s.em,{children:"objects"})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modification of Objects with respect to EQUAL)."]})]})}function y(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}function v(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"})}),"\n",(0,i.jsxs)(s.p,{children:["Any visible change to a ",(0,i.jsx)(s.em,{children:"slot"})," of a ",(0,i.jsx)(s.em,{children:"structure"})," is considered a visible modification with regard to ",(0,i.jsx)(s.strong,{children:"equalp"}),"."]})]})}function w(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}function k(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"})}),"\n",(0,i.jsxs)(s.p,{children:["In an ",(0,i.jsx)(s.em,{children:"array"}),", any visible change to an ",(0,i.jsx)(s.em,{children:"active element"}),", to the ",(0,i.jsx)(s.em,{children:"fill pointer"})," (if the ",(0,i.jsx)(s.em,{children:"array"})," can and does have one), or to the ",(0,i.jsx)(s.em,{children:"dimensions"})," (if the ",(0,i.jsx)(s.em,{children:"array"})," is ",(0,i.jsx)(s.em,{children:"actually adjustable"}),") is considered a visible modification with regard to ",(0,i.jsx)(s.strong,{children:"equalp"}),"."]})]})}function A(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(k,{...e})}):k(e)}function q(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"})}),"\n",(0,i.jsxs)(s.p,{children:["In a ",(0,i.jsx)(s.em,{children:"hash table"}),", any visible change to the count of entries in the ",(0,i.jsx)(s.em,{children:"hash table"}),", to the keys, or to the values associated with the keys is considered a visible modification with regard to ",(0,i.jsx)(s.strong,{children:"equalp"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that the visibility of modifications to the keys depends on the equivalence test of the ",(0,i.jsx)(s.em,{children:"hash table"}),", not on the specification of ",(0,i.jsx)(s.strong,{children:"equalp"}),"."]})]})}function E(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(q,{...e})}):q(e)}function T(e){const s={em:"em",p:"p",strong:"strong",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"18.1.2.4 Visible Modifications by Language Extensions"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Implementations"})," that extend the language by providing additional mutator functions (or additional behavior for existing mutator functions) must document how the use of these extensions interacts with equivalence tests and ",(0,i.jsx)(s.em,{children:"hash table"})," searches."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Implementations"})," that extend the language by defining additional acceptable equivalence tests for ",(0,i.jsx)(s.em,{children:"hash tables"})," (allowing additional values for the ",":test"," argument to ",(0,i.jsx)(s.strong,{children:"make-hash-table"}),") must document the visible components of these tests."]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u20133"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table"})," ",(0,i.jsx)(s.em,{children:"System Class"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Class Precedence List:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table"}),", ",(0,i.jsx)(s.strong,{children:"t"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Hash tables"})," provide a way of mapping any ",(0,i.jsx)(s.em,{children:"object"})," (a ",(0,i.jsx)(s.em,{children:"key"}),") to an associated ",(0,i.jsx)(s.em,{children:"object"})," (a ",(0,i.jsx)(s.em,{children:"value"}),")."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:"Section 18.1 (Hash Table Concepts), Section 22.1.3.13 (Printing Other Objects)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["The intent is that this mapping be implemented by a hashing mechanism, such as that described in Section 6.4 \u201cHashing\u201d of ",(0,i.jsx)(s.em,{children:"The Art of Computer Programming, Volume 3"})," (pp506-549). In spite of this intent, no ",(0,i.jsx)(s.em,{children:"conforming implementation"})," is required to use any particular technique to implement the mapping."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"make-hash-table"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"make-hash-table"})," &key ",(0,i.jsx)(s.em,{children:"test size rehash-size rehash-threshold \u2192 hash-table"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"test"}),"\u2014a ",(0,i.jsx)(s.em,{children:"designator"})," for one of the ",(0,i.jsx)(s.em,{children:"functions"})," ",(0,i.jsx)(s.strong,{children:"eq"}),", ",(0,i.jsx)(s.strong,{children:"eql"}),", ",(0,i.jsx)(s.strong,{children:"equal"}),", or ",(0,i.jsx)(s.strong,{children:"equalp"}),". The default is ",(0,i.jsx)(s.strong,{children:"eql"}),". ",(0,i.jsx)(s.em,{children:"size"}),"\u2014a non-negative ",(0,i.jsx)(s.em,{children:"integer"})," . The default is ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-size"}),"\u2014a ",(0,i.jsx)(s.em,{children:"real"})," of ",(0,i.jsx)(s.em,{children:"type"})," (or (integer 1 *) (float (1.0) *)). The default is ",(0,i.jsx)(s.em,{children:"implementation dependent"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-threshold"}),"\u2014a ",(0,i.jsx)(s.em,{children:"real"})," of ",(0,i.jsx)(s.em,{children:"type"})," (real 0 1). The default is ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),". ",(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Creates and returns a new ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"test"})," determines how ",(0,i.jsx)(s.em,{children:"keys"})," are compared. An ",(0,i.jsx)(s.em,{children:"object"})," is said to be present in the ",(0,i.jsx)(s.em,{children:"hash-table"})," if that ",(0,i.jsx)(s.em,{children:"object"})," is the ",(0,i.jsx)(s.em,{children:"same"})," under the ",(0,i.jsx)(s.em,{children:"test"})," as the ",(0,i.jsx)(s.em,{children:"key"})," for some entry in the ",(0,i.jsx)(s.em,{children:"hash-table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"size"})," is a hint to the ",(0,i.jsx)(s.em,{children:"implementation"})," about how much initial space to allocate in the ",(0,i.jsx)(s.em,{children:"hash-table"}),". This information, taken together with the ",(0,i.jsx)(s.em,{children:"rehash-threshold"}),", controls the approximate number of entries which it should be possible to insert before the table has to grow. The actual size might be"]}),"\n",(0,i.jsxs)(s.p,{children:["rounded up from ",(0,i.jsx)(s.em,{children:"size"})," to the next \u2018good\u2019 size; for example, some ",(0,i.jsx)(s.em,{children:"implementations"})," might round to the next prime number."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-size"})," specifies a minimum amount to increase the size of the ",(0,i.jsx)(s.em,{children:"hash-table"})," when it becomes full enough to require rehashing; see ",(0,i.jsx)(s.em,{children:"rehash-theshold"})," below. If ",(0,i.jsx)(s.em,{children:"rehash-size"})," is an ",(0,i.jsx)(s.em,{children:"integer"})," , the expected growth rate for the table is additive and the ",(0,i.jsx)(s.em,{children:"integer"})," is the number of entries to add; if it is a ",(0,i.jsx)(s.em,{children:"float"}),", the expected growth rate for the table is multiplicative and the ",(0,i.jsx)(s.em,{children:"float"})," is the ratio of the new size to the old size. As with ",(0,i.jsx)(s.em,{children:"size"}),", the actual size of the increase might be rounded up."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-threshold"})," specifies how full the ",(0,i.jsx)(s.em,{children:"hash-table"})," can get before it must grow. It specifies the maximum desired hash-table occupancy level."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"values"})," of ",(0,i.jsx)(s.em,{children:"rehash-size"})," and ",(0,i.jsx)(s.em,{children:"rehash-threshold"})," do not constrain the ",(0,i.jsx)(s.em,{children:"implementation"})," to use any particular method for computing when and by how much the size of ",(0,i.jsx)(s.em,{children:"hash-table"})," should be enlarged. Such decisions are ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),", and these ",(0,i.jsx)(s.em,{children:"values"})," only hints from the ",(0,i.jsx)(s.em,{children:"programmer"})," to the ",(0,i.jsx)(s.em,{children:"implementation"}),", and the ",(0,i.jsx)(s.em,{children:"implementation"})," is permitted to ignore them."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 46142754>"]}),"\n",(0,i.jsxs)(s.p,{children:['(setf (gethash "one" table) 1) ',(0,i.jsx)(s.em,{children:"\u2192"})," 1"]}),"\n",(0,i.jsxs)(s.p,{children:['(gethash "one" table) ',(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table ",":test"," \u2019equal)) ",(0,i.jsx)(s.em,{children:"\u2192"}),' #<HASH-TABLE EQUAL 0/139 46145547> (setf (gethash "one" table) 1) ',(0,i.jsx)(s.em,{children:"\u2192"})," 1"]}),"\n",(0,i.jsxs)(s.p,{children:['(gethash "one" table) ',(0,i.jsx)(s.em,{children:"\u2192"})," 1, T"]}),"\n",(0,i.jsxs)(s.p,{children:["(make-hash-table ",":rehash-size"," 1.5 ",":rehash-threshold"," 0.7)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 46156620>"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"gethash"}),", ",(0,i.jsx)(s.strong,{children:"hash-table"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-p"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-p"})," ",(0,i.jsx)(s.em,{children:"object \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns ",(0,i.jsx)(s.em,{children:"true"})," if ",(0,i.jsx)(s.em,{children:"object"})," is of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"hash-table"}),"; otherwise, returns ",(0,i.jsx)(s.em,{children:"false"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u20135"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32511220>"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-p table) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-p 37) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-p \u2019((a . 1) (b . 2))) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-p ",(0,i.jsx)(s.em,{children:"object"}),") ",(0,i.jsx)(s.em,{children:"\u2261"})," (typep ",(0,i.jsx)(s.em,{children:"object"})," \u2019hash-table)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-count"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-count"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 count"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"count"}),"\u2014a non-negative ",(0,i.jsx)(s.em,{children:"integer"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns the number of entries in the ",(0,i.jsx)(s.em,{children:"hash-table"}),". If ",(0,i.jsx)(s.em,{children:"hash-table"})," has just been created or newly cleared (see ",(0,i.jsx)(s.strong,{children:"clrhash"}),") the entry count is 0."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32115135>"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0"]}),"\n",(0,i.jsxs)(s.p,{children:['(setf (gethash 57 table) "fifty-seven") ',(0,i.jsx)(s.em,{children:"\u2192"}),' "fifty-seven"']}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 1"]}),"\n",(0,i.jsxs)(s.p,{children:["(dotimes (i 100) (setf (gethash i table) i)) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 100"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"clrhash"}),", ",(0,i.jsx)(s.strong,{children:"remhash"}),", ",(0,i.jsx)(s.strong,{children:"setf"})," of ",(0,i.jsx)(s.strong,{children:"gethash"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"hash-table-size"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["The following relationships are functionally correct, although in practice using ",(0,i.jsx)(s.strong,{children:"hash-table-count"})," is probably much faster:"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count ",(0,i.jsx)(s.em,{children:"table"}),") ",(0,i.jsx)(s.em,{children:"\u2261"})]}),"\n",(0,i.jsxs)(s.p,{children:["(loop for value being the hash-values of ",(0,i.jsx)(s.em,{children:"table"})," count t) ",(0,i.jsx)(s.em,{children:"\u2261"})]}),"\n",(0,i.jsx)(s.p,{children:"(let ((total 0))"}),"\n",(0,i.jsx)(s.p,{children:"(maphash #\u2019(lambda (key value)"}),"\n",(0,i.jsx)(s.p,{children:"(declare (ignore key value))"}),"\n",(0,i.jsx)(s.p,{children:"(incf total))"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"table"}),")"]}),"\n",(0,i.jsx)(s.p,{children:"total)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-rehash-size"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-rehash-size"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 rehash-size"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-size"}),"\u2014a ",(0,i.jsx)(s.em,{children:"real"})," of ",(0,i.jsx)(s.em,{children:"type"})," (or (integer 1 *) (float (1.0) *))."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns the current rehash size of ",(0,i.jsx)(s.em,{children:"hash-table"}),", suitable for use in a call to ",(0,i.jsx)(s.strong,{children:"make-hash-table"})," in order to produce a ",(0,i.jsx)(s.em,{children:"hash table"})," with state corresponding to the current state of the ",(0,i.jsx)(s.em,{children:"hash-table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table ",":size"," 100 ",":rehash-size"," 1.4))"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/100 2556371>"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-rehash-size table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 1.4"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["Should signal an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," if ",(0,i.jsx)(s.em,{children:"hash-table"})," is not a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"make-hash-table"}),", ",(0,i.jsx)(s.strong,{children:"hash-table-rehash-threshold"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["If the hash table was created with an ",(0,i.jsx)(s.em,{children:"integer"})," rehash size, the result is an ",(0,i.jsx)(s.em,{children:"integer"})," , indicating that the rate of growth of the ",(0,i.jsx)(s.em,{children:"hash-table"})," when rehashed is intended to be additive; otherwise, the result"]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u20137"})]}),"\n",(0,i.jsxs)(s.p,{children:["is a ",(0,i.jsx)(s.em,{children:"float"}),", indicating that the rate of growth of the ",(0,i.jsx)(s.em,{children:"hash-table"})," when rehashed is intended to be multiplicative. However, this value is only advice to the ",(0,i.jsx)(s.em,{children:"implementation"}),"; the actual amount by which the ",(0,i.jsx)(s.em,{children:"hash-table"})," will grow upon rehash is ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-rehash-threshold"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-rehash-threshold"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 rehash-threshold"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"rehash-threshold"}),"\u2014a ",(0,i.jsx)(s.em,{children:"real"})," of ",(0,i.jsx)(s.em,{children:"type"})," (real 0 1)."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns the current rehash threshold of ",(0,i.jsx)(s.em,{children:"hash-table"}),", which is suitable for use in a call to ",(0,i.jsx)(s.strong,{children:"make-hash-table"})," in order to produce a ",(0,i.jsx)(s.em,{children:"hash table"})," with state corresponding to the current state of the ",(0,i.jsx)(s.em,{children:"hash-table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table ",":size"," 100 ",":rehash-threshold"," 0.5))"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/100 2562446>"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-rehash-threshold table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0.5"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["Should signal an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," if ",(0,i.jsx)(s.em,{children:"hash-table"})," is not a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"make-hash-table"}),", ",(0,i.jsx)(s.strong,{children:"hash-table-rehash-size"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-size"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-size"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 size"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"size"}),"\u2014a non-negative ",(0,i.jsx)(s.em,{children:"integer"})," ."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns the current size of ",(0,i.jsx)(s.em,{children:"hash-table"}),", which is suitable for use in a call to ",(0,i.jsx)(s.strong,{children:"make-hash-table"})," in order to produce a ",(0,i.jsx)(s.em,{children:"hash table"})," with state corresponding to the current state of the ",(0,i.jsx)(s.em,{children:"hash-table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["Should signal an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," if ",(0,i.jsx)(s.em,{children:"hash-table"})," is not a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-count"}),", ",(0,i.jsx)(s.strong,{children:"make-hash-table"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-test"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"hash-table-test"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 test"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"test"}),"\u2014a ",(0,i.jsx)(s.em,{children:"function designator"})," . For the four ",(0,i.jsx)(s.em,{children:"standardized hash table"})," test ",(0,i.jsx)(s.em,{children:"functions"})," (see ",(0,i.jsx)(s.strong,{children:"make-hash-table"}),"), the ",(0,i.jsx)(s.em,{children:"test"})," value returned is always a ",(0,i.jsx)(s.em,{children:"symbol"}),". If an ",(0,i.jsx)(s.em,{children:"implementation"})," per mits additional tests, it is ",(0,i.jsx)(s.em,{children:"implementation-dependent"})," whether such tests are returned as ",(0,i.jsx)(s.em,{children:"function objects"})," or ",(0,i.jsx)(s.em,{children:"function names"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns the test used for comparing ",(0,i.jsx)(s.em,{children:"keys"})," in ",(0,i.jsx)(s.em,{children:"hash-table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["Should signal an error of ",(0,i.jsx)(s.em,{children:"type"})," ",(0,i.jsx)(s.strong,{children:"type-error"})," if ",(0,i.jsx)(s.em,{children:"hash-table"})," is not a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"make-hash-table"})}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u20139"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"gethash"})," ",(0,i.jsx)(s.em,{children:"Accessor"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"gethash"})," ",(0,i.jsx)(s.em,{children:"key hash-table"})," &optional ",(0,i.jsx)(s.em,{children:"default \u2192 value, present-p"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"(setf (gethash"})," ",(0,i.jsx)(s.em,{children:"key hash-table"})," &optional ",(0,i.jsx)(s.em,{children:"default"}),"**)** ",(0,i.jsx)(s.em,{children:"new-value"}),"**)**"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"key"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"default"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),". The default is ",(0,i.jsx)(s.strong,{children:"nil"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"value"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"present-p"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Value"})," is the ",(0,i.jsx)(s.em,{children:"object"})," in ",(0,i.jsx)(s.em,{children:"hash-table"})," whose ",(0,i.jsx)(s.em,{children:"key"})," is the ",(0,i.jsx)(s.em,{children:"same"})," as ",(0,i.jsx)(s.em,{children:"key"})," under the ",(0,i.jsx)(s.em,{children:"hash-table"}),"\u2019s equivalence test. If there is no such entry, ",(0,i.jsx)(s.em,{children:"value"})," is the ",(0,i.jsx)(s.em,{children:"default"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"Present-p"})," is ",(0,i.jsx)(s.em,{children:"true"})," if an entry is found; otherwise, it is ",(0,i.jsx)(s.em,{children:"false"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"setf"})," may be used with ",(0,i.jsx)(s.strong,{children:"gethash"})," to modify the ",(0,i.jsx)(s.em,{children:"value"})," associated with a given ",(0,i.jsx)(s.em,{children:"key"}),", or to add a new entry. When a ",(0,i.jsx)(s.strong,{children:"gethash"})," ",(0,i.jsx)(s.em,{children:"form"})," is used as a ",(0,i.jsx)(s.strong,{children:"setf"})," ",(0,i.jsx)(s.em,{children:"place"}),", any ",(0,i.jsx)(s.em,{children:"default"})," which is supplied is evaluated according to normal left-to-right evaluation rules, but its ",(0,i.jsx)(s.em,{children:"value"})," is ignored."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32206334>"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 1 table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 1 table 2) ",(0,i.jsx)(s.em,{children:"\u2192"})," 2, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:['(setf (gethash 1 table) "one") ',(0,i.jsx)(s.em,{children:"\u2192"}),' "one"']}),"\n",(0,i.jsxs)(s.p,{children:['(setf (gethash 2 table "two") "two") ',(0,i.jsx)(s.em,{children:"\u2192"}),' "two"']}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 1 table) ",(0,i.jsx)(s.em,{children:"\u2192"}),' "one", ',(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 2 table) ",(0,i.jsx)(s.em,{children:"\u2192"}),' "two", ',(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash nil table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(setf (gethash nil table) nil) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash nil table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(defvar *counters* (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," *COUNTERS*"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash \u2019foo *counters*) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash \u2019foo *counters* 0) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(defmacro how-many (obj) \u2018(values (gethash ,obj *counters* 0))) ",(0,i.jsx)(s.em,{children:"\u2192"})," HOW-MANY"]}),"\n",(0,i.jsxs)(s.p,{children:["(defun count-it (obj) (incf (how-many obj))) ",(0,i.jsx)(s.em,{children:"\u2192"})," COUNT-IT"]}),"\n",(0,i.jsx)(s.p,{children:"(dolist (x \u2019(bar foo foo bar bar baz)) (count-it x))"}),"\n",(0,i.jsxs)(s.p,{children:["(how-many \u2019foo) ",(0,i.jsx)(s.em,{children:"\u2192"})," 2"]}),"\n",(0,i.jsxs)(s.p,{children:["(how-many \u2019bar) ",(0,i.jsx)(s.em,{children:"\u2192"})," 3"]}),"\n",(0,i.jsxs)(s.p,{children:["(how-many \u2019quux) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"remhash"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"secondary value"}),", ",(0,i.jsx)(s.em,{children:"present-p"}),", can be used to distinguish the absence of an entry from the presence of an entry that has a value of ",(0,i.jsx)(s.em,{children:"default"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"remhash"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"remhash"})," ",(0,i.jsx)(s.em,{children:"key hash-table \u2192 generalized-boolean"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"key"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"generalized-boolean"}),"\u2014a ",(0,i.jsx)(s.em,{children:"generalized boolean"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Removes the entry for ",(0,i.jsx)(s.em,{children:"key"})," in ",(0,i.jsx)(s.em,{children:"hash-table"}),", if any. Returns ",(0,i.jsx)(s.em,{children:"true"})," if there was such an entry, or ",(0,i.jsx)(s.em,{children:"false"})," otherwise."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32115666>"]}),"\n",(0,i.jsxs)(s.p,{children:['(setf (gethash 100 table) "C") ',(0,i.jsx)(s.em,{children:"\u2192"}),' "C"']}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 100 table) ",(0,i.jsx)(s.em,{children:"\u2192"}),' "C", ',(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(remhash 100 table) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 100 table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsxs)(s.p,{children:["(remhash 100 table) ",(0,i.jsx)(s.em,{children:"\u2192 false"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Side Effects:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"hash-table"})," is modified."]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u201311"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"maphash"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"maphash"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"maphash"})," ",(0,i.jsx)(s.em,{children:"function hash-table \u2192"})," ",(0,i.jsx)(s.strong,{children:"nil"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"function"}),"\u2014a ",(0,i.jsx)(s.em,{children:"designator"})," for a ",(0,i.jsx)(s.em,{children:"function"})," of two ",(0,i.jsx)(s.em,{children:"arguments"}),", the ",(0,i.jsx)(s.em,{children:"key"})," and the ",(0,i.jsx)(s.em,{children:"value"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Iterates over all entries in the ",(0,i.jsx)(s.em,{children:"hash-table"}),". For each entry, the ",(0,i.jsx)(s.em,{children:"function"})," is called with two ",(0,i.jsx)(s.em,{children:"arguments"}),"\u2013the ",(0,i.jsx)(s.em,{children:"key"})," and the ",(0,i.jsx)(s.em,{children:"value"})," of that entry."]}),"\n",(0,i.jsxs)(s.p,{children:["The consequences are unspecified if any attempt is made to add or remove an entry from the ",(0,i.jsx)(s.em,{children:"hash-table"})," while a ",(0,i.jsx)(s.strong,{children:"maphash"})," is in progress, with two exceptions: the ",(0,i.jsx)(s.em,{children:"function"})," can use can use ",(0,i.jsx)(s.strong,{children:"setf"})," of ",(0,i.jsx)(s.strong,{children:"gethash"})," to change the ",(0,i.jsx)(s.em,{children:"value"})," part of the entry currently being processed, or it can use ",(0,i.jsx)(s.strong,{children:"remhash"})," to remove that entry."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32304110>"]}),"\n",(0,i.jsxs)(s.p,{children:["(dotimes (i 10) (setf (gethash i table) i)) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsx)(s.p,{children:"(let ((sum-of-squares 0))"}),"\n",(0,i.jsx)(s.p,{children:"(maphash #\u2019(lambda (key val)"}),"\n",(0,i.jsx)(s.p,{children:"(let ((square (* val val)))"}),"\n",(0,i.jsx)(s.p,{children:"(incf sum-of-squares square)"}),"\n",(0,i.jsx)(s.p,{children:"(setf (gethash key table) square)))"}),"\n",(0,i.jsx)(s.p,{children:"table)"}),"\n",(0,i.jsxs)(s.p,{children:["sum-of-squares) ",(0,i.jsx)(s.em,{children:"\u2192"})," 285"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 10"]}),"\n",(0,i.jsx)(s.p,{children:"(maphash #\u2019(lambda (key val)"}),"\n",(0,i.jsx)(s.p,{children:"(when (oddp val) (remhash key table)))"}),"\n",(0,i.jsxs)(s.p,{children:["table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 5"]}),"\n",(0,i.jsx)(s.p,{children:"(maphash #\u2019(lambda (k v) (print (list k v))) table)"}),"\n",(0,i.jsx)(s.p,{children:"(0 0)"}),"\n",(0,i.jsx)(s.p,{children:"(8 64)"}),"\n",(0,i.jsx)(s.p,{children:"(2 4)"}),"\n",(0,i.jsx)(s.p,{children:"(6 36)"}),"\n",(0,i.jsx)(s.p,{children:"(4 16)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Side Effects:"})}),"\n",(0,i.jsxs)(s.p,{children:["None, other than any which might be done by the ",(0,i.jsx)(s.em,{children:"function"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"loop"}),", ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"}),", Section 3.6 (Traversal Rules and Side Effects)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," ",(0,i.jsx)(s.em,{children:"Macro"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," (",(0,i.jsx)(s.em,{children:"name hash-table"}),") ",(0,i.jsx)(s.em,{children:"{declaration}"}),"* ",(0,i.jsx)(s.em,{children:"{form}"}),"* ",(0,i.jsx)(s.em,{children:"\u2192 {result}"}),"*"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"name"}),"\u2014a name suitable for the first argument to ",(0,i.jsx)(s.strong,{children:"macrolet"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"form"}),", evaluated once, that should produce a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"declaration"}),"\u2014a ",(0,i.jsx)(s.strong,{children:"declare"})," ",(0,i.jsx)(s.em,{children:"expression"}),"; not evaluated."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"forms"}),"\u2014an ",(0,i.jsx)(s.em,{children:"implicit progn"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"results"}),"\u2014the ",(0,i.jsx)(s.em,{children:"values"})," returned by ",(0,i.jsx)(s.em,{children:"forms"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Within the lexical scope of the body, ",(0,i.jsx)(s.em,{children:"name"})," is defined via ",(0,i.jsx)(s.strong,{children:"macrolet"})," such that successive invocations of (",(0,i.jsx)(s.em,{children:"name"}),") return the items, one by one, from the ",(0,i.jsx)(s.em,{children:"hash table"})," that is obtained by evaluating ",(0,i.jsx)(s.em,{children:"hash-table"})," only once."]}),"\n",(0,i.jsxs)(s.p,{children:["An invocation (",(0,i.jsx)(s.em,{children:"name"}),") returns three values as follows:"]}),"\n",(0,i.jsxs)(s.p,{children:["1. A ",(0,i.jsx)(s.em,{children:"generalized boolean"})," that is ",(0,i.jsx)(s.em,{children:"true"})," if an entry is returned."]}),"\n",(0,i.jsxs)(s.p,{children:["2. The key from the ",(0,i.jsx)(s.em,{children:"hash-table"})," entry."]}),"\n",(0,i.jsxs)(s.p,{children:["3. The value from the ",(0,i.jsx)(s.em,{children:"hash-table"})," entry."]}),"\n",(0,i.jsxs)(s.p,{children:["After all entries have been returned by successive invocations of (",(0,i.jsx)(s.em,{children:"name"}),"), then only one value is returned, namely ",(0,i.jsx)(s.strong,{children:"nil"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," ",(0,i.jsx)(s.em,{children:"form"})," such as by returning some ",(0,i.jsx)(s.em,{children:"closure"})," over the invocation ",(0,i.jsx)(s.em,{children:"form"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Any number of invocations of ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," can be nested, and the body of the innermost one can invoke all of the locally ",(0,i.jsx)(s.em,{children:"established macros"}),", provided all of those ",(0,i.jsx)(s.em,{children:"macros"})," have ",(0,i.jsx)(s.em,{children:"distinct"})," names."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["The following function should return ",(0,i.jsx)(s.strong,{children:"t"})," on any ",(0,i.jsx)(s.em,{children:"hash table"}),", and signal an error if the usage of ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," does not agree with the corresponding usage of ",(0,i.jsx)(s.strong,{children:"maphash"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u201313"})]}),"\n",(0,i.jsx)(s.p,{children:"(defun test-hash-table-iterator (hash-table)"}),"\n",(0,i.jsx)(s.p,{children:"(let ((all-entries \u2019())"}),"\n",(0,i.jsx)(s.p,{children:"(generated-entries \u2019())"}),"\n",(0,i.jsx)(s.p,{children:"(unique (list nil)))"}),"\n",(0,i.jsx)(s.p,{children:"(maphash #\u2019(lambda (key value) (push (list key value) all-entries))"}),"\n",(0,i.jsx)(s.p,{children:"hash-table)"}),"\n",(0,i.jsx)(s.p,{children:"(with-hash-table-iterator (generator-fn hash-table)"}),"\n",(0,i.jsx)(s.p,{children:"(loop"}),"\n",(0,i.jsx)(s.p,{children:"(multiple-value-bind (more? key value) (generator-fn)"}),"\n",(0,i.jsx)(s.p,{children:"(unless more? (return))"}),"\n",(0,i.jsx)(s.p,{children:"(unless (eql value (gethash key hash-table unique))"}),"\n",(0,i.jsx)(s.p,{children:'(error "Key ~S not found for value ~S" key value))'}),"\n",(0,i.jsx)(s.p,{children:"(push (list key value) generated-entries))))"}),"\n",(0,i.jsx)(s.p,{children:"(unless (= (length all-entries)"}),"\n",(0,i.jsx)(s.p,{children:"(length generated-entries)"}),"\n",(0,i.jsx)(s.p,{children:"(length (union all-entries generated-entries"}),"\n",(0,i.jsxs)(s.p,{children:[":key"," #\u2019car ",":test"," (hash-table-test hash-table))))"]}),"\n",(0,i.jsx)(s.p,{children:'(error "Generated entries and Maphash entries don\u2019t correspond"))'}),"\n",(0,i.jsx)(s.p,{children:"t))"}),"\n",(0,i.jsxs)(s.p,{children:["The following could be an acceptable definition of ",(0,i.jsx)(s.strong,{children:"maphash"}),", implemented by ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"(defun maphash (function hash-table)"}),"\n",(0,i.jsx)(s.p,{children:"(with-hash-table-iterator (next-entry hash-table)"}),"\n",(0,i.jsx)(s.p,{children:"(loop (multiple-value-bind (more key value) (next-entry)"}),"\n",(0,i.jsx)(s.p,{children:"(unless more (return nil))"}),"\n",(0,i.jsx)(s.p,{children:"(funcall function key value)))))"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Exceptional Situations:"})}),"\n",(0,i.jsxs)(s.p,{children:["The consequences are undefined if the local function named ",(0,i.jsx)(s.em,{children:"name established"})," by ",(0,i.jsx)(s.strong,{children:"with-hash-table-iterator"})," is called after it has returned ",(0,i.jsx)(s.em,{children:"false"})," as its ",(0,i.jsx)(s.em,{children:"primary value"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"See Also:"})}),"\n",(0,i.jsx)(s.p,{children:"Section 3.6 (Traversal Rules and Side Effects)"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"clrhash"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"clrhash"})," ",(0,i.jsx)(s.em,{children:"hash-table \u2192 hash-table"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-table"}),"\u2014a ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Removes all entries from ",(0,i.jsx)(s.em,{children:"hash-table"}),", and then returns that empty ",(0,i.jsx)(s.em,{children:"hash table"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Examples:"})}),"\n",(0,i.jsxs)(s.p,{children:["(setq table (make-hash-table)) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32004073>"]}),"\n",(0,i.jsxs)(s.p,{children:['(dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) ',(0,i.jsx)(s.em,{children:"\u2192"})," NIL"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 100"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 57 table) ",(0,i.jsx)(s.em,{children:"\u2192"}),' "fifty-seven", ',(0,i.jsx)(s.em,{children:"true"})]}),"\n",(0,i.jsxs)(s.p,{children:["(clrhash table) ",(0,i.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32004073>"]}),"\n",(0,i.jsxs)(s.p,{children:["(hash-table-count table) ",(0,i.jsx)(s.em,{children:"\u2192"})," 0"]}),"\n",(0,i.jsxs)(s.p,{children:["(gethash 57 table) ",(0,i.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,i.jsx)(s.em,{children:"false"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Side Effects:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"hash-table"})," is modified."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"sxhash"})," ",(0,i.jsx)(s.em,{children:"Function"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Syntax:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"sxhash"})," ",(0,i.jsx)(s.em,{children:"object \u2192 hash-code"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Arguments and Values:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"object"}),"\u2014an ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"hash-code"}),"\u2014a non-negative ",(0,i.jsx)(s.em,{children:"fixnum"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"sxhash"})," returns a hash code for ",(0,i.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The manner in which the hash code is computed is ",(0,i.jsx)(s.em,{children:"implementation-dependent"}),", but subject to certain constraints:"]}),"\n",(0,i.jsxs)(s.p,{children:["1. (equal ",(0,i.jsx)(s.em,{children:"x y"}),") implies (= (sxhash ",(0,i.jsx)(s.em,{children:"x"}),") (sxhash ",(0,i.jsx)(s.em,{children:"y"}),"))."]}),"\n",(0,i.jsxs)(s.p,{children:["2. For any two ",(0,i.jsx)(s.em,{children:"objects"}),", ",(0,i.jsx)(s.em,{children:"x"})," and ",(0,i.jsx)(s.em,{children:"y"}),", both of which are ",(0,i.jsx)(s.em,{children:"bit vectors"}),", ",(0,i.jsx)(s.em,{children:"characters"}),", ",(0,i.jsx)(s.em,{children:"conses"}),", ",(0,i.jsx)(s.em,{children:"numbers"}),", ",(0,i.jsx)(s.em,{children:"pathnames"}),", ",(0,i.jsx)(s.em,{children:"strings"}),", or ",(0,i.jsx)(s.em,{children:"symbols"}),", and which are ",(0,i.jsx)(s.em,{children:"similar"})," , (sxhash ",(0,i.jsx)(s.em,{children:"x"}),") and (sxhash ",(0,i.jsx)(s.em,{children:"y"}),") ",(0,i.jsx)(s.em,{children:"yield"})," the same mathematical value even if ",(0,i.jsx)(s.em,{children:"x"})," and ",(0,i.jsx)(s.em,{children:"y"})," exist in different ",(0,i.jsx)(s.em,{children:"Lisp images"})," of the same ",(0,i.jsx)(s.em,{children:"implementation"}),". See Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,i.jsxs)(s.p,{children:["3. The ",(0,i.jsx)(s.em,{children:"hash-code"})," for an ",(0,i.jsx)(s.em,{children:"object"})," is always the ",(0,i.jsx)(s.em,{children:"same"})," within a single ",(0,i.jsx)(s.em,{children:"session"})," provided that the ",(0,i.jsx)(s.em,{children:"object"})," is not visibly modified with regard to the equivalence test ",(0,i.jsx)(s.strong,{children:"equal"}),". See Section 18.1.2 (Modifying Hash Table Keys)."]}),"\n",(0,i.jsxs)(s.p,{children:["Hash Tables ",(0,i.jsx)(s.strong,{children:"18\u201315"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"sxhash"})}),"\n",(0,i.jsxs)(s.p,{children:["4. The ",(0,i.jsx)(s.em,{children:"hash-code"})," is intended for hashing. This places no verifiable constraint on a ",(0,i.jsx)(s.em,{children:"conforming implementation"}),", but the intent is that an ",(0,i.jsx)(s.em,{children:"implementation"})," should make a good-faith effort to produce ",(0,i.jsx)(s.em,{children:"hash-codes"})," that are well distributed within the range of non-negative ",(0,i.jsx)(s.em,{children:"fixnums"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["5. Computation of the ",(0,i.jsx)(s.em,{children:"hash-code"})," must terminate, even if the ",(0,i.jsx)(s.em,{children:"object"})," contains circularities. ",(0,i.jsx)(s.strong,{children:"Examples:"})]}),"\n",(0,i.jsxs)(s.p,{children:['(= (sxhash (list \u2019list "ab")) (sxhash (list \u2019list "ab"))) ',(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsxs)(s.p,{children:['(= (sxhash "a") (sxhash (make-string 1 ',":initial-element"," #\\a))) ",(0,i.jsx)(s.em,{children:"\u2192 true"})]}),"\n",(0,i.jsx)(s.p,{children:"(let ((r (make-random-state)))"}),"\n",(0,i.jsx)(s.p,{children:"(= (sxhash r) (sxhash (make-random-state r))))"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:"\u2192 implementation-dependent"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Affected By:"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.em,{children:"implementation"}),"."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(s.p,{children:["Many common hashing needs are satisfied by ",(0,i.jsx)(s.strong,{children:"make-hash-table"})," and the related functions on ",(0,i.jsx)(s.em,{children:"hash tables"}),". ",(0,i.jsx)(s.strong,{children:"sxhash"})," is intended for use where the pre-defined abstractions are insufficient. Its main intent is to allow the user a convenient means of implementing more complicated hashing paradigms than are provided through ",(0,i.jsx)(s.em,{children:"hash tables"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The hash codes returned by ",(0,i.jsx)(s.strong,{children:"sxhash"})," are not necessarily related to any hashing strategy used by any other ",(0,i.jsx)(s.em,{children:"function"})," in Common Lisp."]}),"\n",(0,i.jsxs)(s.p,{children:["For ",(0,i.jsx)(s.em,{children:"objects"})," of ",(0,i.jsx)(s.em,{children:"types"})," that ",(0,i.jsx)(s.strong,{children:"equal"})," compares with ",(0,i.jsx)(s.strong,{children:"eq"}),", item 3 requires that the ",(0,i.jsx)(s.em,{children:"hash-code"})," be based on some immutable quality of the identity of the object. Another legitimate implementation technique would be to have ",(0,i.jsx)(s.strong,{children:"sxhash"})," assign (and cache) a random hash code for these ",(0,i.jsx)(s.em,{children:"objects"}),", since there is no requirement that ",(0,i.jsx)(s.em,{children:"similar"})," but non-",(0,i.jsx)(s.strong,{children:"eq"})," objects have the same hash code."]}),"\n",(0,i.jsxs)(s.p,{children:["Although ",(0,i.jsx)(s.em,{children:"similarity"})," is defined for ",(0,i.jsx)(s.em,{children:"symbols"})," in terms of both the ",(0,i.jsx)(s.em,{children:"symbol"}),"\u2019s ",(0,i.jsx)(s.em,{children:"name"})," and the ",(0,i.jsx)(s.em,{children:"packages"})," in which the ",(0,i.jsx)(s.em,{children:"symbol"})," is ",(0,i.jsx)(s.em,{children:"accessible"}),", item 3 disallows using ",(0,i.jsx)(s.em,{children:"package"})," information to compute the hash code, since changes to the package status of a symbol are not visible to ",(0,i.jsx)(s.em,{children:"equal"}),"."]})]})}function L(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(T,{...e})}):T(e)}const S={title:"18.1 Hash Table Concepts"},H="18.1 Hash Table Concepts",V={id:"chap-18/bi-b-hash-table-concepts",title:"18.1 Hash Table Concepts",description:"18.1.1 Hash",source:"@site/docs/chap-18/bi-b-hash-table-concepts.md",sourceDirName:"chap-18",slug:"/chap-18/bi-b-hash-table-concepts",permalink:"/cl-language-reference/docs/chap-18/bi-b-hash-table-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chap-18/bi-b-hash-table-concepts.md",tags:[],version:"current",frontMatter:{title:"18.1 Hash Table Concepts"},sidebar:"tutorialSidebar",previous:{title:"18. Hash Tables",permalink:"/cl-language-reference/docs/category/18-hash-tables"},next:{title:"intro",permalink:"/cl-language-reference/docs/chap-18/intro"}},z={},Q=[{value:"18.1.1 Hash",id:"1811-hash",level:2},{value:"18.1.2 Modifying Hash Table Keys",id:"1812-modifying-hash-table-keys",level:2},{value:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL",id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",level:3},{value:"18.1.2.2 Visible Modification of Objects with respect to EQUAL",id:"18122-visible-modification-of-objects-with-respect-to-equal",level:3},{value:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL",id:"181221-visible-modification-of-conses-with-respect-to-equal",level:4},{value:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL",id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",level:4},{value:"18.1.2.3 Visible Modification of Objects with respect to EQUALP",id:"18123-visible-modification-of-objects-with-respect-to-equalp",level:3},{value:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP",id:"181231-visible-modification-of-structures-with-respect-to-equalp",level:4},{value:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP",id:"181232-visible-modification-of-arrays-with-respect-to-equalp",level:4},{value:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP",id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",level:4},{value:"18.1.2.4 Visible Modifications by Language Extensions",id:"18124-visible-modifications-by-language-extensions",level:3}];function M(e){const s={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,h.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"181-hash-table-concepts",children:"18.1 Hash Table Concepts"}),"\n","\n",(0,i.jsx)(t,{}),"\n",(0,i.jsx)(s.h2,{id:"1811-hash",children:"18.1.1 Hash"}),"\n","\n",(0,i.jsx)(a,{}),"\n",(0,i.jsx)(s.h2,{id:"1812-modifying-hash-table-keys",children:"18.1.2 Modifying Hash Table Keys"}),"\n","\n",(0,i.jsx)(d,{}),"\n",(0,i.jsx)(s.h3,{id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"}),"\n","\n",(0,i.jsx)(x,{}),"\n",(0,i.jsx)(s.h3,{id:"18122-visible-modification-of-objects-with-respect-to-equal",children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"}),"\n","\n",(0,i.jsx)(m,{}),"\n",(0,i.jsx)(s.h4,{id:"181221-visible-modification-of-conses-with-respect-to-equal",children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"}),"\n","\n",(0,i.jsx)(b,{}),"\n",(0,i.jsx)(s.h4,{id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"}),"\n","\n",(0,i.jsx)(f,{}),"\n",(0,i.jsx)(s.h3,{id:"18123-visible-modification-of-objects-with-respect-to-equalp",children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"}),"\n","\n",(0,i.jsx)(y,{}),"\n",(0,i.jsx)(s.h4,{id:"181231-visible-modification-of-structures-with-respect-to-equalp",children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"}),"\n","\n",(0,i.jsx)(w,{}),"\n",(0,i.jsx)(s.h4,{id:"181232-visible-modification-of-arrays-with-respect-to-equalp",children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"}),"\n","\n",(0,i.jsx)(A,{}),"\n",(0,i.jsx)(s.h4,{id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"}),"\n","\n",(0,i.jsx)(E,{}),"\n",(0,i.jsx)(s.h3,{id:"18124-visible-modifications-by-language-extensions",children:"18.1.2.4 Visible Modifications by Language Extensions"}),"\n","\n","\n",(0,i.jsx)(L,{})]})}function F(e={}){const{wrapper:s}={...(0,h.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(M,{...e})}):M(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>l,a:()=>t});var i=n(7294);const h={},r=i.createContext(h);function t(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(h):e.components||h:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);