"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[25527],{28453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>a});var t=n(96540);const s={},i=t.createContext(s);function c(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:r},e.children)}},57504:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>E,contentTitle:()=>v,default:()=>S,frontMatter:()=>R,metadata:()=>t,toc:()=>A});const t=JSON.parse('{"id":"chap-23/cd-b-reader-concepts","title":"23.1 Reader Concepts","description":"23.1.1 Dynamic Control of the Lisp Reader","source":"@site/docs/chap-23/cd-b-reader-concepts.md","sourceDirName":"chap-23","slug":"/chap-23/cd-b-reader-concepts","permalink":"/cl-language-reference/chap-23/cd-b-reader-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-23/cd-b-reader-concepts.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"23.1 Reader Concepts"},"sidebar":"tutorialSidebar","previous":{"title":"intro","permalink":"/cl-language-reference/chap-22/intro"},"next":{"title":"23.2 Reader Dictionary","permalink":"/cl-language-reference/category/232-reader-dictionary"}}');var s=n(74848),i=n(28453);function c(e){return(0,s.jsx)(s.Fragment,{})}function a(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c()}function d(e){const r={em:"em",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(r.p,{children:["Various aspects of the ",(0,s.jsx)(r.em,{children:"Lisp reader"})," can be controlled dynamically. See Section 2.1.1 (Readtables) and Section 2.1.2 (Variables that affect the Lisp Reader)."]})}function l(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function o(e){const r={em:"em",p:"p",...(0,i.R)(),...e.components},{GlossaryTerm:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(n,{styled:!0,term:"readtable case",children:(0,s.jsx)("i",{children:"readtable case"})})," of the ",(0,s.jsx)(n,{styled:!0,term:"current readtable",children:(0,s.jsx)("i",{children:"current readtable"})})," affects the ",(0,s.jsx)(r.em,{children:"Lisp reader"})," in the following ways: ",":upcase"]}),"\n",(0,s.jsxs)(r.p,{children:["When the ",(0,s.jsx)(n,{styled:!0,term:"readtable case",children:(0,s.jsx)("i",{children:"readtable case"})})," is ",":upcase",", unescaped constituent ",(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"characters"})})," are converted to ",(0,s.jsx)(n,{styled:!0,term:"uppercase",children:(0,s.jsx)("i",{children:"uppercase"})}),", as specified in Section 2.2 (Reader Algorithm)."]}),"\n",(0,s.jsx)(r.p,{children:":downcase"}),"\n",(0,s.jsxs)(r.p,{children:["When the ",(0,s.jsx)(n,{styled:!0,term:"readtable case",children:(0,s.jsx)("i",{children:"readtable case"})})," is ",":downcase",", unescaped constituent ",(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"characters"})})," are converted to ",(0,s.jsx)(n,{styled:!0,term:"lowercase",children:(0,s.jsx)("i",{children:"lowercase"})}),"."]}),"\n",(0,s.jsx)(r.p,{children:":preserve"}),"\n",(0,s.jsxs)(r.p,{children:["When the ",(0,s.jsx)(n,{styled:!0,term:"readtable case",children:(0,s.jsx)("i",{children:"readtable case"})})," is ",":preserve",", the case of all ",(0,s.jsx)(n,{styled:!0,term:"character",children:(0,s.jsx)("i",{children:"characters"})})," remains unchanged."]}),"\n",(0,s.jsx)(r.p,{children:":invert"}),"\n",(0,s.jsxs)(r.p,{children:["When the ",(0,s.jsx)(n,{styled:!0,term:"readtable case",children:(0,s.jsx)("i",{children:"readtable case"})})," is ",":invert",", then if all of the unescaped letters in the extended token are of the same ",(0,s.jsx)(n,{styled:!0,term:"case",children:(0,s.jsx)("i",{children:"case"})}),", those (unescaped) letters are converted to the opposite ",(0,s.jsx)(n,{styled:!0,term:"case",children:(0,s.jsx)("i",{children:"case"})}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function p(e){const r={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lisp",children:'(defun test-readtable-case-reading () \n  (let ((\\*readtable\\* (copy-readtable nil))) \n    (format t "READTABLE-CASE Input Symbol-name~ \n~%\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-~ \n~%") \n    (dolist (readtable-case \u2019(:upcase :downcase :preserve :invert)) \n      (setf (readtable-case \\*readtable\\*) readtable-case) \n      (dolist (input \u2019("ZEBRA" "Zebra" "zebra")) \n\t(format t "~&:~A~16T~A~24T~A" \n\t\t(string-upcase readtable-case) \n\t\tinput \n\t\t(symbol-name (read-from-string input))))))) \n\nThe output from (test-readtable-case-reading) should be as follows: \nREADTABLE-CASE Input Symbol-name \n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013- \n:UPCASE ZEBRA ZEBRA \n:UPCASE Zebra ZEBRA \n:UPCASE zebra ZEBRA \n:DOWNCASE ZEBRA zebra \n:DOWNCASE Zebra zebra \n:DOWNCASE zebra zebra \n:PRESERVE ZEBRA ZEBRA \n:PRESERVE Zebra Zebra \n:PRESERVE zebra zebra \n:INVERT ZEBRA zebra \n:INVERT Zebra Zebra \n:INVERT zebra ZEBRA \n'})})}function x(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}function m(e){return(0,s.jsx)(s.Fragment,{})}function j(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(m,{...e})}):m()}function f(e){const r={em:"em",p:"p",...(0,i.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||b("DictionaryLink",!0),t||b("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"Eof-error-p"})," in input function calls controls what happens if input is from a file (or any other input source that has a definite end) and the end of the file is reached. If ",(0,s.jsx)(r.em,{children:"eof-error-p"})," is ",(0,s.jsx)(t,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})})," (the default), an error of ",(0,s.jsx)(t,{styled:!0,term:"type",children:(0,s.jsx)("i",{children:"type"})})," ",(0,s.jsx)(n,{styled:!0,term:"end-of-file",children:(0,s.jsx)("b",{children:"end-of-file"})})," is signaled at end of file. If it is ",(0,s.jsx)(t,{styled:!0,term:"false",children:(0,s.jsx)("i",{children:"false"})}),", then no error is signaled, and instead the function returns ",(0,s.jsx)(r.em,{children:"eof-value"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Functions such as ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," that read the representation of an ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})})," rather than a single character always signals an error, regardless of ",(0,s.jsx)(r.em,{children:"eof-error-p"}),", if the file ends in the middle of an object representation. For example, if a file does not contain enough right parentheses to balance the left parentheses in it, ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," signals an error. If a file ends in a ",(0,s.jsx)(t,{styled:!0,term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," or a ",(0,s.jsx)(t,{styled:!0,term:"number",children:(0,s.jsx)("i",{children:"number"})})," immediately followed by end-of-file, ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," reads the ",(0,s.jsx)(t,{styled:!0,term:"symbol",children:(0,s.jsx)("i",{children:"symbol"})})," or ",(0,s.jsx)(t,{styled:!0,term:"number",children:(0,s.jsx)("i",{children:"number"})})," successfully and when called again will act according to ",(0,s.jsx)(r.em,{children:"eof-error-p"}),". Similarly, the ",(0,s.jsx)(t,{styled:!0,term:"function",children:(0,s.jsx)("i",{children:"function"})})," ",(0,s.jsx)(n,{styled:!0,term:"read-line",children:(0,s.jsx)("b",{children:"read-line"})})," successfully reads the last line of a file even if that line is terminated by end-of-file rather than the newline character. Ignorable text, such as lines containing only ",(0,s.jsx)(t,{styled:!0,term:"whitespace",children:(0,s.jsx)("i",{children:"whitespace"})}),(0,s.jsx)("sub",{children:"2"})," or comments, are not considered to begin an ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),"; if ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," begins to read an ",(0,s.jsx)(t,{styled:!0,term:"expression",children:(0,s.jsx)("i",{children:"expression"})})," but sees only such ignorable text, it does not consider the file to end in the middle of an ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"object"})}),". Thus an ",(0,s.jsx)(r.em,{children:"eof-error-p"})," argument controls what happens when the file ends between ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})}),"."]})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}function b(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function y(e){const r={em:"em",p:"p",...(0,i.R)(),...e.components},{DictionaryLink:n,GlossaryTerm:t}=r;return n||w("DictionaryLink",!0),t||w("GlossaryTerm",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["If ",(0,s.jsx)(r.em,{children:"recursive-p"})," is supplied and not ",(0,s.jsx)(n,{styled:!0,term:"nil",children:(0,s.jsx)("b",{children:"nil"})}),", it specifies that this function call is not an outermost call to ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," but an embedded call, typically from a ",(0,s.jsx)(t,{styled:!0,term:"reader macro function",children:(0,s.jsx)("i",{children:"reader macro function"})}),". It is important to distinguish such recursive calls for three reasons."]}),"\n",(0,s.jsxs)(r.p,{children:["1. An outermost call establishes the context within which the #",(0,s.jsx)(r.em,{children:"n"}),"= and #",(0,s.jsx)(r.em,{children:"n"}),"# syntax is scoped. Consider, for example, the expression"]}),"\n",(0,s.jsx)(r.p,{children:"(cons \u2019#3=(p q r) \u2019(x y . #3#))"}),"\n",(0,s.jsxs)(r.p,{children:["If the ",(0,s.jsx)(r.em,{children:"single-quote reader macro"})," were defined in this way:"]}),"\n",(0,s.jsx)(r.p,{children:"(set-macro-character #\\\u2019 ;incorrect"}),"\n",(0,s.jsx)(r.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,s.jsx)(r.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(r.p,{children:"(list \u2019quote (read stream))))"}),"\n",(0,s.jsxs)(r.p,{children:["then each call to the ",(0,s.jsx)(r.em,{children:"single-quote reader macro function"})," would establish independent contexts for the scope of ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," information, including the scope of identifications between markers like \u201c#3=\u201d and \u201c#3#\u201d. However, for this expression, the scope was clearly intended to be determined by the outer set of parentheses, so such a definition would be incorrect. The correct way to define the ",(0,s.jsx)(r.em,{children:"single-quote reader macro"})," uses ",(0,s.jsx)(r.em,{children:"recursive-p"}),":"]}),"\n",(0,s.jsx)(r.p,{children:"(set-macro-character #\\\u2019 ;correct"}),"\n",(0,s.jsx)(r.p,{children:"#\u2019(lambda (stream char)"}),"\n",(0,s.jsx)(r.p,{children:"(declare (ignore char))"}),"\n",(0,s.jsx)(r.p,{children:"(list \u2019quote (read stream t nil t))))"}),"\n",(0,s.jsxs)(r.p,{children:["2. A recursive call does not alter whether the reading process is to preserve ",(0,s.jsx)(t,{styled:!0,term:"whitespace",children:(0,s.jsx)("i",{children:"whitespace"})}),(0,s.jsx)("sub",{children:"2"})," or not (as determined by whether the outermost call was to ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})})," or ",(0,s.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,s.jsx)("b",{children:"read-preserving-whitespace"})}),"). Suppose again that ",(0,s.jsx)(t,{styled:!0,term:"single-quote",children:(0,s.jsx)("i",{children:"single-quote"})})," were to be defined as shown above in the incorrect definition. Then a call to ",(0,s.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,s.jsx)("b",{children:"read-preserving-whitespace"})})," that read the expression \u2019foo*\u27e8Space\u27e9* would fail to preserve the space character following the symbol foo because the ",(0,s.jsx)(r.em,{children:"single-quote reader macro function"})," calls ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})}),", not ",(0,s.jsx)(n,{styled:!0,term:"read-preserving-whitespace",children:(0,s.jsx)("b",{children:"read-preserving-whitespace"})}),", to read the following expression (in this case foo). The correct definition, which passes the value ",(0,s.jsx)(t,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})})," for ",(0,s.jsx)(r.em,{children:"recursive-p"})," to ",(0,s.jsx)(n,{styled:!0,term:"read",children:(0,s.jsx)("b",{children:"read"})}),", allows the outermost call to determine whether ",(0,s.jsx)(t,{styled:!0,term:"whitespace",children:(0,s.jsx)("i",{children:"whitespace"})}),(0,s.jsx)("sub",{children:"2"})," is preserved."]}),"\n",(0,s.jsxs)(r.p,{children:["3. When end-of-file is encountered and the ",(0,s.jsx)(r.em,{children:"eof-error-p"})," argument is not ",(0,s.jsx)(n,{styled:!0,term:"nil",children:(0,s.jsx)("b",{children:"nil"})}),", the kind of error that is signaled may depend on the value of ",(0,s.jsx)(r.em,{children:"recursive-p"}),". If ",(0,s.jsx)(r.em,{children:"recursive-p"})," is ",(0,s.jsx)(t,{styled:!0,term:"true",children:(0,s.jsx)("i",{children:"true"})}),", then the end-of-file is deemed to have occurred within the middle of a printed representation; if ",(0,s.jsx)(r.em,{children:"recursive-p"})," is ",(0,s.jsx)(t,{styled:!0,term:"false",children:(0,s.jsx)("i",{children:"false"})}),", then the end-of-file may be deemed to have occurred between ",(0,s.jsx)(t,{styled:!0,term:"object",children:(0,s.jsx)("i",{children:"objects"})})," rather than within the middle of one."]})]})}function g(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}function w(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const R={title:"23.1 Reader Concepts"},v="23.1 Reader Concepts",E={},A=[{value:"23.1.1 Dynamic Control of the Lisp Reader",id:"2311-dynamic-control-of-the-lisp-reader",level:2},{value:"23.1.2 Effect of Readtable Case on the Lisp Reader",id:"2312-effect-of-readtable-case-on-the-lisp-reader",level:2},{value:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader",id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",level:3},{value:"23.1.3 Argument Conventions of Some Reader Functions",id:"2313-argument-conventions-of-some-reader-functions",level:2},{value:"23.1.3.1 The EOF",id:"23131-the-eof",level:3},{value:"23.1.3.2 The RECURSIVE",id:"23132-the-recursive",level:3}];function C(e){const r={h1:"h1",h2:"h2",h3:"h3",header:"header",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"231-reader-concepts",children:"23.1 Reader Concepts"})}),"\n","\n",(0,s.jsx)(a,{}),"\n",(0,s.jsx)(r.h2,{id:"2311-dynamic-control-of-the-lisp-reader",children:"23.1.1 Dynamic Control of the Lisp Reader"}),"\n","\n",(0,s.jsx)(l,{}),"\n",(0,s.jsx)(r.h2,{id:"2312-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2 Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,s.jsx)(h,{}),"\n",(0,s.jsx)(r.h3,{id:"23121-examples-of-effect-of-readtable-case-on-the-lisp-reader",children:"23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader"}),"\n","\n",(0,s.jsx)(x,{}),"\n",(0,s.jsx)(r.h2,{id:"2313-argument-conventions-of-some-reader-functions",children:"23.1.3 Argument Conventions of Some Reader Functions"}),"\n","\n",(0,s.jsx)(j,{}),"\n",(0,s.jsx)(r.h3,{id:"23131-the-eof",children:"23.1.3.1 The EOF"}),"\n","\n",(0,s.jsx)(u,{}),"\n",(0,s.jsx)(r.h3,{id:"23132-the-recursive",children:"23.1.3.2 The RECURSIVE"}),"\n","\n",(0,s.jsx)(g,{})]})}function S(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}}}]);