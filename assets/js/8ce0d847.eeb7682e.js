"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[75818],{85311:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var n=i(85893),o=i(11151);const a={},s="Initialization of Method Metaobjects",r={id:"meta-object-protocol/initialization-of-method-metaobjects",title:"Initialization of Method Metaobjects",description:"Initialization of Method Metaobjects",source:"@site/docs/meta-object-protocol/initialization-of-method-metaobjects.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/initialization-of-method-metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-method-metaobjects",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/initialization-of-method-metaobjects.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Initialization of Generic Function Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-generic-function-metaobjects"},next:{title:"Initialization of Slot Definition Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-slot-definition-metaobjects"}},c={},l=[{value:"Initialization of Method Metaobjects",id:"initialization-of-method-metaobjects-1",level:3},{value:"Methods",id:"methods",level:2}];function h(e){const t={a:"a",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"initialization-of-method-metaobjects",children:"Initialization of Method Metaobjects"}),"\n",(0,n.jsx)(t.h3,{id:"initialization-of-method-metaobjects-1",children:"Initialization of Method Metaobjects"}),"\n",(0,n.jsxs)(t.p,{children:["A method metaobject can be created by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the method. A method metaobject cannot be redefined; calling ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,n.jsxs)(t.p,{children:["Initialization of a method metaobject must be done by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Portable programs must not call ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a method metaoject. Portable programs must not call ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize a method metaobject. Portable programs must not call ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any method metaobject or to turn a non-method object into a method metaobject."]}),"\n",(0,n.jsxs)(t.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on method metaobjects. Since the class of a method metaobject cannot be changed, no behavior is specified for the result of calls to ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on method metaobjects."]}),"\n",(0,n.jsx)(t.p,{children:"During initialization, each initialization argument is checked for errors and then associated with the method metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below (FIXME: insert anchor reference)."}),"\n",(0,n.jsx)(t.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. The section ends with a set of restrictions on portable methods affecting method metaobject initialization."}),"\n",(0,n.jsxs)(t.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,n.jsx)(t.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,n.jsx)(t.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified method metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method",children:"method"}),"."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:":qualifiers"})," argument is a list of method qualifiers. An error is signaled if this value is not a proper list, or if any element of the list is not a non-null atom. This argument defaults to the empty list."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:":lambda-list"})," argument is the unspecialized lambda list of the method. An error is signaled if this value is not a proper lambda list. If this value is not supplied, an error is signaled."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:":specializers"})," argument is a list of the specializer metaobjects for the method. An error is signaled if this value is not a proper list, or if the length of the list differs from the number of required arguments in the ",(0,n.jsx)(t.code,{children:":lambda-list"})," argument, or if any element of the list is not a specializer metaobject. If this value is not supplied, an error is signaled."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:":function"})," argument is a method function. It must be compatible with the methods on ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," defined for this class of method and generic function with which it will be used. That is, it must accept the same number of arguments as all uses of ",(0,n.jsx)(t.a,{href:"/cl-language-reference/chap-7/h-h-dictionary/call-method_make-method_local-macro",children:"call-method"})," that will call it supply. (See ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/compute-effective-method",children:"compute-effective-method"})," for more information.) An error is signaled if this argument is not supplied."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["When the method being initialized is an instance of a subclass of ",(0,n.jsx)(t.code,{children:"standard-accessor-method"}),", the ",(0,n.jsx)(t.code,{children:":slot-definition"})," initialization argument must be provided. Its value is the direct slot definition metaobject which defines this accessor method. An error is signaled if the value is not an instance of a subclass of ",(0,n.jsx)(t.code,{children:"direct-slot-definition"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:":documentation"})," argument is a string or ",(0,n.jsx)(t.code,{children:"nil"}),". An error is signaled if this value is not a string or ",(0,n.jsx)(t.code,{children:"nil"}),". This argument defaults to ",(0,n.jsx)(t.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the method metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,n.jsx)(t.p,{children:"Initialization Argument   Generic Function"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.div,{children:[(0,n.jsxs)(t.div,{children:[(0,n.jsx)(t.code,{children:":qualifiers"}),"             ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/method-qualifiers",children:"method-qualifiers"})]}),(0,n.jsxs)(t.div,{children:["  ",(0,n.jsx)(t.code,{children:":lambda-list"}),"            ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/method-lambda-list",children:"method-lambda-list"})]}),(0,n.jsxs)(t.div,{children:["  ",(0,n.jsx)(t.code,{children:":specializers"}),"           ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/method-specializers",children:"method-specializers"})]}),(0,n.jsxs)(t.div,{children:["  ",(0,n.jsx)(t.code,{children:":function"}),"               ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/method-function",children:"method-function"})]}),(0,n.jsxs)(t.div,{children:["  ",(0,n.jsx)(t.code,{children:":slot-definition"}),"        ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/accessor-method-slot-definition",children:"accessor-method-slot-definition"})]}),(0,n.jsxs)(t.div,{children:["  ",(0,n.jsx)(t.code,{children:":documentation"}),"          ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"})]}),(0,n.jsx)(t.div,{children:(0,n.jsx)(t.p,{children:"Initialization arguments and accessors for method metaobjects."})})]}),"\n",(0,n.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(t.p,{children:"It is not specified which methods provide the initialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented in as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the method metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,n.jsxs)(t.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method",children:"method"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Portable programs must not define methods on ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," or ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["For ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Portable programs must not define primary methods."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The results are undefined if any of these restrictions are violated."})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>s});var n=i(67294);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);