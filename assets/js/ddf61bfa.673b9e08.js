"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[33890],{40849:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>T,contentTitle:()=>V,default:()=>F,frontMatter:()=>L,metadata:()=>Q,toc:()=>O});var n=i(85893),t=i(11151);function o(e){return(0,n.jsx)(n.Fragment,{})}function r(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(o,{...e})}):o()}function a(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["Figure 18\u20131 lists some ",(0,n.jsx)(s.em,{children:"defined names"})," that are applicable to ",(0,n.jsx)(s.em,{children:"hash tables"}),". The following rules apply to ",(0,n.jsx)(s.em,{children:"hash tables"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["\u2013 A ",(0,n.jsx)(s.em,{children:"hash table"})," can only associate one value with a given key. If an attempt is made to add a second value for a given key, the second value will replace the first. Thus, adding a value to a ",(0,n.jsx)(s.em,{children:"hash table"})," is a destructive operation; the ",(0,n.jsx)(s.em,{children:"hash table"})," is modified."]}),"\n",(0,n.jsxs)(s.p,{children:["\u2013 There are four kinds of ",(0,n.jsx)(s.em,{children:"hash tables"}),": those whose keys are compared with ",(0,n.jsx)(s.strong,{children:"eq"}),", those whose keys are compared with ",(0,n.jsx)(s.strong,{children:"eql"}),", those whose keys are compared with ",(0,n.jsx)(s.strong,{children:"equal"}),", and those whose keys are compared with ",(0,n.jsx)(s.strong,{children:"equalp"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["\u2013 ",(0,n.jsx)(s.em,{children:"Hash tables"})," are created by ",(0,n.jsx)(s.strong,{children:"make-hash-table"}),". ",(0,n.jsx)(s.strong,{children:"gethash"})," is used to look up a key and find the associated value. New entries are added to ",(0,n.jsx)(s.em,{children:"hash tables"})," using ",(0,n.jsx)(s.strong,{children:"setf"})," with ",(0,n.jsx)(s.strong,{children:"gethash"}),". ",(0,n.jsx)(s.strong,{children:"remhash"})," is used to remove an entry. For example:"]}),"\n",(0,n.jsxs)(s.p,{children:["(setq a (make-hash-table)) ",(0,n.jsx)(s.em,{children:"\u2192"})," #<HASH-TABLE EQL 0/120 32536573>"]}),"\n",(0,n.jsxs)(s.p,{children:["(setf (gethash \u2019color a) \u2019brown) ",(0,n.jsx)(s.em,{children:"\u2192"})," BROWN"]}),"\n",(0,n.jsxs)(s.p,{children:["(setf (gethash \u2019name a) \u2019fred) ",(0,n.jsx)(s.em,{children:"\u2192"})," FRED"]}),"\n",(0,n.jsxs)(s.p,{children:["(gethash \u2019color a) ",(0,n.jsx)(s.em,{children:"\u2192"})," BROWN, ",(0,n.jsx)(s.em,{children:"true"})]}),"\n",(0,n.jsxs)(s.p,{children:["(gethash \u2019name a) ",(0,n.jsx)(s.em,{children:"\u2192"})," FRED, ",(0,n.jsx)(s.em,{children:"true"})]}),"\n",(0,n.jsxs)(s.p,{children:["(gethash \u2019pointy a) ",(0,n.jsx)(s.em,{children:"\u2192"})," NIL, ",(0,n.jsx)(s.em,{children:"false"})]}),"\n",(0,n.jsxs)(s.p,{children:["In this example, the symbols color and name are being used as keys, and the symbols brown and fred are being used as the associated values. The ",(0,n.jsx)(s.em,{children:"hash table"})," has two items in it, one of which associates from color to brown, and the other of which associates from name to fred."]}),"\n",(0,n.jsxs)(s.p,{children:["\u2013 A key or a value may be any ",(0,n.jsx)(s.em,{children:"object"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["\u2013 The existence of an entry in the ",(0,n.jsx)(s.em,{children:"hash table"})," can be determined from the ",(0,n.jsx)(s.em,{children:"secondary value"})," returned by ",(0,n.jsx)(s.strong,{children:"gethash"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["|",(0,n.jsxs)("p",{children:[(0,n.jsx)(s.strong,{children:"clrhash hash-table-p remhash gethash make-hash-table sxhash"})," "]}),(0,n.jsx)("p",{children:(0,n.jsx)(s.strong,{children:"hash-table-count maphash"})}),"|"]}),"\n",(0,n.jsx)(s.p,{children:"| :- |"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Figure 18\u20131. Hash-table defined names"})}),"\n",(0,n.jsx)(s.p,{children:"Hash"})]})}function c(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}function h(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["The function supplied as the ",":test"," argument to ",(0,n.jsx)(s.strong,{children:"make-hash-table"})," specifies the \u2018equivalence test\u2019 for the ",(0,n.jsx)(s.em,{children:"hash table"})," it creates."]}),"\n",(0,n.jsxs)(s.p,{children:["An ",(0,n.jsx)(s.em,{children:"object"})," is \u2018visibly modified\u2019 with regard to an equivalence test if there exists some set of ",(0,n.jsx)(s.em,{children:"objects"})," (or potential ",(0,n.jsx)(s.em,{children:"objects"}),") which are equivalent to the ",(0,n.jsx)(s.em,{children:"object"})," before the modification but are no longer equivalent afterwards."]}),"\n",(0,n.jsxs)(s.p,{children:["If an ",(0,n.jsx)(s.em,{children:"object O"}),(0,n.jsx)("sub",{children:"1"})," is used as a key in a ",(0,n.jsx)(s.em,{children:"hash table H"})," and is then visibly modified with regard to the equivalence test of ",(0,n.jsx)(s.em,{children:"H"}),", then the consequences are unspecified if ",(0,n.jsx)(s.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"}),", or any ",(0,n.jsx)(s.em,{children:"object O"}),(0,n.jsx)("sub",{children:"2"})," equivalent to ",(0,n.jsx)(s.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," under the equivalence test (either before or after the modification), is used as a key in further operations on ",(0,n.jsx)(s.em,{children:"H"}),". The consequences of using ",(0,n.jsx)(s.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," as a key are unspecified even if ",(0,n.jsx)(s.em,{children:"O"}),(0,n.jsx)("sub",{children:"1"})," is visibly"]}),"\n",(0,n.jsx)(s.p,{children:"modified and then later modified again in such a way as to undo the visible modification."}),"\n",(0,n.jsxs)(s.p,{children:["Following are specifications of the modifications which are visible to the equivalence tests which must be supported by ",(0,n.jsx)(s.em,{children:"hash tables"}),". The modifications are described in terms of modification of components, and are defined recursively. Visible modifications of components of the ",(0,n.jsx)(s.em,{children:"object"})," are visible modifications of the ",(0,n.jsx)(s.em,{children:"object"}),"."]})]})}function l(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}function d(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["No ",(0,n.jsx)(s.em,{children:"standardized function"})," is provided that is capable of visibly modifying an ",(0,n.jsx)(s.em,{children:"object"})," with regard to ",(0,n.jsx)(s.strong,{children:"eq"})," or ",(0,n.jsx)(s.strong,{children:"eql"}),"."]})}function m(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function p(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(s.strong,{children:"equal"}),", the rules for visible modification of ",(0,n.jsx)(s.em,{children:"objects"})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.1 (Visible Modification of Objects with respect to EQ and EQL)."]})}function f(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}function j(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["Any visible change to the ",(0,n.jsx)(s.em,{children:"car"})," or the ",(0,n.jsx)(s.em,{children:"cdr"})," of a ",(0,n.jsx)(s.em,{children:"cons"})," is considered a visible modification with regard to ",(0,n.jsx)(s.strong,{children:"equal"}),"."]})}function x(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(j,{...e})}):j(e)}function u(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["For a ",(0,n.jsx)(s.em,{children:"vector"})," of ",(0,n.jsx)(s.em,{children:"type"})," ",(0,n.jsx)(s.strong,{children:"bit-vector"})," or of ",(0,n.jsx)(s.em,{children:"type"})," ",(0,n.jsx)(s.strong,{children:"string"}),", any visible change to an ",(0,n.jsx)(s.em,{children:"active element"})," of the ",(0,n.jsx)(s.em,{children:"vector"})," , or to the ",(0,n.jsx)(s.em,{children:"length"})," of the ",(0,n.jsx)(s.em,{children:"vector"})," (if it is ",(0,n.jsx)(s.em,{children:"actually adjustable"})," or has a ",(0,n.jsx)(s.em,{children:"fill pointer"})," ) is considered a visible modification with regard to ",(0,n.jsx)(s.strong,{children:"equal"}),"."]})}function b(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}function g(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["As a consequence of the behavior for ",(0,n.jsx)(s.strong,{children:"equalp"}),", the rules for visible modification of ",(0,n.jsx)(s.em,{children:"objects"})," not explicitly mentioned in this section are inherited from those in Section 18.1.2.2 (Visible Modification of Objects with respect to EQUAL)."]})}function v(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(g,{...e})}):g(e)}function w(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["Any visible change to a ",(0,n.jsx)(s.em,{children:"slot"})," of a ",(0,n.jsx)(s.em,{children:"structure"})," is considered a visible modification with regard to ",(0,n.jsx)(s.strong,{children:"equalp"}),"."]})}function y(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(w,{...e})}):w(e)}function q(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(s.p,{children:["In an ",(0,n.jsx)(s.em,{children:"array"}),", any visible change to an ",(0,n.jsx)(s.em,{children:"active element"}),", to the ",(0,n.jsx)(s.em,{children:"fill pointer"})," (if the ",(0,n.jsx)(s.em,{children:"array"})," can and does have one), or to the ",(0,n.jsx)(s.em,{children:"dimensions"})," (if the ",(0,n.jsx)(s.em,{children:"array"})," is ",(0,n.jsx)(s.em,{children:"actually adjustable"}),") is considered a visible modification with regard to ",(0,n.jsx)(s.strong,{children:"equalp"}),"."]})}function k(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(q,{...e})}):q(e)}function E(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["In a ",(0,n.jsx)(s.em,{children:"hash table"}),", any visible change to the count of entries in the ",(0,n.jsx)(s.em,{children:"hash table"}),", to the keys, or to the values associated with the keys is considered a visible modification with regard to ",(0,n.jsx)(s.strong,{children:"equalp"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["Note that the visibility of modifications to the keys depends on the equivalence test of the ",(0,n.jsx)(s.em,{children:"hash table"}),", not on the specification of ",(0,n.jsx)(s.strong,{children:"equalp"}),"."]})]})}function A(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(E,{...e})}):E(e)}function M(e){const s={em:"em",p:"p",strong:"strong",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.em,{children:"Implementations"})," that extend the language by providing additional mutator functions (or additional behavior for existing mutator functions) must document how the use of these extensions interacts with equivalence tests and ",(0,n.jsx)(s.em,{children:"hash table"})," searches."]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.em,{children:"Implementations"})," that extend the language by defining additional acceptable equivalence tests for ",(0,n.jsx)(s.em,{children:"hash tables"})," (allowing additional values for the ",":test"," argument to ",(0,n.jsx)(s.strong,{children:"make-hash-table"}),") must document the visible components of these tests."]}),"\n",(0,n.jsx)(s.p,{children:"Hash"})]})}function H(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(M,{...e})}):M(e)}const L={title:"18.1 Hash Table Concepts"},V="18.1 Hash Table Concepts",Q={id:"chap-18/bi-b-hash-table-concepts",title:"18.1 Hash Table Concepts",description:"18.1.1 Hash",source:"@site/docs/chap-18/bi-b-hash-table-concepts.md",sourceDirName:"chap-18",slug:"/chap-18/bi-b-hash-table-concepts",permalink:"/cl-language-reference/docs/chap-18/bi-b-hash-table-concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-18/bi-b-hash-table-concepts.md",tags:[],version:"current",frontMatter:{title:"18.1 Hash Table Concepts"},sidebar:"tutorialSidebar",previous:{title:"18. Hash Tables",permalink:"/cl-language-reference/docs/category/18-hash-tables"},next:{title:"18.2 Hash Tables Dictionary",permalink:"/cl-language-reference/docs/category/182-hash-tables-dictionary"}},T={},O=[{value:"18.1.1 Hash",id:"1811-hash",level:2},{value:"18.1.2 Modifying Hash Table Keys",id:"1812-modifying-hash-table-keys",level:2},{value:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL",id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",level:3},{value:"18.1.2.2 Visible Modification of Objects with respect to EQUAL",id:"18122-visible-modification-of-objects-with-respect-to-equal",level:3},{value:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL",id:"181221-visible-modification-of-conses-with-respect-to-equal",level:4},{value:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL",id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",level:4},{value:"18.1.2.3 Visible Modification of Objects with respect to EQUALP",id:"18123-visible-modification-of-objects-with-respect-to-equalp",level:3},{value:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP",id:"181231-visible-modification-of-structures-with-respect-to-equalp",level:4},{value:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP",id:"181232-visible-modification-of-arrays-with-respect-to-equalp",level:4},{value:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP",id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",level:4},{value:"18.1.2.4 Visible Modifications by Language Extensions",id:"18124-visible-modifications-by-language-extensions",level:3}];function U(e){const s={h1:"h1",h2:"h2",h3:"h3",h4:"h4",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"181-hash-table-concepts",children:"18.1 Hash Table Concepts"}),"\n","\n",(0,n.jsx)(r,{}),"\n",(0,n.jsx)(s.h2,{id:"1811-hash",children:"18.1.1 Hash"}),"\n","\n",(0,n.jsx)(c,{}),"\n",(0,n.jsx)(s.h2,{id:"1812-modifying-hash-table-keys",children:"18.1.2 Modifying Hash Table Keys"}),"\n","\n",(0,n.jsx)(l,{}),"\n",(0,n.jsx)(s.h3,{id:"18121-visible-modification-of-objects-with-respect-to-eq-and-eql",children:"18.1.2.1 Visible Modification of Objects with respect to EQ and EQL"}),"\n","\n",(0,n.jsx)(m,{}),"\n",(0,n.jsx)(s.h3,{id:"18122-visible-modification-of-objects-with-respect-to-equal",children:"18.1.2.2 Visible Modification of Objects with respect to EQUAL"}),"\n","\n",(0,n.jsx)(f,{}),"\n",(0,n.jsx)(s.h4,{id:"181221-visible-modification-of-conses-with-respect-to-equal",children:"18.1.2.2.1 Visible Modification of Conses with respect to EQUAL"}),"\n","\n",(0,n.jsx)(x,{}),"\n",(0,n.jsx)(s.h4,{id:"181222-visible-modification-of-bit-vectors-and-strings-with-respect-to-equal",children:"18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL"}),"\n","\n",(0,n.jsx)(b,{}),"\n",(0,n.jsx)(s.h3,{id:"18123-visible-modification-of-objects-with-respect-to-equalp",children:"18.1.2.3 Visible Modification of Objects with respect to EQUALP"}),"\n","\n",(0,n.jsx)(v,{}),"\n",(0,n.jsx)(s.h4,{id:"181231-visible-modification-of-structures-with-respect-to-equalp",children:"18.1.2.3.1 Visible Modification of Structures with respect to EQUALP"}),"\n","\n",(0,n.jsx)(y,{}),"\n",(0,n.jsx)(s.h4,{id:"181232-visible-modification-of-arrays-with-respect-to-equalp",children:"18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP"}),"\n","\n",(0,n.jsx)(k,{}),"\n",(0,n.jsx)(s.h4,{id:"181233-visible-modification-of-hash-tables-with-respect-to-equalp",children:"18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP"}),"\n","\n",(0,n.jsx)(A,{}),"\n",(0,n.jsx)(s.h3,{id:"18124-visible-modifications-by-language-extensions",children:"18.1.2.4 Visible Modifications by Language Extensions"}),"\n","\n","\n",(0,n.jsx)(H,{})]})}function F(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(U,{...e})}):U(e)}},11151:(e,s,i)=>{i.d(s,{Z:()=>a,a:()=>r});var n=i(67294);const t={},o=n.createContext(t);function r(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);