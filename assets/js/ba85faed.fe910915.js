"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[83558],{89209:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>n,default:()=>l,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var r=t(85893),s=t(11151);const c={},n="Processing of the user interface macros",i={id:"meta-object-protocol/processing-of-the-user-interface-macros",title:"Processing of the user interface macros",description:"Processing of the user interface macros",source:"@site/docs/meta-object-protocol/processing-of-the-user-interface-macros.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/processing-of-the-user-interface-macros",permalink:"/cl-language-reference/meta-object-protocol/processing-of-the-user-interface-macros",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/processing-of-the-user-interface-macros.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Processing method bodies",permalink:"/cl-language-reference/meta-object-protocol/processing-method-bodies"},next:{title:"reader-method-class-funcallable-standard-class-standard-direct-slot-definition",permalink:"/cl-language-reference/meta-object-protocol/reader-method-class-funcallable-standard-class-standard-direct-slot-definition"}},a={},d=[{value:"Processing of the user interface macros",id:"processing-of-the-user-interface-macros-1",level:2}];function h(e){const o={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.h1,{id:"processing-of-the-user-interface-macros",children:"Processing of the user interface macros"}),"\n",(0,r.jsx)(o.h2,{id:"processing-of-the-user-interface-macros-1",children:"Processing of the user interface macros"}),"\n",(0,r.jsxs)(o.p,{children:["A list in which the first element is one of the symbols ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"}),", ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"}),", ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_4.htm#define-method-combination",children:"define-method-combination"}),", ",(0,r.jsx)(o.code,{children:"generic-function"}),", ",(0,r.jsx)(o.code,{children:"generic-flet"})," or ",(0,r.jsx)(o.code,{children:"generic-labels"}),", and which has proper syntax for that macro is called a ",(0,r.jsx)(o.em,{children:"user interface macro form"}),". This document provides an extended specification of the ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," and ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"})," macros."]}),"\n",(0,r.jsxs)(o.p,{children:["The user interface macros ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"})," and ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," can be used not only to define metaobjects that are instances of the corresponding standard metaobject class, but also to define metaobjects that are instances of appropriate portable metaobject classes. To make it possible for portable metaobject classes to properly process the information appearing in the macro form, this document provides a limited specification of the processing of these macro forms."]}),"\n",(0,r.jsxs)(o.p,{children:["User interface macro forms can be ",(0,r.jsx)(o.code,{children:"evaluated"})," or ",(0,r.jsx)(o.code,{children:"compiled"})," and later ",(0,r.jsx)(o.code,{children:"executed"}),". The effect of evaluating or executing a user interface macro form is specified in terms of calls to specified functions and generic functions which provide the actual behavior of the macro. The arguments received by these functions and generic functions are derived in a specified way from the macro form."]}),"\n",(0,r.jsx)(o.p,{children:"Converting a user interface macro form into the arguments to the appropriate functions and generic functions has two major aspects: the conversion of the macro argument syntax into a form more suitable for later processing, and the processing of macro arguments which are forms to be evaluated (including method bodies)."}),"\n",(0,r.jsxs)(o.p,{children:["In the syntax of the ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," macro, the ",(0,r.jsx)(o.em,{children:"initform"})," and ",(0,r.jsx)(o.em,{children:"default-initarg-initial-value-form"})," arguments are forms which will be evaluated one or more times after the macro form is evaluated or executed. Special processing must be done on these arguments to ensure that the lexical scope of the forms is captured properly. This is done by building a function of zero arguments which, when called, returns the result of evaluating the form in the proper lexical environment."]}),"\n",(0,r.jsxs)(o.p,{children:["In the syntax of the ",(0,r.jsx)(o.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," macro the ",(0,r.jsx)(o.em,{children:"form"}),"* argument is a list of forms that comprise the body of the method definition. This list of forms must be processed specially to capture the lexical scope of the macro form. In addition, the lexical functions available only in the body of methods must be introduced. To allow this and any other special processing (such as slot access optimization), a specializable protocol is used for processing the body of methods. This is discussed in ",(0,r.jsx)(o.a,{href:"/meta-object-protocol/processing-method-bodies",children:"the section ``Processing Method Bodies.''"})]}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsx)(o.li,{children:(0,r.jsx)(o.a,{href:"/meta-object-protocol/compile-file-processing-of-the-user-interface-macros",children:"Compile-file processing of the user interface macros."})}),"\n",(0,r.jsx)(o.li,{children:(0,r.jsxs)(o.a,{href:"/meta-object-protocol/the-defclass-macro",children:["The ",(0,r.jsx)(o.code,{children:"defclass"})," macro."]})}),"\n",(0,r.jsx)(o.li,{children:(0,r.jsxs)(o.a,{href:"/meta-object-protocol/the-defmethod-macro",children:["The ",(0,r.jsx)(o.code,{children:"defmethod"})," macro."]})}),"\n",(0,r.jsx)(o.li,{children:(0,r.jsx)(o.a,{href:"/meta-object-protocol/processing-method-bodies",children:"Processing method bodies."})}),"\n",(0,r.jsx)(o.li,{children:(0,r.jsxs)(o.a,{href:"/meta-object-protocol/the-defgeneric-macro",children:["The ",(0,r.jsx)(o.code,{children:"defgeneric"})," macro."]})}),"\n"]})]})}function l(e={}){const{wrapper:o}={...(0,s.a)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},11151:(e,o,t)=>{t.d(o,{Z:()=>i,a:()=>n});var r=t(67294);const s={},c=r.createContext(s);function n(e){const o=r.useContext(c);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),r.createElement(c.Provider,{value:o},e.children)}}}]);