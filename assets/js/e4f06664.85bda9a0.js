"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[99078],{17816:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>r});var s=i(85893),n=i(11151);const a={},o="Initialization of Class Metaobjects",c={id:"meta-object-protocol/initialization-of-class-metaobjects2",title:"Initialization of Class Metaobjects",description:"Initialization of Class Metaobjects",source:"@site/docs/meta-object-protocol/initialization-of-class-metaobjects2.md",sourceDirName:"meta-object-protocol",slug:"/meta-object-protocol/initialization-of-class-metaobjects2",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-class-metaobjects2",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/initialization-of-class-metaobjects2.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Initialization of Class Metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-class-metaobjects"},next:{title:"Initialization of generic function and method metaobjects",permalink:"/cl-language-reference/meta-object-protocol/initialization-of-generic-function-and-method-metaobjects"}},l={},r=[{value:"Initialization of Class Metaobjects",id:"initialization-of-class-metaobjects-1",level:3},{value:"Methods",id:"methods",level:2},{value:"Comments and remarks",id:"comments-and-remarks",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"initialization-of-class-metaobjects",children:"Initialization of Class Metaobjects"}),"\n",(0,s.jsx)(t.h3,{id:"initialization-of-class-metaobjects-1",children:"Initialization of Class Metaobjects"}),"\n",(0,s.jsxs)(t.p,{children:["A class metaobject can be created by calling ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The initialization arguments establish the definition of the class. A class metaobject can be redefined by calling ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Some classes of class metaobject do not support redefinition; in these cases, ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," signals an error."]}),"\n",(0,s.jsxs)(t.p,{children:["Initialization of a class metaobject must be done by calling ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," and allowing it to call ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),". Reinitialization of a class metaobject must be done by calling ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),". Portable programs must not call ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," directly to initialize a class metaobject. Portable programs must not call ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"})," directly to initialize or reinitialize a class metaobject. Portable programs must not call ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_chg_cl.htm#change-class",children:"change-class"})," to change the class of any class metaobject or to turn a non-class object into a class metaobject."]}),"\n",(0,s.jsxs)(t.p,{children:["Since metaobject classes may not be redefined, no behavior is specified for the result of calls to ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_upda_1.htm#update-instance-for-redefined-class",children:"update-instance-for-redefined-class"})," on class metaobjects. Since the class of class metaobjects may not be changed, no behavior is specified for the result of calls to ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_update.htm#update-instance-for-different-class",children:"update-instance-for-different-class"})," on class metaobjects."]}),"\n",(0,s.jsxs)(t.p,{children:["During initialization or reinitialization, each initialization argument is checked for errors and then associated with the class metaobject. The value can then be accessed by calling the appropriate accessor as shown in the table below. (FIXME",":insert"," anchor)"]}),"\n",(0,s.jsx)(t.p,{children:"This section begins with a description of the error checking and processing of each initialization argument. This is followed by a table showing the generic functions that can be used to access the stored initialization arguments. Initialization behavior specific to the different specified class metaobject classes comes next. The section ends with a set of restrictions on portable methods affecting class metaobject initialization and reinitialization."}),"\n",(0,s.jsxs)(t.p,{children:["In these descriptions, the phrase ``this argument defaults to ",(0,s.jsx)(t.em,{children:"value"}),"'' means that when that initialization argument is not supplied, initialization or reinitialization is performed as if ",(0,s.jsx)(t.em,{children:"value"})," had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified class metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_class.htm#class",children:"class"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Unless there is a specific note to the contrary, then during reinitialization, if an initialization argument is not supplied, the previously stored value is left unchanged."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:":direct-default-initargs"})," argument is a list of canonicalized default initialization arguments."]}),"\n",(0,s.jsx)(t.p,{children:"An error is signaled if this value is not a proper list, or if any element of the list is not a canonicalized default initialization argument."}),"\n",(0,s.jsx)(t.p,{children:"If the class metaobject is being initialized, this argument defaults to the empty list."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:":direct-slots"})," argument is a list of canonicalized slot specifications."]}),"\n",(0,s.jsx)(t.p,{children:"An error is signaled if this value is not a proper list or if any element of the list is not a canonicalized slot specification."}),"\n",(0,s.jsxs)(t.p,{children:["After error checking, this value is converted to a list of direct slot definition metaobjects before it is associated with the class metaobject. Conversion of each canonicalized slot specification to a direct slot definition metaobject is a two-step process. First, the generic function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/direct-slot-definition-class",children:"direct-slot-definition-class"})," is called with the class metaobject and the canonicalized slot specification to determine the class of the new direct slot definition metaobject; this permits both the class metaobject and the canonicalized slot specification to control the resulting direct slot definition metaobject class. Second, ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," is applied to the direct slot definition metaobject class and the canonicalized slot specification. This conversion could be implemented as shown in the following code:"]}),"\n",(0,s.jsx)(t.p,{children:"(defun convert-to-direct-slot-definition (class canonicalized-slot)\n(apply #'make-instance\n(apply #'direct-slot-definition-class\nclass canonicalized-slot)\ncanonicalized-slot))"}),"\n",(0,s.jsx)(t.p,{children:"If the class metaobject is being initialized, this argument defaults to the empty list."}),"\n",(0,s.jsxs)(t.p,{children:["Once the direct slot definition metaobjects have been created, the specified reader and writer methods are created. The generic functions ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/reader-method-class",children:"reader-method-class"})," and ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/writer-method-class",children:"writer-method-class"})," are called to determine the classes of the method metaobjects created."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:":direct-superclasses"})," argument is a list of class metaobjects. Classes which do not support multiple inheritance signal an error if the list contains more than one element."]}),"\n",(0,s.jsxs)(t.p,{children:["An error is signaled if this value is not a proper list or if ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/validate-superclass",children:"validate-superclass"})," applied to ",(0,s.jsx)(t.em,{children:"class"})," and any element of this list returns false."]}),"\n",(0,s.jsxs)(t.p,{children:["When the class metaobject is being initialized, and this argument is either not supplied or is the empty list, this argument defaults as follows: if the class is an instance of ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," or one of its subclasses the default value is a list of the class ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_std_ob.htm#standard-object",children:"standard-object"}),"; if the class is an instance of ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," or one of its subclasses the default value is list of the class ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-object",children:"funcallable-standard-object"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["After any defaulting of the value, the generic function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/add-direct-subclass",children:"add-direct-subclass"})," is called once for each element of the list."]}),"\n",(0,s.jsxs)(t.p,{children:["When the class metaobject is being reinitialized and this argument is supplied, the generic function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/remove-direct-subclass",children:"remove-direct-subclass"})," is called once for each class metaobject in the previously stored value but not in the new value; the generic function ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/add-direct-subclass",children:"add-direct-subclass"})," is called once for each class metaobject in the new value but not in the previously stored value."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:":documentation"})," argument is a string or ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["An error is signaled if this value is not a string or ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If the class metaobject is being initialized, this argument defaults to ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:":name"})," argument is an object."]}),"\n",(0,s.jsxs)(t.p,{children:["If the class is being initialized, this argument defaults to ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"After the processing and defaulting of initialization arguments described above, the value of each initialization argument is associated with the class metaobject. These values can then be accessed by calling the corresponding generic function. The correspondences are as follows:"}),"\n",(0,s.jsx)(t.p,{children:"Initialization Argument        Generic Function"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:":direct-default-initargs"}),"   ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-direct-default-initargs",children:"class-direct-default-initargs"}),"\n",(0,s.jsx)(t.strong,{children:":direct-slots"}),"              ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-direct-slots",children:"class-direct-slots"}),"\n",(0,s.jsx)(t.strong,{children:":direct-superclasses"}),"       ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-direct-superclasses",children:"class-direct-superclasses"}),"\n",(0,s.jsx)(t.strong,{children:":documentation"}),"             ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_docume.htm#documentation",children:"documentation"}),"\n",(0,s.jsx)(t.strong,{children:":name"}),"                      ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-name",children:"class-name"})]}),"\n",(0,s.jsx)(t.p,{children:"Initialization arguments and accessors for class metaobjects."}),"\n",(0,s.jsxs)(t.p,{children:["Instances of the class ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-standard-class",children:"standard-class"})," support multiple inheritance and reinitialization. Instances of the class ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-funcallable-standard-class",children:"funcallable-standard-class"})," support multiple inheritance and reinitialization. For forward referenced classes, all of the initialization arguments default to ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Since built-in classes cannot be created or reinitialized by the user, an error is signaled if ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," or ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"})," are called to initialize or reinitialize a derived instance of the class ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/class-built-in-class",children:"built-in-class"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.p,{children:"It is not specified which methods provide the initialization and reinitialization behavior described above. Instead, the information needed to allow portable programs to specialize this behavior is presented as a set of restrictions on the methods a portable program can define. The model is that portable initialization methods have access to the class metaobject when either all or none of the specified initialization has taken effect."}),"\n",(0,s.jsxs)(t.p,{children:["These restrictions govern the methods that a portable program can define on the generic functions ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"}),", ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),", and ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),". These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/t_class.htm#class",children:"class"}),". Other portable methods on these generic functions are not affected by these restrictions."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Portable programs must not define methods on ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize",children:"shared-initialize"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["For ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance",children:"initialize-instance"})," and ",(0,s.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance",children:"reinitialize-instance"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Portable programs must not define primary methods."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Portable programs may define around-methods, but these must be extending, not overriding methods."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The results are undefined if any of these restrictions are violated."}),"\n",(0,s.jsx)(t.h2,{id:"comments-and-remarks",children:"Comments and remarks"}),"\n",(0,s.jsxs)(t.p,{children:["This section is named ",(0,s.jsx)(t.em,{children:"Initialization of Class Metaobjects"})," and appears in Chapter 6 (Generic functions and methods) of the original text. There is ",(0,s.jsx)(t.a,{href:"/meta-object-protocol/initialization-of-class-metaobjects",children:"a section with the same name in Chapter 5 (Concepts) of the original text."})," When sections are referred to in the text, it is not specified which one."]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>c,a:()=>o});var s=i(67294);const n={},a=s.createContext(n);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);