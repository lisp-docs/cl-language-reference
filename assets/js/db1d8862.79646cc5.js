"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[72708],{42781:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>x,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var t=i(85893),s=i(11151);function r(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components},{ClLinks:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"define-condition"})," ",(0,t.jsx)(i,{styled:!0,term:"macro",children:(0,t.jsx)("i",{children:"Macro"})})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," ",(0,t.jsx)(i,{styled:!0,term:"name",children:(0,t.jsx)("i",{children:"name"})})," (",(0,t.jsx)(n.em,{children:"{parent-type}"}),"*) (",(0,t.jsx)(n.em,{children:"{\u2193slot-spec}"}),"*) ",(0,t.jsx)(n.em,{children:"{option}"}),"*"]}),"\n",(0,t.jsx)(n.p,{children:"\u2192 name"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"slot-spec::"}),"=",(0,t.jsx)(n.em,{children:"slot-name |"})," (",(0,t.jsx)(n.em,{children:"slot-name \u2193slot-option"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"slot-option::"}),"=[[ ",(0,t.jsx)(n.em,{children:"{"}),":reader"," ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol}"})}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":writer"," ",(0,t.jsx)(n.em,{children:"\u2193function-name}"}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":accessor"," ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol}"})}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":allocation"," ",(0,t.jsx)(n.em,{children:"\u2193allocation-type} |"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":initarg"," ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol}"})}),"* ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":initform"," ",(0,t.jsx)(n.em,{children:"form} |"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"{"}),":type"," ",(0,t.jsx)(n.em,{children:"type-specifier}"})," ]]"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"option::"}),"=[[(",":default-initargs"," . ",(0,t.jsx)(n.em,{children:"initarg-list"}),") ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:["(",":documentation"," ",(0,t.jsx)(i,{styled:!0,term:"string",children:(0,t.jsx)("i",{children:"string"})}),") ",(0,t.jsx)(n.em,{children:"|"})]}),"\n",(0,t.jsxs)(n.p,{children:["(",":report"," ",(0,t.jsx)(n.em,{children:"report-name"}),") ]]"]}),"\n",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"function-name::"}),"=",(0,t.jsx)(n.em,{children:"{symbol |"})," (setf ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})}),")",(0,t.jsx)(n.em,{children:"}"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"allocation-type::"}),"=",":instance"," ",(0,t.jsx)(n.em,{children:"|"})," ",":class"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"report-name::"}),"=",(0,t.jsx)(n.em,{children:"string | symbol | lambda expression"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(i,{styled:!0,term:"name",children:(0,t.jsx)("i",{children:"name"})}),"\u2014a ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"parent-type"}),"\u2014a ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," naming a ",(0,t.jsx)(n.em,{children:"condition type"}),". If no ",(0,t.jsx)(n.em,{children:"parent-types"})," are supplied, the ",(0,t.jsx)(n.em,{children:"parent-types"})," default to (condition)."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"default-initargs"}),"\u2014a ",(0,t.jsx)(i,{styled:!0,term:"list",children:(0,t.jsx)("i",{children:"list"})})," of ",(0,t.jsx)(n.em,{children:"keyword/value pairs"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Slot-spec"})," \u2013 the ",(0,t.jsx)(i,{styled:!0,term:"name",children:(0,t.jsx)("i",{children:"name"})})," of a ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," or a ",(0,t.jsx)(i,{styled:!0,term:"list",children:(0,t.jsx)("i",{children:"list"})})," consisting of the ",(0,t.jsx)(n.em,{children:"slot-name"})," followed by zero or more ",(0,t.jsx)(n.em,{children:"slot-options"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Slot-name"})," \u2013 a slot name (a ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})}),"), the ",(0,t.jsx)(i,{styled:!0,term:"list",children:(0,t.jsx)("i",{children:"list"})})," of a slot name, or the ",(0,t.jsx)(i,{styled:!0,term:"list",children:(0,t.jsx)("i",{children:"list"})})," of slot name/slot form pairs. ",(0,t.jsx)(n.em,{children:"Option"})," \u2013 Any of the following:"]}),"\n",(0,t.jsx)(n.p,{children:":reader"}),"\n",(0,t.jsxs)(n.p,{children:[":reader"," can be supplied more than once for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," and cannot be ",(0,t.jsx)(i,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":writer"}),"\n",(0,t.jsxs)(n.p,{children:[":writer"," can be supplied more than once for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," and must name a ",(0,t.jsx)(n.em,{children:"generic function"}),". ",":accessor"]}),"\n",(0,t.jsxs)(n.p,{children:[":accessor"," can be supplied more than once for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," and cannot be ",(0,t.jsx)(i,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":allocation"}),"\n",(0,t.jsxs)(n.p,{children:[":allocation"," can be supplied once at most for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". The default if ",":allocation"," is not supplied is ",":instance","."]}),"\n",(0,t.jsx)(n.p,{children:":initarg"}),"\n",(0,t.jsxs)(n.p,{children:[":initarg"," can be supplied more than once for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":initform"}),"\n",(0,t.jsxs)(n.p,{children:[":initform"," can be supplied once at most for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":type"}),"\n",(0,t.jsxs)(n.p,{children:[":type"," can be supplied once at most for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})}),"\n",(0,t.jsx)(n.p,{children:":documentation"}),"\n",(0,t.jsxs)(n.p,{children:[":documentation"," can be supplied once at most for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":report"}),"\n",(0,t.jsxs)(n.p,{children:[":report"," can be supplied once at most."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Description:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," defines a new condition type called ",(0,t.jsx)(i,{styled:!0,term:"name",children:(0,t.jsx)("i",{children:"name"})}),", which is a ",(0,t.jsx)(i,{styled:!0,term:"subtype",children:(0,t.jsx)("i",{children:"subtype"})})," of the ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})})," or ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"types"})})," named by ",(0,t.jsx)(n.em,{children:"parent-type"}),". Each ",(0,t.jsx)(n.em,{children:"parent-type"})," argument specifies a direct ",(0,t.jsx)(i,{styled:!0,term:"supertype",children:(0,t.jsx)("i",{children:"supertype"})})," of the new ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})}),". The new ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," inherits ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," and ",(0,t.jsx)(i,{styled:!0,term:"method",children:(0,t.jsx)("i",{children:"methods"})})," from each of its direct ",(0,t.jsx)(i,{styled:!0,term:"supertype",children:(0,t.jsx)("i",{children:"supertypes"})}),", and so on."]}),"\n",(0,t.jsxs)(n.p,{children:["If a slot name/slot form pair is supplied, the slot form is a ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," that can be evaluated by ",(0,t.jsx)(i,{styled:!0,term:"make-condition",children:(0,t.jsx)("b",{children:"make-condition"})})," to produce a default value when an explicit value is not provided. If no slot form is supplied, the contents of the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is initialized in an ",(0,t.jsx)(i,{styled:!0,term:"implementation-dependent",children:(0,t.jsx)("i",{children:"implementation-dependent"})})," way."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})})," being defined and some other ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})})," from which it inherits have a slot by the same name, only one slot is allocated in the ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})}),", but the supplied slot form overrides any slot form that might otherwise have been inherited from a ",(0,t.jsx)(n.em,{children:"parent-type"}),". If no slot form is supplied, the inherited slot form (if any) is still visible."]}),"\n",(0,t.jsxs)(n.p,{children:["Accessors are created according to the same rules as used by ",(0,t.jsx)(i,{styled:!0,term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["A description of ",(0,t.jsx)(n.em,{children:"slot-options"})," follows:"]}),"\n",(0,t.jsx)(n.p,{children:":reader"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":reader"," slot option specifies that an ",(0,t.jsx)(n.em,{children:"unqualified method"})," is to be defined on the ",(0,t.jsx)(n.em,{children:"generic function"})," named by the argument to ",":reader"," to read the value of the given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"\u2022"})," The ",":initform"," slot option is used to provide a default initial value form to be used in the initialization of the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". This ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," is evaluated every time it is used to initialize the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". The ",(0,t.jsx)(n.em,{children:"lexical environment"})," in which this ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," is evaluated is the lexical ",(0,t.jsx)(i,{styled:!0,term:"environment",children:(0,t.jsx)("i",{children:"environment"})})," in which the ",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," form was evaluated. Note that the ",(0,t.jsx)(n.em,{children:"lexical environment"})," refers both to variables and to ",(0,t.jsx)(i,{styled:!0,term:"function",children:(0,t.jsx)("i",{children:"functions"})}),". For ",(0,t.jsx)(n.em,{children:"local slots"}),", the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," is the dynamic ",(0,t.jsx)(i,{styled:!0,term:"environment",children:(0,t.jsx)("i",{children:"environment"})})," in which ",(0,t.jsx)(i,{styled:!0,term:"make-condition",children:(0,t.jsx)("b",{children:"make-condition"})})," was called; for ",(0,t.jsx)(n.em,{children:"shared slots"}),", the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," is the ",(0,t.jsx)(n.em,{children:"dynamic environment"})," in which the ",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," form was evaluated."]}),"\n",(0,t.jsxs)(n.p,{children:["No implementation is permitted to extend the syntax of ",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," to allow (",(0,t.jsx)(n.em,{children:"slot-name form"}),") as an abbreviation for (",(0,t.jsx)(n.em,{children:"slot-name"})," ",":initform"," ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})}),")."]}),"\n",(0,t.jsx)(n.p,{children:":initarg"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":initarg"," slot option declares an initialization argument named by its ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," argument and specifies that this initialization argument initializes the given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". If the initialization"]}),"\n",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:["argument has a value in the call to ",(0,t.jsx)(i,{styled:!0,term:"initialize-instance",children:(0,t.jsx)("b",{children:"initialize-instance"})}),", the value is stored into the given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),", and the slot\u2019s ",":initform"," slot option, if any, is not evaluated. If none of the initialization arguments specified for a given ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," has a value, the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is initialized according to the ",":initform"," slot option, if specified."]}),"\n",(0,t.jsx)(n.p,{children:":type"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":type"," slot option specifies that the contents of the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is always of the specified ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})}),". It effectively declares the result type of the reader generic function when applied to an ",(0,t.jsx)(i,{styled:!0,term:"object",children:(0,t.jsx)("i",{children:"object"})})," of this ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," type. The consequences of attempting to store in a ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," a value that does not satisfy the type of the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is undefined."]}),"\n",(0,t.jsx)(n.p,{children:":default-initargs"}),"\n",(0,t.jsxs)(n.p,{children:["This option is treated the same as it would be ",(0,t.jsx)(i,{styled:!0,term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":documentation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",":documentation"," slot option provides a ",(0,t.jsx)(n.em,{children:"documentation string"})," for the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:":report"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"Condition"})})," reporting is mediated through the ",(0,t.jsx)(i,{styled:!0,term:"print-object",children:(0,t.jsx)("b",{children:"print-object"})})," method for the ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," type in question, with ",(0,t.jsx)(i,{styled:!0,term:"print-escape",children:(0,t.jsx)("b",{children:"*print-escape*"})})," always being ",(0,t.jsx)(i,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),". Specifying (",":report"," ",(0,t.jsx)(n.em,{children:"report-name"}),") in the definition of a condition type C is equivalent to:"]}),"\n",(0,t.jsx)(n.p,{children:"(defmethod print-object ((x c) stream)"}),"\n",(0,t.jsxs)(n.p,{children:["(if *print-escape* (call-next-method) (",(0,t.jsx)(n.em,{children:"report-name"})," x stream)))"]}),"\n",(0,t.jsxs)(n.p,{children:["If the value supplied by the argument to ",":report"," (",(0,t.jsx)(n.em,{children:"report-name"}),") is a ",(0,t.jsx)(i,{styled:!0,term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," or a ",(0,t.jsx)(n.em,{children:"lambda expression"}),", it must be acceptable to ",(0,t.jsx)(i,{styled:!0,term:"function",children:(0,t.jsx)("b",{children:"function"})}),". (function ",(0,t.jsx)(n.em,{children:"report-name"}),") is evaluated in the current ",(0,t.jsx)(n.em,{children:"lexical environment"}),". It should return a ",(0,t.jsx)(i,{styled:!0,term:"function",children:(0,t.jsx)("i",{children:"function"})})," of two arguments, a ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," and a ",(0,t.jsx)(i,{styled:!0,term:"stream",children:(0,t.jsx)("i",{children:"stream"})}),", that prints on the ",(0,t.jsx)(i,{styled:!0,term:"stream",children:(0,t.jsx)("i",{children:"stream"})})," a description of the ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})}),". This ",(0,t.jsx)(i,{styled:!0,term:"function",children:(0,t.jsx)("i",{children:"function"})})," is called whenever the ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," is printed while ",(0,t.jsx)(i,{styled:!0,term:"print-escape",children:(0,t.jsx)("b",{children:"*print-escape*"})})," is ",(0,t.jsx)(i,{styled:!0,term:"nil",children:(0,t.jsx)("b",{children:"nil"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.em,{children:"report-name"})," is a ",(0,t.jsx)(i,{styled:!0,term:"string",children:(0,t.jsx)("i",{children:"string"})}),", it is a shorthand for"]}),"\n",(0,t.jsx)(n.p,{children:"(lambda (condition stream)"}),"\n",(0,t.jsx)(n.p,{children:"(declare (ignore condition))"}),"\n",(0,t.jsxs)(n.p,{children:["(write-string ",(0,t.jsx)(n.em,{children:"report-name"})," stream))"]}),"\n",(0,t.jsxs)(n.p,{children:["This option is processed after the new ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," type has been defined, so use of the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," accessors within the ",":report"," function is permitted. If this option is not supplied, information about how to report this type of ",(0,t.jsx)(i,{styled:!0,term:"condition",children:(0,t.jsx)("i",{children:"condition"})})," is inherited from the ",(0,t.jsx)(n.em,{children:"parent-type"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The consequences are unspecifed if an attempt is made to ",(0,t.jsx)(i,{styled:!0,term:"read",children:(0,t.jsx)("i",{children:"read"})})," a ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," that has not been explicitly initialized and that has not been given a default value."]}),"\n",(0,t.jsxs)(n.p,{children:["The consequences are unspecified if an attempt is made to assign the ",(0,t.jsx)(i,{styled:!0,term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," by using ",(0,t.jsx)(i,{styled:!0,term:"setf",children:(0,t.jsx)("b",{children:"setf"})}),"."]}),"\n",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})}),"\n",(0,t.jsxs)(n.p,{children:["If a ",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," appears as a ",(0,t.jsx)(n.em,{children:"top level form"}),", the ",(0,t.jsx)(i,{styled:!0,term:"compiler",children:(0,t.jsx)("i",{children:"compiler"})})," must make ",(0,t.jsx)(i,{styled:!0,term:"name",children:(0,t.jsx)("i",{children:"name"})})," recognizable as a valid ",(0,t.jsx)(i,{styled:!0,term:"type",children:(0,t.jsx)("i",{children:"type"})})," name, and it must be possible to reference the ",(0,t.jsx)(n.em,{children:"condition type"})," as the ",(0,t.jsx)(n.em,{children:"parent-type"})," of another ",(0,t.jsx)(n.em,{children:"condition type"})," in a subsequent ",(0,t.jsx)(i,{styled:!0,term:"define-condition",children:(0,t.jsx)("b",{children:"define-condition"})})," ",(0,t.jsx)(i,{styled:!0,term:"form",children:(0,t.jsx)("i",{children:"form"})})," in the ",(0,t.jsx)(i,{styled:!0,term:"file",children:(0,t.jsx)("i",{children:"file"})})," being compiled."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:'\nThe following form defines a condition of *type* peg/hole-mismatch which inherits from a condition type called blocks-world-error: \n(define-condition peg/hole-mismatch \n    (blocks-world-error) \n  ((peg-shape :initarg :peg-shape \n\t      :reader peg/hole-mismatch-peg-shape) \n   (hole-shape :initarg :hole-shape \n\t       :reader peg/hole-mismatch-hole-shape)) \n  (:report (lambda (condition stream) \n\t     (format stream "A ~A peg cannot go in a ~A hole." \n\t\t     (peg/hole-mismatch-peg-shape condition) \n\t\t     (peg/hole-mismatch-hole-shape condition))))) \nThe new type has slots peg-shape and hole-shape, so **make-condition** accepts :peg-shape and :hole-shape keywords. The *readers* peg/hole-mismatch-peg-shape and peg/hole-mismatch-hole-shape apply to objects of this type, as illustrated in the :report information. \nThe following form defines a *condition type* named machine-error which inherits from **error**: \n(define-condition machine-error \n    (error) \n  ((machine-name :initarg :machine-name \n\t\t :reader machine-error-machine-name)) \n  (:report (lambda (condition stream) \n\t     (format stream "There is a problem with ~A." \n\t\t     (machine-error-machine-name condition))))) \nBuilding on this definition, a new error condition can be defined which is a subtype of machine-error for use when machines are not available: \n(define-condition machine-not-available-error (machine-error) () \n  (:report (lambda (condition stream) \n\t     (format stream "The machine ~A is not available." \n\t\t     (machine-error-machine-name condition))))) \nThis defines a still more specific condition, built upon machine-not-available-error, which provides a slot initialization form for machine-name but which does not provide any new slots or report information. It just gives the machine-name slot a default initialization: \n(define-condition my-favorite-machine-not-available-error \n    (machine-not-available-error) \n\n  \n  \n  ((machine-name :initform "mc.lcs.mit.edu"))) \nNote that since no :report clause was given, the information inherited from machine-not-available-error is used to report this type of condition. \n(define-condition ate-too-much (error) \n  ((person :initarg :person :reader ate-too-much-person) \n   (weight :initarg :weight :reader ate-too-much-weight) \n   (kind-of-food :initarg :kind-of-food \n\t\t :reader :ate-too-much-kind-of-food))) \n\u2192 ATE-TOO-MUCH \n(define-condition ate-too-much-ice-cream (ate-too-much) \n  ((kind-of-food :initform \u2019ice-cream) \n   (flavor :initarg :flavor \n\t   :reader ate-too-much-ice-cream-flavor \n\t   :initform \u2019vanilla )) \n  (:report (lambda (condition stream) \n\t     (format stream "~A ate too much ~A ice-cream" \n\t\t     (ate-too-much-person condition) \n\t\t     (ate-too-much-ice-cream-flavor condition))))) \n\u2192 ATE-TOO-MUCH-ICE-CREAM \n(make-condition \u2019ate-too-much-ice-cream \n\t\t :person \u2019fred \n\t\t :weight 300 \n\t\t :flavor \u2019chocolate) \n\u2192 #<ATE-TOO-MUCH-ICE-CREAM 32236101> \n(format t "~A" \\*) \n\u25b7 FRED ate too much CHOCOLATE ice-cream \n\u2192 NIL \n\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(i,{styled:!0,term:"make-condition",children:(0,t.jsx)("b",{children:"make-condition"})}),", ",(0,t.jsx)(i,{styled:!0,term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})}),", Section 9.1 (Condition System Concepts)"]})]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}const d={title:"define-condition"},l="define-condition",c={id:"chap-9/j-c-dictionary/define-condition_macro",title:"define-condition",description:"Expanded Reference: define-condition",source:"@site/docs/chap-9/j-c-dictionary/define-condition_macro.md",sourceDirName:"chap-9/j-c-dictionary",slug:"/chap-9/j-c-dictionary/define-condition_macro",permalink:"/cl-language-reference/chap-9/j-c-dictionary/define-condition_macro",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-9/j-c-dictionary/define-condition_macro.md",tags:[],version:"current",frontMatter:{title:"define-condition"},sidebar:"tutorialSidebar",previous:{title:"debugger-hook",permalink:"/cl-language-reference/chap-9/j-c-dictionary/debugger-hook_variable"},next:{title:"error",permalink:"/cl-language-reference/chap-9/j-c-dictionary/error_condition-type"}},h={},a=[{value:"Expanded Reference: define-condition",id:"expanded-reference-define-condition",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"define-condition",children:"define-condition"}),"\n","\n","\n",(0,t.jsx)(o,{}),"\n",(0,t.jsx)(n.h2,{id:"expanded-reference-define-condition",children:"Expanded Reference: define-condition"}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lisp",children:"(define-condition )\n"})})]})}function x(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>o});var t=i(67294);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);