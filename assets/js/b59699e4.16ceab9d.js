"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[82772],{6145:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>w,contentTitle:()=>g,default:()=>T,frontMatter:()=>x,metadata:()=>b,toc:()=>y});var n=o(85893),i=o(11151);function s(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"processing-of-the-user-interface-macros",children:"Processing of the user interface macros"}),"\n",(0,n.jsx)(t.h2,{id:"processing-of-the-user-interface-macros-1",children:"Processing of the user interface macros"}),"\n",(0,n.jsxs)(t.p,{children:["A list in which the first element is one of the symbols ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"}),", ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"}),", ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_4.htm#define-method-combination",children:"define-method-combination"}),", ",(0,n.jsx)(t.code,{children:"generic-function"}),", ",(0,n.jsx)(t.code,{children:"generic-flet"})," or ",(0,n.jsx)(t.code,{children:"generic-labels"}),", and which has proper syntax for that macro is called a ",(0,n.jsx)(t.em,{children:"user interface macro form"}),". This document provides an extended specification of the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," and ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"})," macros."]}),"\n",(0,n.jsxs)(t.p,{children:["The user interface macros ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"}),", ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defgen.htm#defgeneric",children:"defgeneric"})," and ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," can be used not only to define metaobjects that are instances of the corresponding standard metaobject class, but also to define metaobjects that are instances of appropriate portable metaobject classes. To make it possible for portable metaobject classes to properly process the information appearing in the macro form, this document provides a limited specification of the processing of these macro forms."]}),"\n",(0,n.jsxs)(t.p,{children:["User interface macro forms can be ",(0,n.jsx)(t.code,{children:"evaluated"})," or ",(0,n.jsx)(t.code,{children:"compiled"})," and later ",(0,n.jsx)(t.code,{children:"executed"}),". The effect of evaluating or executing a user interface macro form is specified in terms of calls to specified functions and generic functions which provide the actual behavior of the macro. The arguments received by these functions and generic functions are derived in a specified way from the macro form."]}),"\n",(0,n.jsx)(t.p,{children:"Converting a user interface macro form into the arguments to the appropriate functions and generic functions has two major aspects: the conversion of the macro argument syntax into a form more suitable for later processing, and the processing of macro arguments which are forms to be evaluated (including method bodies)."}),"\n",(0,n.jsxs)(t.p,{children:["In the syntax of the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass",children:"defclass"})," macro, the ",(0,n.jsx)(t.em,{children:"initform"})," and ",(0,n.jsx)(t.em,{children:"default-initarg-initial-value-form"})," arguments are forms which will be evaluated one or more times after the macro form is evaluated or executed. Special processing must be done on these arguments to ensure that the lexical scope of the forms is captured properly. This is done by building a function of zero arguments which, when called, returns the result of evaluating the form in the proper lexical environment."]}),"\n",(0,n.jsxs)(t.p,{children:["In the syntax of the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmet.htm#defmethod",children:"defmethod"})," macro the ",(0,n.jsx)(t.em,{children:"form"}),"* argument is a list of forms that comprise the body of the method definition. This list of forms must be processed specially to capture the lexical scope of the macro form. In addition, the lexical functions available only in the body of methods must be introduced. To allow this and any other special processing (such as slot access optimization), a specializable protocol is used for processing the body of methods. This is discussed in ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/processing-method-bodies",children:"the section ``Processing Method Bodies.''"})]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/meta-object-protocol/compile-file-processing-of-the-user-interface-macros",children:"Compile-file processing of the user interface macros."})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsxs)(t.a,{href:"/meta-object-protocol/the-defclass-macro",children:["The ",(0,n.jsx)(t.code,{children:"defclass"})," macro."]})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsxs)(t.a,{href:"/meta-object-protocol/the-defmethod-macro",children:["The ",(0,n.jsx)(t.code,{children:"defmethod"})," macro."]})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/meta-object-protocol/processing-method-bodies",children:"Processing method bodies."})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsxs)(t.a,{href:"/meta-object-protocol/the-defgeneric-macro",children:["The ",(0,n.jsx)(t.code,{children:"defgeneric"})," macro."]})}),"\n"]})]})}function r(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(s,{...e})}):s(e)}function c(e){const t={a:"a",em:"em",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"compile-file-processing-of-the-user-interface-macros",children:"Compile-file processing of the user interface macros"}),"\n",(0,n.jsx)(t.h3,{id:"compile-file-processing-of-the-user-interface-macros-1",children:"Compile-file processing of the user interface macros"}),"\n",(0,n.jsxs)(t.p,{children:["It is common practice for Common Lisp compilers, while processing a file or set of files, to maintain information about the definitions that have been compiled so far. Among other things, this makes it possible to ensure that a global macro definition (",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/m_defmac.htm#defmacro",children:"defmacro"})," form) which appears in a file will affect uses of the macro later in that file. This information about the state of the compilation is called the ",(0,n.jsx)(t.em,{children:"compile-file environment"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"When compiling files containing CLOS definitions, it is useful to maintain certain additional information in the compile-file environment. This can make it possible to issue various kinds of warnings (e.g., lambda list congruence) and to do various performance optimizations that would not otherwise be possible."}),"\n",(0,n.jsx)(t.p,{children:"At this time, there is such significant variance in the way existing Common Lisp implementations handle compile-file environments that it would be premature to specify this mechanism. Consequently, this document specifies only the behavior of evaluating or executing user interface macro forms. What functions and generic functions are called during compile-file processing of a user interface macro form is not specified. Implementations are free to define and document their own behavior. Users may need to check implementation-specific behavior before attempting to compile certain portable programs."})]})}function a(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"the-defclass-macro",children:"The defclass macro"}),"\n",(0,n.jsxs)(t.h3,{id:"the-defclass-macro-1",children:["The ",(0,n.jsx)(t.code,{children:"defclass"})," macro"]}),"\n",(0,n.jsxs)(t.p,{children:["The evaluation or execution of a ",(0,n.jsx)(t.code,{children:"defclass"})," form results in a call to the ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," function. The arguments received by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," are derived from the ",(0,n.jsx)(t.code,{children:"defclass"})," form in a defined way. The exact macro-expansion of the ",(0,n.jsx)(t.code,{children:"defclass"})," form is not defined, only the relationship between the arguments to the ",(0,n.jsx)(t.code,{children:"defclass"})," macro and the arguments received by the ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," function. Examples of typical ",(0,n.jsx)(t.code,{children:"defclass"})," forms and sample expansions are shown in the Figures below."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["(defclass plane (moving-object graphics-object)\n((altitude ",":initform"," 0 ",":accessor"," plane-altitude)\n(speed))\n(",":default-initargs"," ",":engine"," ",(0,n.jsx)(t.em,{children:"jet"}),"))"]}),"\n",(0,n.jsxs)(t.p,{children:["(ensure-class 'plane\n'",":direct-superclasses"," '(moving-object graphics-object)\n'",":direct-slots"," (list (list '",":name"," 'altitude\n'",":initform"," '0\n'",":initfunction"," #'(lambda () 0)\n'",":readers"," '(plane-altitude)\n'",":writers"," '((setf plane-altitude)))\n(list '",":name"," 'speed))\n'",":direct-default-initargs"," (list (list '",":engine","\n'",(0,n.jsx)(t.em,{children:"jet"}),"\n#'(lambda () ",(0,n.jsx)(t.em,{children:"jet"}),"))))"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"defclass"})," form with standard slot and class options and an expansion of it that would result in the proper call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["(defclass sst (plane)\n((mach mag-step 2\nlocator sst-mach\nlocator mach-location\n",":reader"," mach-speed\n",":reader"," mach))\n(",":metaclass"," faster-class)\n(another-option foo bar))"]}),"\n",(0,n.jsxs)(t.p,{children:["(ensure-class 'sst\n'",":direct-superclasses"," '(plane)\n'",":direct-slots"," (list (list '",":name"," 'mach\n'",":readers"," '(mach-speed mach)\n'mag-step '2\n'locator '(sst-mach mach-location)))\n'",":metaclass"," 'faster-class\n'another-option '(foo bar))"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"defclass"})," form with non-standard class and slot options, and an expansion of it which results in the proper call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),". Note that the order of the slot options has not affected the order of the properties in the canonicalized slot specification, but has affected the order of the elements in the lists which are the values of those properties."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"name"})," argument to ",(0,n.jsx)(t.code,{children:"defclass"})," becomes the value of the first argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),". This is the only positional argument accepted by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"; all other arguments are keyword arguments."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"direct-superclasses"})," argument to ",(0,n.jsx)(t.code,{children:"defclass"})," becomes the value of the ",(0,n.jsx)(t.code,{children:":direct-super-classes"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"direct slots"})," argument to ",(0,n.jsx)(t.code,{children:"defclass"})," becomes the value of the ",(0,n.jsx)(t.code,{children:":direct-slots"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),". Special processing of this value is done to regularize the form of each slot specification and to properly capture the lexical scope of the initialization forms. This is done by converting each slot specification to a property list called a ",(0,n.jsx)(t.em,{children:"canonicalized slot specification"}),". The resulting list of canonicalized slot specifications is the value of the ",(0,n.jsx)(t.code,{children:":direct-slots"})," keyword argument."]}),"\n",(0,n.jsxs)(t.p,{children:["Canonicalized slot specifications are later used as the keyword arguments to a generic function which will, in turn, pass them to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," for use as a set of initialization arguments. Each canonicalized slot specification is formed from the corresponding slot specification as follows:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The name of the slot is the value of the ",(0,n.jsx)(t.code,{children:":name"})," property. This property appears in every canonicalized slot specification."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["When the ",(0,n.jsx)(t.code,{children:":initform"})," slot option is present in the slot specification, then both the ",(0,n.jsx)(t.code,{children:":initform"})," and ",(0,n.jsx)(t.code,{children:":initfunction"})," properties are present in the canonicalized slot specification. The value of the ",(0,n.jsx)(t.code,{children:":initform"})," property is the initialization form. The value of the ",(0,n.jsx)(t.code,{children:":initfunction"})," property is a function of zero arguments which, when called, returns the result of evaluating the initialization form in its proper lexical environment."]}),"\n",(0,n.jsxs)(t.p,{children:["If the ",(0,n.jsx)(t.code,{children:":initform"})," slot option is not present in the slot specification, then either the ",(0,n.jsx)(t.code,{children:":initfunction"})," property will not appear, or its value will be false. In such cases, the value of the ",(0,n.jsx)(t.code,{children:":initform"})," property, or whether it appears, is unspecified."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The value of the ",(0,n.jsx)(t.code,{children:":initargs"})," property is a list of the values of each ",(0,n.jsx)(t.code,{children:":initarg"})," slot option. If there are no ",(0,n.jsx)(t.code,{children:":initarg"})," slot options, then either the ",(0,n.jsx)(t.code,{children:":initargs"})," property will not appear or its value will be the empty list."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The value of the ",(0,n.jsx)(t.code,{children:":readers"})," property is a list of the values of each ",(0,n.jsx)(t.code,{children:":reader"})," and ",(0,n.jsx)(t.code,{children:":accessor"})," slot option. If there are no ",(0,n.jsx)(t.code,{children:":reader"})," or ",(0,n.jsx)(t.code,{children:":accessor"})," slot options, then either the ",(0,n.jsx)(t.code,{children:":readers"})," property will not appear or its value will be the empty list."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The value of the ",(0,n.jsx)(t.code,{children:":writers"})," property is a list of the values specified by each ",(0,n.jsx)(t.code,{children:":writer"})," and ",(0,n.jsx)(t.code,{children:":accessor"})," slot option. The value specified by a ",(0,n.jsx)(t.code,{children:":writer"})," slot option is just the value of the slot option. The value specified by an ",(0,n.jsx)(t.code,{children:":accessor"})," slot option is a two element list: the first element is the symbol ",(0,n.jsx)(t.code,{children:"setf"}),", the second element is the value of the slot option. If there are no ",(0,n.jsx)(t.code,{children:":writer"})," or ",(0,n.jsx)(t.code,{children:":accessor"})," slot options, then either the ",(0,n.jsx)(t.code,{children:":writers"})," property will not appear or its value will be the empty list."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The value of the ",(0,n.jsx)(t.code,{children:":documentation"})," property is the value of the ",(0,n.jsx)(t.code,{children:":documentation"})," slot option. If there is no ",(0,n.jsx)(t.code,{children:":documentation"})," slot option, then either the ",(0,n.jsx)(t.code,{children:":documentation"})," property will not appear or its value will be false."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["All other slot options appear as the values of properties with the same name as the slot option. Note that this includes not only the remaining standard slot options (",(0,n.jsx)(t.code,{children:":allocation"})," and ",(0,n.jsx)(t.code,{children:":type"}),"), but also any other options and values appearing in the slot specification. If one of these slot options appears more than once, the value of the property will be a list of the specified values."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["An implementation is free to add additional properties to the canonicalized slot specification provided these are not symbols accessible in the ",(0,n.jsx)(t.code,{children:"common-lisp-user"})," package, or exported by any package defined in the ANSI Common Lisp standard."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Returning to the correspondence between arguments to the ",(0,n.jsx)(t.code,{children:"defclass"})," macro and the arguments received by the ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," function:"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"default initargs"})," class option, if it is present in the ",(0,n.jsx)(t.code,{children:"defclass"})," form, becomes the value of the ",(0,n.jsx)(t.code,{children:":direct-default-initargs"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),". Special processing of this value is done to properly capture the lexical scope of the default value forms. This is done by converting each default initarg in the class option into a ",(0,n.jsx)(t.em,{children:"canonicalized default initarg"}),". The resulting list of canonicalized default initargs is the value of the ",(0,n.jsx)(t.code,{children:":direct-default-initargs"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"A canonicalized default initarg is a list of three elements. The first element is the name; the second is the actual form itself; and the third is a function of zero arguments which, when called, returns the result of evaluating the default value form in its proper lexical environment."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"metaclass"})," class option, if it is present in the ",(0,n.jsx)(t.code,{children:"defclass"})," form, becomes the value of the ",(0,n.jsx)(t.code,{children:":metaclass"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"documentation"})," class option, if it is present in the ",(0,n.jsx)(t.code,{children:"defclass"})," form, becomes the value of the ",(0,n.jsx)(t.code,{children:":documentation"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Any other class options become the value of keyword arguments with the same name. The value of the keyword argument is the tail of the class option. An error is signaled if any class option appears more than once in the ",(0,n.jsx)(t.code,{children:"defclass"})," form."]}),"\n",(0,n.jsxs)(t.p,{children:["In the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"}),", every element of its arguments appears in the same left-to-right order as the corresponding element of the ",(0,n.jsx)(t.code,{children:"defclass"})," form, except that the order of the properties of canonicalized slot specifications is unspecified. The values of properties in canonicalized slot specifications do follow this ordering requirement. Other ordering relationships in the keyword arguments to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," are unspecified."]}),"\n",(0,n.jsxs)(t.p,{children:["The result of the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-class",children:"ensure-class"})," is returned as the result of evaluating or executing the ",(0,n.jsx)(t.code,{children:"defclass"})," form."]})]})}function l(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"the-defmethod-macro",children:"The defmethod macro"}),"\n",(0,n.jsxs)(t.h3,{id:"the-defmethod-macro-1",children:["The ",(0,n.jsx)(t.code,{children:"defmethod"})," macro"]}),"\n",(0,n.jsxs)(t.p,{children:["The evaluation or execution of a ",(0,n.jsx)(t.code,{children:"defmethod"})," form requires first that the body of the method be converted to a method function. This process is described in the next section. The result of this process is a method function and a set of additional initialization arguments to be used when creating the new method. Given these two values, the evaluation or execution of a ",(0,n.jsx)(t.code,{children:"defmethod"})," form proceeds in three steps. The first step ensures the existence of a generic function with the specified name. This is done by calling the function ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),". The first argument in this call is the generic function name specified in the ",(0,n.jsx)(t.code,{children:"defmethod"})," form. The second step is the creation of the new method metaobject by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"}),". The class of the new method metaobject is determined by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/generic-function-method-class",children:"generic-function-method-class"})," on the result of the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," from the first step. The initialization arguments received by the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-instance",children:"make-instance"})," are as follows:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"qualifiers"})," initialization argument is a list of the qualifiers which appeared in the ",(0,n.jsx)(t.code,{children:"defmethod"})," form. No special processing is done on these values. The order of the elements of this list is the same as in the ",(0,n.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"lambda-list"})," initialization argument is the unspecialized lambda list from the ",(0,n.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"specializers"})," initialization argument is a list of the specializers for the method. For specializers which are classes, the specializer is the class metaobject itself. In the case of ",(0,n.jsx)(t.code,{children:"eql"})," specializers, it will be an ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/class-eql-specializer",children:"eql-specializer"})," metaobject obtained by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/intern-eql-specializer",children:"intern-eql-specializer"})," on the result of evaluating the ",(0,n.jsx)(t.code,{children:"eql"})," specializer form in the lexical environment of the ",(0,n.jsx)(t.code,{children:"defmethod"})," form."]}),"\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"function"})," initialization argument is the method function."]}),"\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"declarations"})," initialization argument is a list of the declarations from the ",(0,n.jsx)(t.code,{children:"defmethod"})," form. If there are no declarations in the macro form, this initialization argument either doesn't appear, or appears with a value of the empty list."]}),"\n",(0,n.jsxs)(t.li,{children:["The value of the ",(0,n.jsx)(t.code,{children:"documentation"})," initialization argument is the documentation string from the ",(0,n.jsx)(t.code,{children:"defmethod"})," form. If there is no documentation string in the macro form this initialization argument either doesn't appear, or appears with a value of false."]}),"\n",(0,n.jsx)(t.li,{children:"Any other initialization argument produced in conjunction with the method function are also included."}),"\n",(0,n.jsxs)(t.li,{children:["The implementation is free to include additional initialization arguments provided these are not symbols accessible in the ",(0,n.jsx)(t.code,{children:"common-lisp-user"})," package, or exported by any package defined in the ANSI Common Lisp standard."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In the third step, ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/add-method",children:"add-method"})," is called to add the newly created method to the set of methods associated with the generic function metaobject. The result of the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/add-method",children:"add-method"})," is returned as the result of evaluating or executing the ",(0,n.jsx)(t.code,{children:"defmethod"})," form. An example showing a typical ",(0,n.jsx)(t.code,{children:"defmethod"})," form and a sample expansion is shown in ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/fig-defmethod-1",children:"this figure"}),". The processing of the method body for this method is shown in ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/fig-defmethod-2",children:"this figure"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function f(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"processing-method-bodies",children:"Processing method bodies"}),"\n",(0,n.jsx)(t.h3,{id:"processing-method-bodies-1",children:"Processing method bodies"}),"\n",(0,n.jsx)(t.p,{children:"Before a method can be created, the list of forms comprising the method body must be converted to a method function. This conversion is a two step process."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Note:"})}),"\n",(0,n.jsxs)(t.p,{children:["The body of methods can also appear in the ",(0,n.jsx)(t.code,{children:":initial-methods"})," option of ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/the-defgeneric-macro",children:"defgeneric"})," forms. Initial methods are not considered by any of the protocols specified in this document."]}),"\n",(0,n.jsxs)(t.p,{children:["The first step occurs during macro-expansion of the macro form. In this step, the method lambda list, declarations and body are converted to a lambda expression called a ",(0,n.jsx)(t.em,{children:"method lambda"}),". This conversion is based on information associated with the generic function definition in effect at the time the macro form is expanded."]}),"\n",(0,n.jsxs)(t.p,{children:["The generic function definition is obtained by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," with a first argument of the generic function name specified in the macro form. The ",(0,n.jsx)(t.code,{children:":lambda-list"})," keyword argument is not passed in this call."]}),"\n",(0,n.jsxs)(t.p,{children:["Given the generic function, production of the method lambda proceeds by calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"}),". The first argument in this call is the generic function obtained as described above. The second argument is the result of calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/class-prototype",children:"class-prototype"})," on the result of calling ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/generic-function-method-class",children:"generic-function-method-class"})," on the generic function. The third argument is a lambda expression formed from the method lambda list, declarations and body. The fourth argument is the macro-expansion environment of the macro form; this is the value of the ",(0,n.jsx)(t.code,{children:"&environment"})," argument to the ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/the-defmethod-macro",children:"defmethod"})," macro."]}),"\n",(0,n.jsxs)(t.p,{children:["The generic function ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/make-method-lambda",children:"make-method-lambda"})," returns two values. The first is the method lambda itself. The second is a list of initialization arguments and values. These are included in the initialization arguments when the method is created."]}),"\n",(0,n.jsxs)(t.p,{children:["In the second step, the method lambda is converted to a function which properly captures the lexical scope of the macro form. This is done by having the method lambda appear in the macro-expansion as the argument of the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/s_fn.htm",children:"function"})," special form. During the subsequent evaluation of the macro-expansion, the result of the ",(0,n.jsx)(t.a,{href:"http://www.lispworks.com/documentation/HyperSpec/Body/s_fn.htm",children:"function"})," special form is the methodfunction."]})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(f,{...e})}):f(e)}function u(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"the-defgeneric-macro",children:"The defgeneric macro"}),"\n",(0,n.jsxs)(t.h3,{id:"the-defgeneric-macro-1",children:["The ",(0,n.jsx)(t.code,{children:"defgeneric"})," macro"]}),"\n",(0,n.jsxs)(t.p,{children:["The evaluation or execution of a ",(0,n.jsx)(t.code,{children:"defgeneric"})," form results in a call to the ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," function. The arguments received by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," are derived from the ",(0,n.jsx)(t.code,{children:"defgeneric"})," form in a defined way. As with ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/the-defclass-macro",children:"defclass"})," and ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/the-defmethod-macro",children:"defmethod"}),", the exact macro-expansion of the ",(0,n.jsx)(t.code,{children:"defgeneric"})," form is not defined, only the relationship between the arguments to the macro and the arguments received by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),"."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"function-name"})," argument to ",(0,n.jsx)(t.code,{children:"defgeneric"})," becomes the first argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),". This is the only positional argument accepted by ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),"; all other arguments are keyword arguments."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"lambda-list"})," argument to ",(0,n.jsx)(t.code,{children:"defgeneric"})," becomes the value of the ",(0,n.jsx)(t.code,{children:":lambda-list"})," keyword argument to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["For each of the options ",(0,n.jsx)(t.code,{children:":argument-precedence-order"}),", ",(0,n.jsx)(t.code,{children:":documentation"}),", ",(0,n.jsx)(t.code,{children:":generic-function-class"})," and ",(0,n.jsx)(t.code,{children:":method-class"}),", the value of the option becomes the value of the keyword argument with the same name. If the option does not appear in the macro form, the keyword argument does not appear in the resulting call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["For the option ",(0,n.jsx)(t.code,{children:"declare"}),", the list of declarations becomes the value of the ",(0,n.jsx)(t.code,{children:":declarations"})," keyword argument. If the ",(0,n.jsx)(t.code,{children:"declare"})," option does not appear in the macro form, the ",(0,n.jsx)(t.code,{children:":declarations"})," keyword argument does not appear in the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["The handling of the ",(0,n.jsx)(t.code,{children:":method-combination"})," option is not specified."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The result of the call to ",(0,n.jsx)(t.a,{href:"/meta-object-protocol/ensure-generic-function",children:"ensure-generic-function"})," is returned as the result of evaluating or executing the ",(0,n.jsx)(t.code,{children:"defgeneric"})," form."]})]})}function j(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}const x={title:"5.4 Processing Of The User Interface Macros"},g=void 0,b={id:"meta-object-protocol/chap-5/5-4-processing",title:"5.4 Processing Of The User Interface Macros",description:"5.4.1 Compile File Processing Of The User Interface Macros",source:"@site/docs/meta-object-protocol/chap-5/5-4-processing.md",sourceDirName:"meta-object-protocol/chap-5",slug:"/meta-object-protocol/chap-5/5-4-processing",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-4-processing",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/meta-object-protocol/chap-5/5-4-processing.md",tags:[],version:"current",lastUpdatedBy:"Daniel Nussenbaum",frontMatter:{title:"5.4 Processing Of The User Interface Macros"},sidebar:"tutorialSidebar",previous:{title:"5.3 Inheritance Structure Of Metaobject Classes",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-3-inheritance"},next:{title:"5.5 Subprotocols",permalink:"/cl-language-reference/meta-object-protocol/chap-5/5-5-subprotocols"}},w={},y=[{value:"5.4.1 Compile File Processing Of The User Interface Macros",id:"541-compile-file-processing-of-the-user-interface-macros",level:2},{value:"5.4.2 The Defclass Macro",id:"542-the-defclass-macro",level:2},{value:"5.4.3 The Defmethod Macro",id:"543-the-defmethod-macro",level:2},{value:"5.4.4 Processing Method Bodies",id:"544-processing-method-bodies",level:2},{value:"5.4.5 The Defgeneric Macro",id:"545-the-defgeneric-macro",level:2}];function v(e){const t={h2:"h2",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r,{}),"\n",(0,n.jsx)(t.h2,{id:"541-compile-file-processing-of-the-user-interface-macros",children:"5.4.1 Compile File Processing Of The User Interface Macros"}),"\n","\n",(0,n.jsx)(a,{}),"\n",(0,n.jsx)(t.h2,{id:"542-the-defclass-macro",children:"5.4.2 The Defclass Macro"}),"\n","\n",(0,n.jsx)(l,{}),"\n",(0,n.jsx)(t.h2,{id:"543-the-defmethod-macro",children:"5.4.3 The Defmethod Macro"}),"\n","\n",(0,n.jsx)(m,{}),"\n",(0,n.jsx)(t.h2,{id:"544-processing-method-bodies",children:"5.4.4 Processing Method Bodies"}),"\n","\n",(0,n.jsx)(p,{}),"\n",(0,n.jsx)(t.h2,{id:"545-the-defgeneric-macro",children:"5.4.5 The Defgeneric Macro"}),"\n","\n","\n",(0,n.jsx)(j,{})]})}function T(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(v,{...e})}):v(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>c,a:()=>r});var n=o(67294);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);