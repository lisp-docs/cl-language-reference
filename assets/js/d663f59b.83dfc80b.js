"use strict";(globalThis.webpackChunkcl_language_reference=globalThis.webpackChunkcl_language_reference||[]).push([[34238],{28453:(e,s,i)=>{i.d(s,{R:()=>l,x:()=>c});var n=i(96540);const t={},r=n.createContext(t);function l(e){const s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(r.Provider,{value:s},e.children)}},44849:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>y,contentTitle:()=>b,default:()=>w,frontMatter:()=>p,metadata:()=>n,toc:()=>g});const n=JSON.parse('{"id":"chap-7/h-f-slots","title":"7.5 Slots","description":"7.5.1 Introduction to Slots","source":"@site/docs/chap-7/h-f-slots.md","sourceDirName":"chap-7","slug":"/chap-7/h-f-slots","permalink":"/cl-language-reference/chap-7/h-f-slots","draft":false,"unlisted":false,"editUrl":"https://github.com/lisp-docs/cl-language-reference/tree/main/docs/chap-7/h-f-slots.md","tags":[],"version":"current","lastUpdatedBy":"Daniel Nussenbaum","frontMatter":{"title":"7.5 Slots"},"sidebar":"tutorialSidebar","previous":{"title":"7.4 Meta","permalink":"/cl-language-reference/chap-7/h-e-metaobjects"},"next":{"title":"7.6 Generic Functions and Methods","permalink":"/cl-language-reference/chap-7/h-g-generic-functions-and-methods"}}');var t=i(74848),r=i(28453);function l(e){return(0,t.jsx)(t.Fragment,{})}function c(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l()}function d(e){const s={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:n}=s;return i||o("DictionaryLink",!0),n||o("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["An ",(0,t.jsx)(n,{term:"object",children:(0,t.jsx)("i",{children:"object"})})," of ",(0,t.jsx)(n,{term:"metaclass",children:(0,t.jsx)("i",{children:"metaclass"})})," ",(0,t.jsx)(i,{term:"standard-class",children:(0,t.jsx)("b",{children:"standard-class"})})," has zero or more named ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})}),". The ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," of an ",(0,t.jsx)(n,{term:"object",children:(0,t.jsx)("i",{children:"object"})})," are determined by the ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," of the ",(0,t.jsx)(n,{term:"object",children:(0,t.jsx)("i",{children:"object"})}),". Each ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," can hold one value. The ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," of a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is a ",(0,t.jsx)(n,{term:"symbol",children:(0,t.jsx)("i",{children:"symbol"})})," that is syntactically valid for use as a variable name."]}),"\n",(0,t.jsxs)(s.p,{children:["When a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," does not have a value, the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is said to be ",(0,t.jsx)(n,{term:"unbound",children:(0,t.jsx)("i",{children:"unbound"})}),". When an unbound ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is read, the ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," ",(0,t.jsx)(i,{term:"slot-unbound",children:(0,t.jsx)("b",{children:"slot-unbound"})})," is invoked. The system-supplied primary ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," for ",(0,t.jsx)(i,{term:"slot-unbound",children:(0,t.jsx)("b",{children:"slot-unbound"})})," on ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," ",(0,t.jsx)(i,{term:"t",children:(0,t.jsx)("b",{children:"t"})})," signals an error. If ",(0,t.jsx)(i,{term:"slot-unbound",children:(0,t.jsx)("b",{children:"slot-unbound"})})," returns, its ",(0,t.jsx)(n,{styled:!0,term:"primary value",children:(0,t.jsx)("i",{children:"primary value"})})," is used that time as the ",(0,t.jsx)(n,{term:"value",children:(0,t.jsx)("i",{children:"value"})})," of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The default initial value form for a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is defined by the ",":initform"," slot option. When the ",":initform"," form is used to supply a value, it is evaluated in the lexical environment in which the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form was evaluated. The ",":initform"," along with the lexical environment in which the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form was evaluated is called a ",(0,t.jsx)(n,{styled:!0,term:"captured initialization form",children:(0,t.jsx)("i",{children:"captured initialization form"})}),". For more details, see Section 7.1 (Object Creation and Initialization)."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})})," is defined to be a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," that is ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," to exactly one ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})}),", namely the one in which the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is allocated. A ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," is defined to be a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," that is visible to more than one ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of a given ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," and its ",(0,t.jsx)(s.em,{children:"subclasses"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," is said to define a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," with a given ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," when the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form for that ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," contains a ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," with that ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})}),". Defining a ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})})," does not immediately create a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"; it causes a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," to be created each time an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of the ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," is created. Defining a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," immediately creates a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",":allocation"," slot option to ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," controls the kind of ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," that is defined. If the value of the ",":allocation"," slot option is ",":instance",", a ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})})," is created. If the value of ",":allocation"," is ",":class",", a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," is created."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is said to be ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," in an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of a ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," if the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is defined by the ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," of the ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," or is inherited from a ",(0,t.jsx)(n,{term:"superclass",children:(0,t.jsx)("i",{children:"superclass"})})," of that ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})}),". At most one ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," of a given ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," can be ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," in an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})}),". A ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," defined by a ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," is ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," in all ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instances"})})," of that ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})}),". A detailed explanation of the inheritance of ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," is given in Section 7.5.3 (Inheritance of Slots and Slot Options)."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function o(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function a(e){const s={em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:n}=s;return i||j("DictionaryLink",!0),n||j("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:[(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"Slots"})})," can be ",(0,t.jsx)(s.em,{children:"accessed"})," in two ways: by use of the primitive function ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})})," and by use of ",(0,t.jsx)(s.em,{children:"generic functions"})," generated by the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(n,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})})," can be used with any of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," names specified in the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form to ",(0,t.jsx)(n,{term:"access",children:(0,t.jsx)("i",{children:"access"})})," a specific ",(0,t.jsx)(s.em,{children:"slot accessible"})," in an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of the given ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The macro ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," provides syntax for generating ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," to read and write ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})}),". If a reader ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is requested, a ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is automatically generated for reading the value of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),", but no ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," for storing a value into it is generated. If a writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is requested, a ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is automatically generated for storing a value into the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),", but no ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," for reading its value is generated. If an accessor ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is requested, a ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," for reading the value of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," and a ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," for storing a value into the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," are automatically generated. Reader and writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})]}),"\n",(0,t.jsxs)(s.p,{children:["are implemented using ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["When a reader or writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is specified for a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),", the name of the ",(0,t.jsx)(s.em,{children:"generic function"})," to which the generated ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," belongs is directly specified. If the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," specified for the writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is the symbol name, the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," of the ",(0,t.jsx)(s.em,{children:"generic function"})," for writing the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the symbol name, and the ",(0,t.jsx)(s.em,{children:"generic function"})," takes two arguments: the new value and the ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})}),", in that order. If the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," specified for the accessor ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," is the symbol name, the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," of the ",(0,t.jsx)(s.em,{children:"generic function"})," for reading"]}),"\n",(0,t.jsxs)(s.p,{children:["the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the symbol name, and the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," of the ",(0,t.jsx)(s.em,{children:"generic function"})," for writing the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the list (setf name)."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})})," created or modified by supplying ",":reader",", ",":writer",", or ",":accessor"," ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," options can be treated exactly as an ordinary ",(0,t.jsx)(n,{styled:!0,term:"generic function",children:(0,t.jsx)("i",{children:"generic function"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Note that ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})})," can be used to read or write the value of a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," whether or not reader or writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," exist for that ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". When ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})})," is used, no reader or writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," are invoked."]}),"\n",(0,t.jsxs)(s.p,{children:["The macro ",(0,t.jsx)(i,{term:"with-slots",children:(0,t.jsx)("b",{children:"with-slots"})})," can be used to establish a ",(0,t.jsx)(n,{styled:!0,term:"lexical environment",children:(0,t.jsx)("i",{children:"lexical environment"})})," in which specified ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," are lexically available as if they were variables. The macro ",(0,t.jsx)(i,{term:"with-slots",children:(0,t.jsx)("b",{children:"with-slots"})})," invokes the ",(0,t.jsx)(n,{term:"function",children:(0,t.jsx)("i",{children:"function"})})," ",(0,t.jsx)(i,{term:"slot-value",children:(0,t.jsx)("b",{children:"slot-value"})})," to ",(0,t.jsx)(n,{term:"access",children:(0,t.jsx)("i",{children:"access"})})," the specified ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The macro ",(0,t.jsx)(i,{term:"with-accessors",children:(0,t.jsx)("b",{children:"with-accessors"})})," can be used to establish a lexical environment in which specified ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," are lexically available through their accessors as if they were variables. The macro ",(0,t.jsx)(i,{term:"with-accessors",children:(0,t.jsx)("b",{children:"with-accessors"})})," invokes the appropriate accessors to ",(0,t.jsx)(n,{term:"access",children:(0,t.jsx)("i",{children:"access"})})," the specified ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})}),"."]})]})}function x(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function j(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}function m(e){const s={code:"code",em:"em",p:"p",...(0,r.R)(),...e.components},{DictionaryLink:i,GlossaryTerm:n}=s;return i||u("DictionaryLink",!0),n||u("GlossaryTerm",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["The set of the ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"names"})})," of all ",(0,t.jsx)(s.em,{children:"slots accessible"})," in an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of a ",(0,t.jsx)(s.em,{children:"class C"})," is the union of the sets of ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"names"})})," of ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slots"})})," defined by ",(0,t.jsx)(s.em,{children:"C"})," and its ",(0,t.jsx)(s.em,{children:"superclasses"}),". The structure of an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," is the set of ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"names"})})," of ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slots"})})," in that ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["In the simplest case, only one ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," among ",(0,t.jsx)(s.em,{children:"C"})," and its ",(0,t.jsx)(s.em,{children:"superclasses"})," defines a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," with a given ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," name. If a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is defined by a ",(0,t.jsx)(n,{term:"superclass",children:(0,t.jsx)("i",{children:"superclass"})})," of ",(0,t.jsx)(s.em,{children:"C"}),", the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is said to be inherited. The characteristics of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," are determined by the ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," of the defining ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})}),". Consider the defining ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," for a slot ",(0,t.jsx)(s.em,{children:"S"}),". If the value of the ",(0,t.jsx)(s.code,{children:":allocation"})," slot option is ",":instance",", then ",(0,t.jsx)(s.em,{children:"S"})," is a ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})})," and each ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of ",(0,t.jsx)(s.em,{children:"C"})," has its own ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," named ",(0,t.jsx)(s.em,{children:"S"})," that stores its own value. If the value of the ",(0,t.jsx)(s.code,{children:":allocation"})," slot option is ",(0,t.jsx)(s.code,{children:":class"}),", then ",(0,t.jsx)(s.em,{children:"S"})," is a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})}),", the ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," that defined ",(0,t.jsx)(s.em,{children:"S"})," stores the value, and all ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instances"})})," of ",(0,t.jsx)(s.em,{children:"C"})," can ",(0,t.jsx)(n,{term:"access",children:(0,t.jsx)("i",{children:"access"})})," that single ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". If the ",(0,t.jsx)(s.code,{children:":allocation"})," slot option is omitted, ",":instance"," is used."]}),"\n",(0,t.jsxs)(s.p,{children:["In general, more than one ",(0,t.jsx)(n,{term:"class",children:(0,t.jsx)("i",{children:"class"})})," among ",(0,t.jsx)(s.em,{children:"C"})," and its ",(0,t.jsx)(s.em,{children:"superclasses"})," can define a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," with a given ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})}),". In such cases, only one ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," with the given name is ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," in an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of ",(0,t.jsx)(s.em,{children:"C"}),", and the characteristics of that ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," are a combination of the several ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," specifiers, computed as follows:"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"\u2022"})," All the ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifiers"})})," for a given ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," name are ordered from most specific to least specific, according to the order in ",(0,t.jsx)(s.em,{children:"C"}),"\u2019s ",(0,t.jsx)(n,{styled:!0,term:"class precedence list",children:(0,t.jsx)("i",{children:"class precedence list"})})," of the ",(0,t.jsx)(s.em,{children:"classes"})," that define them. All references to the specificity of ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifiers"})})," immediately below refers to this ordering."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"\u2022"})," The allocation of a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is controlled by the most specific ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," . If the most specific ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," does not contain an ",(0,t.jsx)(s.code,{children:":allocation"})," slot option, ",":instance"," is used. Less specific ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifiers"})})," do not affect the allocation."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"\u2022"})," The default initial value form for a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the value of the ",":initform"," slot option in the most specific ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," that contains one. If no ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," contains an ",":initform"," slot option, the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," has no default initial value form."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)("i",{children:"\u2022"})," The contents of a ",(0,t.jsx)("i",{children:"slot"})," will always be of type (and ",(0,t.jsx)("i",{children:"T"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . T",(0,t.jsx)("sub",{children:"n"})]}),") where ",(0,t.jsx)("i",{children:"T"}),(0,t.jsx)("sub",{children:"1"})," ",(0,t.jsxs)("i",{children:[". . . T",(0,t.jsx)("sub",{children:"n"})]})," are the values of the ",":type"," slot options contained in all of the ",(0,t.jsx)("i",{children:"slot specifiers"}),". If no ",(0,t.jsx)("i",{children:"slot specifier"})," contains the ",":type"," slot option, the contents of the ",(0,t.jsx)("i",{children:"slot"})," will always be of ",(0,t.jsx)("i",{children:"type"})," ",(0,t.jsx)("b",{children:"t"}),". The consequences of attempting to store in a ",(0,t.jsx)("i",{children:"slot"})," a value that does not satisfy the ",(0,t.jsx)("i",{children:"type"})," of the ",(0,t.jsx)("i",{children:"slot"})," are undefined."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"\u2022"})," The set of initialization arguments that initialize a given ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the union of the initialization arguments declared in the ",":initarg"," slot options in all the ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifiers"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.em,{children:"\u2022"})," The ",(0,t.jsx)(n,{styled:!0,term:"documentation string",children:(0,t.jsx)("i",{children:"documentation string"})})," for a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is the value of the ",":documentation"," slot option in the most specific ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," specifier that contains one. If no ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," contains a ",":documentation"," slot option, the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," has no ",(0,t.jsx)(n,{styled:!0,term:"documentation string",children:(0,t.jsx)("i",{children:"documentation string"})}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["A consequence of the allocation rule is that a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," can be ",(0,t.jsx)(s.em,{children:"shadowed"}),". For example, if a class ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," defines a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," named ",(0,t.jsx)(s.em,{children:"S"})," whose value for the ",(0,t.jsx)(s.code,{children:":allocation"})," slot option is ",(0,t.jsx)(s.code,{children:":class"}),", that ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is ",(0,t.jsx)(n,{term:"accessible",children:(0,t.jsx)("i",{children:"accessible"})})," in ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instances"})})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," and all of its ",(0,t.jsx)(s.em,{children:"subclasses"}),". However, if ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," is a ",(0,t.jsx)(n,{term:"subclass",children:(0,t.jsx)("i",{children:"subclass"})})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," and also defines a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," named ",(0,t.jsx)(s.em,{children:"S"}),", ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"}),"\u2019s ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is not shared by ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instances"})})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," and its ",(0,t.jsx)(s.em,{children:"subclasses"}),". When a class ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," defines a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})}),", any subclass ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," will share this single ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," unless the ",(0,t.jsx)(i,{term:"defclass",children:(0,t.jsx)("b",{children:"defclass"})})," form for ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," specifies a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," of the same ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})})," or there is a ",(0,t.jsx)(n,{term:"superclass",children:(0,t.jsx)("i",{children:"superclass"})})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," that precedes ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"1"})," in the ",(0,t.jsx)(n,{styled:!0,term:"class precedence list",children:(0,t.jsx)("i",{children:"class precedence list"})})," of ",(0,t.jsx)(s.em,{children:"C"}),(0,t.jsx)("sub",{children:"2"})," that defines a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," of the same name."]}),"\n",(0,t.jsxs)(s.p,{children:["A consequence of the type rule is that the value of a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," satisfies the type constraint of each ",(0,t.jsx)(n,{styled:!0,term:"slot specifier",children:(0,t.jsx)("i",{children:"slot specifier"})})," that contributes to that ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". Because the result of attempting to store in a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," a value that does not satisfy the type constraint for the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," is undefined, the value in a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," might fail to satisfy its type constraint."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:":reader"}),", ",(0,t.jsx)(s.code,{children:":writer"}),", and ",(0,t.jsx)(s.code,{children:":accessor"})," slot options create ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," rather than define the characteristics of a ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),". Reader and writer ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"methods"})})," are inherited in the sense described in Section 7.6.7 (Inheritance of Methods)."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"Methods"})})," that ",(0,t.jsx)(s.em,{children:"access slots"})," use only the name of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})})," and the ",(0,t.jsx)(n,{term:"type",children:(0,t.jsx)("i",{children:"type"})})," of the ",(0,t.jsx)(n,{term:"slot",children:(0,t.jsx)("i",{children:"slot"})}),"\u2019s value. Suppose a ",(0,t.jsx)(n,{term:"superclass",children:(0,t.jsx)("i",{children:"superclass"})})," provides a ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," that expects to ",(0,t.jsx)(n,{term:"access",children:(0,t.jsx)("i",{children:"access"})})," a ",(0,t.jsx)(n,{styled:!0,term:"shared slot",children:(0,t.jsx)("i",{children:"shared slot"})})," of a given ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})}),", and a ",(0,t.jsx)(n,{term:"subclass",children:(0,t.jsx)("i",{children:"subclass"})})," defines a ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})})," with the same ",(0,t.jsx)(n,{term:"name",children:(0,t.jsx)("i",{children:"name"})}),". If the ",(0,t.jsx)(n,{term:"method",children:(0,t.jsx)("i",{children:"method"})})," provided by the ",(0,t.jsx)(n,{term:"superclass",children:(0,t.jsx)("i",{children:"superclass"})})," is used on an ",(0,t.jsx)(n,{term:"instance",children:(0,t.jsx)("i",{children:"instance"})})," of the ",(0,t.jsx)(n,{term:"subclass",children:(0,t.jsx)("i",{children:"subclass"})}),", the ",(0,t.jsx)(s.em,{children:"method accesses"})," the ",(0,t.jsx)(n,{styled:!0,term:"local slot",children:(0,t.jsx)("i",{children:"local slot"})}),"."]})]})}function f(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}function u(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}const p={title:"7.5 Slots"},b="7.5 Slots",y={},g=[{value:"7.5.1 Introduction to Slots",id:"751-introduction-to-slots",level:2},{value:"7.5.2 Accessing Slots",id:"752-accessing-slots",level:2},{value:"7.5.3 Inheritance of Slots and Slot Options",id:"753-inheritance-of-slots-and-slot-options",level:2}];function v(e){const s={h1:"h1",h2:"h2",header:"header",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"75-slots",children:"7.5 Slots"})}),"\n","\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(s.h2,{id:"751-introduction-to-slots",children:"7.5.1 Introduction to Slots"}),"\n","\n",(0,t.jsx)(h,{}),"\n",(0,t.jsx)(s.h2,{id:"752-accessing-slots",children:"7.5.2 Accessing Slots"}),"\n","\n",(0,t.jsx)(x,{}),"\n",(0,t.jsx)(s.h2,{id:"753-inheritance-of-slots-and-slot-options",children:"7.5.3 Inheritance of Slots and Slot Options"}),"\n","\n",(0,t.jsx)(f,{})]})}function w(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(v,{...e})}):v(e)}}}]);