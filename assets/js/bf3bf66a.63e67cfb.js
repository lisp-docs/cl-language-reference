"use strict";(self.webpackChunkcl_language_reference=self.webpackChunkcl_language_reference||[]).push([[50175],{31059:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>j,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var r=t(85893),i=t(11151);function s(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components},{ClLinks:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("ClLinks",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"make-load-form"})," ",(0,r.jsx)(n.em,{children:"Standard Generic Function"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," &optional ",(0,r.jsx)(n.em,{children:"environment \u2192 creation-form"}),"[",(0,r.jsx)(n.em,{children:", initialization-form"}),"]"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method Signatures:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," (",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," ",(0,r.jsx)(t,{styled:!0,term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})}),") &optional ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," (",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," ",(0,r.jsx)(t,{styled:!0,term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})}),") &optional ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," (",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," ",(0,r.jsx)(t,{styled:!0,term:"condition",children:(0,r.jsx)("b",{children:"condition"})}),") &optional ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," (",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("b",{children:"class"})}),") &optional ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Arguments and Values:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),"\u2014an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),"\u2014an ",(0,r.jsx)(n.em,{children:"environment object"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"creation-form"}),"\u2014a ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"initialization-form"}),"\u2014a ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"generic function"})," ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," creates and returns one or two ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})}),", a ",(0,r.jsx)(n.em,{children:"creation-form"})," and an ",(0,r.jsx)(n.em,{children:"initialization-form"}),", that enable ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})})," to construct an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," equivalent to ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),". ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"Environment"})})," is an ",(0,r.jsx)(n.em,{children:"environment object"})," corresponding to the ",(0,r.jsx)(n.em,{children:"lexical environment"})," in which the ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})})," will be processed."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"file compiler"})," calls ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," to process certain ",(0,r.jsx)(n.em,{children:"classes"})," of ",(0,r.jsx)(n.em,{children:"literal objects"}),"; see Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Conforming programs"})," may call ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," directly, providing ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," is a ",(0,r.jsx)(n.em,{children:"generalized instance"})," of ",(0,r.jsx)(t,{styled:!0,term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})}),", ",(0,r.jsx)(t,{styled:!0,term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})}),", or ",(0,r.jsx)(t,{styled:!0,term:"condition",children:(0,r.jsx)("b",{children:"condition"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The creation form is a ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})})," that, when evaluated at ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})})," time, should return an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," that is equivalent to ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),". The exact meaning of equivalent depends on the ",(0,r.jsx)(t,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," of ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," and is up to the programmer who defines a ",(0,r.jsx)(t,{styled:!0,term:"method",children:(0,r.jsx)("i",{children:"method"})})," for ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),"; see Section 3.2.4 (Literal Objects in Compiled Files)."]}),"\n",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),"\n",(0,r.jsxs)(n.p,{children:["The initialization form is a ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})})," that, when evaluated at ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})})," time, should perform further initialization of the ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),". The value returned by the initialization form is ignored. If ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," returns only one value, the initialization form is ",(0,r.jsx)(t,{styled:!0,term:"nil",children:(0,r.jsx)("b",{children:"nil"})}),", which has no effect. If ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," appears as a constant in the initialization form, at ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})})," time it will be replaced by the equivalent ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," constructed by the creation form; this is how the further initialization gains access to the ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Both the ",(0,r.jsx)(n.em,{children:"creation-form"})," and the ",(0,r.jsx)(n.em,{children:"initialization-form"})," may contain references to any ",(0,r.jsx)(n.em,{children:"externalizable object"}),". However, there must not be any circular dependencies in creation forms. An example of a circular dependency is when the creation form for the object X contains a reference to the object Y, and the creation form for the object Y contains a reference to the object X. Initialization forms are not subject to any restriction against circular dependencies, which is the reason that initialization forms exist; see the example of circular data structures below."]}),"\n",(0,r.jsxs)(n.p,{children:["The creation form for an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," is always ",(0,r.jsx)(n.em,{children:"evaluated"})," before the initialization form for that ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})}),". When either the creation form or the initialization form references other ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," that have not been referenced earlier in the ",(0,r.jsx)(t,{styled:!0,term:"file",children:(0,r.jsx)("i",{children:"file"})})," being ",(0,r.jsx)(n.em,{children:"compiled"}),", the ",(0,r.jsx)(t,{styled:!0,term:"compiler",children:(0,r.jsx)("i",{children:"compiler"})})," ensures that all of the referenced ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," have been created before ",(0,r.jsx)(n.em,{children:"evaluating"})," the referencing ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})}),". When the referenced ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," is of a ",(0,r.jsx)(t,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," which the ",(0,r.jsx)(n.em,{children:"file compiler"})," processes using ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),", this involves ",(0,r.jsx)(n.em,{children:"evaluating"})," the creation form returned for it. (This is the reason for the prohibition against circular references among creation forms)."]}),"\n",(0,r.jsxs)(n.p,{children:["Each initialization form is ",(0,r.jsx)(n.em,{children:"evaluated"})," as soon as possible after its associated creation form, as determined by data flow. If the initialization form for an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," does not reference any other ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," not referenced earlier in the ",(0,r.jsx)(t,{styled:!0,term:"file",children:(0,r.jsx)("i",{children:"file"})})," and processed by the ",(0,r.jsx)(n.em,{children:"file compiler"})," using ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),", the initialization form is evaluated immediately after the creation form. If a creation or initialization form ",(0,r.jsx)(n.em,{children:"F"})," does contain references to such ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})}),", the creation forms for those other objects are evaluated before ",(0,r.jsx)(n.em,{children:"F"}),", and the initialization forms for those other ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," are also evaluated before ",(0,r.jsx)(n.em,{children:"F"})," whenever they do not depend on the ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," created or initialized by ",(0,r.jsx)(n.em,{children:"F"}),". Where these rules do not uniquely determine an order of ",(0,r.jsx)(t,{styled:!0,term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})})," between two creation/initialization forms, the order of ",(0,r.jsx)(t,{styled:!0,term:"evaluation",children:(0,r.jsx)("i",{children:"evaluation"})})," is unspecified."]}),"\n",(0,r.jsxs)(n.p,{children:["While these creation and initialization forms are being evaluated, the ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," are possibly in an uninitialized state, analogous to the state of an ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"object"})})," between the time it has been created by ",(0,r.jsx)(t,{styled:!0,term:"allocate-instance",children:(0,r.jsx)("b",{children:"allocate-instance"})})," and it has been processed fully by ",(0,r.jsx)(t,{styled:!0,term:"initialize-instance",children:(0,r.jsx)("b",{children:"initialize-instance"})}),". Programmers writing"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"method",children:(0,r.jsx)("i",{children:"methods"})})," for ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," must take care in manipulating ",(0,r.jsx)(t,{styled:!0,term:"object",children:(0,r.jsx)("i",{children:"objects"})})," not to depend on ",(0,r.jsx)(t,{styled:!0,term:"slot",children:(0,r.jsx)("i",{children:"slots"})})," that have not yet been initialized."]}),"\n",(0,r.jsxs)(n.p,{children:["It is ",(0,r.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," whether ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})})," calls ",(0,r.jsx)(t,{styled:!0,term:"eval",children:(0,r.jsx)("b",{children:"eval"})})," on the ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})})," or does some other operation that has an equivalent effect. For example, the ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})})," might be translated into different but equivalent ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})})," and then evaluated, they might be compiled and the resulting functions called by ",(0,r.jsx)(t,{styled:!0,term:"load",children:(0,r.jsx)("b",{children:"load"})}),", or they might be interpreted by a special-purpose function different from ",(0,r.jsx)(t,{styled:!0,term:"eval",children:(0,r.jsx)("b",{children:"eval"})}),". All that is required is that the effect be equivalent to evaluating the ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"method specialized"})," on ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("b",{children:"class"})})," returns a creation ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})})," using the ",(0,r.jsx)(t,{styled:!0,term:"name",children:(0,r.jsx)("i",{children:"name"})})," of the ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," if the ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," has a ",(0,r.jsx)(n.em,{children:"proper name"})," in ",(0,r.jsx)(t,{styled:!0,term:"environment",children:(0,r.jsx)("i",{children:"environment"})}),", signaling an error of ",(0,r.jsx)(t,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(t,{styled:!0,term:"error",children:(0,r.jsx)("b",{children:"error"})})," if it does not have a ",(0,r.jsx)(n.em,{children:"proper name"}),". ",(0,r.jsx)(n.em,{children:"Evaluation"})," of the creation ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})})," uses the ",(0,r.jsx)(t,{styled:!0,term:"name",children:(0,r.jsx)("i",{children:"name"})})," to find the ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," with that ",(0,r.jsx)(t,{styled:!0,term:"name",children:(0,r.jsx)("i",{children:"name"})}),", as if by"]}),"\n",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"calling"})," ",(0,r.jsx)(t,{styled:!0,term:"find-class",children:(0,r.jsx)("b",{children:"find-class"})}),". If a ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," with that ",(0,r.jsx)(t,{styled:!0,term:"name",children:(0,r.jsx)("i",{children:"name"})})," has not been defined, then a ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," may be computed in an ",(0,r.jsx)(t,{styled:!0,term:"implementation-defined",children:(0,r.jsx)("i",{children:"implementation-defined"})})," manner. If a ",(0,r.jsx)(t,{styled:!0,term:"class",children:(0,r.jsx)("i",{children:"class"})})," cannot be returned as the result of ",(0,r.jsx)(n.em,{children:"evaluating"})," the creation ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"form"})}),", then an error of ",(0,r.jsx)(t,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(t,{styled:!0,term:"error",children:(0,r.jsx)("b",{children:"error"})})," is signaled."]}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.em,{children:"conforming implementations"})," and ",(0,r.jsx)(n.em,{children:"conforming programs"})," may further ",(0,r.jsx)(t,{styled:!0,term:"specialize",children:(0,r.jsx)("i",{children:"specialize"})})," ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"\n(defclass obj () \n  ((x :initarg :x :reader obj-x) \n   (y :initarg :y :reader obj-y) \n   (dist :accessor obj-dist))) \n\u2192 #<STANDARD-CLASS OBJ 250020030> \n(defmethod shared-initialize :after ((self obj) slot-names &rest keys) \n\t   (declare (ignore slot-names keys)) \n\t   (unless (slot-boundp self \u2019dist) \n\t     (setf (obj-dist self) \n\t\t   (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2)))))) \n\u2192 #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714> \n(defmethod make-load-form ((self obj) &optional environment) \n  (declare (ignore environment)) \n  ;; Note that this definition only works because X and Y do not \n  ;; contain information which refers back to the object itself. \n  ;; For a more general solution to this problem, see revised example below. \n  \u2018(make-instance \u2019,(class-of self) \n\t\t   :x \u2019,(obj-x self) :y \u2019,(obj-y self))) \n\u2192 #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532> \n(setq obj1 (make-instance \u2019obj :x 3.0 :y 4.0)) \u2192 #<OBJ 26274136> \n(obj-dist obj1) \u2192 5.0 \n(make-load-form obj1) \u2192 (MAKE-INSTANCE \u2019OBJ :X \u20193.0 :Y \u20194.0) \nIn the above example, an equivalent *instance* of obj is reconstructed by using the values of two of its *slots*. The value of the third *slot* is derived from those two values. \nAnother way to write the **make-load-form** *method* in that example is to use **make-load-form-saving-slots**. The code it generates might yield a slightly different result from the **make-load-form** *method* shown above, but the operational effect will be the same. For example: \n;; Redefine method defined above. \n(defmethod make-load-form ((self obj) &optional environment) \n    (make-load-form-saving-slots self \n\t\t\t\t :slot-names \u2019(x y) \n\t\t\t\t :environment environment)) \n\u2192 #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655> \n\n\n\n**make-load-form** \n;; Try MAKE-LOAD-FORM on object created above. \n(make-load-form obj1) \n\u2192 (ALLOCATE-INSTANCE \u2019#<STANDARD-CLASS OBJ 250020030>), \n(PROGN \n  (SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019X) \u20193.0) \n  (SETF (SLOT-VALUE \u2019#<OBJ 26274136> \u2019Y) \u20194.0) \n  (INITIALIZE-INSTANCE \u2019#<OBJ 26274136>)) \nIn the following example, *instances* of my-frob are \u201cinterned\u201d in some way. An equivalent *instance* is reconstructed by using the value of the name slot as a key for searching existing *objects*. In this case the programmer has chosen to create a new *object* if no existing *object* is found; alternatively an error could have been signaled in that case. \n(defclass my-frob () \n  ((name :initarg :name :reader my-name))) \n(defmethod make-load-form ((self my-frob) &optional environment) \n  (declare (ignore environment)) \n  \u2018(find-my-frob \u2019,(my-name self) :if-does-not-exist :create)) \nIn the following example, the data structure to be dumped is circular, because each parent has a list of its children and each child has a reference back to its parent. If **make-load-form** is called on one *object* in such a structure, the creation form creates an equivalent *object* and fills in the children slot, which forces creation of equivalent *objects* for all of its children, grandchildren, etc. \nAt this point none of the parent *slots* have been filled in. The initialization form fills in the parent *slot*, which forces creation of an equivalent *object* for the parent if it was not already created. Thus the entire tree is recreated at **load** time. At compile time, **make-load-form** is called once for each *object* in the tree. All of the creation forms are evaluated, in *implementation-dependent* order, and then all of the initialization forms are evaluated, also in *implementation-dependent* order. \n(defclass tree-with-parent () ((parent :accessor tree-parent) \n\t\t\t       (children :initarg :children))) \n(defmethod make-load-form ((x tree-with-parent) &optional environment) \n  (declare (ignore environment)) \n  (values \n   ;; creation form \n   \u2018(make-instance \u2019,(class-of x) :children \u2019,(slot-value x \u2019children)) \n   ;; initialization form \n   \u2018(setf (tree-parent \u2019,x) \u2019,(slot-value x \u2019parent)))) \nIn the following example, the data structure to be dumped has no special properties and an equivalent structure can be reconstructed simply by reconstructing the *slots*\u2019 contents. \n(defstruct my-struct a b c) \n(defmethod make-load-form ((s my-struct) &optional environment) \n    (make-load-form-saving-slots s :environment environment)) \n\n\n\n\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Exceptional Situations:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"methods specialized"})," on ",(0,r.jsx)(t,{styled:!0,term:"standard-object",children:(0,r.jsx)("b",{children:"standard-object"})}),", ",(0,r.jsx)(t,{styled:!0,term:"structure-object",children:(0,r.jsx)("b",{children:"structure-object"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"condition",children:(0,r.jsx)("b",{children:"condition"})})," all signal an error of ",(0,r.jsx)(t,{styled:!0,term:"type",children:(0,r.jsx)("i",{children:"type"})})," ",(0,r.jsx)(t,{styled:!0,term:"error",children:(0,r.jsx)("b",{children:"error"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["It is ",(0,r.jsx)(t,{styled:!0,term:"implementation-dependent",children:(0,r.jsx)("i",{children:"implementation-dependent"})})," whether ",(0,r.jsx)(n.em,{children:"calling"})," ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," on a ",(0,r.jsx)(n.em,{children:"generalized instance"})," of a ",(0,r.jsx)(n.em,{children:"system class"})," signals an error or returns creation and initialization ",(0,r.jsx)(t,{styled:!0,term:"form",children:(0,r.jsx)("i",{children:"forms"})}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Also:"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(t,{styled:!0,term:"compile-file",children:(0,r.jsx)("b",{children:"compile-file"})}),", ",(0,r.jsx)(t,{styled:!0,term:"make-load-form-saving-slots",children:(0,r.jsx)("b",{children:"make-load-form-saving-slots"})}),", Section 3.2.4.4 (Additional Constraints on Externaliz able Objects) Section 3.1 (Evaluation), Section 3.2 (Compilation)"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"file compiler"})," calls ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})})," in specific circumstances detailed in Section 3.2.4.4 (Additional Constraints on Externalizable Objects)."]}),"\n",(0,r.jsxs)(n.p,{children:["Some ",(0,r.jsx)(t,{styled:!0,term:"implementation",children:(0,r.jsx)("i",{children:"implementations"})})," may provide facilities for defining new ",(0,r.jsx)(n.em,{children:"subclasses"})," of ",(0,r.jsx)(n.em,{children:"classes"})," which are specified as ",(0,r.jsx)(n.em,{children:"system classes"}),". (Some likely candidates include ",(0,r.jsx)(t,{styled:!0,term:"generic-function",children:(0,r.jsx)("b",{children:"generic-function"})}),", ",(0,r.jsx)(t,{styled:!0,term:"method",children:(0,r.jsx)("b",{children:"method"})}),", and ",(0,r.jsx)(t,{styled:!0,term:"stream",children:(0,r.jsx)("b",{children:"stream"})}),"). Such ",(0,r.jsx)(t,{styled:!0,term:"implementation",children:(0,r.jsx)("i",{children:"implementations"})})," should document how the ",(0,r.jsx)(n.em,{children:"file compiler"})," processes ",(0,r.jsx)(t,{styled:!0,term:"instance",children:(0,r.jsx)("i",{children:"instances"})})," of such ",(0,r.jsx)(n.em,{children:"classes"})," when encountered as ",(0,r.jsx)(n.em,{children:"literal objects"}),", and should document any relevant ",(0,r.jsx)(t,{styled:!0,term:"method",children:(0,r.jsx)("i",{children:"methods"})})," for ",(0,r.jsx)(t,{styled:!0,term:"make-load-form",children:(0,r.jsx)("b",{children:"make-load-form"})}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}const o={title:"make-load-form"},d="make-load-form",a={id:"chap-7/h-h-dictionary/make-load-form_standard-generic-function",title:"make-load-form",description:"Expanded Reference: make-load-form",source:"@site/docs/chap-7/h-h-dictionary/make-load-form_standard-generic-function.md",sourceDirName:"chap-7/h-h-dictionary",slug:"/chap-7/h-h-dictionary/make-load-form_standard-generic-function",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/make-load-form_standard-generic-function",draft:!1,unlisted:!1,editUrl:"https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-7/h-h-dictionary/make-load-form_standard-generic-function.md",tags:[],version:"current",frontMatter:{title:"make-load-form"},sidebar:"tutorialSidebar",previous:{title:"make-load-form-saving-slots",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/make-load-form-saving-slots_function"},next:{title:"method-qualifiers",permalink:"/cl-language-reference/docs/chap-7/h-h-dictionary/method-qualifiers_standard-generic-function"}},c={},h=[{value:"Expanded Reference: make-load-form",id:"expanded-reference-make-load-form",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"make-load-form",children:"make-load-form"}),"\n","\n","\n",(0,r.jsx)(l,{}),"\n",(0,r.jsx)(n.h2,{id:"expanded-reference-make-load-form",children:"Expanded Reference: make-load-form"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"TODO: Please contribute to this page by adding explanations and examples"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lisp",children:"(make-load-form )\n"})})]})}function j(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>l});var r=t(67294);const i={},s=r.createContext(i);function l(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);