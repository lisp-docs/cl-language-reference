<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-chap-19/bj-d-logical-pathnames" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">19.3 Logical Pathnames | Common Lisp (New) Language Reference</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lisp-docs.github.io/cl-language-reference/img/1024px-Lisp_logo.svg.png"><meta data-rh="true" name="twitter:image" content="https://lisp-docs.github.io/cl-language-reference/img/1024px-Lisp_logo.svg.png"><meta data-rh="true" property="og:url" content="https://lisp-docs.github.io/cl-language-reference/docs/chap-19/bj-d-logical-pathnames"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="19.3 Logical Pathnames | Common Lisp (New) Language Reference"><meta data-rh="true" name="description" content="19.3.1 Syntax of Logical Pathname Namestrings"><meta data-rh="true" property="og:description" content="19.3.1 Syntax of Logical Pathname Namestrings"><link data-rh="true" rel="icon" href="/cl-language-reference/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-19/bj-d-logical-pathnames"><link data-rh="true" rel="alternate" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-19/bj-d-logical-pathnames" hreflang="en"><link data-rh="true" rel="alternate" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-19/bj-d-logical-pathnames" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://C1F2Q5VM6X-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/cl-language-reference/blog/rss.xml" title="Common Lisp (New) Language Reference RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cl-language-reference/blog/atom.xml" title="Common Lisp (New) Language Reference Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Common Lisp (New) Language Reference" href="/cl-language-reference/opensearch.xml"><link rel="stylesheet" href="/cl-language-reference/assets/css/styles.3db452cc.css">
<script src="/cl-language-reference/assets/js/runtime~main.026c2a54.js" defer="defer"></script>
<script src="/cl-language-reference/assets/js/main.ea9dc74c.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cl-language-reference/"><div class="navbar__logo"><img src="/cl-language-reference/img/logo.svg" alt="LISP Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/cl-language-reference/img/logo.svg" alt="LISP Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">CL Technical Reference </b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cl-language-reference/docs/intro">The CL Reference</a><a class="navbar__item navbar__link" href="/cl-language-reference/contribute">Contribute!</a><a class="navbar__item navbar__link" href="/cl-language-reference/todo">TODO</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/cl-language-reference/blog">Blog</a><a href="https://github.com/lisp-docs/cl-language-reference/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/intro">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/contents-and-figures">Contents and Figures</a><button aria-label="Expand sidebar category &#x27;Contents and Figures&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/1-introduction">1. Introduction</a><button aria-label="Expand sidebar category &#x27;1. Introduction&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/2-syntax">2. Syntax</a><button aria-label="Expand sidebar category &#x27;2. Syntax&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/3-evaluation-and-compilation">3. Evaluation and Compilation</a><button aria-label="Expand sidebar category &#x27;3. Evaluation and Compilation&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/4-types-and-classes">4. Types and Classes</a><button aria-label="Expand sidebar category &#x27;4. Types and Classes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/5-data-and-control-flow">5. Data and Control Flow</a><button aria-label="Expand sidebar category &#x27;5. Data and Control Flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/6-iteration">6. Iteration</a><button aria-label="Expand sidebar category &#x27;6. Iteration&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/7-objects">7. Objects</a><button aria-label="Expand sidebar category &#x27;7. Objects&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/8-structures">8. Structures</a><button aria-label="Expand sidebar category &#x27;8. Structures&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/9-conditions">9. Conditions</a><button aria-label="Expand sidebar category &#x27;9. Conditions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/10-symbols">10. Symbols</a><button aria-label="Expand sidebar category &#x27;10. Symbols&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/11-packages">11. Packages</a><button aria-label="Expand sidebar category &#x27;11. Packages&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/12-numbers">12. Numbers</a><button aria-label="Expand sidebar category &#x27;12. Numbers&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/13-characters">13. Characters</a><button aria-label="Expand sidebar category &#x27;13. Characters&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/14-conses">14. Conses</a><button aria-label="Expand sidebar category &#x27;14. Conses&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/15-arrays">15. Arrays</a><button aria-label="Expand sidebar category &#x27;15. Arrays&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/16-strings">16. Strings</a><button aria-label="Expand sidebar category &#x27;16. Strings&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/17-sequences">17. Sequences</a><button aria-label="Expand sidebar category &#x27;17. Sequences&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/18-hash-tables">18. Hash Tables</a><button aria-label="Expand sidebar category &#x27;18. Hash Tables&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/cl-language-reference/docs/category/19-filenames">19. Filenames</a><button aria-label="Collapse sidebar category &#x27;19. Filenames&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-19/bj-b-overview-of-filenames">19.1 Overview of Filenames</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-19/bj-c-pathnames">19.2 Pathnames</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cl-language-reference/docs/chap-19/bj-d-logical-pathnames">19.3 Logical Pathnames</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-19/intro">intro</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/20-files">20. Files</a><button aria-label="Expand sidebar category &#x27;20. Files&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/21-streams">21. Streams</a><button aria-label="Expand sidebar category &#x27;21. Streams&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/22-printer">22. Printer</a><button aria-label="Expand sidebar category &#x27;22. Printer&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/23-reader">23. Reader</a><button aria-label="Expand sidebar category &#x27;23. Reader&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/24-system-construction">24. System Construction</a><button aria-label="Expand sidebar category &#x27;24. System Construction&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/25-environment">25. Environment</a><button aria-label="Expand sidebar category &#x27;25. Environment&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/26-glossary">26. Glossary</a><button aria-label="Expand sidebar category &#x27;26. Glossary&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/a-appendix">A. Appendix</a><button aria-label="Expand sidebar category &#x27;A. Appendix&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/code-blocks-double-slashes">Code Blocks TODO Fixes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/code-blocks">code-blocks</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/cl-language-reference/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cl-language-reference/docs/category/19-filenames"><span itemprop="name">19. Filenames</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">19.3 Logical Pathnames</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>19.3 Logical Pathnames</h1>
<!-- -->
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1931-syntax-of-logical-pathname-namestrings">19.3.1 Syntax of Logical Pathname Namestrings<a href="#1931-syntax-of-logical-pathname-namestrings" class="hash-link" aria-label="Direct link to 19.3.1 Syntax of Logical Pathname Namestrings" title="Direct link to 19.3.1 Syntax of Logical Pathname Namestrings">​</a></h2>
<!-- -->
<p>The syntax of a <em>logical pathname namestring</em> is as follows. (Note that unlike many notational descriptions in this document, this is a syntactic description of character sequences, not a structural description of <em>objects</em>.)</p>
<p><em>logical-pathname::</em>=[<em>↓host host-marker</em>]</p>
<p>[<em>↓relative-directory-marker</em>] <em>{↓directory directory-marker}</em>*</p>
<p>[<em>↓name</em>] [<em>type-marker ↓type</em> [<em>version-marker ↓version</em>]]</p>
<p><em>host::</em>=<em>↓word</em></p>
<p><em>directory::</em>=<em>↓word | ↓wildcard-word | ↓wild-inferiors-word</em></p>
<p><em>name::</em>=<em>↓word | ↓wildcard-word</em></p>
<p><em>type::</em>=<em>↓word | ↓wildcard-word</em></p>
<p><em>version::</em>=<em>↓pos-int | newest-word | wildcard-version</em></p>
<p><em>host-marker</em>—a <em>colon</em>.</p>
<p><em>relative-directory-marker</em>—a <em>semicolon</em>.</p>
<p><em>directory-marker</em>—a <em>semicolon</em>.</p>
<p><em>type-marker</em>—a <em>dot</em>.</p>
<p><em>version-marker</em>—a <em>dot</em>.</p>
<p><em>wild-inferiors-word</em>—The two character sequence “**” (two <em>asterisks</em>).</p>
<p><em>newest-word</em>—The six character sequence “newest” or the six character sequence “NEWEST”. <em>wildcard-version</em>—an <em>asterisk</em>.</p>
<p><em>wildcard-word</em>—one or more <em>asterisks</em>, uppercase letters, digits, and hyphens, including at least one <em>asterisk</em>, with no two <em>asterisks</em> adjacent.</p>
<p><em>word</em>—one or more uppercase letters, digits, and hyphens.</p>
<p><em>pos-int</em>—a positive <em>integer</em> .</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="19311-additional-information-about-parsing-logical-pathname-namestrings">19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings<a href="#19311-additional-information-about-parsing-logical-pathname-namestrings" class="hash-link" aria-label="Direct link to 19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings" title="Direct link to 19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings">​</a></h3>
<!-- -->
<!-- -->
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193111-the-host-part-of-a-logical-pathname-namestring">19.3.1.1.1 The Host part of a Logical Pathname Namestring<a href="#193111-the-host-part-of-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.1 The Host part of a Logical Pathname Namestring" title="Direct link to 19.3.1.1.1 The Host part of a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>The <em>host</em> must have been defined as a <em>logical pathname</em> host; this can be done by using <strong>setf</strong> of <strong>logical-pathname-translations</strong>.</p>
<p>The <em>logical pathname</em> host name &quot;SYS&quot; is reserved for the implementation. The existence and meaning of SYS: <em>logical pathnames</em> is <em>implementation-defined</em>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193112-the-device-part-of-a-logical-pathname-namestring">19.3.1.1.2 The Device part of a Logical Pathname Namestring<a href="#193112-the-device-part-of-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.2 The Device part of a Logical Pathname Namestring" title="Direct link to 19.3.1.1.2 The Device part of a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>There is no syntax for a <em>logical pathname</em> device since the device component of a <em>logical pathname</em> is always <!-- -->:unspecific<!-- -->; see Section 19.3.2.1 (Unspecific Components of a Logical Pathname).</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193113-the-directory-part-of-a-logical-pathname-namestring">19.3.1.1.3 The Directory part of a Logical Pathname Namestring<a href="#193113-the-directory-part-of-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.3 The Directory part of a Logical Pathname Namestring" title="Direct link to 19.3.1.1.3 The Directory part of a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>If a <em>relative-directory-marker</em> precedes the <em>directories</em>, the directory component parsed is as <em>relative</em>; otherwise, the directory component is parsed as <em>absolute</em>.</p>
<p>If a <em>wild-inferiors-marker</em> is specified, it parses into <!-- -->:wild-inferiors<!-- -->.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193114-the-type-part-of-a-logical-pathname-namestring">19.3.1.1.4 The Type part of a Logical Pathname Namestring<a href="#193114-the-type-part-of-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.4 The Type part of a Logical Pathname Namestring" title="Direct link to 19.3.1.1.4 The Type part of a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>The <em>type</em> of a <em>logical pathname</em> for a <em>source file</em> is &quot;LISP&quot;. This should be translated into whatever type is appropriate in a physical pathname.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193115-the-version-part-of-a-logical-pathname-namestring">19.3.1.1.5 The Version part of a Logical Pathname Namestring<a href="#193115-the-version-part-of-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.5 The Version part of a Logical Pathname Namestring" title="Direct link to 19.3.1.1.5 The Version part of a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>Some <em>file systems</em> do not have <em>versions</em>. <em>Logical pathname</em> translation to such a <em>file system</em> ignores the <em>version</em>. This implies that a program cannot rely on being able to store more than one version of a file named by a <em>logical pathname</em>.</p>
<p>If a <em>wildcard-version</em> is specified, it parses into <!-- -->:wild<!-- -->.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193116-wildcard-words-in-a-logical-pathname-namestring">19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring<a href="#193116-wildcard-words-in-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring" title="Direct link to 19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>Each <em>asterisk</em> in a <em>wildcard-word</em> matches a sequence of zero or more characters. The <em>wildcard-word</em> “*” parses into <!-- -->:wild<!-- -->; other <em>wildcard-words</em> parse into <em>strings</em>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193117-lowercase-letters-in-a-logical-pathname-namestring">19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring<a href="#193117-lowercase-letters-in-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring" title="Direct link to 19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>When parsing <em>words</em> and <em>wildcard-words</em>, lowercase letters are translated to uppercase. Filenames <strong>19–13</strong></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="193118-other-syntax-in-a-logical-pathname-namestring">19.3.1.1.8 Other Syntax in a Logical Pathname Namestring<a href="#193118-other-syntax-in-a-logical-pathname-namestring" class="hash-link" aria-label="Direct link to 19.3.1.1.8 Other Syntax in a Logical Pathname Namestring" title="Direct link to 19.3.1.1.8 Other Syntax in a Logical Pathname Namestring">​</a></h4>
<!-- -->
<p>The consequences of using characters other than those specified here in a <em>logical pathname namestring</em> are unspecified.</p>
<p>The consequences of using any value not specified here as a <em>logical pathname</em> component are unspecified.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1932-logical-pathname-components">19.3.2 Logical Pathname Components<a href="#1932-logical-pathname-components" class="hash-link" aria-label="Direct link to 19.3.2 Logical Pathname Components" title="Direct link to 19.3.2 Logical Pathname Components">​</a></h2>
<!-- -->
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="19321-unspecific-components-of-a-logical-pathname">19.3.2.1 Unspecific Components of a Logical Pathname<a href="#19321-unspecific-components-of-a-logical-pathname" class="hash-link" aria-label="Direct link to 19.3.2.1 Unspecific Components of a Logical Pathname" title="Direct link to 19.3.2.1 Unspecific Components of a Logical Pathname">​</a></h3>
<!-- -->
<p>The device component of a <em>logical pathname</em> is always <!-- -->:unspecific<!-- -->; no other component of a <em>logical pathname</em> can be <!-- -->:unspecific<!-- -->.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="19322-null-strings-as-components-of-a-logical-pathname">19.3.2.2 Null Strings as Components of a Logical Pathname<a href="#19322-null-strings-as-components-of-a-logical-pathname" class="hash-link" aria-label="Direct link to 19.3.2.2 Null Strings as Components of a Logical Pathname" title="Direct link to 19.3.2.2 Null Strings as Components of a Logical Pathname">​</a></h3>
<!-- -->
<!-- -->
<p>The null string, &quot;&quot;, is not a valid value for any component of a <em>logical pathname</em>.</p>
<p><strong>pathname</strong> <em>System Class</em></p>
<p><strong>Class Precedence List:</strong></p>
<p><strong>pathname</strong>, <strong>t</strong></p>
<p><strong>Description:</strong></p>
<p>A <em>pathname</em> is a structured <em>object</em> which represents a <em>filename</em>.</p>
<p>There are two kinds of <em>pathnames</em>—<em>physical pathnames</em> and <em>logical pathnames</em>.</p>
<p><strong>logical-pathname</strong> <em>System Class</em></p>
<p><strong>Class Precedence List:</strong></p>
<p><strong>logical-pathname</strong>, <strong>pathname</strong>, <strong>t</strong></p>
<p><strong>Description:</strong></p>
<p>A <em>pathname</em> that uses a <em>namestring</em> syntax that is <em>implementation-independent</em>, and that has component values that are <em>implementation-independent</em>. <em>Logical pathnames</em> do not refer directly to <em>filenames</em></p>
<p><strong>See Also:</strong></p>
<p>Section 20.1 (File System Concepts), Section 2.4.8.14 (Sharpsign P), Section 22.1.3.11 (Printing Pathnames)</p>
<p><strong>pathname</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>pathname</strong> <em>pathspec → pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathspec</em>—a <em>pathname designator</em> .</p>
<p><em>pathname</em>—a <em>pathname</em>.</p>
<p><strong>Description:</strong></p>
<p>Returns the <em>pathname</em> denoted by <em>pathspec</em>.</p>
<p>Filenames <strong>19–15</strong></p>
<p><strong>pathname</strong></p>
<p>If the <em>pathspec designator</em> is a <em>stream</em>, the <em>stream</em> can be either open or closed; in both cases, the <strong>pathname</strong> returned corresponds to the <em>filename</em> used to open the <em>file</em>. <strong>pathname</strong> returns the same <em>pathname</em> for a <em>file stream</em> after it is closed as it did when it was open.</p>
<p>If the <em>pathspec designator</em> is a <em>file stream</em> created by opening a <em>logical pathname</em>, a <em>logical pathname</em> is returned.</p>
<p><strong>Examples:</strong></p>
<p>;; There is a great degree of variability permitted here. The next</p>
<p>;; several examples are intended to illustrate just a few of the many</p>
<p>;; possibilities. Whether the name is canonicalized to a particular</p>
<p>;; case (either upper or lower) depends on both the file system and the</p>
<p>;; implementation since two different implementations using the same</p>
<p>;; file system might differ on many issues. How information is stored</p>
<p>;; internally (and possibly presented in #S notation) might vary,</p>
<p>;; possibly requiring ‘accessors’ such as PATHNAME-NAME to perform case</p>
<p>;; conversion upon access. The format of a namestring is dependent both</p>
<p>;; on the file system and the implementation since, for example, one</p>
<p>;; implementation might include the host name in a namestring, and</p>
<p>;; another might not. #S notation would generally only be used in a</p>
<p>;; situation where no appropriate namestring could be constructed for use</p>
<p>;; with #P.</p>
<p>(setq p1 (pathname &quot;test&quot;))</p>
<p><em>→</em> #P&quot;CHOCOLATE<!-- -->:TEST<!-- -->&quot; ; with case canonicalization (e.g., VMS)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #P&quot;VANILLA<!-- -->:test<!-- -->&quot; ; without case canonicalization (e.g., Unix)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #P&quot;test&quot;</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #S(PATHNAME <!-- -->:HOST<!-- --> &quot;STRAWBERRY&quot; <!-- -->:NAME<!-- --> &quot;TEST&quot;)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #S(PATHNAME <!-- -->:HOST<!-- --> &quot;BELGIAN-CHOCOLATE&quot; <!-- -->:NAME<!-- --> &quot;test&quot;)</p>
<p>(setq p2 (pathname &quot;test&quot;))</p>
<p><em>→</em> #P&quot;CHOCOLATE<!-- -->:TEST<!-- -->&quot;</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #P&quot;VANILLA<!-- -->:test<!-- -->&quot;</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #P&quot;test&quot;</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #S(PATHNAME <!-- -->:HOST<!-- --> &quot;STRAWBERRY&quot; <!-- -->:NAME<!-- --> &quot;TEST&quot;)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; #S(PATHNAME <!-- -->:HOST<!-- --> &quot;BELGIAN-CHOCOLATE&quot; <!-- -->:NAME<!-- --> &quot;test&quot;)</p>
<p>(pathnamep p1) <em>→ true</em></p>
<p>(eq p1 (pathname p1)) <em>→ true</em></p>
<p>(eq p1 p2)</p>
<p><em>→ true</em></p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→ false&lt;/i&gt;</p>
<p>(with-open-file (stream &quot;test&quot; <!-- -->:direction<!-- --> <!-- -->:output<!-- -->)</p>
<p>(pathname stream))</p>
<p><em>→</em> #P&quot;ORANGE-CHOCOLATE:&gt;Gus&gt;test.lisp.newest&quot;</p>
<p><strong>See Also:</strong></p>
<p><strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as</p>
<p>Filenames)</p>
<p><strong>make-pathname</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>make-pathname</strong> &amp;key <em>host device directory name type version defaults case</em></p>
<p><em>→ pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>host</em>—a <em>valid physical pathname host</em>. Complicated defaulting behavior; see below. <em>device</em>—a <em>valid pathname device</em>. Complicated defaulting behavior; see below.</p>
<p><em>directory</em>—a <em>valid pathname directory</em>. Complicated defaulting behavior; see below. <em>name</em>—a <em>valid pathname name</em>. Complicated defaulting behavior; see below.</p>
<p><em>type</em>—a <em>valid pathname type</em>. Complicated defaulting behavior; see below.</p>
<p><em>version</em>—a <em>valid pathname version</em>. Complicated defaulting behavior; see below.</p>
<p><em>defaults</em>—a <em>pathname designator</em> . The default is a <em>pathname</em> whose host component is the same as the host component of the <em>value</em> of <strong>*default-pathname-defaults*</strong>, and whose other components are all <strong>nil</strong>.</p>
<p><em>case</em>—one of <!-- -->:common<!-- --> or <!-- -->:local<!-- -->. The default is <!-- -->:local<!-- -->.</p>
<p><em>pathname</em>—a <em>pathname</em>.</p>
<p><strong>Description:</strong></p>
<p>Constructs and returns a <em>pathname</em> from the supplied keyword arguments.</p>
<p>After the components supplied explicitly by <em>host</em>, <em>device</em>, <em>directory</em>, <em>name</em>, <em>type</em>, and <em>version</em> are filled in, the merging rules used by <strong>merge-pathnames</strong> are used to fill in any unsupplied components from the defaults supplied by <em>defaults</em>.</p>
<p>Whenever a <em>pathname</em> is constructed the components may be canonicalized if appropriate. For the explanation of the arguments that can be supplied for each component, see Section 19.2.1 (Pathname Components).</p>
<p>If <em>case</em> is supplied, it is treated as described in Section 19.2.2.1.2 (Case in Pathname Components).</p>
<p>The resulting <em>pathname</em> is a <em>logical pathname</em> if and only its host component is a <em>logical host</em> or a <em>string</em> that names a defined <em>logical host</em>.</p>
<p>Filenames <strong>19–17</strong></p>
<p><strong>make-pathname</strong></p>
<p>If the <em>directory</em> is a <em>string</em>, it should be the name of a top level directory, and should not contain any punctuation characters; that is, specifying a <em>string</em>, <em>str</em>, is equivalent to specifying the list (<!-- -->:absolute<!-- --> <em>str</em>). Specifying the symbol <!-- -->:wild<!-- --> is equivalent to specifying the list (<!-- -->:absolute<!-- --> <!-- -->:wild-inferiors<!-- -->), or (<!-- -->:absolute<!-- --> <!-- -->:wild<!-- -->) in a file system that does not support <!-- -->:wild-inferiors<!-- -->.</p>
<p><strong>Examples:</strong></p>
<p>;; Implementation A – an implementation with access to a single</p>
<p>;; Unix file system. This implementation happens to never display</p>
<p>;; the ‘host’ information in a namestring, since there is only one host.</p>
<p>(make-pathname <!-- -->:directory<!-- --> ’(<!-- -->:absolute<!-- --> &quot;public&quot; &quot;games&quot;)</p>
<p>:name<!-- --> &quot;chess&quot; <!-- -->:type<!-- --> &quot;db&quot;)</p>
<p><em>→</em> #P&quot;/public/games/chess.db&quot;</p>
<p>;; Implementation B – an implementation with access to one or more</p>
<p>;; VMS file systems. This implementation displays ‘host’ information</p>
<p>;; in the namestring only when the host is not the local host.</p>
<p>;; It uses a double colon to separate a host name from the host’s local</p>
<p>;; file name.</p>
<p>(make-pathname <!-- -->:directory<!-- --> ’(<!-- -->:absolute<!-- --> &quot;PUBLIC&quot; &quot;GAMES&quot;)</p>
<p>:name<!-- --> &quot;CHESS&quot; <!-- -->:type<!-- --> &quot;DB&quot;)</p>
<p><em>→</em> #P&quot;SYS$DISK:[PUBLIC.GAMES]CHESS.DB&quot;</p>
<p>(make-pathname <!-- -->:host<!-- --> &quot;BOBBY&quot;</p>
<p>:directory<!-- --> ’(<!-- -->:absolute<!-- --> &quot;PUBLIC&quot; &quot;GAMES&quot;)</p>
<p>:name<!-- --> &quot;CHESS&quot; <!-- -->:type<!-- --> &quot;DB&quot;)</p>
<p><em>→</em> #P&quot;BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB&quot;</p>
<p>;; Implementation C – an implementation with simultaneous access to</p>
<p>;; multiple file systems from the same Lisp image. In this</p>
<p>;; implementation, there is a convention that any text preceding the</p>
<p>;; first colon in a pathname namestring is a host name.</p>
<p>(dolist (case ’(<!-- -->:common<!-- --> <!-- -->:local<!-- -->))</p>
<p>(dolist (host ’(&quot;MY-LISPM&quot; &quot;MY-VAX&quot; &quot;MY-UNIX&quot;))</p>
<p>(print (make-pathname <!-- -->:host<!-- --> host <!-- -->:case<!-- --> case</p>
<p>:directory<!-- --> ’(<!-- -->:absolute<!-- --> &quot;PUBLIC&quot; &quot;GAMES&quot;)</p>
<p>:name<!-- --> &quot;CHESS&quot; <!-- -->:type<!-- --> &quot;DB&quot;))))</p>
<p>▷ #P&quot;MY-LISPM:&gt;public&gt;games&gt;chess.db&quot;</p>
<p>▷ #P&quot;MY-VAX<!-- -->:SYS<!-- -->$DISK:[PUBLIC.GAMES]CHESS.DB&quot;</p>
<p>▷ #P&quot;MY-UNIX:/public/games/chess.db&quot;</p>
<p>▷ #P&quot;MY-LISPM:&gt;public&gt;games&gt;chess.db&quot;</p>
<p>▷ #P&quot;MY-VAX<!-- -->:SYS<!-- -->$DISK:[PUBLIC.GAMES]CHESS.DB&quot;</p>
<p>▷ #P&quot;MY-UNIX:/PUBLIC/GAMES/CHESS.DB&quot;</p>
<p><em>→</em> NIL</p>
<p><strong>Affected By:</strong></p>
<p>The <em>file system</em>.</p>
<p><strong>See Also:</strong></p>
<p><strong>merge-pathnames</strong>, <strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>Notes:</strong></p>
<p>Portable programs should not supply <!-- -->:unspecific<!-- --> for any component. See Section 19.2.2.2.3 (<!-- -->:UNSPECIFIC<!-- --> as a Component Value).</p>
<p><strong>pathnamep</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>pathnamep</strong> <em>object → generalized-boolean</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>object</em>—an <em>object</em>.</p>
<p><em>generalized-boolean</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <strong>pathname</strong>; otherwise, returns <em>false</em>.</p>
<p><strong>Examples:</strong></p>
<p>(setq q &quot;test&quot;) <em>→</em> &quot;test&quot;</p>
<p>(pathnamep q) <em>→ false</em></p>
<p>(setq q (pathname &quot;test&quot;))</p>
<p><em>→</em> #S(PATHNAME <!-- -->:HOST<!-- --> NIL <!-- -->:DEVICE<!-- --> NIL <!-- -->:DIRECTORY<!-- --> NIL <!-- -->:NAME<!-- --> &quot;test&quot; <!-- -->:TYPE<!-- --> NIL</p>
<p>:VERSION<!-- --> NIL)</p>
<p>(pathnamep q) <em>→ true</em></p>
<p>(setq q (logical-pathname &quot;SYS<!-- -->:SITE<!-- -->;FOO.SYSTEM&quot;))</p>
<p><em>→</em> #P&quot;SYS<!-- -->:SITE<!-- -->;FOO.SYSTEM&quot;</p>
<p>(pathnamep q) <em>→ true</em></p>
<p><strong>Notes:</strong></p>
<p>(pathnamep <em>object</em>) <em>≡</em> (typep <em>object</em> ’pathname)</p>
<p>Filenames <strong>19–19</strong></p>
<p>&lt;b&gt;&lt;sup&gt;pathname-host, pathname-device, pathname&lt;/sup&gt; directory, pathname-name, pathname-type, pathname-version&lt;/b&gt; &lt;i&gt;Function&lt;/i&gt;</p>
<p><strong>Syntax:</strong></p>
<p><strong>pathname-host</strong> <em>pathname</em> &amp;key <em>case → host</em></p>
<p><strong>pathname-device</strong> <em>pathname</em> &amp;key <em>case → device</em></p>
<p><strong>pathname-directory</strong> <em>pathname</em> &amp;key <em>case → directory</em></p>
<p><strong>pathname-name</strong> <em>pathname</em> &amp;key <em>case → name</em></p>
<p><strong>pathname-type</strong> <em>pathname</em> &amp;key <em>case → type</em></p>
<p><strong>pathname-version</strong> <em>pathname → version</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> .</p>
<p><em>case</em>—one of <!-- -->:local<!-- --> or <!-- -->:common<!-- -->. The default is <!-- -->:local<!-- -->.</p>
<p><em>host</em>—a <em>valid pathname host</em>.</p>
<p><em>device</em>—a <em>valid pathname device</em>.</p>
<p><em>directory</em>—a <em>valid pathname directory</em>.</p>
<p><em>name</em>—a <em>valid pathname name</em>.</p>
<p><em>type</em>—a <em>valid pathname type</em>.</p>
<p><em>version</em>—a <em>valid pathname version</em>.</p>
<p><strong>Description:</strong></p>
<p>These functions return the components of <em>pathname</em>.</p>
<p>If the <em>pathname designator</em> is a <em>pathname</em>, it represents the name used to open the file. This may be, but is not required to be, the actual name of the file.</p>
<p>If <em>case</em> is supplied, it is treated as described in Section 19.2.2.1.2 (Case in Pathname Components). <strong>Examples:</strong></p>
<p><strong>pathname-host, pathname-device,</strong> <em>. . .</em></p>
<p>(setq q (make-pathname <!-- -->:host<!-- --> &quot;KATHY&quot;</p>
<p>:directory<!-- --> &quot;CHAPMAN&quot;</p>
<p>:name<!-- --> &quot;LOGIN&quot; <!-- -->:type<!-- --> &quot;COM&quot;))</p>
<p><em>→</em> #P&quot;KATHY::[CHAPMAN]LOGIN.COM&quot;</p>
<p>(pathname-host q) <em>→</em> &quot;KATHY&quot;</p>
<p>(pathname-name q) <em>→</em> &quot;LOGIN&quot;</p>
<p>(pathname-type q) <em>→</em> &quot;COM&quot;</p>
<p>;; Because namestrings are used, the results shown in the remaining</p>
<p>;; examples are not necessarily the only possible results. Mappings</p>
<p>;; from namestring representation to pathname representation are</p>
<p>;; dependent both on the file system involved and on the implementation</p>
<p>;; (since there may be several implementations which can manipulate the</p>
<p>;; the same file system, and those implementations are not constrained</p>
<p>;; to agree on all details). Consult the documentation for each</p>
<p>;; implementation for specific information on how namestrings are treated</p>
<p>;; that implementation.</p>
<p>;; VMS</p>
<p>(pathname-directory (parse-namestring &quot;[FOO.*.BAR]BAZ.LSP&quot;))</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; &quot;BAR&quot;)</p>
<p>(pathname-directory (parse-namestring &quot;[FOO.*.BAR]BAZ.LSP&quot;) <!-- -->:case<!-- --> <!-- -->:common<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; &quot;BAR&quot;)</p>
<p>;; Unix</p>
<p>(pathname-directory &quot;foo.l&quot;) <em>→</em> NIL</p>
<p>(pathname-device &quot;foo.l&quot;) <em>→</em> <!-- -->:UNSPECIFIC</p>
<p>(pathname-name &quot;foo.l&quot;) <em>→</em> &quot;foo&quot;</p>
<p>(pathname-name &quot;foo.l&quot; <!-- -->:case<!-- --> <!-- -->:local<!-- -->) <em>→</em> &quot;foo&quot;</p>
<p>(pathname-name &quot;foo.l&quot; <!-- -->:case<!-- --> <!-- -->:common<!-- -->) <em>→</em> &quot;FOO&quot;</p>
<p>(pathname-type &quot;foo.l&quot;) <em>→</em> &quot;l&quot;</p>
<p>(pathname-type &quot;foo.l&quot; <!-- -->:case<!-- --> <!-- -->:local<!-- -->) <em>→</em> &quot;l&quot;</p>
<p>(pathname-type &quot;foo.l&quot; <!-- -->:case<!-- --> <!-- -->:common<!-- -->) <em>→</em> &quot;L&quot;</p>
<p>(pathname-type &quot;foo&quot;) <em>→</em> <!-- -->:UNSPECIFIC</p>
<p>(pathname-type &quot;foo&quot; <!-- -->:case<!-- --> <!-- -->:common<!-- -->) <em>→</em> <!-- -->:UNSPECIFIC</p>
<p>(pathname-type &quot;foo.&quot;) <em>→</em> &quot;&quot;</p>
<p>(pathname-type &quot;foo.&quot; <!-- -->:case<!-- --> <!-- -->:common<!-- -->) <em>→</em> &quot;&quot;</p>
<p>(pathname-directory (parse-namestring &quot;/foo/bar/baz.lisp&quot;) <!-- -->:case<!-- --> <!-- -->:local<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;foo&quot; &quot;bar&quot;)</p>
<p>(pathname-directory (parse-namestring &quot;/foo/bar/baz.lisp&quot;) <!-- -->:case<!-- --> <!-- -->:local<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; &quot;BAR&quot;)</p>
<p>(pathname-directory (parse-namestring &quot;../baz.lisp&quot;))</p>
<p><em>→</em> (<!-- -->:RELATIVE<!-- --> <!-- -->:UP<!-- -->)</p>
<p>(PATHNAME-DIRECTORY (PARSE-NAMESTRING &quot;/foo/BAR/../Mum/baz&quot;))</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;foo&quot; &quot;BAR&quot; <!-- -->:UP<!-- --> &quot;Mum&quot;)</p>
<p>Filenames <strong>19–21</strong></p>
<p>(PATHNAME-DIRECTORY (PARSE-NAMESTRING &quot;/foo/BAR/../Mum/baz&quot;) <!-- -->:case<!-- --> <!-- -->:common<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; &quot;bar&quot; <!-- -->:UP<!-- --> &quot;Mum&quot;)</p>
<p>(PATHNAME-DIRECTORY (PARSE-NAMESTRING &quot;/foo/*/bar/baz.l&quot;))</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;foo&quot; <!-- -->:WILD<!-- --> &quot;bar&quot;)</p>
<p>(PATHNAME-DIRECTORY (PARSE-NAMESTRING &quot;/foo/*/bar/baz.l&quot;) <!-- -->:case<!-- --> <!-- -->:common<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; <!-- -->:WILD<!-- --> &quot;BAR&quot;)</p>
<p>;; Symbolics LMFS</p>
<p>(pathname-directory (parse-namestring &quot;&gt;foo&gt;**&gt;bar&gt;baz.lisp&quot;))</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;foo&quot; <!-- -->:WILD-INFERIORS<!-- --> &quot;bar&quot;)</p>
<p>(pathname-directory (parse-namestring &quot;&gt;foo&gt;*&gt;bar&gt;baz.lisp&quot;))</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;foo&quot; <!-- -->:WILD<!-- --> &quot;bar&quot;)</p>
<p>(pathname-directory (parse-namestring &quot;&gt;foo&gt;*&gt;bar&gt;baz.lisp&quot;) <!-- -->:case<!-- --> <!-- -->:common<!-- -->)</p>
<p><em>→</em> (<!-- -->:ABSOLUTE<!-- --> &quot;FOO&quot; <!-- -->:WILD<!-- --> &quot;BAR&quot;)</p>
<p>(pathname-device (parse-namestring &quot;&gt;foo&gt;baz.lisp&quot;)) <em>→</em> <!-- -->:UNSPECIFIC</p>
<p><strong>Affected By:</strong></p>
<p>The <em>implementation</em> and the host <em>file system</em>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>Should signal an error of <em>type</em> <strong>type-error</strong> if its first argument is not a <em>pathname</em>.</p>
<p><strong>See Also:</strong></p>
<p><strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>load-logical-pathname-translations</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>load-logical-pathname-translations</strong> <em>host → just-loaded</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>host</em>—a <em>string</em>.</p>
<p><em>just-loaded</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p>Searches for and loads the definition of a <em>logical host</em> named <em>host</em>, if it is not already defined. The specific nature of the search is <em>implementation-defined</em>.</p>
<p>If the <em>host</em> is already defined, no attempt to find or load a definition is attempted, and <em>false</em> is returned. If the <em>host</em> is not already defined, but a definition is successfully found and loaded, <em>true</em> is returned. Otherwise, an error is signaled.</p>
<p><strong>Examples:</strong></p>
<p>(translate-logical-pathname &quot;hacks<!-- -->:weather<!-- -->;barometer.lisp.newest&quot;)</p>
<p>▷ Error: The logical host HACKS is not defined.</p>
<p>(load-logical-pathname-translations &quot;HACKS&quot;)</p>
<p>▷ ;; Loading SYS<!-- -->:SITE<!-- -->;HACKS.TRANSLATIONS</p>
<p>▷ ;; Loading done.</p>
<p><em>→ true</em></p>
<p>(translate-logical-pathname &quot;hacks<!-- -->:weather<!-- -->;barometer.lisp.newest&quot;)</p>
<p><em>→</em> #P&quot;HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0&quot;</p>
<p>(load-logical-pathname-translations &quot;HACKS&quot;)</p>
<p><em>→ false</em></p>
<p><strong>Exceptional Situations:</strong></p>
<p>If no definition is found, an error of <em>type</em> <strong>error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>logical-pathname</strong></p>
<p><strong>Notes:</strong></p>
<p><em>Logical pathname</em> definitions will be created not just by <em>implementors</em> but also by <em>programmers</em>. As such, it is important that the search strategy be documented. For example, an <em>implementation</em> might define that the definition of a <em>host</em> is to be found in a file called “<em>host</em>.translations” in some specifically named directory.</p>
<p><strong>logical-pathname-translations</strong> <em>Accessor</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>logical-pathname-translations</strong> <em>host → translations</em></p>
<p><strong>(setf (logical-pathname-translations</strong> <em>host</em>**)** <em>new-translations</em>**)**</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>host</em>–a <em>logical host designator</em> .</p>
<p><em>translations</em>, <em>new-translations</em>—a <em>list</em>.</p>
<p>Filenames <strong>19–23</strong></p>
<p><strong>logical-pathname-translations</strong></p>
<p><strong>Description:</strong></p>
<p>Returns the host’s <em>list</em> of translations. Each translation is a <em>list</em> of at least two elements: <em>from-wildcard</em> and <em>to-wildcard</em>. Any additional elements are <em>implementation-defined</em>. <em>From-wildcard</em> is a <em>logical pathname</em> whose host is <em>host</em>. <em>To-wildcard</em> is a <em>pathname</em>.</p>
<p>(setf (logical-pathname-translations <em>host</em>) <em>translations</em>) sets a <em>logical pathname</em> host’s <em>list</em> of <em>translations</em>. If <em>host</em> is a <em>string</em> that has not been previously used as a <em>logical pathname</em> host, a new <em>logical pathname</em> host is defined; otherwise an existing host’s translations are replaced. <em>logical pathname</em> host names are compared with <strong>string-equal</strong>.</p>
<p>When setting the translations list, each <em>from-wildcard</em> can be a <em>logical pathname</em> whose host is <em>host</em> or a <em>logical pathname</em> namestring parseable by (parse-namestring <em>string host</em>), where <em>host</em> represents the appropriate <em>object</em> as defined by <strong>parse-namestring</strong>. Each <em>to-wildcard</em> can be anything coercible to a <em>pathname</em> by (pathname <em>to-wildcard</em>). If <em>to-wildcard</em> coerces to a <em>logical pathname</em>, <strong>translate-logical-pathname</strong> will perform repeated translation steps when it uses it.</p>
<p><em>host</em> is either the host component of a <em>logical pathname</em> or a <em>string</em> that has been defined as a <em>logical pathname</em> host name by <strong>setf</strong> of <strong>logical-pathname-translations</strong>.</p>
<p><strong>Examples:</strong></p>
<p>;;;A very simple example of setting up a logical pathname host. No</p>
<p>;;;translations are necessary to get around file system restrictions, so</p>
<p>;;;all that is necessary is to specify the root of the physical directory</p>
<p>;;;tree that contains the logical file system.</p>
<p>;;;The namestring syntax on the right-hand side is implementation-dependent.</p>
<p>(setf (logical-pathname-translations &quot;foo&quot;)</p>
<p>’((&quot;**;*.*.*&quot; &quot;MY-LISPM:&gt;library&gt;foo&gt;**&gt;&quot;)))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;foo<!-- -->:bar<!-- -->;baz;mum.quux.3&quot;)</p>
<p><em>→</em> #P&quot;MY-LISPM:&gt;library&gt;foo&gt;bar&gt;baz&gt;mum.quux.3&quot;</p>
<p>;;;A more complex example, dividing the files among two file servers</p>
<p>;;;and several different directories. This Unix doesn’t support</p>
<p>;;;<!-- -->:WILD-INFERIORS<!-- --> in the directory, so each directory level must</p>
<p>;;;be translated individually. No file name or type translations</p>
<p>;;;are required except for .MAIL to .MBX.</p>
<p>;;;The namestring syntax on the right-hand side is implementation-dependent.</p>
<p>(setf (logical-pathname-translations &quot;prog&quot;)</p>
<p>’((&quot;RELEASED;*.*.*&quot; &quot;MY-UNIX:/sys/bin/my-prog/&quot;)</p>
<p>(&quot;RELEASED;*;*.*.*&quot; &quot;MY-UNIX:/sys/bin/my-prog/*/&quot;)</p>
<p>(&quot;EXPERIMENTAL;*.*.*&quot; &quot;MY-UNIX:/usr/Joe/development/prog/&quot;)</p>
<p><strong>logical-pathname-translations</strong></p>
<p>(&quot;EXPERIMENTAL;DOCUMENTATION;*.*.*&quot;</p>
<p>&quot;MY-VAX<!-- -->:SYS<!-- -->$DISK:[JOE.DOC]&quot;)</p>
<p>(&quot;EXPERIMENTAL;*;*.*.*&quot; &quot;MY-UNIX:/usr/Joe/development/prog/*/&quot;)</p>
<p>(&quot;MAIL;**;*.MAIL&quot; &quot;MY-VAX<!-- -->:SYS<!-- -->$DISK:[JOE.MAIL.PROG...]*.MBX&quot;)))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;prog<!-- -->:mail<!-- -->;save;ideas.mail.3&quot;)</p>
<p><em>→</em> #P&quot;MY-VAX<!-- -->:SYS<!-- -->$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3&quot;</p>
<p>;;;Example translations for a program that uses three files main.lisp,</p>
<p>;;;auxiliary.lisp, and documentation.lisp. These translations might be</p>
<p>;;;supplied by a software supplier as examples.</p>
<p>;;;For Unix with long file names</p>
<p>(setf (logical-pathname-translations &quot;prog&quot;)</p>
<p>’((&quot;CODE;*.*.*&quot; &quot;/lib/prog/&quot;)))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;prog<!-- -->:code<!-- -->;documentation.lisp&quot;)</p>
<p><em>→</em> #P&quot;/lib/prog/documentation.lisp&quot;</p>
<p>;;;For Unix with 14-character file names, using .lisp as the type</p>
<p>(setf (logical-pathname-translations &quot;prog&quot;)</p>
<p>’((&quot;CODE;DOCUMENTATION.*.*&quot; &quot;/lib/prog/docum.*&quot;)</p>
<p>(&quot;CODE;*.*.*&quot; &quot;/lib/prog/&quot;)))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;prog<!-- -->:code<!-- -->;documentation.lisp&quot;)</p>
<p><em>→</em> #P&quot;/lib/prog/docum.lisp&quot;</p>
<p>;;;For Unix with 14-character file names, using .l as the type</p>
<p>;;;The second translation shortens the compiled file type to .b</p>
<p>(setf (logical-pathname-translations &quot;prog&quot;)</p>
<p>‘((&quot;**;*.LISP.*&quot; ,(logical-pathname &quot;PROG:**;*.L.*&quot;))</p>
<p>(,(compile-file-pathname (logical-pathname &quot;PROG:**;*.LISP.*&quot;))</p>
<p>Filenames <strong>19–25</strong></p>
<p><strong>logical-pathname-translations</strong></p>
<p>,(logical-pathname &quot;PROG:**;*.B.*&quot;))</p>
<p>(&quot;CODE;DOCUMENTATION.*.*&quot; &quot;/lib/prog/documentatio.*&quot;)</p>
<p>(&quot;CODE;*.*.*&quot; &quot;/lib/prog/&quot;)))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;prog<!-- -->:code<!-- -->;documentation.lisp&quot;)</p>
<p><em>→</em> #P&quot;/lib/prog/documentatio.l&quot;</p>
<p>;;;For a Cray with 6 character names and no directories, types, or versions. (setf (logical-pathname-translations &quot;prog&quot;)</p>
<p>(let ((l ’((&quot;MAIN&quot; &quot;PGMN&quot;)</p>
<p>(&quot;AUXILIARY&quot; &quot;PGAUX&quot;)</p>
<p>(&quot;DOCUMENTATION&quot; &quot;PGDOC&quot;)))</p>
<p>(logpath (logical-pathname &quot;prog<!-- -->:code<!-- -->;&quot;))</p>
<p>(phypath (pathname &quot;XXX&quot;)))</p>
<p>(append</p>
<p>;; Translations for source files</p>
<p>(mapcar #’(lambda (x)</p>
<p>(let ((log (first x))</p>
<p>(phy (second x)))</p>
<p>(list (make-pathname <!-- -->:name<!-- --> log</p>
<p>:type<!-- --> &quot;LISP&quot;</p>
<p>:version<!-- --> <!-- -->:wild</p>
<p>:defaults<!-- --> logpath)</p>
<p>(make-pathname <!-- -->:name<!-- --> phy</p>
<p>:defaults<!-- --> phypath))))</p>
<p>l)</p>
<p>;; Translations for compiled files</p>
<p>(mapcar #’(lambda (x)</p>
<p>(let* ((log (first x))</p>
<p>(phy (second x))</p>
<p>(com (compile-file-pathname</p>
<p>(make-pathname <!-- -->:name<!-- --> log</p>
<p>:type<!-- --> &quot;LISP&quot;</p>
<p>:version<!-- --> <!-- -->:wild</p>
<p>:defaults<!-- --> logpath))))</p>
<p>(setq phy (concatenate ’string phy &quot;B&quot;))</p>
<p>(list com</p>
<p>(make-pathname <!-- -->:name<!-- --> phy</p>
<p>:defaults<!-- --> phypath))))</p>
<p>l))))</p>
<p>;;;Sample use of that logical pathname. The return value</p>
<p>;;;is implementation-dependent.</p>
<p>(translate-logical-pathname &quot;prog<!-- -->:code<!-- -->;documentation.lisp&quot;)</p>
<p><em>→</em> #P&quot;PGDOC&quot;</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>host</em> is incorrectly supplied, an error of <em>type</em> <strong>type-error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>logical-pathname</strong>, Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>Notes:</strong></p>
<p>Implementations can define additional <em>functions</em> that operate on <em>logical pathname</em> hosts, for example to specify additional translation rules or options.</p>
<p><strong>logical-pathname</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>logical-pathname</strong> <em>pathspec → logical-pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathspec</em>—a <em>logical pathname</em>, a <em>logical pathname namestring</em>, or a <em>stream</em>.</p>
<p><em>logical-pathname</em>—a <em>logical pathname</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>logical-pathname</strong> converts <em>pathspec</em> to a <em>logical pathname</em> and returns the new <em>logical pathname</em>. If <em>pathspec</em> is a <em>logical pathname namestring</em>, it should contain a host component and its following <em>colon</em>. If <em>pathspec</em> is a <em>stream</em>, it should be one for which <strong>pathname</strong> returns a <em>logical pathname</em>.</p>
<p>If <em>pathspec</em> is a <em>stream</em>, the <em>stream</em> can be either open or closed. <strong>logical-pathname</strong> returns the same <em>logical pathname</em> after a file is closed as it did when the file was open. It is an error if <em>pathspec</em> is a <em>stream</em> that is created with <strong>make-two-way-stream</strong>, <strong>make-echo-stream</strong>, <strong>make-broadcast-stream</strong>, <strong>make-concatenated-stream</strong>, <strong>make-string-input-stream</strong>, or <strong>make-string-output-stream</strong>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>Signals an error of <em>type</em> <strong>type-error</strong> if <em>pathspec</em> isn’t supplied correctly.</p>
<p><strong>See Also:</strong></p>
<p><strong>logical-pathname</strong>, <strong>translate-logical-pathname</strong>, Section 19.3 (Logical Pathnames) Filenames <strong>19–27</strong></p>
<p><em>∗</em><strong>default-pathname-defaults</strong><em>∗ Variable</em></p>
<p><strong>Value Type:</strong></p>
<p>a <em>pathname object</em>.</p>
<p><strong>Initial Value:</strong></p>
<p>An <em>implementation-dependent pathname</em>, typically in the working directory that was current when Common Lisp was started up.</p>
<p><strong>Description:</strong></p>
<p>a <em>pathname</em>, used as the default whenever a <em>function</em> needs a default <em>pathname</em> and one is not supplied.</p>
<p><strong>Examples:</strong></p>
<p>;; This example illustrates a possible usage for a hypothetical Lisp running on a ;; DEC TOPS-20 file system. Since pathname conventions vary between Lisp</p>
<p>;; implementations and host file system types, it is not possible to provide a ;; general-purpose, conforming example.</p>
<p>*default-pathname-defaults* <em>→</em> #P&quot;PS:&lt;FRED&gt;&quot;</p>
<p>(merge-pathnames (make-pathname <!-- -->:name<!-- --> &quot;CALENDAR&quot;))</p>
<p><em>→</em> #P&quot;PS:&lt;FRED&gt;CALENDAR&quot;</p>
<p>(let ((*default-pathname-defaults* (pathname &quot;&lt;MARY&gt;&quot;)))</p>
<p>(merge-pathnames (make-pathname <!-- -->:name<!-- --> &quot;CALENDAR&quot;)))</p>
<p><em>→</em> #P&quot;&lt;MARY&gt;CALENDAR&quot;</p>
<p><strong>Affected By:</strong></p>
<p>The <em>implementation</em>.</p>
<p><strong>namestring, file-namestring, directory-namestring, host-namestring, enough-namestring</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>namestring</strong> <em>pathname → namestring</em></p>
<p><strong>file-namestring</strong> <em>pathname → namestring</em></p>
<p><strong>directory-namestring</strong> <em>pathname → namestring</em></p>
<p><strong>host-namestring</strong> <em>pathname → namestring</em></p>
<p><strong>enough-namestring</strong> <em>pathname</em> &amp;optional <em>defaults → namestring</em></p>
<p><strong>namestring, file-namestring, directory-namestring,</strong> <em>. . .</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> .</p>
<p><em>defaults</em>—a <em>pathname designator</em> . The default is the <em>value</em> of <strong>*default-pathname-defaults*</strong>. <em>namestring</em>—a <em>string</em> or <strong>nil</strong>.</p>
<p><strong>Description:</strong></p>
<p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form.</p>
<p><strong>namestring</strong> returns the full form of <em>pathname</em>.</p>
<p><strong>file-namestring</strong> returns just the name, type, and version components of <em>pathname</em>. <strong>directory-namestring</strong> returns the directory name portion.</p>
<p><strong>host-namestring</strong> returns the host name.</p>
<p><strong>enough-namestring</strong> returns an abbreviated namestring that is just sufficient to identify the file named by <em>pathname</em> when considered relative to the <em>defaults</em>. It is required that</p>
<p>(merge-pathnames (enough-namestring pathname defaults) defaults)</p>
<p><em>≡</em> (merge-pathnames (parse-namestring pathname nil defaults) defaults)</p>
<p>in all cases, and the result of <strong>enough-namestring</strong> is the shortest reasonable <em>string</em> that will satisfy this criterion.</p>
<p>It is not necessarily possible to construct a valid <em>namestring</em> by concatenating some of the three shorter <em>namestrings</em> in some order.</p>
<p><strong>Examples:</strong></p>
<p>(namestring &quot;getty&quot;)</p>
<p><em>→</em> &quot;getty&quot;</p>
<p>(setq q (make-pathname <!-- -->:host<!-- --> &quot;kathy&quot;</p>
<p>:directory</p>
<p>(pathname-directory *default-pathname-defaults*)</p>
<p>:name<!-- --> &quot;getty&quot;))</p>
<p><em>→</em> #S(PATHNAME <!-- -->:HOST<!-- --> &quot;kathy&quot; <!-- -->:DEVICE<!-- --> NIL <!-- -->:DIRECTORY<!-- --> <em>directory-name</em></p>
<p>:NAME<!-- --> &quot;getty&quot; <!-- -->:TYPE<!-- --> NIL <!-- -->:VERSION<!-- --> NIL)</p>
<p>(file-namestring q) <em>→</em> &quot;getty&quot;</p>
<p>(directory-namestring q) <em>→ directory-name</em></p>
<p>(host-namestring q) <em>→</em> &quot;kathy&quot;</p>
<p>;;;Using Unix syntax and the wildcard conventions used by the</p>
<p>;;;particular version of Unix on which this example was created:</p>
<p>Filenames <strong>19–29</strong></p>
<p>(namestring</p>
<p>(translate-pathname &quot;/usr/dmr/hacks/frob.l&quot;</p>
<p>&quot;/usr/d*/hacks/*.l&quot;</p>
<p>&quot;/usr/d*/backup/hacks/backup-*.*&quot;))</p>
<p><em>→</em> &quot;/usr/dmr/backup/hacks/backup-frob.l&quot;</p>
<p>(namestring</p>
<p>(translate-pathname &quot;/usr/dmr/hacks/frob.l&quot;</p>
<p>&quot;/usr/d*/hacks/fr*.l&quot;</p>
<p>&quot;/usr/d*/backup/hacks/backup-*.*&quot;))</p>
<p><em>→</em> &quot;/usr/dmr/backup/hacks/backup-ob.l&quot;</p>
<p>;;;This is similar to the above example but uses two different hosts,</p>
<p>;;;U: which is a Unix and V: which is a VMS. Note the translation</p>
<p>;;;of file type and alphabetic case conventions.</p>
<p>(namestring</p>
<p>(translate-pathname &quot;U:/usr/dmr/hacks/frob.l&quot;</p>
<p>&quot;U:/usr/d*/hacks/*.l&quot;</p>
<p>&quot;V<!-- -->:SYS<!-- -->$DISK:[D*.BACKUP.HACKS]BACKUP-*.*&quot;))</p>
<p><em>→</em> &quot;V<!-- -->:SYS<!-- -->$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP&quot;</p>
<p>(namestring</p>
<p>(translate-pathname &quot;U:/usr/dmr/hacks/frob.l&quot;</p>
<p>&quot;U:/usr/d*/hacks/fr*.l&quot;</p>
<p>&quot;V<!-- -->:SYS<!-- -->$DISK:[D*.BACKUP.HACKS]BACKUP-*.*&quot;))</p>
<p><em>→</em> &quot;V<!-- -->:SYS<!-- -->$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP&quot;</p>
<p><strong>See Also:</strong></p>
<p><strong>truename</strong>, <strong>merge-pathnames</strong>, <strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>parse-namestring</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>parse-namestring</strong> <em>thing</em> &amp;optional <em>host default-pathname</em> &amp;key <em>start end junk-allowed → pathname, position</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>thing</em>—a <em>string</em>, a <em>pathname</em>, or a <em>stream associated with a file</em>.</p>
<p><em>host</em>—a <em>valid pathname host</em>, a <em>logical host</em>, or <strong>nil</strong>.</p>
<p><em>default-pathname</em>—a <em>pathname designator</em> . The default is the <em>value</em> of</p>
<p><strong>*default-pathname-defaults*</strong>.</p>
<p><strong>parse-namestring</strong></p>
<p><em>start</em>, <em>end</em>—<em>bounding index designators</em> of <em>thing</em>. The defaults for <em>start</em> and <em>end</em> are 0 and <strong>nil</strong>, respectively.</p>
<p><em>junk-allowed</em>—a <em>generalized boolean</em>. The default is <em>false</em>.</p>
<p><em>pathname</em>—a <em>pathname</em>, or <strong>nil</strong>.</p>
<p><em>position</em>—a <em>bounding index designator</em> for <em>thing</em>.</p>
<p><strong>Description:</strong></p>
<p>Converts <em>thing</em> into a <em>pathname</em>.</p>
<p>The <em>host</em> supplies a host name with respect to which the parsing occurs.</p>
<p>If <em>thing</em> is a <em>stream associated with a file</em>, processing proceeds as if the <em>pathname</em> used to open that <em>file</em> had been supplied instead.</p>
<p>If <em>thing</em> is a <em>pathname</em>, the <em>host</em> and the host component of <em>thing</em> are compared. If they match, two values are immediately returned: <em>thing</em> and <em>start</em>; otherwise (if they do not match), an error is signaled.</p>
<p>Otherwise (if <em>thing</em> is a <em>string</em>), <strong>parse-namestring</strong> parses the name of a <em>file</em> within the substring of <em>thing</em> bounded by <em>start</em> and <em>end</em>.</p>
<p>If <em>thing</em> is a <em>string</em> then the substring of <em>thing bounded</em> by <em>start</em> and <em>end</em> is parsed into a <em>pathname</em> as follows:</p>
<p><em>•</em> If <em>host</em> is a <em>logical host</em> then <em>thing</em> is parsed as a <em>logical pathname namestring</em> on the <em>host</em>.</p>
<p><em>•</em> If <em>host</em> is <strong>nil</strong> and <em>thing</em> is a syntactically valid <em>logical pathname namestring</em> containing an explicit host, then it is parsed as a <em>logical pathname namestring</em>.</p>
<p><em>•</em> If <em>host</em> is <strong>nil</strong>, <em>default-pathname</em> is a <em>logical pathname</em>, and <em>thing</em> is a syntactically valid <em>logical pathname namestring</em> without an explicit host, then it is parsed as a <em>logical pathname namestring</em> on the host that is the host component of <em>default-pathname</em>.</p>
<p><em>•</em> Otherwise, the parsing of <em>thing</em> is <em>implementation-defined</em>.</p>
<p>In the first of these cases, the host portion of the <em>logical pathname</em> namestring and its following <em>colon</em> are optional.</p>
<p>If the host portion of the namestring and <em>host</em> are both present and do not match, an error is signaled.</p>
<p>If <em>junk-allowed</em> is <em>true</em>, then the <em>primary value</em> is the <em>pathname</em> parsed or, if no syntactically correct <em>pathname</em> was seen, <strong>nil</strong>. If <em>junk-allowed</em> is <em>false</em>, then the entire substring is scanned, and the <em>primary value</em> is the <em>pathname</em> parsed.</p>
<p>In either case, the <em>secondary value</em> is the index into <em>thing</em> of the delimiter that terminated the Filenames <strong>19–31</strong></p>
<p>parse, or the index beyond the substring if the parse terminated at the end of the substring (as will always be the case if <em>junk-allowed</em> is <em>false</em>).</p>
<p>Parsing a <em>null string</em> always succeeds, producing a <em>pathname</em> with all components (except the host) equal to <strong>nil</strong>.</p>
<p>If <em>thing</em> contains an explicit host name and no explicit device name, then it is <em>implementation defined</em> whether <strong>parse-namestring</strong> will supply the standard default device for that host as the device component of the resulting <em>pathname</em>.</p>
<p><strong>Examples:</strong></p>
<p>(setq q (parse-namestring &quot;test&quot;))</p>
<p><em>→</em> #S(PATHNAME <!-- -->:HOST<!-- --> NIL <!-- -->:DEVICE<!-- --> NIL <!-- -->:DIRECTORY<!-- --> NIL <!-- -->:NAME<!-- --> &quot;test&quot;</p>
<p>:TYPE<!-- --> NIL <!-- -->:VERSION<!-- --> NIL)</p>
<p>(pathnamep q) <em>→ true</em></p>
<p>(parse-namestring &quot;test&quot;)</p>
<p><em>→</em> #S(PATHNAME <!-- -->:HOST<!-- --> NIL <!-- -->:DEVICE<!-- --> NIL <!-- -->:DIRECTORY<!-- --> NIL <!-- -->:NAME<!-- --> &quot;test&quot;</p>
<p>:TYPE<!-- --> NIL <!-- -->:VERSION<!-- --> NIL), 4</p>
<p>(setq s (open <em>xxx</em>)) <em>→</em> #&lt;Input File Stream...&gt;</p>
<p>(parse-namestring s)</p>
<p><em>→</em> #S(PATHNAME <!-- -->:HOST<!-- --> NIL <!-- -->:DEVICE<!-- --> NIL <!-- -->:DIRECTORY<!-- --> NIL <!-- -->:NAME<!-- --> <em>xxx</em></p>
<p>:TYPE<!-- --> NIL <!-- -->:VERSION<!-- --> NIL), 0</p>
<p>(parse-namestring &quot;test&quot; nil nil <!-- -->:start<!-- --> 2 <!-- -->:end<!-- --> 4 )</p>
<p><em>→</em> #S(PATHNAME ...), 15</p>
<p>(parse-namestring &quot;foo.lisp&quot;)</p>
<p><em>→</em> #P&quot;foo.lisp&quot;</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>junk-allowed</em> is <em>false</em>, an error of <em>type</em> <strong>parse-error</strong> is signaled if <em>thing</em> does not consist entirely of the representation of a <em>pathname</em>, possibly surrounded on either side by <em>whitespace</em>&lt;sub&gt;1&lt;/sub&gt; characters if that is appropriate to the cultural conventions of the implementation.</p>
<p>If <em>host</em> is supplied and not <strong>nil</strong>, and <em>thing</em> contains a manifest host name, an error of <em>type</em> <strong>error</strong> is signaled if the hosts do not match.</p>
<p>If <em>thing</em> is a <em>logical pathname</em> namestring and if the host portion of the namestring and <em>host</em> are both present and do not match, an error of <em>type</em> <strong>error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.2.2.2.3 (<!-- -->:UNSPE<!-- --> CIFIC as a Component Value), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>wild-pathname-p</strong></p>
<p><strong>wild-pathname-p</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>wild-pathname-p</strong> <em>pathname</em> &amp;optional <em>field-key → generalized-boolean</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> .</p>
<p><em>Field-key</em>—one of <!-- -->:host<!-- -->, <!-- -->:device<!-- --> <!-- -->:directory<!-- -->, <!-- -->:name<!-- -->, <!-- -->:type<!-- -->, <!-- -->:version<!-- -->, or <strong>nil</strong>.</p>
<p><em>generalized-boolean</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>wild-pathname-p</strong> tests <em>pathname</em> for the presence of wildcard components.</p>
<p>If <em>pathname</em> is a <em>pathname</em> (as returned by <strong>pathname</strong>) it represents the name used to open the file. This may be, but is not required to be, the actual name of the file.</p>
<p>If <em>field-key</em> is not supplied or <strong>nil</strong>, <strong>wild-pathname-p</strong> returns true if <em>pathname</em> has any wildcard components, <strong>nil</strong> if <em>pathname</em> has none. If <em>field-key</em> is <em>non-nil</em>, <strong>wild-pathname-p</strong> returns true if the indicated component of <em>pathname</em> is a wildcard, <strong>nil</strong> if the component is not a wildcard.</p>
<p><strong>Examples:</strong></p>
<p>;;;The following examples are not portable. They are written to run</p>
<p>;;;with particular file systems and particular wildcard conventions.</p>
<p>;;;Other implementations will behave differently. These examples are</p>
<p>;;;intended to be illustrative, not to be prescriptive.</p>
<p>(wild-pathname-p (make-pathname <!-- -->:name<!-- --> <!-- -->:wild<!-- -->)) <em>→ true</em></p>
<p>(wild-pathname-p (make-pathname <!-- -->:name<!-- --> <!-- -->:wild<!-- -->) <!-- -->:name<!-- -->) <em>→ true</em></p>
<p>(wild-pathname-p (make-pathname <!-- -->:name<!-- --> <!-- -->:wild<!-- -->) <!-- -->:type<!-- -->) <em>→ false</em></p>
<p>(wild-pathname-p (pathname &quot;s:&gt;foo&gt;**&gt;&quot;)) <em>→ true</em> ;Lispm</p>
<p>(wild-pathname-p (pathname <!-- -->:name<!-- --> &quot;F*O&quot;)) <em>→ true</em> ;Most places</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>pathname</em> is not a <em>pathname</em>, a <em>string</em>, or a <em>stream associated with a file</em> an error of <em>type</em> <strong>type-error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>Notes:</strong></p>
<p>Not all implementations support wildcards in all fields. See Section 19.2.2.2.2 (<!-- -->:WILD<!-- --> as a Filenames <strong>19–33</strong></p>
<p>Component Value) and Section 19.2.2.3 (Restrictions on Wildcard Pathnames).</p>
<p><strong>pathname-match-p</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>pathname-match-p</strong> <em>pathname wildcard → generalized-boolean</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> .</p>
<p><em>wildcard</em>—a <em>designator</em> for a <em>wild pathname</em>.</p>
<p><em>generalized-boolean</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>pathname-match-p</strong> returns true if <em>pathname</em> matches <em>wildcard</em>, otherwise <strong>nil</strong>. The matching rules are <em>implementation-defined</em> but should be consistent with <strong>directory</strong>. Missing components of <em>wildcard</em> default to <!-- -->:wild<!-- -->.</p>
<p>It is valid for <em>pathname</em> to be a wild <em>pathname</em>; a wildcard field in <em>pathname</em> only matches a wildcard field in <em>wildcard</em> (<em>i.e.</em>, <strong>pathname-match-p</strong> is not commutative). It is valid for <em>wildcard</em> to be a non-wild <em>pathname</em>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>pathname</em> or <em>wildcard</em> is not a <em>pathname</em>, <em>string</em>, or <em>stream associated with a file</em> an error of <em>type</em> <strong>type-error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>directory</strong>, <strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>translate-logical-pathname</strong></p>
<p><strong>translate-logical-pathname</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>translate-logical-pathname</strong> <em>pathname</em> &amp;key <em>→ physical-pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> , or a <em>logical pathname namestring</em>.</p>
<p><em>physical-pathname</em>—a <em>physical pathname</em>.</p>
<p><strong>Description:</strong></p>
<p>Translates <em>pathname</em> to a <em>physical pathname</em>, which it returns.</p>
<p>If <em>pathname</em> is a <em>stream</em>, the <em>stream</em> can be either open or closed. <strong>translate-logical-pathname</strong> returns the same physical pathname after a file is closed as it did when the file was open. It is an er ror if <em>pathname</em> is a <em>stream</em> that is created with <strong>make-two-way-stream</strong>, <strong>make-echo-stream</strong>, <strong>make-broadcast-stream</strong>, <strong>make-concatenated-stream</strong>, <strong>make-string-input-stream</strong>, <strong>make-string-output-stream</strong>.</p>
<p>If <em>pathname</em> is a <em>logical pathname</em> namestring, the host portion of the <em>logical pathname</em> namestring and its following <em>colon</em> are required.</p>
<p><em>Pathname</em> is first coerced to a <em>pathname</em>. If the coerced <em>pathname</em> is a physical pathname, it is returned. If the coerced <em>pathname</em> is a <em>logical pathname</em>, the first matching translation (according to <strong>pathname-match-p</strong>) of the <em>logical pathname</em> host is applied, as if by calling <strong>translate-pathname</strong>. If the result is a <em>logical pathname</em>, this process is repeated. When the result is finally a physical pathname, it is returned. If no translation matches, an error is signaled.</p>
<p><strong>translate-logical-pathname</strong> might perform additional translations, typically to provide translation of file types to local naming conventions, to accomodate physical file systems with limited length names, or to deal with special character requirements such as translating hyphens to underscores or uppercase letters to lowercase. Any such additional translations are <em>implementation-defined</em>. Some implementations do no additional translations.</p>
<p>There are no specified keyword arguments for <strong>translate-logical-pathname</strong>, but implementations are permitted to extend it by adding keyword arguments.</p>
<p><strong>Examples:</strong></p>
<p>See <strong>logical-pathname-translations</strong>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>pathname</em> is incorrectly supplied, an error of <em>type</em> <strong>type-error</strong> is signaled.</p>
<p>If no translation matches, an error of <em>type</em> <strong>file-error</strong> is signaled.</p>
<p>Filenames <strong>19–35</strong></p>
<p><strong>See Also:</strong></p>
<p><strong>logical-pathname</strong>, <strong>logical-pathname-translations</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>translate-pathname</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>translate-pathname</strong> <em>source from-wildcard to-wildcard</em> &amp;key</p>
<p><em>→ translated-pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>source</em>—a <em>pathname designator</em> .</p>
<p><em>from-wildcard</em>—a <em>pathname designator</em> .</p>
<p><em>to-wildcard</em>—a <em>pathname designator</em> .</p>
<p><em>translated-pathname</em>—a <em>pathname</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>translate-pathname</strong> translates <em>source</em> (that matches <em>from-wildcard</em>) into a corresponding <em>pathname</em> that matches <em>to-wildcard</em>, and returns the corresponding <em>pathname</em>.</p>
<p>The resulting <em>pathname</em> is <em>to-wildcard</em> with each wildcard or missing field replaced by a portion of <em>source</em>. A “wildcard field” is a <em>pathname</em> component with a value of <!-- -->:wild<!-- -->, a <!-- -->:wild<!-- --> element of a <em>list</em>-valued directory component, or an <em>implementation-defined</em> portion of a component, such as the &quot;*&quot; in the complex wildcard string &quot;foo*bar&quot; that some implementations support. An implementation that adds other wildcard features, such as regular expressions, must define how <strong>translate-pathname</strong> extends to those features. A “missing field” is a <em>pathname</em> component with a value of <strong>nil</strong>.</p>
<p>The portion of <em>source</em> that is copied into the resulting <em>pathname</em> is <em>implementation-defined</em>. Typically it is determined by the user interface conventions of the file systems involved. Usually it is the portion of <em>source</em> that matches a wildcard field of <em>from-wildcard</em> that is in the same position as the wildcard or missing field of <em>to-wildcard</em>. If there is no wildcard field in <em>from-wildcard</em> at that position, then usually it is the entire corresponding <em>pathname</em> component of <em>source</em>, or in the case of a <em>list</em>-valued directory component, the entire corresponding <em>list</em> element.</p>
<p>During the copying of a portion of <em>source</em> into the resulting <em>pathname</em>, additional <em>implementation defined</em> translations of <em>case</em> or file naming conventions might occur, especially when <em>from-wildcard</em> and <em>to-wildcard</em> are for different hosts.</p>
<p>It is valid for <em>source</em> to be a wild <em>pathname</em>; in general this will produce a wild result. It is valid for <em>from-wildcard</em> and/or <em>to-wildcard</em> to be non-wild <em>pathnames</em>.</p>
<p><strong>translate-pathname</strong></p>
<p>There are no specified keyword arguments for <strong>translate-pathname</strong>, but implementations are permitted to extend it by adding keyword arguments.</p>
<p><strong>translate-pathname</strong> maps customary case in <em>source</em> into customary case in the output <em>pathname</em>. <strong>Examples:</strong></p>
<p>;; The results of the following five forms are all implementation-dependent.</p>
<p>;; The second item in particular is shown with multiple results just to</p>
<p>;; emphasize one of many particular variations which commonly occurs.</p>
<p>(pathname-name (translate-pathname &quot;foobar&quot; &quot;foo*&quot; &quot;*baz&quot;)) <em>→</em> &quot;barbaz&quot;</p>
<p>(pathname-name (translate-pathname &quot;foobar&quot; &quot;foo*&quot; &quot;*&quot;))</p>
<p><em>→</em> &quot;foobar&quot;</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; &quot;bar&quot;</p>
<p>(pathname-name (translate-pathname &quot;foobar&quot; &quot;*&quot; &quot;foo*&quot;)) <em>→</em> &quot;foofoobar&quot;</p>
<p>(pathname-name (translate-pathname &quot;bar&quot; &quot;*&quot; &quot;foo*&quot;)) <em>→</em> &quot;foobar&quot;</p>
<p>(pathname-name (translate-pathname &quot;foobar&quot; &quot;foo*&quot; &quot;baz*&quot;)) <em>→</em> &quot;bazbar&quot;</p>
<p>(defun translate-logical-pathname-1 (pathname rules)</p>
<p>(let ((rule (assoc pathname rules <!-- -->:test<!-- --> #’pathname-match-p)))</p>
<p>(unless rule (error &quot;No translation rule for ~A&quot; pathname))</p>
<p>(translate-pathname pathname (first rule) (second rule))))</p>
<p>(translate-logical-pathname-1 &quot;FOO<!-- -->:CODE<!-- -->;BASIC.LISP&quot;</p>
<p>’((&quot;FOO<!-- -->:DOCUMENTATION<!-- -->;&quot; &quot;MY-UNIX:/doc/foo/&quot;)</p>
<p>(&quot;FOO<!-- -->:CODE<!-- -->;&quot; &quot;MY-UNIX:/lib/foo/&quot;)</p>
<p>(&quot;FOO<!-- -->:PATCHES<!-- -->;*;&quot; &quot;MY-UNIX:/lib/foo/patch/*/&quot;)))</p>
<p><em>→</em> #P&quot;MY-UNIX:/lib/foo/basic.l&quot;</p>
<p>;;;This example assumes one particular set of wildcard conventions</p>
<p>;;;Not all file systems will run this example exactly as written</p>
<p>(defun rename-files (from to)</p>
<p>(dolist (file (directory from))</p>
<p>(rename-file file (translate-pathname file from to))))</p>
<p>(rename-files &quot;/usr/me/*.lisp&quot; &quot;/dev/her/*.l&quot;)</p>
<p>;Renames /usr/me/init.lisp to /dev/her/init.l</p>
<p>(rename-files &quot;/usr/me/pcl*/*&quot; &quot;/sys/pcl/*/&quot;)</p>
<p>;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp</p>
<p>;In some file systems the result might be /sys/pcl/5-may/low.lisp</p>
<p>(rename-files &quot;/usr/me/pcl*/*&quot; &quot;/sys/library/*/&quot;)</p>
<p>;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp</p>
<p>;In some file systems the result might be /sys/library/5-may/low.lisp</p>
<p>(rename-files &quot;/usr/me/foo.bar&quot; &quot;/usr/me2/&quot;)</p>
<p>;Renames /usr/me/foo.bar to /usr/me2/foo.bar</p>
<p>(rename-files &quot;/usr/joe/*-recipes.text&quot; &quot;/usr/jim/cookbook/joe’s-*-rec.text&quot;) ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe’s-lamb-rec.text</p>
<p>;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe’s-pork-rec.text</p>
<p>Filenames <strong>19–37</strong></p>
<p>;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe’s-veg-rec.text</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If any of <em>source</em>, <em>from-wildcard</em>, or <em>to-wildcard</em> is not a <em>pathname</em>, a <em>string</em>, or a <em>stream associated with a file</em> an error of <em>type</em> <strong>type-error</strong> is signaled.</p>
<p>(pathname-match-p <em>source from-wildcard</em>) must be true or an error of <em>type</em> <strong>error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>namestring</strong>, <strong>pathname-host</strong>, <strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>Notes:</strong></p>
<p>The exact behavior of <strong>translate-pathname</strong> cannot be dictated by the Common Lisp language and must be allowed to vary, depending on the user interface conventions of the file systems involved.</p>
<p>The following is an implementation guideline. One file system performs this operation by examining each piece of the three <em>pathnames</em> in turn, where a piece is a <em>pathname</em> component or a <em>list</em> element of a structured component such as a hierarchical directory. Hierarchical directory elements in <em>from-wildcard</em> and <em>to-wildcard</em> are matched by whether they are wildcards, not by depth in the directory hierarchy. If the piece in <em>to-wildcard</em> is present and not wild, it is copied into the result. If the piece in <em>to-wildcard</em> is <!-- -->:wild<!-- --> or <strong>nil</strong>, the piece in <em>source</em> is copied into the result. Otherwise, the piece in <em>to-wildcard</em> might be a complex wildcard such as &quot;foo*bar&quot; and the piece in <em>from-wildcard</em> should be wild; the portion of the piece in <em>source</em> that matches the wildcard portion of the piece in <em>from-wildcard</em> replaces the wildcard portion of the piece in <em>to-wildcard</em> and the value produced is used in the result.</p>
<p><strong>merge-pathnames</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>merge-pathnames</strong> <em>pathname</em> &amp;optional <em>default-pathname default-version</em></p>
<p><em>→ merged-pathname</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>pathname</em>—a <em>pathname designator</em> .</p>
<p><em>default-pathname</em>—a <em>pathname designator</em> . The default is the <em>value</em> of</p>
<p><strong>*default-pathname-defaults*</strong>.</p>
<p><em>default-version</em>—a <em>valid pathname version</em>. The default is <!-- -->:newest<!-- -->.</p>
<p><em>merged-pathname</em>—a <em>pathname</em>.</p>
<p><strong>merge-pathnames</strong></p>
<p><strong>Description:</strong></p>
<p>Constructs a <em>pathname</em> from <em>pathname</em> by filling in any unsupplied components with the corresponding values from <em>default-pathname</em> and <em>default-version</em>.</p>
<p>Defaulting of pathname components is done by filling in components taken from another <em>pathname</em>. This is especially useful for cases such as a program that has an input file and an output file. Unspecified components of the output pathname will come from the input pathname, except that the type should not default to the type of the input pathname but rather to the appropriate default type for output from the program; for example, see the <em>function</em> <strong>compile-file-pathname</strong>.</p>
<p>If no version is supplied, <em>default-version</em> is used. If <em>default-version</em> is <strong>nil</strong>, the version component will remain unchanged.</p>
<p>If <em>pathname</em> explicitly specifies a host and not a device, and if the host component of <em>default-pathname</em> matches the host component of <em>pathname</em>, then the device is taken from the <em>default-pathname</em>; otherwise the device will be the default file device for that host. If <em>pathname</em> does not specify a host, device, directory, name, or type, each such component is copied from <em>default-pathname</em>. If <em>pathname</em> does not specify a name, then the version, if not provided, will come from <em>default-pathname</em>, just like the other components. If <em>pathname</em> does specify a name, then the version is not affected by <em>default-pathname</em>. If this process leaves the version missing, the <em>default-version</em> is used. If the host’s file name syntax provides a way to input a version without a name or type, the user can let the name and type default but supply a version different from the one in <em>default-pathname</em>.</p>
<p>If <em>pathname</em> is a <em>stream</em>, <em>pathname</em> effectively becomes (pathname <em>pathname</em>). <strong>merge-pathnames</strong> can be used on either an open or a closed <em>stream</em>.</p>
<p>If <em>pathname</em> is a <em>pathname</em> it represents the name used to open the file. This may be, but is not required to be, the actual name of the file.</p>
<p><strong>merge-pathnames</strong> recognizes a <em>logical pathname namestring</em> when <em>default-pathname</em> is a <em>logical pathname</em>, or when the <em>namestring</em> begins with the name of a defined <em>logical host</em> followed by a <em>colon</em>. In the first of these two cases, the host portion of the <em>logical pathname namestring</em> and its following <em>colon</em> are optional.</p>
<p><strong>merge-pathnames</strong> returns a <em>logical pathname</em> if and only if its first argument is a <em>logical pathname</em>, or its first argument is a <em>logical pathname namestring</em> with an explicit host, or its first argument does not specify a host and the <em>default-pathname</em> is a <em>logical pathname</em>.</p>
<p><em>Pathname</em> merging treats a relative directory specially. If (pathname-directory <em>pathname</em>) is a <em>list</em> whose <em>car</em> is <!-- -->:relative<!-- -->, and (pathname-directory <em>default-pathname</em>) is a <em>list</em>, then the merged directory is the value of</p>
<p>(append (pathname-directory <em>default-pathname</em>)</p>
<p>(cdr ;remove <!-- -->:relative<!-- --> from the front</p>
<p>(pathname-directory <em>pathname</em>)))</p>
<p>except that if the resulting <em>list</em> contains a <em>string</em> or <!-- -->:wild<!-- --> immediately followed by <!-- -->:back<!-- -->, Filenames <strong>19–39</strong></p>
<p><strong>merge-pathnames</strong></p>
<p>both of them are removed. This removal of redundant <!-- -->:back<!-- --> <em>keywords</em> is repeated as many times as possible. If (pathname-directory <em>default-pathname</em>) is not a <em>list</em> or (pathname-directory <em>pathname</em>) is not a <em>list</em> whose <em>car</em> is <!-- -->:relative<!-- -->, the merged directory is (or (pathname-directory <em>pathname</em>) (pathname-directory <em>default-pathname</em>))</p>
<p><strong>merge-pathnames</strong> maps customary case in <em>pathname</em> into customary case in the output <em>pathname</em>.</p>
<p><strong>Examples:</strong></p>
<p>(merge-pathnames &quot;CMUC::FORMAT&quot;</p>
<p>&quot;CMUC::PS:&lt;LISPIO&gt;.FASL&quot;)</p>
<p><em>→</em> #P&quot;CMUC::PS:&lt;LISPIO&gt;FORMAT.FASL.0&quot;</p>
<p><strong>See Also:</strong></p>
<p><strong>*default-pathname-defaults*</strong>, <strong>pathname</strong>, <strong>logical-pathname</strong>, Section 20.1 (File System Concepts), Section 19.1.2 (Pathnames as Filenames)</p>
<p><strong>Notes:</strong></p>
<p>The net effect is that if just a name is supplied, the host, device, directory, and type will come from <em>default-pathname</em>, but the version will come from <em>default-version</em>. If nothing or just a directory is supplied, the name, type, and version will come from <em>default-pathname</em> together.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/lisp-docs/cl-language-reference/tree/develop/docs/chap-19/bj-d-logical-pathnames.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/cl-language-reference/docs/chap-19/bj-c-pathnames"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">19.2 Pathnames</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cl-language-reference/docs/chap-19/intro"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">intro</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1931-syntax-of-logical-pathname-namestrings" class="table-of-contents__link toc-highlight">19.3.1 Syntax of Logical Pathname Namestrings</a><ul><li><a href="#19311-additional-information-about-parsing-logical-pathname-namestrings" class="table-of-contents__link toc-highlight">19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings</a><ul><li><a href="#193111-the-host-part-of-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.1 The Host part of a Logical Pathname Namestring</a></li><li><a href="#193112-the-device-part-of-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.2 The Device part of a Logical Pathname Namestring</a></li><li><a href="#193113-the-directory-part-of-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.3 The Directory part of a Logical Pathname Namestring</a></li><li><a href="#193114-the-type-part-of-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.4 The Type part of a Logical Pathname Namestring</a></li><li><a href="#193115-the-version-part-of-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.5 The Version part of a Logical Pathname Namestring</a></li><li><a href="#193116-wildcard-words-in-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring</a></li><li><a href="#193117-lowercase-letters-in-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring</a></li><li><a href="#193118-other-syntax-in-a-logical-pathname-namestring" class="table-of-contents__link toc-highlight">19.3.1.1.8 Other Syntax in a Logical Pathname Namestring</a></li></ul></li></ul></li><li><a href="#1932-logical-pathname-components" class="table-of-contents__link toc-highlight">19.3.2 Logical Pathname Components</a><ul><li><a href="#19321-unspecific-components-of-a-logical-pathname" class="table-of-contents__link toc-highlight">19.3.2.1 Unspecific Components of a Logical Pathname</a></li><li><a href="#19322-null-strings-as-components-of-a-logical-pathname" class="table-of-contents__link toc-highlight">19.3.2.2 Null Strings as Components of a Logical Pathname</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cl-language-reference/docs/intro">Cl Technical Reference</a></li><li class="footer__item"><a href="https://lisp-docs.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">CL Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/common-lisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/hhk46CE" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.reddit.com/r/common_lisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">Reddit<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://irclog.tymoon.eu/libera/commonlisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">IRC<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cl-language-reference/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/lisp-docs/cl-language-reference/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 LISP Docs, MIT License. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>