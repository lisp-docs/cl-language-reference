<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-chap-3/d-h-destructive-operations" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">3.7 Destructive Operations | Common Lisp (New) Language Reference</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://lisp-docs.github.io/cl-language-reference/img/1024px-Lisp_logo.svg.png"><meta data-rh="true" name="twitter:image" content="https://lisp-docs.github.io/cl-language-reference/img/1024px-Lisp_logo.svg.png"><meta data-rh="true" property="og:url" content="https://lisp-docs.github.io/cl-language-reference/docs/chap-3/d-h-destructive-operations"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="3.7 Destructive Operations | Common Lisp (New) Language Reference"><meta data-rh="true" name="description" content="3.7.1 Modification of Literal Objects"><meta data-rh="true" property="og:description" content="3.7.1 Modification of Literal Objects"><link data-rh="true" rel="icon" href="/cl-language-reference/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-3/d-h-destructive-operations"><link data-rh="true" rel="alternate" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-3/d-h-destructive-operations" hreflang="en"><link data-rh="true" rel="alternate" href="https://lisp-docs.github.io/cl-language-reference/docs/chap-3/d-h-destructive-operations" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/cl-language-reference/blog/rss.xml" title="Common Lisp (New) Language Reference RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cl-language-reference/blog/atom.xml" title="Common Lisp (New) Language Reference Atom Feed"><link rel="stylesheet" href="/cl-language-reference/assets/css/styles.d3a7613c.css">
<script src="/cl-language-reference/assets/js/runtime~main.e590c64b.js" defer="defer"></script>
<script src="/cl-language-reference/assets/js/main.cc80e5a1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cl-language-reference/"><div class="navbar__logo"><img src="/cl-language-reference/img/logo.svg" alt="LISP Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/cl-language-reference/img/logo.svg" alt="LISP Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">CL Technical Reference </b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cl-language-reference/docs/intro">The CL Reference</a><a class="navbar__item navbar__link" href="/cl-language-reference/contribue">Contribute!</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/cl-language-reference/blog">Blog</a><a href="https://github.com/lisp-docs/cl-language-reference/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/chapter-3">Chapter 3</a><button aria-label="Expand sidebar category &#x27;Chapter 3&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/nil">NIL</a><button aria-label="Expand sidebar category &#x27;NIL&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/1-introduction">1. Introduction</a><button aria-label="Expand sidebar category &#x27;1. Introduction&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/10-symbols">10. Symbols</a><button aria-label="Expand sidebar category &#x27;10. Symbols&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/11-packages">11. Packages</a><button aria-label="Expand sidebar category &#x27;11. Packages&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/12-numbers">12. Numbers</a><button aria-label="Expand sidebar category &#x27;12. Numbers&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/13-characters">13. Characters</a><button aria-label="Expand sidebar category &#x27;13. Characters&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/14-conses">14. Conses</a><button aria-label="Expand sidebar category &#x27;14. Conses&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/15-arrays">15. Arrays</a><button aria-label="Expand sidebar category &#x27;15. Arrays&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/16-strings">16. Strings</a><button aria-label="Expand sidebar category &#x27;16. Strings&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/17-sequences">17. Sequences</a><button aria-label="Expand sidebar category &#x27;17. Sequences&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/18-hash-tables">18. Hash Tables</a><button aria-label="Expand sidebar category &#x27;18. Hash Tables&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/19-filenames">19. Filenames</a><button aria-label="Expand sidebar category &#x27;19. Filenames&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/2-syntax">2. Syntax</a><button aria-label="Expand sidebar category &#x27;2. Syntax&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/chap-2">chap-2</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/20-files">20. Files</a><button aria-label="Expand sidebar category &#x27;20. Files&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/21-streams">21. Streams</a><button aria-label="Expand sidebar category &#x27;21. Streams&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/22-printer">22. Printer</a><button aria-label="Expand sidebar category &#x27;22. Printer&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/23-reader">23. Reader</a><button aria-label="Expand sidebar category &#x27;23. Reader&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/24-system-construction">24. System Construction</a><button aria-label="Expand sidebar category &#x27;24. System Construction&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/25-environment">25. Environment</a><button aria-label="Expand sidebar category &#x27;25. Environment&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/26-glossary">26. Glossary</a><button aria-label="Expand sidebar category &#x27;26. Glossary&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/cl-language-reference/docs/category/3-evaluation-and-compilation">3. Evaluation and Compilation</a><button aria-label="Collapse sidebar category &#x27;3. Evaluation and Compilation&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-b-evaluation">3.1 Evaluation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-c-compilation">3.2 Compilation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-d-declarations">3.3 Declarations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-e-lambda-lists">3.4 Lambda Lists</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-f-error-checking-in-function-calls">3.5 Error Checking in Function Calls</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/d-g-traversal-rules-and-side-effects">3.6 Traversal Rules and Side Effects</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cl-language-reference/docs/chap-3/d-h-destructive-operations">3.7 Destructive Operations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cl-language-reference/docs/chap-3/intro">intro</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/chap-3">chap-3</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/4-types-and-classes">4. Types and Classes</a><button aria-label="Expand sidebar category &#x27;4. Types and Classes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/5-data-and-control-flow">5. Data and Control Flow</a><button aria-label="Expand sidebar category &#x27;5. Data and Control Flow&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/6-iteration">6. Iteration</a><button aria-label="Expand sidebar category &#x27;6. Iteration&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/7-objects">7. Objects</a><button aria-label="Expand sidebar category &#x27;7. Objects&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/8-structures">8. Structures</a><button aria-label="Expand sidebar category &#x27;8. Structures&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/9-conditions">9. Conditions</a><button aria-label="Expand sidebar category &#x27;9. Conditions&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cl-language-reference/docs/category/a-appendix">A. Appendix</a><button aria-label="Expand sidebar category &#x27;A. Appendix&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cl-language-reference/docs/chap2">chap2</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/cl-language-reference/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cl-language-reference/docs/category/3-evaluation-and-compilation"><span itemprop="name">3. Evaluation and Compilation</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">3.7 Destructive Operations</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>3.7 Destructive Operations</h1>
<!-- -->
<p><strong>3.7 Destructive Operations</strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="371-modification-of-literal-objects">3.7.1 Modification of Literal Objects<a href="#371-modification-of-literal-objects" class="hash-link" aria-label="Direct link to 3.7.1 Modification of Literal Objects" title="Direct link to 3.7.1 Modification of Literal Objects">​</a></h2>
<!-- -->
<p><strong>3.7.1 Modification of Literal Objects</strong></p>
<p>The consequences are undefined if <em>literal objects</em> are destructively modified. For this purpose, the following operations are considered <em>destructive</em>:</p>
<p><strong>random-state</strong></p>
<p>Using it as an <em>argument</em> to the <em>function</em> <strong>random</strong>.</p>
<p><strong>cons</strong></p>
<p>Changing the <em>car</em> &lt;sub&gt;1&lt;/sub&gt; or <em>cdr</em> &lt;sub&gt;1&lt;/sub&gt; of the <em>cons</em>, or performing a <em>destructive</em> operation on an <em>object</em> which is either the <em>car</em> &lt;sub&gt;2&lt;/sub&gt; or the <em>cdr</em> &lt;sub&gt;2&lt;/sub&gt; of the <em>cons</em>.</p>
<p><strong>array</strong></p>
<p>Storing a new value into some element of the <em>array</em>, or performing a <em>destructive</em> operation on an <em>object</em> that is already such an <em>element</em>.</p>
<p>Changing the <em>fill pointer</em> , <em>dimensions</em>, or displacement of the <em>array</em> (regardless of whether the <em>array</em> is <em>actually adjustable</em>).</p>
<p>Performing a <em>destructive</em> operation on another <em>array</em> that is displaced to the <em>array</em> or that otherwise shares its contents with the <em>array</em>.</p>
<p><strong>hash-table</strong></p>
<p>Performing a <em>destructive</em> operation on any <em>key</em>.</p>
<p>Storing a new <em>value</em>&lt;sub&gt;4&lt;/sub&gt; for any <em>key</em>, or performing a <em>destructive</em> operation on any <em>object</em> that is such a <em>value</em>.</p>
<p>Adding or removing entries from the <em>hash table</em>.</p>
<p><strong>structure-object</strong></p>
<p>Storing a new value into any slot, or performing a <em>destructive</em> operation on an <em>object</em> that is the value of some slot.</p>
<p><strong>standard-object</strong></p>
<p>Storing a new value into any slot, or performing a <em>destructive</em> operation on an <em>object</em> that is the value of some slot.</p>
<p>Changing the class of the <em>object</em> (<em>e.g.</em>, using the <em>function</em> <strong>change-class</strong>).</p>
<p><strong>readtable</strong></p>
<p>Altering the <em>readtable case</em>.</p>
<p>Altering the syntax type of any character in this readtable.</p>
<p>Altering the <em>reader macro function</em> associated with any <em>character</em> in the <em>readtable</em>, or altering the <em>reader macro functions</em> associated with <em>characters</em> defined as <em>dispatching macro characters</em> in the <em>readtable</em>.</p>
<p><strong>stream</strong></p>
<p>Performing I/O operations on the <em>stream</em>, or <em>closing</em> the <em>stream</em>.</p>
<p>All other standardized types</p>
<p>[This category includes, for example, <strong>character</strong>, <strong>condition</strong>, <strong>function</strong>,</p>
<p><strong>method-combination</strong>, <strong>method</strong>, <strong>number</strong>, <strong>package</strong>, <strong>pathname</strong>, <strong>restart</strong>, and <strong>symbol</strong>.] There are no <em>standardized destructive</em> operations defined on <em>objects</em> of these <em>types</em>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="372-transfer-of-control-during-a-destructive-operation">3.7.2 Transfer of Control during a Destructive Operation<a href="#372-transfer-of-control-during-a-destructive-operation" class="hash-link" aria-label="Direct link to 3.7.2 Transfer of Control during a Destructive Operation" title="Direct link to 3.7.2 Transfer of Control during a Destructive Operation">​</a></h2>
<!-- -->
<p><strong>3.7.2 Transfer of Control during a Destructive Operation</strong></p>
<p>Should a transfer of control out of a <em>destructive</em> operation occur (<em>e.g.</em>, due to an error) the state of the <em>object</em> being modified is <em>implementation-dependent</em>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="3721-examples-of-transfer-of-control-during-a-destructive-operation">3.7.2.1 Examples of Transfer of Control during a Destructive Operation<a href="#3721-examples-of-transfer-of-control-during-a-destructive-operation" class="hash-link" aria-label="Direct link to 3.7.2.1 Examples of Transfer of Control during a Destructive Operation" title="Direct link to 3.7.2.1 Examples of Transfer of Control during a Destructive Operation">​</a></h3>
<!-- -->
<!-- -->
<p><strong>3.7.2.1 Examples of Transfer of Control during a Destructive Operation</strong></p>
<p>The following examples illustrate some of the many ways in which the <em>implementation-dependent</em> nature of the modification can manifest itself.</p>
<p>(let ((a (list 2 1 4 3 7 6 ’five)))</p>
<p>(ignore-errors (sort a #’&lt;))</p>
<p>a)</p>
<p><em>→</em> (1 2 3 4 6 7 FIVE)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; (2 1 4 3 7 6 FIVE)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; (2)</p>
<p>(prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))</p>
<p>(sort a #’(lambda (x y) (if (zerop (random 5)) (return-from foo a) (&gt; x y))))) <em>→</em> (1 2 3 4 5 6 7 8 9 10)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; (3 4 5 6 2 7 8 9 10 1)</p>
<p>&lt;i&gt;&lt;sup&gt;or&lt;/sup&gt;→&lt;/i&gt; (1 2 4 3)</p>
<p><strong>lambda</strong> <em>Symbol</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>lambda</strong> <em>lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>*</p>
<p><strong>Arguments:</strong></p>
<p><em>lambda-list</em>—an <em>ordinary lambda list</em>.</p>
<p><em>declaration</em>—a <strong>declare</strong> <em>expression</em>; not evaluated.</p>
<p><em>documentation</em>—a <em>string</em>; not evaluated.</p>
<p><em>form</em>—a <em>form</em>.</p>
<p><strong>Description:</strong></p>
<p>A <em>lambda expression</em> is a <em>list</em> that can be used in place of a <em>function name</em> in certain contexts to denote a <em>function</em> by directly describing its behavior rather than indirectly by referring to the name of an <em>established function</em>.</p>
<p><em>Documentation</em> is attached to the denoted <em>function</em> (if any is actually created) as a <em>documentation string</em>.</p>
<p><strong>See Also:</strong></p>
<p><strong>function</strong>, <strong>documentation</strong>, Section 3.1.3 (Lambda Expressions), Section 3.1.2.1.2.4 (Lambda Forms), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)</p>
<p><strong>Notes:</strong></p>
<p>The <em>lambda form</em></p>
<p>((lambda <em>lambda-list</em> . <em>body</em>) . <em>arguments</em>)</p>
<p>is semantically equivalent to the <em>function form</em></p>
<p>(funcall #’(lambda <em>lambda-list</em> . <em>body</em>) . <em>arguments</em>)</p>
<p><strong>lambda</strong> <em>Macro</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>lambda</strong> <em>lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>* <em>→ function</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>lambda-list</em>—an <em>ordinary lambda list</em>.</p>
<p><em>declaration</em>—a <strong>declare</strong> <em>expression</em>; not evaluated.</p>
<p><em>documentation</em>—a <em>string</em>; not evaluated.</p>
<p><em>form</em>—a <em>form</em>.</p>
<p><em>function</em>—a <em>function</em>.</p>
<p><strong>Description:</strong></p>
<p>Provides a shorthand notation for a <strong>function</strong> <em>special form</em> involving a <em>lambda expression</em> such that:</p>
<p>(lambda <em>lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>*)</p>
<p><em>≡</em> (function (lambda <em>lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>*))</p>
<p><em>≡</em> #’(lambda <em>lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>*)</p>
<p><strong>Examples:</strong></p>
<p>(funcall (lambda (x) (+ x 3)) 4) <em>→</em> 7</p>
<p><strong>See Also:</strong></p>
<p><strong>lambda</strong> (symbol)</p>
<p><strong>Notes:</strong></p>
<p>This macro could be implemented by:</p>
<p>(defmacro lambda (&amp;whole form &amp;rest bvl-decls-and-body)</p>
<p>(declare (ignore bvl-decls-and-body))</p>
<p>‘#’,form)</p>
<p><strong>compile</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>compile</strong> <em>name</em> &amp;optional <em>definition → function, warnings-p, failure-p</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>name</em>—a <em>function name</em>, or <strong>nil</strong>.</p>
<p><em>definition</em>—a <em>lambda expression</em> or a <em>function</em>. The default is the function definition of <em>name</em> if it names a <em>function</em>, or the <em>macro function</em> of <em>name</em> if it names a <em>macro</em>. The consequences are undefined if no <em>definition</em> is supplied when the <em>name</em> is <strong>nil</strong>.</p>
<p><em>function</em>—the <em>function-name</em>, or a <em>compiled function</em>.</p>
<p><em>warnings-p</em>—a <em>generalized boolean</em>.</p>
<p><strong>compile</strong></p>
<p><em>failure-p</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p>Compiles an <em>interpreted function</em>.</p>
<p><strong>compile</strong> produces a <em>compiled function</em> from <em>definition</em>. If the <em>definition</em> is a <em>lambda expression</em>, it is coerced to a <em>function</em>. If the <em>definition</em> is already a <em>compiled function</em>, <strong>compile</strong> either produces that function itself (<em>i.e.</em>, is an identity operation) or an equivalent function.</p>
<p>If the <em>name</em> is <strong>nil</strong>, the resulting <em>compiled function</em> is returned directly as the <em>primary value</em>. If a <em>non-nil name</em> is given, then the resulting <em>compiled function</em> replaces the existing <em>function</em> definition of <em>name</em> and the <em>name</em> is returned as the <em>primary value</em>; if <em>name</em> is a <em>symbol</em> that names a <em>macro</em>, its <em>macro function</em> is updated and the <em>name</em> is returned as the <em>primary value</em>.</p>
<p><em>Literal objects</em> appearing in code processed by the <strong>compile</strong> function are neither copied nor <em>coalesced</em>. The code resulting from the execution of <strong>compile</strong> references <em>objects</em> that are <strong>eql</strong> to the corresponding <em>objects</em> in the source code.</p>
<p><strong>compile</strong> is permitted, but not required, to <em>establish</em> a <em>handler</em> for <em>conditions</em> of <em>type</em> <strong>error</strong>. For example, the <em>handler</em> might issue a warning and restart compilation from some <em>implementation dependent</em> point in order to let the compilation proceed without manual intervention.</p>
<p>The <em>secondary value</em>, <em>warnings-p</em>, is <em>false</em> if no <em>conditions</em> of <em>type</em> <strong>error</strong> or <strong>warning</strong> were detected by the compiler, and <em>true</em> otherwise.</p>
<p>The <em>tertiary value</em>, <em>failure-p</em>, is <em>false</em> if no <em>conditions</em> of <em>type</em> <strong>error</strong> or <strong>warning</strong> (other than <strong>style-warning</strong>) were detected by the compiler, and <em>true</em> otherwise.</p>
<p><strong>Examples:</strong></p>
<p>(defun foo () &quot;bar&quot;) <em>→</em> FOO</p>
<p>(compiled-function-p #’foo) <em>→ implementation-dependent</em></p>
<p>(compile ’foo) <em>→</em> FOO</p>
<p>(compiled-function-p #’foo) <em>→ true</em></p>
<p>(setf (symbol-function ’foo)</p>
<p>(compile nil ’(lambda () &quot;replaced&quot;))) <em>→</em> #&lt;Compiled-Function&gt;</p>
<p>(foo) <em>→</em> &quot;replaced&quot;</p>
<p><strong>Affected By:</strong></p>
<p><strong>*error-output*</strong>, <strong>*macroexpand-hook*</strong>.</p>
<p>The presence of macro definitions and proclamations.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>The consequences are undefined if the <em>lexical environment</em> surrounding the <em>function</em> to be compiled contains any <em>bindings</em> other than those for <em>macros</em>, <em>symbol macros</em>, or <em>declarations</em>.</p>
<p>For information about errors detected during the compilation process, see Section 3.2.5 (Exceptional Evaluation and Compilation <strong>3–57</strong></p>
<p>Situations in the Compiler).</p>
<p><strong>See Also:</strong></p>
<p><strong>compile-file</strong></p>
<p><strong>eval</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>eval</strong> <em>form → {result}</em>*</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>form</em>—a <em>form</em>.</p>
<p><em>results</em>—the <em>values yielded</em> by the <em>evaluation</em> of <em>form</em>.</p>
<p><strong>Description:</strong></p>
<p>Evaluates <em>form</em> in the current <em>dynamic environment</em> and the <em>null lexical environment</em>. <strong>eval</strong> is a user interface to the evaluator.</p>
<p>The evaluator expands macro calls as if through the use of <strong>macroexpand-1</strong>.</p>
<p>Constants appearing in code processed by <strong>eval</strong> are not copied nor coalesced. The code resulting from the execution of <strong>eval</strong> references <em>objects</em> that are <strong>eql</strong> to the corresponding <em>objects</em> in the source code.</p>
<p><strong>Examples:</strong></p>
<p>(setq form ’(1+ a) a 999) <em>→</em> 999</p>
<p>(eval form) <em>→</em> 1000</p>
<p>(eval ’form) <em>→</em> (1+ A)</p>
<p>(let ((a ’(this would break if eval used local value))) (eval form))</p>
<p><em>→</em> 1000</p>
<p><strong>See Also:</strong></p>
<p><strong>macroexpand-1</strong>, Section 3.1.2 (The Evaluation Model)</p>
<p><strong>Notes:</strong></p>
<p>To obtain the current dynamic value of a <em>symbol</em>, use of <strong>symbol-value</strong> is equivalent (and usually preferable) to use of <strong>eval</strong>.</p>
<p>Note that an <strong>eval</strong> <em>form</em> involves two levels of <em>evaluation</em> for its <em>argument</em>. First, <em>form</em> is <em>evaluated</em> by the normal argument evaluation mechanism as would occur with any <em>call</em>. The <em>object</em> that</p>
<p>results from this normal <em>argument evaluation</em> becomes the <em>value</em> of the <em>form parameter</em> , and is then <em>evaluated</em> as part of the <strong>eval</strong> <em>form</em>. For example:</p>
<p>(eval (list ’cdr (car ’((quote (a . b)) c)))) <em>→</em> b</p>
<p>The <em>argument form</em> (list ’cdr (car ’((quote (a . b)) c))) is evaluated in the usual way to produce the <em>argument</em> (cdr (quote (a . b))); <strong>eval</strong> then evaluates its <em>argument</em>, (cdr (quote (a . b))), to produce b. Since a single <em>evaluation</em> already occurs for any <em>argument form</em> in any <em>function form</em>, <strong>eval</strong> is sometimes said to perform “an extra level of evaluation.”</p>
<p><strong>eval-when</strong> <em>Special Operator</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>eval-when</strong> (<em>{situation}</em>*) <em>{form}</em>* <em>→ {result}</em>*</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>situation</em>—One of the <em>symbols</em> <!-- -->:compile-toplevel<!-- -->, <!-- -->:load-toplevel<!-- -->, <!-- -->:execute<!-- -->, <strong>compile</strong>, <strong>load</strong>, or <strong>eval</strong>. The use of <strong>eval</strong>, <strong>compile</strong>, and <strong>load</strong> is deprecated.</p>
<p><em>forms</em>—an <em>implicit progn</em>.</p>
<p><em>results</em>—the <em>values</em> of the <em>forms</em> if they are executed, or <strong>nil</strong> if they are not.</p>
<p><strong>Description:</strong></p>
<p>The body of an <strong>eval-when</strong> form is processed as an <em>implicit progn</em>, but only in the <em>situations</em> listed.</p>
<p>The use of the <em>situations</em> <!-- -->:compile-toplevel<!-- --> (or compile) and <!-- -->:load-toplevel<!-- --> (or load) controls whether and when <em>evaluation</em> occurs when <strong>eval-when</strong> appears as a <em>top level form</em> in code processed by <strong>compile-file</strong>. See Section 3.2.3 (File Compilation).</p>
<p>The use of the <em>situation</em> <!-- -->:execute<!-- --> (or eval) controls whether evaluation occurs for other <strong>eval-when</strong> <em>forms</em>; that is, those that are not <em>top level forms</em>, or those in code processed by <strong>eval</strong> or <strong>compile</strong>. If the <!-- -->:execute<!-- --> situation is specified in such a <em>form</em>, then the body <em>forms</em> are processed as an <em>implicit progn</em>; otherwise, the <strong>eval-when</strong> <em>form</em> returns <strong>nil</strong>.</p>
<p><strong>eval-when</strong> normally appears as a <em>top level form</em>, but it is meaningful for it to appear as a <em>non-top-level form</em>. However, the compile-time side effects described in Section 3.2 (Compilation) only take place when <strong>eval-when</strong> appears as a <em>top level form</em>.</p>
<p><strong>Examples:</strong></p>
<p>One example of the use of <strong>eval-when</strong> is that for the compiler to be able to read a file properly when it uses user-defined <em>reader macros</em>, it is necessary to write</p>
<p>(eval-when (<!-- -->:compile-toplevel<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:execute<!-- -->)</p>
<p><strong>eval-when</strong></p>
<p>(set-macro-character #$ #’(lambda (stream char)</p>
<p>(declare (ignore char))</p>
<p>(list ’dollar (read stream))))) <em>→</em> T</p>
<p>This causes the call to <strong>set-macro-character</strong> to be executed in the compiler’s execution environment, thereby modifying its reader syntax table.</p>
<p>;;; The EVAL-WHEN in this case is not at toplevel, so only the <!-- -->:EXECUTE</p>
<p>;;; keyword is considered. At compile time, this has no effect.</p>
<p>;;; At load time (if the LET is at toplevel), or at execution time</p>
<p>;;; (if the LET is embedded in some other form which does not execute</p>
<p>;;; until later) this sets (SYMBOL-FUNCTION ’FOO1) to a function which</p>
<p>;;; returns 1.</p>
<p>(let ((x 1))</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:compile-toplevel<!-- -->)</p>
<p>(setf (symbol-function ’foo1) #’(lambda () x))))</p>
<p>;;; If this expression occurs at the toplevel of a file to be compiled,</p>
<p>;;; it has BOTH a compile time AND a load-time effect of setting</p>
<p>;;; (SYMBOL-FUNCTION ’FOO2) to a function which returns 2.</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:compile-toplevel<!-- -->)</p>
<p>(let ((x 2))</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:compile-toplevel<!-- -->)</p>
<p>(setf (symbol-function ’foo2) #’(lambda () x)))))</p>
<p>;;; If this expression occurs at the toplevel of a file to be compiled,</p>
<p>;;; it has BOTH a compile time AND a load-time effect of setting the</p>
<p>;;; function cell of FOO3 to a function which returns 3.</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:compile-toplevel<!-- -->)</p>
<p>(setf (symbol-function ’foo3) #’(lambda () 3)))</p>
<p>;;; #4: This always does nothing. It simply returns NIL.</p>
<p>(eval-when (<!-- -->:compile-toplevel<!-- -->)</p>
<p>(eval-when (<!-- -->:compile-toplevel<!-- -->)</p>
<p>(print ’foo4)))</p>
<p>;;; If this form occurs at toplevel of a file to be compiled, FOO5 is</p>
<p>;;; printed at compile time. If this form occurs in a non-top-level</p>
<p>;;; position, nothing is printed at compile time. Regardless of context,</p>
<p>;;; nothing is ever printed at load time or execution time.</p>
<p>(eval-when (<!-- -->:compile-toplevel<!-- -->)</p>
<p>(eval-when (<!-- -->:execute<!-- -->)</p>
<p>(print ’foo5)))</p>
<p>;;; If this form occurs at toplevel of a file to be compiled, FOO6 is</p>
<p>;;; printed at compile time. If this form occurs in a non-top-level</p>
<p><strong>eval-when</strong></p>
<p>;;; position, nothing is printed at compile time. Regardless of context,</p>
<p>;;; nothing is ever printed at load time or execution time.</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- -->)</p>
<p>(eval-when (<!-- -->:compile-toplevel<!-- -->)</p>
<p>(print ’foo6)))</p>
<p><strong>See Also:</strong></p>
<p><strong>compile-file</strong>, Section 3.2 (Compilation)</p>
<p><strong>Notes:</strong></p>
<p>The following effects are logical consequences of the definition of <strong>eval-when</strong>:</p>
<p><em>•</em> Execution of a single <strong>eval-when</strong> expression executes the body code at most once.</p>
<p><em>• Macros</em> intended for use in <em>top level forms</em> should be written so that side-effects are done by the <em>forms</em> in the macro expansion. The macro-expander itself should not do the side-effects.</p>
<p>For example:</p>
<p>Wrong:</p>
<p>(defmacro foo ()</p>
<p>(really-foo)</p>
<p>‘(really-foo))</p>
<p>Right:</p>
<p>(defmacro foo ()</p>
<p>‘(eval-when (<!-- -->:compile-toplevel<!-- --> <!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- -->) (really-foo)))</p>
<p>Adherence to this convention means that such <em>macros</em> behave intuitively when appearing as <em>non-top-level forms</em>.</p>
<p><em>•</em> Placing a variable binding around an <strong>eval-when</strong> reliably captures the binding because the compile-time-too mode cannot occur (<em>i.e.</em>, introducing a variable binding means that the <strong>eval-when</strong> is not a <em>top level form</em>). For example,</p>
<p>(let ((x 3))</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- --> <!-- -->:compile-toplevel<!-- -->) (print x)))</p>
<p>prints 3 at execution (<em>i.e.</em>, load) time, and does not print anything at compile time. This is important so that expansions of <strong>defun</strong> and <strong>defmacro</strong> can be done in terms of <strong>eval-when</strong> and can correctly capture the <em>lexical environment</em>.</p>
<p>(defun bar (x) (defun foo () (+ x 3)))</p>
<p>(defun bar (x)</p>
<p>(progn (eval-when (<!-- -->:compile-toplevel<!-- -->)</p>
<p>(compiler::notice-function-definition ’foo ’(x)))</p>
<p>(eval-when (<!-- -->:execute<!-- --> <!-- -->:load-toplevel<!-- -->)</p>
<p>(setf (symbol-function ’foo) #’(lambda () (+ x 3))))))</p>
<p>which would be treated by the above rules the same as</p>
<p>(defun bar (x)</p>
<p>(setf (symbol-function ’foo) #’(lambda () (+ x 3))))</p>
<p>when the definition of bar is not a <em>top level form</em>.</p>
<p><strong>load-time-value</strong> <em>Special Operator</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>load-time-value</strong> <em>form</em> &amp;optional <em>read-only-p → object</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>form</em>—a <em>form</em>; evaluated as described below.</p>
<p><em>read-only-p</em>—a <em>boolean</em>; not evaluated.</p>
<p><em>object</em>—the <em>primary value</em> resulting from evaluating <em>form</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>load-time-value</strong> provides a mechanism for delaying evaluation of <em>form</em> until the expression is in the run-time environment; see Section 3.2 (Compilation).</p>
<p><em>Read-only-p</em> designates whether the result can be considered a <em>constant object</em>. If <strong>t</strong>, the result is a read-only quantity that can, if appropriate to the <em>implementation</em>, be copied into read-only space and/or <em>coalesced</em> with <em>similar constant objects</em> from other <em>programs</em>. If <strong>nil</strong> (the default), the result must be neither copied nor coalesced; it must be considered to be potentially modifiable data.</p>
<p>If a <strong>load-time-value</strong> expression is processed by <strong>compile-file</strong>, the compiler performs its normal semantic processing (such as macro expansion and translation into machine code) on <em>form</em>, but arranges for the execution of <em>form</em> to occur at load time in a <em>null lexical environment</em>, with the result of this <em>evaluation</em> then being treated as a <em>literal object</em> at run time. It is guaranteed that</p>
<p>the evaluation of <em>form</em> will take place only once when the <em>file</em> is <em>loaded</em>, but the order of evaluation with respect to the evaluation of <em>top level forms</em> in the file is <em>implementation-dependent</em>.</p>
<p>If a <strong>load-time-value</strong> expression appears within a function compiled with <strong>compile</strong>, the <em>form</em> is evaluated at compile time in a <em>null lexical environment</em>. The result of this compile-time evaluation is treated as a <em>literal object</em> in the compiled code.</p>
<p><strong>load-time-value</strong></p>
<p>If a <strong>load-time-value</strong> expression is processed by <strong>eval</strong>, <em>form</em> is evaluated in a <em>null lexical environment</em>, and one value is returned. Implementations that implicitly compile (or partially compile) expressions processed by <strong>eval</strong> might evaluate <em>form</em> only once, at the time this compilation is performed.</p>
<p>If the <em>same list</em> (load-time-value <em>form</em>) is evaluated or compiled more than once, it is <em>implementation-dependent</em> whether <em>form</em> is evaluated only once or is evaluated more than once. This can happen both when an expression being evaluated or compiled shares substructure, and when the <em>same form</em> is processed by <strong>eval</strong> or <strong>compile</strong> multiple times. Since a <strong>load-time-value</strong> expression can be referenced in more than one place and can be evaluated multiple times by <strong>eval</strong>, it is <em>implementation-dependent</em> whether each execution returns a fresh <em>object</em> or returns the same <em>object</em> as some other execution. Users must use caution when destructively modifying the resulting <em>object</em>.</p>
<p>If two lists (load-time-value <em>form</em>) that are the <em>same</em> under <strong>equal</strong> but are not <em>identical</em> are evaluated or compiled, their values always come from distinct evaluations of <em>form</em>. Their <em>values</em> may not be coalesced unless <em>read-only-p</em> is <strong>t</strong>.</p>
<p><strong>Examples:</strong></p>
<p>;;; The function INCR1 always returns the same value, even in different images. ;;; The function INCR2 always returns the same value in a given image,</p>
<p>;;; but the value it returns might vary from image to image.</p>
<p>(defun incr1 (x) (+ x #.(random 17)))</p>
<p>(defun incr2 (x) (+ x (load-time-value (random 17))))</p>
<p>;;; The function FOO1-REF references the nth element of the first of</p>
<p>;;; the *FOO-ARRAYS* that is available at load time. It is permissible for</p>
<p>;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the</p>
<p>;;; updated values.</p>
<p>(defvar *foo-arrays* (list (make-array 7) (make-array 8)))</p>
<p>(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))</p>
<p>(defun set-foo1-ref (n val)</p>
<p>(setf (aref (load-time-value (first *my-arrays*) nil) n) val))</p>
<p>;;; The function BAR1-REF references the nth element of the first of</p>
<p>;;; the *BAR-ARRAYS* that is available at load time. The programmer has</p>
<p>;;; promised that the array will be treated as read-only, so the system</p>
<p>;;; can copy or coalesce the array.</p>
<p>(defvar *bar-arrays* (list (make-array 7) (make-array 8)))</p>
<p>(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))</p>
<p>;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced</p>
<p>;;; even though NIL was specified, because the object was already read-only</p>
<p>;;; when it was written as a literal vector rather than created by a constructor. ;;; User programs must treat the vector v as read-only.</p>
<p>(defun baz-ref (n)</p>
<p>(let ((v (load-time-value #(A B C) nil)))</p>
<p>(values (svref v n) v)))</p>
<p>;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced</p>
<p>;;; even though NIL was specified in the outer situation because T was specified ;;; in the inner situation. User programs must treat the vector v as read-only. (defun baz-ref (n)</p>
<p>(let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))</p>
<p>(values (svref v n) v)))</p>
<p><strong>See Also:</strong></p>
<p><strong>compile-file</strong>, <strong>compile</strong>, <strong>eval</strong>, Section 3.2.2.2 (Minimal Compilation), Section 3.2 (Compilation)</p>
<p><strong>Notes:</strong></p>
<p><strong>load-time-value</strong> must appear outside of quoted structure in a “for <em>evaluation</em>” position. In situations which would appear to call for use of <strong>load-time-value</strong> within a quoted structure, the <em>backquote reader macro</em> is probably called for; see Section 2.4.6 (Backquote).</p>
<p>Specifying <strong>nil</strong> for <em>read-only-p</em> is not a way to force an object to become modifiable if it has already been made read-only. It is only a way to say that, for an object that is modifiable, this operation is not intended to make that object read-only.</p>
<p><strong>quote</strong> <em>Special Operator</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>quote</strong> <em>object → object</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>object</em>—an <em>object</em>; not evaluated.</p>
<p><strong>Description:</strong></p>
<p>The <strong>quote</strong> <em>special operator</em> just returns <em>object</em>.</p>
<p>The consequences are undefined if <em>literal objects</em> (including <em>quoted objects</em>) are destructively modified.</p>
<p><strong>Examples:</strong></p>
<p>(setq a 1) <em>→</em> 1</p>
<p>(quote (setq a 3)) <em>→</em> (SETQ A 3)</p>
<p>a <em>→</em> 1</p>
<p>’a <em>→</em> A</p>
<p>”a <em>→</em> (QUOTE A)</p>
<p>”’a <em>→</em> (QUOTE (QUOTE A))</p>
<p>(setq a 43) <em>→</em> 43</p>
<p>(list a (cons a 3)) <em>→</em> (43 (43 . 3))</p>
<p>(list (quote a) (quote (cons a 3))) <em>→</em> (A (CONS A 3))</p>
<p>1 <em>→</em> 1</p>
<p>’1 <em>→</em> 1</p>
<p>&quot;foo&quot; <em>→</em> &quot;foo&quot;</p>
<p>’&quot;foo&quot; <em>→</em> &quot;foo&quot;</p>
<p>(car ’(a b)) <em>→</em> A</p>
<p>’(car ’(a b)) <em>→</em> (CAR (QUOTE (A B)))</p>
<p>#(car ’(a b)) <em>→</em> #(CAR (QUOTE (A B)))</p>
<p>’#(car ’(a b)) <em>→</em> #(CAR (QUOTE (A B)))</p>
<p><strong>See Also:</strong></p>
<p>Section 3.1 (Evaluation), Section 2.4.3 (Single-Quote), Section 3.2.1 (Compiler Terminology)</p>
<p><strong>Notes:</strong></p>
<p>The textual notation ’<em>object</em> is equivalent to (quote <em>object</em>); see Section 3.2.1 (Compiler Terminology).</p>
<p>Some <em>objects</em>, called <em>self-evaluating objects</em>, do not require quotation by <strong>quote</strong>. However, <em>symbols</em> and <em>lists</em> are used to represent parts of programs, and so would not be useable as constant data in a program without <strong>quote</strong>. Since <strong>quote</strong> suppresses the <em>evaluation</em> of these <em>objects</em>, they become data rather than program.</p>
<p><strong>compiler-macro-function</strong> <em>Accessor</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>compiler-macro-function</strong> <em>name</em> &amp;optional <em>environment → function</em></p>
<p><strong>(setf (compiler-macro-function</strong> <em>name</em> &amp;optional <em>environment</em>**)** <em>new-function</em>**)**</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>name</em>—a <em>function name</em>.</p>
<p><em>environment</em>—an <em>environment object</em>.</p>
<p><em>function</em>, <em>new-function</em>—a <em>compiler macro function</em>, or <strong>nil</strong>.</p>
<p><strong>Description:</strong></p>
<p><em>Accesses</em> the <em>compiler macro function</em> named <em>name</em>, if any, in the <em>environment</em>.</p>
<p>A value of <strong>nil</strong> denotes the absence of a <em>compiler macro function</em> named <em>name</em>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>The consequences are undefined if <em>environment</em> is <em>non-nil</em> in a use of <strong>setf</strong> of <strong>compiler-macro-function</strong>.</p>
<p><strong>See Also:</strong></p>
<p><strong>define-compiler-macro</strong>, Section 3.2.2.1 (Compiler Macros)</p>
<p><strong>define-compiler-macro</strong> <em>Macro</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>define-compiler-macro</strong> <em>name lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>* <em>→ name</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>name</em>—a <em>function name</em>.</p>
<p><em>lambda-list</em>—a <em>macro lambda list</em>.</p>
<p><em>declaration</em>—a <strong>declare</strong> <em>expression</em>; not evaluated.</p>
<p><em>documentation</em>—a <em>string</em>; not evaluated.</p>
<p><em>form</em>—a <em>form</em>.</p>
<p><strong>Description:</strong></p>
<p>This is the normal mechanism for defining a <em>compiler macro function</em>. Its manner of definition is the same as for <strong>defmacro</strong>; the only differences are:</p>
<p><em>•</em> The <em>name</em> can be a <em>function name</em> naming any <em>function</em> or <em>macro</em>.</p>
<p><em>•</em> The expander function is installed as a <em>compiler macro function</em> for the <em>name</em>, rather than as a <em>macro function</em>.</p>
<p><em>•</em> The <strong>&amp;whole</strong> argument is bound to the form argument that is passed to the <em>compiler macro function</em>. The remaining lambda-list parameters are specified as if this form contained the function name in the <em>car</em> and the actual arguments in the <em>cdr</em> , but if the <em>car</em> of the actual form is the symbol <strong>funcall</strong>, then the destructuring of the arguments is actually performed using its <em>cddr</em> instead.</p>
<p><em>• Documentation</em> is attached as a <em>documentation string</em> to <em>name</em> (as kind <strong>compiler-macro</strong>) and to the <em>compiler macro function</em>.</p>
<p><strong>define-compiler-macro</strong></p>
<p><em>•</em> Unlike an ordinary <em>macro</em>, a <em>compiler macro</em> can decline to provide an expansion merely by returning a form that is the <em>same</em> as the original (which can be obtained by using <strong>&amp;whole</strong>).</p>
<p><strong>Examples:</strong></p>
<p>(defun square (x) (expt x 2)) <em>→</em> SQUARE</p>
<p>(define-compiler-macro square (&amp;whole form arg)</p>
<p>(if (atom arg)</p>
<p>‘(expt ,arg 2)</p>
<p>(case (car arg)</p>
<p>(square (if (= (length arg) 2)</p>
<p>‘(expt ,(nth 1 arg) 4)</p>
<p>form))</p>
<p>(expt (if (= (length arg) 3)</p>
<p>(if (numberp (nth 2 arg))</p>
<p>‘(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))</p>
<p>‘(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))</p>
<p>form))</p>
<p>(otherwise ‘(expt ,arg 2))))) <em>→</em> SQUARE</p>
<p>(square (square 3)) <em>→</em> 81</p>
<p>(macroexpand ’(square x)) <em>→</em> (SQUARE X), <em>false</em></p>
<p>(funcall (compiler-macro-function ’square) ’(square x) nil)</p>
<p><em>→</em> (EXPT X 2)</p>
<p>(funcall (compiler-macro-function ’square) ’(square (square x)) nil)</p>
<p><em>→</em> (EXPT X 4)</p>
<p>(funcall (compiler-macro-function ’square) ’(funcall #’square x) nil)</p>
<p><em>→</em> (EXPT X 2)</p>
<p>(defun distance-positional (x1 y1 x2 y2)</p>
<p>(sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))</p>
<p><em>→</em> DISTANCE-POSITIONAL</p>
<p>(defun distance (&amp;key (x1 0) (y1 0) (x2 x1) (y2 y1))</p>
<p>(distance-positional x1 y1 x2 y2))</p>
<p><em>→</em> DISTANCE</p>
<p>(define-compiler-macro distance (&amp;whole form</p>
<p>&amp;rest key-value-pairs</p>
<p>&amp;key (x1 0 x1-p)</p>
<p>(y1 0 y1-p)</p>
<p>(x2 x1 x2-p)</p>
<p>(y2 y1 y2-p)</p>
<p>&amp;allow-other-keys</p>
<p>&amp;environment env)</p>
<p>(flet ((key (n) (nth (* n 2) key-value-pairs))</p>
<p>(arg (n) (nth (1+ (* n 2)) key-value-pairs))</p>
<p>(simplep (x)</p>
<p><strong>define-compiler-macro</strong></p>
<p>(let ((expanded-x (macroexpand x env)))</p>
<p>(or (constantp expanded-x env)</p>
<p>(symbolp expanded-x)))))</p>
<p>(let ((n (/ (length key-value-pairs) 2)))</p>
<p>(multiple-value-bind (x1s y1s x2s y2s others)</p>
<p>(loop for (key) on key-value-pairs by #’cddr</p>
<p>count (eq key ’<!-- -->:x1<!-- -->) into x1s</p>
<p>count (eq key ’<!-- -->:y1<!-- -->) into y1s</p>
<p>count (eq key ’<!-- -->:x2<!-- -->) into x2s</p>
<p>count (eq key ’<!-- -->:y1<!-- -->) into y2s</p>
<p>count (not (member key ’(<!-- -->:x1<!-- --> <!-- -->:x2<!-- --> <!-- -->:y1<!-- --> <!-- -->:y2<!-- -->)))</p>
<p>into others</p>
<p>finally (return (values x1s y1s x2s y2s others)))</p>
<p>(cond ((and (= n 4)</p>
<p>(eq (key 0) <!-- -->:x1<!-- -->)</p>
<p>(eq (key 1) <!-- -->:y1<!-- -->)</p>
<p>(eq (key 2) <!-- -->:x2<!-- -->)</p>
<p>(eq (key 3) <!-- -->:y2<!-- -->))</p>
<p>‘(distance-positional ,x1 ,y1 ,x2 ,y2))</p>
<p>((and (if x1-p (and (= x1s 1) (simplep x1)) t)</p>
<p>(if y1-p (and (= y1s 1) (simplep y1)) t)</p>
<p>(if x2-p (and (= x2s 1) (simplep x2)) t)</p>
<p>(if y2-p (and (= y2s 1) (simplep y2)) t)</p>
<p>(zerop others))</p>
<p>‘(distance-positional ,x1 ,y1 ,x2 ,y2))</p>
<p>((and (&lt; x1s 2) (&lt; y1s 2) (&lt; x2s 2) (&lt; y2s 2)</p>
<p>(zerop others))</p>
<p>(let ((temps (loop repeat n collect (gensym))))</p>
<p>‘(let ,(loop for i below n</p>
<p>collect (list (nth i temps) (arg i)))</p>
<p>(distance</p>
<p>,@(loop for i below n</p>
<p>append (list (key i) (nth i temps)))))))</p>
<p>(t form))))))</p>
<p><em>→</em> DISTANCE</p>
<p>(dolist (form</p>
<p>’((distance <!-- -->:x1<!-- --> (setq x 7) <!-- -->:x2<!-- --> (decf x) <!-- -->:y1<!-- --> (decf x) <!-- -->:y2<!-- --> (decf x)) (distance <!-- -->:x1<!-- --> (setq x 7) <!-- -->:y1<!-- --> (decf x) <!-- -->:x2<!-- --> (decf x) <!-- -->:y2<!-- --> (decf x))</p>
<p>(distance <!-- -->:x1<!-- --> (setq x 7) <!-- -->:y1<!-- --> (incf x))</p>
<p>(distance <!-- -->:x1<!-- --> (setq x 7) <!-- -->:y1<!-- --> (incf x) <!-- -->:x1<!-- --> (incf x))</p>
<p>(distance <!-- -->:x1<!-- --> a1 <!-- -->:y1<!-- --> b1 <!-- -->:x2<!-- --> a2 <!-- -->:y2<!-- --> b2)</p>
<p>(distance <!-- -->:x1<!-- --> a1 <!-- -->:x2<!-- --> a2 <!-- -->:y1<!-- --> b1 <!-- -->:y2<!-- --> b2)</p>
<p>(distance <!-- -->:x1<!-- --> a1 <!-- -->:y1<!-- --> b1 <!-- -->:z1<!-- --> c1 <!-- -->:x2<!-- --> a2 <!-- -->:y2<!-- --> b2 <!-- -->:z2<!-- --> c2)))</p>
<p>(print (funcall (compiler-macro-function ’distance) form nil)))</p>
<p>▷ (LET ((#<!-- -->:G6558<!-- --> (SETQ X 7))</p>
<p>▷ (#<!-- -->:G6559<!-- --> (DECF X))</p>
<p>▷ (#<!-- -->:G6560<!-- --> (DECF X))</p>
<p>▷ (#<!-- -->:G6561<!-- --> (DECF X)))</p>
<p>▷ (DISTANCE <!-- -->:X1<!-- --> #<!-- -->:G6558<!-- --> <!-- -->:X2<!-- --> #<!-- -->:G6559<!-- --> <!-- -->:Y1<!-- --> #<!-- -->:G6560<!-- --> <!-- -->:Y2<!-- --> #<!-- -->:G6561<!-- -->))</p>
<p>▷ (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))</p>
<p>▷ (LET ((#<!-- -->:G6567<!-- --> (SETQ X 7))</p>
<p>▷ (#<!-- -->:G6568<!-- --> (INCF X)))</p>
<p>▷ (DISTANCE <!-- -->:X1<!-- --> #<!-- -->:G6567<!-- --> <!-- -->:Y1<!-- --> #<!-- -->:G6568<!-- -->))</p>
<p>▷ (DISTANCE <!-- -->:X1<!-- --> (SETQ X 7) <!-- -->:Y1<!-- --> (INCF X) <!-- -->:X1<!-- --> (INCF X))</p>
<p>▷ (DISTANCE-POSITIONAL A1 B1 A2 B2)</p>
<p>▷ (DISTANCE-POSITIONAL A1 B1 A2 B2)</p>
<p>▷ (DISTANCE <!-- -->:X1<!-- --> A1 <!-- -->:Y1<!-- --> B1 <!-- -->:Z1<!-- --> C1 <!-- -->:X2<!-- --> A2 <!-- -->:Y2<!-- --> B2 <!-- -->:Z2<!-- --> C2)</p>
<p><em>→</em> NIL</p>
<p><strong>See Also:</strong></p>
<p><strong>compiler-macro-function</strong>, <strong>defmacro</strong>, <strong>documentation</strong>, Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)</p>
<p><strong>Notes:</strong></p>
<p>The consequences of writing a <em>compiler macro</em> definition for a function in the COMMON-LISP <em>package</em> are undefined; it is quite possible that in some <em>implementations</em> such an attempt would override an equivalent or equally important definition. In general, it is recommended that a programmer only write <em>compiler macro</em> definitions for <em>functions</em> he or she personally maintains–writing a <em>compiler macro</em> definition for a function maintained elsewhere is normally considered a violation of traditional rules of modularity and data abstraction.</p>
<p><strong>defmacro</strong> <em>Macro</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>defmacro</strong> <em>name lambda-list</em> [[ <em>{declaration}</em>* <em>| documentation</em> ]] <em>{form}</em>*</p>
<p><em>→ name</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>name</em>—a <em>symbol</em>.</p>
<p><em>lambda-list</em>—a <em>macro lambda list</em>.</p>
<p><em>declaration</em>—a <strong>declare</strong> <em>expression</em>; not evaluated.</p>
<p><em>documentation</em>—a <em>string</em>; not evaluated.</p>
<p><em>form</em>—a <em>form</em>.</p>
<p><strong>defmacro</strong></p>
<p><strong>Description:</strong></p>
<p>Defines <em>name</em> as a <em>macro</em> by associating a <em>macro function</em> with that <em>name</em> in the global environment. The <em>macro function</em> is defined in the same <em>lexical environment</em> in which the <strong>defmacro</strong> <em>form</em> appears.</p>
<p>The parameter variables in <em>lambda-list</em> are bound to destructured portions of the macro call.</p>
<p>The expansion function accepts two arguments, a <em>form</em> and an <em>environment</em>. The expansion function returns a <em>form</em>. The body of the expansion function is specified by <em>forms</em>. <em>Forms</em> are executed in order. The value of the last <em>form</em> executed is returned as the expansion of the <em>macro</em>. The body <em>forms</em> of the expansion function (but not the <em>lambda-list</em>) are implicitly enclosed in a <em>block</em> whose name is <em>name</em>.</p>
<p>The <em>lambda-list</em> conforms to the requirements described in Section 3.4.4 (Macro Lambda Lists).</p>
<p><em>Documentation</em> is attached as a <em>documentation string</em> to <em>name</em> (as kind <strong>function</strong>) and to the <em>macro function</em>.</p>
<p><strong>defmacro</strong> can be used to redefine a <em>macro</em> or to replace a <em>function</em> definition with a <em>macro</em> definition.</p>
<p>Recursive expansion of the <em>form</em> returned must terminate, including the expansion of other <em>macros</em> which are <em>subforms</em> of other <em>forms</em> returned.</p>
<p>The consequences are undefined if the result of fully macroexpanding a <em>form</em> contains any <em>circular list structure</em> except in <em>literal objects</em>.</p>
<p>If a <strong>defmacro</strong> <em>form</em> appears as a <em>top level form</em>, the <em>compiler</em> must store the <em>macro</em> definition at compile time, so that occurrences of the macro later on in the file can be expanded correctly. Users must ensure that the body of the <em>macro</em> can be evaluated at compile time if it is referenced within the <em>file</em> being <em>compiled</em>.</p>
<p><strong>Examples:</strong></p>
<p>(defmacro mac1 (a b) &quot;Mac1 multiplies and adds&quot;</p>
<p>‘(+ ,a (* ,b 3))) <em>→</em> MAC1</p>
<p>(mac1 4 5) <em>→</em> 19</p>
<p>(documentation ’mac1 ’function) <em>→</em> &quot;Mac1 multiplies and adds&quot;</p>
<p>(defmacro mac2 (&amp;optional (a 2 b) (c 3 d) &amp;rest x) ‘’(,a ,b ,c ,d ,x)) <em>→</em> MAC2 (mac2 6) <em>→</em> (6 T 3 NIL NIL)</p>
<p>(mac2 6 3 8) <em>→</em> (6 T 3 T (8))</p>
<p>(defmacro mac3 (&amp;whole r a &amp;optional (b 3) &amp;rest x &amp;key c (d a))</p>
<p>‘’(,r ,a ,b ,c ,d ,x)) <em>→</em> MAC3</p>
<p>(mac3 1 6 <!-- -->:d<!-- --> 8 <!-- -->:c<!-- --> 9 <!-- -->:d<!-- --> 10) <em>→</em> ((MAC3 1 6 <!-- -->:D<!-- --> 8 <!-- -->:C<!-- --> 9 <!-- -->:D<!-- --> 10) 1 6 9 8 (<!-- -->:D<!-- --> 8 <!-- -->:C<!-- --> 9 <!-- -->:D<!-- --> 10))</p>
<p>The stipulation that an embedded <em>destructuring lambda list</em> is permitted only where <em>ordinary lambda list</em> syntax would permit a parameter name but not a <em>list</em> is made to prevent ambiguity. For example, the following is not valid:</p>
<p><strong>defmacro</strong></p>
<p>(defmacro loser (x &amp;optional (a b &amp;rest c) &amp;rest z)</p>
<p>...)</p>
<p>because <em>ordinary lambda list</em> syntax does permit a <em>list</em> following &amp;optional; the list (a b &amp;rest c) would be interpreted as describing an optional parameter named a whose default value is that of the form b, with a supplied-p parameter named <strong>&amp;rest</strong> (not valid), and an extraneous symbol c in the list (also not valid). An almost correct way to express this is</p>
<p>(defmacro loser (x &amp;optional ((a b &amp;rest c)) &amp;rest z)</p>
<p>...)</p>
<p>The extra set of parentheses removes the ambiguity. However, the definition is now incorrect because a macro call such as (loser (car pool)) would not provide any argument form for the lambda list (a b &amp;rest c), and so the default value against which to match the <em>lambda list</em> would be <strong>nil</strong> because no explicit default value was specified. The consequences of this are unspecified since the empty list, <strong>nil</strong>, does not have <em>forms</em> to satisfy the parameters a and b. The fully correct definition would be either</p>
<p>(defmacro loser (x &amp;optional ((a b &amp;rest c) ’(nil nil)) &amp;rest z)</p>
<p>...)</p>
<p>or</p>
<p>(defmacro loser (x &amp;optional ((&amp;optional a b &amp;rest c)) &amp;rest z)</p>
<p>...)</p>
<p>These differ slightly: the first requires that if the macro call specifies a explicitly then it must also specify b explicitly, whereas the second does not have this requirement. For example,</p>
<p>(loser (car pool) ((+ x 1)))</p>
<p>would be a valid call for the second definition but not for the first.</p>
<p>(defmacro dm1a (&amp;whole x) ‘’,x)</p>
<p>(macroexpand ’(dm1a)) <em>→</em> (QUOTE (DM1A))</p>
<p>(macroexpand ’(dm1a a)) is an error.</p>
<p>(defmacro dm1b (&amp;whole x a &amp;optional b) ‘’(,x ,a ,b))</p>
<p>(macroexpand ’(dm1b)) is an error.</p>
<p>(macroexpand ’(dm1b q)) <em>→</em> (QUOTE ((DM1B Q) Q NIL))</p>
<p>(macroexpand ’(dm1b q r)) <em>→</em> (QUOTE ((DM1B Q R) Q R))</p>
<p>(macroexpand ’(dm1b q r s)) is an error.</p>
<p>(defmacro dm2a (&amp;whole form a b) ‘’(form ,form a ,a b ,b))</p>
<p>(macroexpand ’(dm2a x y)) <em>→</em> (QUOTE (FORM (DM2A X Y) A X B Y))</p>
<p>(dm2a x y) <em>→</em> (FORM (DM2A X Y) A X B Y)</p>
<p>(defmacro dm2b (&amp;whole form a (&amp;whole b (c . d) &amp;optional (e 5))</p>
<p>&amp;body f &amp;environment env)</p>
<p>“(,’,form „a ,’,b ,’,(macroexpand c env) ,’,d ,’,e ,’,f))</p>
<p>;Note that because backquote is involved, implementations may differ</p>
<p>;slightly in the nature (though not the functionality) of the expansion.</p>
<p>(macroexpand ’(dm2b x1 (((incf x2) x3 x4)) x5 x6))</p>
<p><em>→</em> (LIST* ’(DM2B X1 (((INCF X2) X3 X4))</p>
<p>X5 X6)</p>
<p>X1</p>
<p>’((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),</p>
<p>T</p>
<p>(let ((x1 5))</p>
<p>(macrolet ((segundo (x) ‘(cadr ,x)))</p>
<p>(dm2b x1 (((segundo x2) x3 x4)) x5 x6)))</p>
<p><em>→</em> ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)</p>
<p>5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))</p>
<p><strong>See Also:</strong></p>
<p><strong>define-compiler-macro</strong>, <strong>destructuring-bind</strong>, <strong>documentation</strong>, <strong>macroexpand</strong>,</p>
<p><strong>*macroexpand-hook*</strong>, <strong>macrolet</strong>, <strong>macro-function</strong>, Section 3.1 (Evaluation), Section 3.2 (Compilation), Section 3.4.11 (Syntactic Interaction of Documentation Strings and Declarations)</p>
<p><strong>macro-function</strong> <em>Accessor</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>macro-function</strong> <em>symbol</em> &amp;optional <em>environment → function</em></p>
<p><strong>(setf (macro-function</strong> <em>symbol</em> &amp;optional <em>environment</em>**)** <em>new-function</em>**)**</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>symbol</em>—a <em>symbol</em>.</p>
<p><em>environment</em>—an <em>environment object</em>.</p>
<p><em>function</em>—a <em>macro function</em> or <strong>nil</strong>.</p>
<p><em>new-function</em>—a <em>macro function</em>.</p>
<p><strong>Description:</strong></p>
<p>Determines whether <em>symbol</em> has a function definition as a macro in the specified <em>environment</em>.</p>
<p>If so, the macro expansion function, a function of two arguments, is returned. If <em>symbol</em> has no function definition in the lexical environment <em>environment</em>, or its definition is not a <em>macro</em>, <strong>macro-function</strong> returns <strong>nil</strong>.</p>
<p>It is possible for both <strong>macro-function</strong> and <strong>special-operator-p</strong> to return <em>true</em> of <em>symbol</em>. The <em>macro</em> definition must be available for use by programs that understand only the standard Common Lisp <em>special forms</em>.</p>
<p><strong>Examples:</strong></p>
<p>(defmacro macfun (x) ’(macro-function ’macfun)) <em>→</em> MACFUN</p>
<p>(not (macro-function ’macfun)) <em>→ false</em></p>
<p>(macrolet ((foo (&amp;environment env)</p>
<p>(if (macro-function ’bar env)</p>
<p>”yes</p>
<p>”no)))</p>
<p>(list (foo)</p>
<p>(macrolet ((bar () <!-- -->:beep<!-- -->))</p>
<p>(foo))))</p>
<p><em>→</em> (NO YES)</p>
<p><strong>Affected By:</strong></p>
<p>(setf macro-function), <strong>defmacro</strong>, and <strong>macrolet</strong>.</p>
<p><strong>Exceptional Situations:</strong></p>
<p>The consequences are undefined if <em>environment</em> is <em>non-nil</em> in a use of <strong>setf</strong> of <strong>macro-function</strong>.</p>
<p><strong>See Also:</strong></p>
<p><strong>defmacro</strong>, Section 3.1 (Evaluation)</p>
<p><strong>Notes:</strong></p>
<p><strong>setf</strong> can be used with <strong>macro-function</strong> to install a <em>macro</em> as a symbol’s global function definition: (setf (macro-function symbol) fn)</p>
<p>The value installed must be a <em>function</em> that accepts two arguments, the entire macro call and an <em>environment</em>, and computes the expansion for that call. Performing this operation causes <em>symbol</em> to have only that macro definition as its global function definition; any previous definition, whether as a <em>macro</em> or as a <em>function</em>, is lost.</p>
<p><strong>macroexpand, macroexpand-1</strong></p>
<p><strong>macroexpand, macroexpand-1</strong> <em>Function</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>macroexpand</strong> <em>form</em> &amp;optional <em>env → expansion, expanded-p</em></p>
<p><strong>macroexpand-1</strong> <em>form</em> &amp;optional <em>env → expansion, expanded-p</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>form</em>—a <em>form</em>.</p>
<p><em>env</em>—an <em>environment object</em>. The default is <strong>nil</strong>.</p>
<p><em>expansion</em>—a <em>form</em>.</p>
<p><em>expanded-p</em>—a <em>generalized boolean</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>macroexpand</strong> and <strong>macroexpand-1</strong> expand <em>macros</em>.</p>
<p>If <em>form</em> is a <em>macro form</em>, then <strong>macroexpand-1</strong> expands the <em>macro form</em> call once.</p>
<p><strong>macroexpand</strong> repeatedly expands <em>form</em> until it is no longer a <em>macro form</em>. In effect, <strong>macroexpand</strong> calls <strong>macroexpand-1</strong> repeatedly until the <em>secondary value</em> it returns is <strong>nil</strong>.</p>
<p>If <em>form</em> is a <em>macro form</em>, then the <em>expansion</em> is a <em>macro expansion</em> and <em>expanded-p</em> is <em>true</em>. Otherwise, the <em>expansion</em> is the given <em>form</em> and <em>expanded-p</em> is <em>false</em>.</p>
<p>Macro expansion is carried out as follows. Once <strong>macroexpand-1</strong> has determined that the <em>form</em> is a <em>macro form</em>, it obtains an appropriate expansion <em>function</em> for the <em>macro</em> or <em>symbol macro</em>. The value of <strong>*macroexpand-hook*</strong> is coerced to a <em>function</em> and then called as a <em>function</em> of three arguments: the expansion <em>function</em>, the <em>form</em>, and the <em>env</em>. The <em>value</em> returned from this call is taken to be the expansion of the <em>form</em>.</p>
<p>In addition to <em>macro</em> definitions in the global environment, any local macro definitions established within <em>env</em> by <strong>macrolet</strong> or <strong>symbol-macrolet</strong> are considered. If only <em>form</em> is supplied as an argument, then the environment is effectively null, and only global macro definitions as established by <strong>defmacro</strong> are considered. <em>Macro</em> definitions are shadowed by local <em>function</em> definitions.</p>
<p><strong>Examples:</strong></p>
<p>(defmacro alpha (x y) ‘(beta ,x ,y)) <em>→</em> ALPHA</p>
<p>(defmacro beta (x y) ‘(gamma ,x ,y)) <em>→</em> BETA</p>
<p>(defmacro delta (x y) ‘(gamma ,x ,y)) <em>→</em> EPSILON</p>
<p>(defmacro expand (form &amp;environment env)</p>
<p>(multiple-value-bind (expansion expanded-p)</p>
<p>(macroexpand form env)</p>
<p>‘(values ’,expansion ’,expanded-p))) <em>→</em> EXPAND</p>
<p><strong>macroexpand, macroexpand-1</strong></p>
<p>(defmacro expand-1 (form &amp;environment env)</p>
<p>(multiple-value-bind (expansion expanded-p)</p>
<p>(macroexpand-1 form env)</p>
<p>‘(values ’,expansion ’,expanded-p))) <em>→</em> EXPAND-1</p>
<p>;; Simple examples involving just the global environment</p>
<p>(macroexpand-1 ’(alpha a b)) <em>→</em> (BETA A B), <em>true</em></p>
<p>(expand-1 (alpha a b)) <em>→</em> (BETA A B), <em>true</em></p>
<p>(macroexpand ’(alpha a b)) <em>→</em> (GAMMA A B), <em>true</em></p>
<p>(expand (alpha a b)) <em>→</em> (GAMMA A B), <em>true</em></p>
<p>(macroexpand-1 ’not-a-macro) <em>→</em> NOT-A-MACRO, <em>false</em></p>
<p>(expand-1 not-a-macro) <em>→</em> NOT-A-MACRO, <em>false</em></p>
<p>(macroexpand ’(not-a-macro a b)) <em>→</em> (NOT-A-MACRO A B), <em>false</em></p>
<p>(expand (not-a-macro a b)) <em>→</em> (NOT-A-MACRO A B), <em>false</em></p>
<p>;; Examples involving lexical environments</p>
<p>(macrolet ((alpha (x y) ‘(delta ,x ,y)))</p>
<p>(macroexpand-1 ’(alpha a b))) <em>→</em> (BETA A B), <em>true</em></p>
<p>(macrolet ((alpha (x y) ‘(delta ,x ,y)))</p>
<p>(expand-1 (alpha a b))) <em>→</em> (DELTA A B), <em>true</em></p>
<p>(macrolet ((alpha (x y) ‘(delta ,x ,y)))</p>
<p>(macroexpand ’(alpha a b))) <em>→</em> (GAMMA A B), <em>true</em></p>
<p>(macrolet ((alpha (x y) ‘(delta ,x ,y)))</p>
<p>(expand (alpha a b))) <em>→</em> (GAMMA A B), <em>true</em></p>
<p>(macrolet ((beta (x y) ‘(epsilon ,x ,y)))</p>
<p>(expand (alpha a b))) <em>→</em> (EPSILON A B), <em>true</em></p>
<p>(let ((x (list 1 2 3)))</p>
<p>(symbol-macrolet ((a (first x)))</p>
<p>(expand a))) <em>→</em> (FIRST X), <em>true</em></p>
<p>(let ((x (list 1 2 3)))</p>
<p>(symbol-macrolet ((a (first x)))</p>
<p>(macroexpand ’a))) <em>→</em> A, <em>false</em></p>
<p>(symbol-macrolet ((b (alpha x y)))</p>
<p>(expand-1 b)) <em>→</em> (ALPHA X Y), <em>true</em></p>
<p>(symbol-macrolet ((b (alpha x y)))</p>
<p>(expand b)) <em>→</em> (GAMMA X Y), <em>true</em></p>
<p>(symbol-macrolet ((b (alpha x y))</p>
<p>(a b))</p>
<p>(expand-1 a)) <em>→</em> B, <em>true</em></p>
<p>(symbol-macrolet ((b (alpha x y))</p>
<p>(a b))</p>
<p>(expand a)) <em>→</em> (GAMMA X Y), <em>true</em></p>
<p>;; Examples of shadowing behavior</p>
<p>(flet ((beta (x y) (+ x y)))</p>
<p>(expand (alpha a b))) <em>→</em> (BETA A B), <em>true</em></p>
<p>(macrolet ((alpha (x y) ‘(delta ,x ,y)))</p>
<p>(flet ((alpha (x y) (+ x y)))</p>
<p>(expand (alpha a b)))) <em>→</em> (ALPHA A B), <em>false</em></p>
<p>(let ((x (list 1 2 3)))</p>
<p>(symbol-macrolet ((a (first x)))</p>
<p>(let ((a x))</p>
<p>(expand a)))) <em>→</em> A, <em>false</em></p>
<p><strong>Affected By:</strong></p>
<p><strong>defmacro</strong>, <strong>setf</strong> of <strong>macro-function</strong>, <strong>macrolet</strong>, <strong>symbol-macrolet</strong></p>
<p><strong>See Also:</strong></p>
<p><strong>*macroexpand-hook*</strong>, <strong>defmacro</strong>, <strong>setf</strong> of <strong>macro-function</strong>, <strong>macrolet</strong>, <strong>symbol-macrolet</strong>, Section 3.1 (Evaluation)</p>
<p><strong>Notes:</strong></p>
<p>Neither <strong>macroexpand</strong> nor <strong>macroexpand-1</strong> makes any explicit attempt to expand <em>macro forms</em> that are either <em>subforms</em> of the <em>form</em> or <em>subforms</em> of the <em>expansion</em>. Such expansion might occur implicitly, however, due to the semantics or implementation of the <em>macro function</em>.</p>
<p><strong>define-symbol-macro</strong> <em>Macro</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>define-symbol-macro</strong> <em>symbol expansion</em></p>
<p><em>→ symbol</em></p>
<p><strong>Arguments and Values:</strong></p>
<p><em>symbol</em>—a <em>symbol</em>.</p>
<p><em>expansion</em>—a <em>form</em>.</p>
<p><strong>Description:</strong></p>
<p>Provides a mechanism for globally affecting the <em>macro expansion</em> of the indicated <em>symbol</em>.</p>
<p>Globally establishes an expansion function for the <em>symbol macro</em> named by <em>symbol</em>. The only guaranteed property of an expansion <em>function</em> for a <em>symbol macro</em> is that when it is applied to the <em>form</em> and the <em>environment</em> it returns the correct expansion. (In particular, it is <em>implementation dependent</em> whether the expansion is conceptually stored in the expansion function, the <em>environment</em>, or both.)</p>
<p>Each global reference to <em>symbol</em> (<em>i.e.</em>, not <em>shadowed</em> &lt;sub&gt;2&lt;/sub&gt; by a <em>binding</em> for a <em>variable</em> or <em>symbol macro</em> named by the same <em>symbol</em>) is expanded by the normal macro expansion process; see Section 3.1.2.1.1 (Symbols as Forms). The expansion of a <em>symbol macro</em> is subject to further <em>macro expansion</em> in the same <em>lexical environment</em> as the <em>symbol macro</em> reference, exactly analogous to normal <em>macros</em>.</p>
<p>The consequences are unspecified if a <strong>special</strong> declaration is made for <em>symbol</em> while in the scope of this definition (<em>i.e.</em>, when it is not <em>shadowed</em> &lt;sub&gt;2&lt;/sub&gt; by a <em>binding</em> for a <em>variable</em> or <em>symbol macro</em> named by the same <em>symbol</em>).</p>
<p>Any use of <strong>setq</strong> to set the value of the <em>symbol</em> while in the scope of this definition is treated as if it were a <strong>setf</strong>. <strong>psetq</strong> of <em>symbol</em> is treated as if it were a <strong>psetf</strong>, and <strong>multiple-value-setq</strong> is treated as if it were a <strong>setf</strong> of <strong>values</strong>.</p>
<p>A <em>binding</em> for a <em>symbol macro</em> can be <em>shadowed</em> &lt;sub&gt;2&lt;/sub&gt; by <strong>let</strong> or <strong>symbol-macrolet</strong>.</p>
<p><strong>Examples:</strong></p>
<p>(defvar *things* (list ’alpha ’beta ’gamma)) <em>→</em> *THINGS*</p>
<p>(define-symbol-macro thing1 (first *things*)) <em>→</em> THING1</p>
<p>(define-symbol-macro thing2 (second *things*)) <em>→</em> THING2</p>
<p>(define-symbol-macro thing3 (third *things*)) <em>→</em> THING3</p>
<p>thing1 <em>→</em> ALPHA</p>
<p>(setq thing1 ’ONE) <em>→</em> ONE</p>
<p>*things* <em>→</em> (ONE BETA GAMMA)</p>
<p>(multiple-value-setq (thing2 thing3) (values ’two ’three)) <em>→</em> TWO</p>
<p>thing3 <em>→</em> THREE</p>
<p>*things* <em>→</em> (ONE TWO THREE)</p>
<p>(list thing2 (let ((thing2 2)) thing2)) <em>→</em> (TWO 2)</p>
<p><strong>Exceptional Situations:</strong></p>
<p>If <em>symbol</em> is already defined as a <em>global variable</em>, an error of <em>type</em> <strong>program-error</strong> is signaled.</p>
<p><strong>See Also:</strong></p>
<p><strong>symbol-macrolet</strong>, <strong>macroexpand</strong></p>
<p><strong>symbol-macrolet</strong></p>
<p><strong>symbol-macrolet</strong> <em>Special Operator</em></p>
<p><strong>Syntax:</strong></p>
<p><strong>symbol-macrolet</strong> (<em>{</em>(<em>symbol expansion</em>)<em>}</em>*) <em>{declaration}</em>* <em>{form}</em>*</p>
<p><em>→ {result}</em>*</p>
<p><strong>Arguments and Values:</strong></p>
<p><em>symbol</em>—a <em>symbol</em>.</p>
<p><em>expansion</em>—a <em>form</em>.</p>
<p><em>declaration</em>—a <strong>declare</strong> <em>expression</em>; not evaluated.</p>
<p><em>forms</em>—an <em>implicit progn</em>.</p>
<p><em>results</em>—the <em>values</em> returned by the <em>forms</em>.</p>
<p><strong>Description:</strong></p>
<p><strong>symbol-macrolet</strong> provides a mechanism for affecting the <em>macro expansion</em> environment for <em>symbols</em>.</p>
<p><strong>symbol-macrolet</strong> lexically establishes expansion functions for each of the <em>symbol macros</em> named by <em>symbols</em>. The only guaranteed property of an expansion <em>function</em> for a <em>symbol macro</em> is that when it is applied to the <em>form</em> and the <em>environment</em> it returns the correct expansion. (In particular, it is <em>implementation-dependent</em> whether the expansion is conceptually stored in the expansion function, the <em>environment</em>, or both.)</p>
<p>Each reference to <em>symbol</em> as a variable within the lexical <em>scope</em> of <strong>symbol-macrolet</strong> is expanded by the normal macro expansion process; see Section 3.1.2.1.1 (Symbols as Forms). The expansion of a symbol macro is subject to further macro expansion in the same lexical environment as the symbol macro invocation, exactly analogous to normal <em>macros</em>.</p>
<p>Exactly the same <em>declarations</em> are allowed as for <strong>let</strong> with one exception: <strong>symbol-macrolet</strong> signals an error if a <strong>special</strong> declaration names one of the <em>symbols</em> being defined by <strong>symbol-macrolet</strong>.</p>
<p>When the <em>forms</em> of the <strong>symbol-macrolet</strong> form are expanded, any use of <strong>setq</strong> to set the value of one of the specified variables is treated as if it were a <strong>setf</strong>. <strong>psetq</strong> of a <em>symbol</em> defined as a symbol macro is treated as if it were a <strong>psetf</strong>, and <strong>multiple-value-setq</strong> is treated as if it were a <strong>setf</strong> of <strong>values</strong>.</p>
<p>The use of <strong>symbol-macrolet</strong> can be shadowed by <strong>let</strong>. In other words, <strong>symbol-macrolet</strong> only substitutes for occurrences of <em>symbol</em> that would be in the <em>scope</em> of a lexical binding of <em>symbol</em> surrounding the <em>forms</em>.</p>
<p><strong>Examples:</strong></p>
<p>;;; The following is equivalent to</p>
<p>;;; (list ’foo (let ((x ’bar)) x)),</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chap-3/d-h-destructive-operations.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/cl-language-reference/docs/chap-3/d-g-traversal-rules-and-side-effects"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">3.6 Traversal Rules and Side Effects</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cl-language-reference/docs/chap-3/intro"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">intro</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#371-modification-of-literal-objects" class="table-of-contents__link toc-highlight">3.7.1 Modification of Literal Objects</a></li><li><a href="#372-transfer-of-control-during-a-destructive-operation" class="table-of-contents__link toc-highlight">3.7.2 Transfer of Control during a Destructive Operation</a><ul><li><a href="#3721-examples-of-transfer-of-control-during-a-destructive-operation" class="table-of-contents__link toc-highlight">3.7.2.1 Examples of Transfer of Control during a Destructive Operation</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cl-language-reference/docs/intro">Cl Technical Reference</a></li><li class="footer__item"><a href="https://lisp-docs.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">CL Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/common-lisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/hhk46CE" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.reddit.com/r/common_lisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">Reddit<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://irclog.tymoon.eu/libera/commonlisp" target="_blank" rel="noopener noreferrer" class="footer__link-item">IRC<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cl-language-reference/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/lisp-docs/cl-language-reference/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 LISP Docs, MIT License. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>